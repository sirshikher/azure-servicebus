// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
import { __awaiter } from "tslib";
import * as Constants from "./util/constants";
import { retry, RetryOperationType } from "./retry";
import { ReceiverEvents, generate_uuid } from "rhea-promise";
import { translate, ConditionStatusMapper } from "./errors";
import * as log from "./log";
/**
 * Describes an amqp request(sender)-response(receiver) link that is created over an amqp session.
 * @class RequestResponseLink
 */
export class RequestResponseLink {
    /**
     * @constructor
     * @param {Session} session The amqp session.
     * @param {Sender} sender The amqp sender link.
     * @param {Receiver} receiver The amqp receiver link.
     */
    constructor(session, sender, receiver) {
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
    }
    /**
     * Provides the underlying amqp connection object.
     * @returns {Connection} Connection.
     */
    get connection() {
        return this.session.connection;
    }
    /**
     * Indicates whether the session and the sender and receiver links are all open or closed.
     * @returns {boolean} boolean - `true` - `open`, `false` - `closed`.
     */
    isOpen() {
        return (this.session.isOpen() && this.sender.isOpen() && this.receiver.isOpen());
    }
    /**
     * Sends the given request message and returns the received response. If the operation is not
     * completed in the provided timeout in seconds `default: 10`, then the request will be retried
     * linearly for the provided number of times `default: 3` with the provided delay in seconds
     * `default: 15` between each attempt.
     *
     * @param {Message} request The AMQP (request) message.
     * @param {SendRequestOptions} [options] Options that can be provided while sending a request.
     * @returns {Promise<Message>} Promise<Message> The AMQP (response) message.
     */
    sendRequest(request, options) {
        if (!options)
            options = {};
        if (!options.timeoutInSeconds) {
            options.timeoutInSeconds = Constants.defaultOperationTimeoutInSeconds;
        }
        let count = 0;
        const sendRequestPromise = () => new Promise((resolve, reject) => {
            let waitTimer;
            let timeOver = false;
            count++;
            if (count !== 1) {
                // Generate a new message_id every time after the first attempt
                request.message_id = generate_uuid();
            }
            else if (!request.message_id) {
                // Set the message_id in the first attempt only if it is not set
                request.message_id = generate_uuid();
            }
            // Handle different variations of property names in responses emitted by EventHubs and ServiceBus.
            const getCodeDescriptionAndError = (props) => {
                if (!props)
                    props = {};
                return {
                    statusCode: (props[Constants.statusCode] ||
                        props.statusCode),
                    statusDescription: (props[Constants.statusDescription] ||
                        props.statusDescription),
                    errorCondition: (props[Constants.errorCondition] ||
                        props.errorCondition)
                };
            };
            const messageCallback = (context) => {
                // remove the event listener as this will be registered next time when someone makes a request.
                this.receiver.removeListener(ReceiverEvents.message, messageCallback);
                const info = getCodeDescriptionAndError(context.message.application_properties);
                const responseCorrelationId = context.message.correlation_id;
                log.reqres("[%s] %s response: ", this.connection.id, request.to || "$management", context.message);
                if (info.statusCode > 199 && info.statusCode < 300) {
                    if (request.message_id === responseCorrelationId ||
                        request.correlation_id === responseCorrelationId) {
                        if (!timeOver) {
                            clearTimeout(waitTimer);
                        }
                        log.reqres("[%s] request-messageId | '%s' == '%s' | response-correlationId.", this.connection.id, request.message_id, responseCorrelationId);
                        return resolve(context.message);
                    }
                    else {
                        log.error("[%s] request-messageId | '%s' != '%s' | response-correlationId. " +
                            "Hence dropping this response and waiting for the next one.", this.connection.id, request.message_id, responseCorrelationId);
                    }
                }
                else {
                    const condition = info.errorCondition ||
                        ConditionStatusMapper[info.statusCode] ||
                        "amqp:internal-error";
                    const e = {
                        condition: condition,
                        description: info.statusDescription
                    };
                    const error = translate(e);
                    log.error(error);
                    return reject(error);
                }
            };
            const actionAfterTimeout = () => {
                timeOver = true;
                this.receiver.removeListener(ReceiverEvents.message, messageCallback);
                const address = this.receiver.address || "address";
                const desc = `The request with message_id "${request.message_id}" to "${address}" ` +
                    `endpoint timed out. Please try again later.`;
                const e = {
                    condition: ConditionStatusMapper[408],
                    description: desc
                };
                return reject(translate(e));
            };
            this.receiver.on(ReceiverEvents.message, messageCallback);
            waitTimer = setTimeout(actionAfterTimeout, options.timeoutInSeconds * 1000);
            log.reqres("[%s] %s request sent: %O", this.connection.id, request.to || "$managment", request);
            this.sender.send(request);
        });
        const config = {
            operation: sendRequestPromise,
            connectionId: this.connection.id,
            operationType: request.to && request.to === Constants.cbsEndpoint
                ? RetryOperationType.cbsAuth
                : RetryOperationType.management,
            delayInSeconds: options.delayInSeconds,
            times: options.times
        };
        return retry(config);
    }
    /**
     * Closes the sender, receiver link and the underlying session.
     * @returns {Promise<void>} Promise<void>
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sender.close();
            yield this.receiver.close();
            yield this.session.close();
        });
    }
    /**
     * Removes the sender, receiver link and it's underlying session.
     * @returns {void} void
     */
    remove() {
        this.sender.remove();
        this.receiver.remove();
        this.session.remove();
    }
    /**
     * Creates an amqp request/response link.
     *
     * @param {Connection} connection The amqp connection.
     * @param {SenderOptions} senderOptions Options that must be provided to create the sender link.
     * @param {ReceiverOptions} receiverOptions Options that must be provided to create the receiver link.
     * @returns {Promise<RequestResponseLink>} Promise<RequestResponseLink>
     */
    static create(connection, senderOptions, receiverOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const session = yield connection.createSession();
            const sender = yield session.createSender(senderOptions);
            const receiver = yield session.createReceiver(receiverOptions);
            log.reqres("[%s] Successfully created the sender and receiver links on the same session.", connection.id);
            return new RequestResponseLink(session, sender, receiver);
        });
    }
}
//# sourceMappingURL=requestResponseLink.js.map