// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import * as log from "./log";
import { ManagementClient } from "./core/managementClient";
import { ConcurrentExpiringMap } from "./util/concurrentExpiringMap";
import { SessionManager } from "./session/sessionManager";
/**
 * @internal
 */
export var ClientEntityContext;
(function (ClientEntityContext) {
    /**
     * @internal
     */
    function create(entityPath, clientType, context, clientId, options) {
        log.entityCtxt("[%s] Creating client entity context for %s: %O", context.connectionId, clientId);
        if (!options)
            options = {};
        const entityContext = {
            namespace: context,
            entityPath: entityPath,
            clientType: clientType,
            clientId: clientId,
            isClosed: false,
            requestResponseLockedMessages: new ConcurrentExpiringMap(),
            isSessionEnabled: !!options.isSessionEnabled,
            messageSessions: {},
            expiredMessageSessions: {}
        };
        entityContext.sessionManager = new SessionManager(entityContext);
        entityContext.getReceiver = (name, sessionId) => {
            if (sessionId != undefined && entityContext.expiredMessageSessions[sessionId]) {
                const error = new Error(`The session lock has expired on the session with id ${sessionId}.`);
                error.name = "SessionLockLostError";
                log.error("[%s] Failed to find receiver '%s' as the session with id '%s' is expired", entityContext.namespace.connectionId, name, sessionId);
                throw error;
            }
            if (sessionId != null &&
                entityContext.messageSessions[sessionId] &&
                entityContext.messageSessions[sessionId].name === name) {
                return entityContext.messageSessions[sessionId];
            }
            if (entityContext.streamingReceiver && entityContext.streamingReceiver.name === name) {
                return entityContext.streamingReceiver;
            }
            if (entityContext.batchingReceiver && entityContext.batchingReceiver.name === name) {
                return entityContext.batchingReceiver;
            }
            let existingReceivers = "";
            if (sessionId != null && entityContext.messageSessions[sessionId]) {
                existingReceivers = entityContext.messageSessions[sessionId].name;
            }
            else {
                if (entityContext.streamingReceiver) {
                    existingReceivers = entityContext.streamingReceiver.name;
                }
                if (entityContext.batchingReceiver) {
                    existingReceivers +=
                        (existingReceivers ? ", " : "") + entityContext.batchingReceiver.name;
                }
            }
            log.error("[%s] Failed to find receiver '%s' among existing receivers: %s", entityContext.namespace.connectionId, name, existingReceivers);
            return;
        };
        entityContext.onDetached = (error) => __awaiter(this, void 0, void 0, function* () {
            const connectionId = entityContext.namespace.connectionId;
            // Call onDetached() on sender so that it can decide whether to reconnect or not
            const sender = entityContext.sender;
            if (sender && !sender.isConnecting) {
                try {
                    log.error("[%s] calling detached on sender '%s'.", connectionId, sender.name);
                    yield sender.onDetached();
                }
                catch (err) {
                    log.error("[%s] An error occurred while calling onDetached() the sender '%s': %O.", connectionId, sender.name, err);
                }
            }
            // Call onDetached() on batchingReceiver so that it can gracefully close any ongoing batch operation.
            const batchingReceiver = entityContext.batchingReceiver;
            if (batchingReceiver && !batchingReceiver.isConnecting) {
                try {
                    log.error("[%s] calling detached on batching receiver '%s'.", connectionId, batchingReceiver.name);
                    yield batchingReceiver.onDetached(error);
                }
                catch (err) {
                    log.error("[%s] An error occurred while calling onDetached() on the batching receiver '%s': %O.", connectionId, batchingReceiver.name, err);
                }
            }
            // Call onDetached() on streamingReceiver so that it can decide whether to reconnect or not
            const streamingReceiver = entityContext.streamingReceiver;
            if (streamingReceiver && !streamingReceiver.isConnecting) {
                try {
                    log.error("[%s] calling detached on streaming receiver '%s'.", connectionId, streamingReceiver.name);
                    yield streamingReceiver.onDetached(error);
                }
                catch (err) {
                    log.error("[%s] An error occurred while calling onDetached() on the streaming receiver '%s': %O.", connectionId, streamingReceiver.name, err);
                }
            }
        });
        const isManagementClientSharedWithOtherClients = () => {
            for (const id of Object.keys(context.clientContexts)) {
                if (context.clientContexts[id].entityPath === entityContext.entityPath &&
                    context.clientContexts[id].clientId !== entityContext.clientId) {
                    return true;
                }
            }
            return false;
        };
        entityContext.close = () => __awaiter(this, void 0, void 0, function* () {
            if (!context.connection || !context.connection.isOpen()) {
                return;
            }
            log.entityCtxt("[%s] Closing client entity context for %s: %O", context.connectionId, clientId);
            // Close sender
            if (entityContext.sender) {
                yield entityContext.sender.close();
            }
            // Close batching receiver
            if (entityContext.batchingReceiver) {
                yield entityContext.batchingReceiver.close();
            }
            // Close streaming receiver
            if (entityContext.streamingReceiver) {
                yield entityContext.streamingReceiver.close();
            }
            // Close all the MessageSessions.
            for (const messageSessionId of Object.keys(entityContext.messageSessions)) {
                yield entityContext.messageSessions[messageSessionId].close();
            }
            // Close the sessionManager.
            if (entityContext.sessionManager) {
                entityContext.sessionManager.close();
            }
            // Make sure that we clear the map of deferred messages
            entityContext.requestResponseLockedMessages.clear();
            // Delete the reference in ConnectionContext
            delete context.clientContexts[clientId];
            // Close the managementClient unless it is shared with other clients
            if (entityContext.managementClient && !isManagementClientSharedWithOtherClients()) {
                yield entityContext.managementClient.close();
                entityContext.managementClient = undefined;
            }
            entityContext.isClosed = true;
            log.entityCtxt("[%s] Closed client entity context for %s: %O", context.connectionId, clientId);
        });
        let managementClient = getManagementClient(context.clientContexts, entityPath);
        if (!managementClient) {
            const mOptions = {
                address: options.managementClientAddress || `${entityPath}/$management`,
                audience: options.managementClientAudience
            };
            managementClient = new ManagementClient(entityContext, mOptions);
        }
        entityContext.managementClient = managementClient;
        const clientEntityContext = entityContext;
        context.clientContexts[entityContext.clientId] = clientEntityContext;
        log.entityCtxt("[%s] Created client entity context for %s: %O", context.connectionId, clientId);
        return clientEntityContext;
    }
    ClientEntityContext.create = create;
})(ClientEntityContext || (ClientEntityContext = {}));
// Multiple clients for the same Service Bus entity should be using the same management client.
function getManagementClient(clients, entityPath) {
    let result;
    for (const id of Object.keys(clients)) {
        if (clients[id].entityPath === entityPath) {
            result = clients[id].managementClient;
            break;
        }
    }
    return result;
}
//# sourceMappingURL=clientEntityContext.js.map