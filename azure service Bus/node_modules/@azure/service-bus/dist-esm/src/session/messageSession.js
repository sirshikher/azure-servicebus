// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import { translate, Constants, ErrorNameConditionMapper } from "@azure/amqp-common";
import { ReceiverEvents, isAmqpError } from "rhea-promise";
import * as log from "../log";
import { LinkEntity } from "../core/linkEntity";
import { convertTicksToDate, calculateRenewAfterDuration } from "../util/utils";
import { throwErrorIfConnectionClosed } from "../util/errors";
import { ServiceBusMessage, DispositionType, ReceiveMode } from "../serviceBusMessage";
/**
 * Enum to denote who is calling the session receiver
 * @internal
 */
export var SessionCallee;
(function (SessionCallee) {
    SessionCallee["standalone"] = "standalone";
    SessionCallee["sessionManager"] = "sessionManager";
})(SessionCallee || (SessionCallee = {}));
/**
 * @internal
 * Describes the receiver for a Message Session.
 */
export class MessageSession extends LinkEntity {
    constructor(context, options) {
        super(context.entityPath, context, {
            address: context.entityPath,
            audience: `${context.namespace.config.endpoint}${context.entityPath}`
        });
        /**
         * @property {number} [maxConcurrentCalls] The maximum number of messages that should be
         * processed concurrently in a session while in streaming mode. Once this limit has been reached,
         * more messages will not be received until the user's message handler has completed processing current message.
         * - **Default**: `1` (message in a session at a time).
         */
        this.maxConcurrentCalls = 1;
        /**
         * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that
         * are being actively disposed. It acts as a store for correlating the responses received for
         * active dispositions.
         */
        this._deliveryDispositionMap = new Map();
        this._context.isSessionEnabled = true;
        this.isReceivingMessages = false;
        if (!options)
            options = { sessionId: undefined };
        this.autoComplete = false;
        this.sessionId = options.sessionId;
        this.receiveMode = options.receiveMode || ReceiveMode.peekLock;
        this.callee = options.callee || SessionCallee.standalone;
        this.maxAutoRenewDurationInSeconds =
            options.maxSessionAutoRenewLockDurationInSeconds != null
                ? options.maxSessionAutoRenewLockDurationInSeconds
                : 300;
        this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;
        this.autoRenewLock =
            this.maxAutoRenewDurationInSeconds > 0 && this.receiveMode === ReceiveMode.peekLock;
        // setting all the handlers
        this._onSettled = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const delivery = context.delivery;
            if (delivery) {
                const id = delivery.id;
                const state = delivery.remote_state;
                const settled = delivery.remote_settled;
                log.receiver("[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been " + "received.", connectionId, id, settled, state && state.error ? state.error : state);
                if (settled && this._deliveryDispositionMap.has(id)) {
                    const promise = this._deliveryDispositionMap.get(id);
                    clearTimeout(promise.timer);
                    log.receiver("[%s] Found the delivery with id %d in the map and cleared the timer.", connectionId, id);
                    const deleteResult = this._deliveryDispositionMap.delete(id);
                    log.receiver("[%s] Successfully deleted the delivery with id %d from the map.", connectionId, id, deleteResult);
                    if (state && state.error && (state.error.condition || state.error.description)) {
                        const error = translate(state.error);
                        return promise.reject(error);
                    }
                    return promise.resolve();
                }
            }
        };
        this._notifyError = (error) => {
            if (this._onError) {
                this._onError(error);
                log.error("[%s] Notified the user's error handler about the error received by the " +
                    "Receiver '%s'.", this._context.namespace.connectionId, this.name);
            }
        };
        this._onAmqpError = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const sbError = translate(receiverError);
                if (sbError.name === "SessionLockLostError") {
                    this._context.expiredMessageSessions[this.sessionId] = true;
                    sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;
                }
                log.error("[%s] An error occurred for Receiver '%s': %O.", connectionId, this.name, sbError);
                this._notifyError(sbError);
            }
        };
        this._onSessionError = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = translate(sessionError);
                log.error("[%s] An error occurred on the session for Receiver '%s': %O.", connectionId, this.name, sbError);
                this._notifyError(sbError);
            }
        };
        this._onAmqpClose = (context) => __awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            const receiverError = context.receiver && context.receiver.error;
            const receiver = this._receiver || context.receiver;
            let isClosedDueToExpiry = false;
            if (receiverError) {
                const sbError = translate(receiverError);
                if (sbError.name === "SessionLockLostError") {
                    isClosedDueToExpiry = true;
                }
                log.error("[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.sessionId, sbError);
                // no need to notify the user's error handler since rhea guarantees that receiver_error
                // will always be emitted before receiver_close.
            }
            if (receiver && !receiver.isItselfClosed()) {
                log.error("[%s] 'receiver_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", connectionId, this.name, this.sessionId);
                try {
                    yield this.close(isClosedDueToExpiry);
                }
                catch (err) {
                    log.error("[%s] An error occurred while closing the receiver '%s' for sessionId '%s': %O.", connectionId, this.name, this.sessionId, err);
                }
            }
            else {
                log.error("[%s] 'receiver_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "because the sdk initiated it. Hence no need to gracefully close the receiver", connectionId, this.name, this.sessionId);
            }
        });
        this._onSessionClose = (context) => __awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            const receiver = this._receiver || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = translate(sessionError);
                log.error("[%s] 'session_close' event occurred for receiver '%s' for sessionId '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.sessionId, sbError);
                // no need to notify the user's error handler since rhea guarantees that session_error
                // will always be emitted before session_close.
            }
            if (receiver && !receiver.isSessionItselfClosed()) {
                log.error("[%s] 'session_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", connectionId, this.name, this.sessionId);
                try {
                    yield this.close();
                }
                catch (err) {
                    log.error("[%s] An error occurred while closing the receiver '%s' for sessionId '%s': %O.", connectionId, this.name, this.sessionId, err);
                }
            }
            else {
                log.error("[%s] 'session_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "because the sdk initiated it. Hence no need to gracefully close the receiver", connectionId, this.name, this.sessionId);
            }
        });
    }
    /**
     * Ensures that the session lock is renewed before it expires. The lock will not be renewed for
     * more than the configured totalAutoLockRenewDuration.
     */
    _ensureSessionLockRenewal() {
        if (this.autoRenewLock &&
            new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc &&
            Date.now() < this._totalAutoLockRenewDuration &&
            this.isOpen()) {
            const connectionId = this._context.namespace.connectionId;
            const nextRenewalTimeout = calculateRenewAfterDuration(this.sessionLockedUntilUtc);
            this._sessionLockRenewalTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    log.messageSession("[%s] Attempting to renew the session lock for MessageSession '%s' " +
                        "with name '%s'.", connectionId, this.sessionId, this.name);
                    this.sessionLockedUntilUtc = yield this._context.managementClient.renewSessionLock(this.sessionId, {
                        delayInSeconds: 0,
                        timeoutInSeconds: 10,
                        times: 4
                    });
                    log.receiver("[%s] Successfully renewed the session lock for MessageSession '%s' " +
                        "with name '%s'.", connectionId, this.sessionId, this.name);
                    log.receiver("[%s] Calling _ensureSessionLockRenewal() again for MessageSession '%s'.", connectionId, this.sessionId);
                    this._ensureSessionLockRenewal();
                }
                catch (err) {
                    log.error("[%s] An error occurred while renewing the session lock for MessageSession " +
                        "'%s' with name '%s': %O", this._context.namespace.connectionId, this.sessionId, this.name, err);
                }
            }), nextRenewalTimeout);
            log.messageSession("[%s] MessageSession '%s' with name '%s', has next session lock renewal " +
                "in %d seconds @(%s).", this._context.namespace.connectionId, this.sessionId, this.name, nextRenewalTimeout / 1000, new Date(Date.now() + nextRenewalTimeout).toString());
        }
    }
    /**
     * Deletes the MessageSession from the internal cache.
     */
    _deleteFromCache() {
        this._receiver = undefined;
        delete this._context.messageSessions[this.sessionId];
        log.error("[%s] Deleted the receiver '%s' with sessionId '%s' from the client cache.", this._context.namespace.connectionId, this.name, this.sessionId);
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     */
    _init() {
        return __awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            try {
                if (!this.isOpen() && !this.isConnecting) {
                    log.error("[%s] The receiver '%s' with address '%s' is not open and is not currently " +
                        "establishing itself. Hence let's try to connect.", connectionId, this.name, this.address);
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    const options = this._createMessageSessionOptions();
                    log.error("[%s] Trying to create receiver '%s' with options %O", connectionId, this.name, options);
                    this._receiver = yield this._context.namespace.connection.createReceiver(options);
                    this.isConnecting = false;
                    const receivedSessionId = this._receiver.source &&
                        this._receiver.source.filter &&
                        this._receiver.source.filter[Constants.sessionFilterName];
                    let errorMessage = "";
                    // SB allows a sessionId with empty string value :)
                    if (receivedSessionId == null) {
                        errorMessage =
                            `Received an incorrect sessionId '${receivedSessionId}' while creating ` +
                                `the receiver '${this.name}'.`;
                    }
                    if (this.sessionId != null && receivedSessionId !== this.sessionId) {
                        errorMessage =
                            `Received sessionId '${receivedSessionId}' does not match the provided ` +
                                `sessionId '${this.sessionId}' while creating the receiver '${this.name}'.`;
                    }
                    if (errorMessage) {
                        const error = translate({
                            description: errorMessage,
                            condition: ErrorNameConditionMapper.SessionCannotBeLockedError
                        });
                        log.error("[%s] %O", this._context.namespace.connectionId, error);
                        throw error;
                    }
                    if (this.sessionId == null)
                        this.sessionId = receivedSessionId;
                    this.sessionLockedUntilUtc = convertTicksToDate(this._receiver.properties["com.microsoft:locked-until-utc"]);
                    log.messageSession("[%s] Session with id '%s' is locked until: '%s'.", connectionId, this.sessionId, this.sessionLockedUntilUtc.toISOString());
                    log.error("[%s] Receiver '%s' for sessionId '%s' has established itself.", connectionId, this.name, this.sessionId);
                    log.messageSession("Promise to create the receiver resolved. " + "Created receiver with name: ", this.name);
                    log.messageSession("[%s] Receiver '%s' created with receiver options: %O", connectionId, this.name, options);
                    if (!this._context.messageSessions[this.sessionId]) {
                        this._context.messageSessions[this.sessionId] = this;
                    }
                    this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;
                    yield this._ensureTokenRenewal();
                    yield this._ensureSessionLockRenewal();
                }
                else {
                    log.error("[%s] The receiver '%s' for sessionId '%s' is open -> %s and is connecting " +
                        "-> %s. Hence not reconnecting.", connectionId, this.name, this.sessionId, this.isOpen(), this.isConnecting);
                }
            }
            catch (err) {
                this.isConnecting = false;
                const errObj = translate(err);
                log.error("[%s] An error occured while creating the receiver '%s': %O", this._context.namespace.connectionId, this.name, errObj);
                throw errObj;
            }
        });
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */
    _createMessageSessionOptions() {
        const rcvrOptions = {
            name: this.name,
            autoaccept: false,
            // receiveAndDelete -> first(0), peekLock -> second (1)
            rcv_settle_mode: this.receiveMode === ReceiveMode.receiveAndDelete ? 0 : 1,
            // receiveAndDelete -> settled (1), peekLock -> unsettled (0)
            snd_settle_mode: this.receiveMode === ReceiveMode.receiveAndDelete ? 1 : 0,
            source: {
                address: this.address,
                filter: {}
            },
            credit_window: 0,
            onClose: (context) => this._onAmqpClose(context).catch(() => {
                /* */
            }),
            onSessionClose: (context) => this._onSessionClose(context).catch(() => {
                /* */
            }),
            onError: this._onAmqpError,
            onSessionError: this._onSessionError,
            onSettled: this._onSettled
        };
        rcvrOptions.source.filter[Constants.sessionFilterName] = this.sessionId;
        return rcvrOptions;
    }
    /**
     * Closes the underlying AMQP receiver link.
     * @param isClosedDueToExpiry Flag that denotes if close is invoked due to session expiring.
     * This is so that the internal map of expired sessions doesn't get cleared when session is
     * closed due to expiry.
     */
    close(isClosedDueToExpiry) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                log.messageSession("[%s] Closing the MessageSession '%s' for queue '%s'.", this._context.namespace.connectionId, this.sessionId, this.name);
                this.isReceivingMessages = false;
                if (this._newMessageReceivedTimer)
                    clearTimeout(this._newMessageReceivedTimer);
                if (this._sessionLockRenewalTimer)
                    clearTimeout(this._sessionLockRenewalTimer);
                log.messageSession("[%s] Cleared the timers for 'no new message received' task and " +
                    "'session lock renewal' task.", this._context.namespace.connectionId);
                if (!isClosedDueToExpiry) {
                    delete this._context.expiredMessageSessions[this.sessionId];
                }
                if (this._receiver) {
                    const receiverLink = this._receiver;
                    this._deleteFromCache();
                    yield this._closeLink(receiverLink);
                }
            }
            catch (err) {
                log.error("[%s] An error occurred while closing the message session with id '%s': %O.", this._context.namespace.connectionId, this.sessionId, err);
            }
        });
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     */
    isOpen() {
        const result = this._receiver && this._receiver.isOpen();
        log.messageSession("[%s] Receiver '%s' for sessionId '%s' is open? -> %s", this._context.namespace.connectionId, this.name, this.sessionId, result);
        return result;
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver or set the property
     * `newMessageWaitTimeoutInSeconds` in the options to provide a timeout.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed. You can
     * also provide a timeout in seconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     *
     * @returns void
     */
    receive(onMessage, onError, options) {
        if (!options)
            options = {};
        this.isReceivingMessages = true;
        if (typeof options.maxConcurrentCalls === "number" && options.maxConcurrentCalls > 0) {
            this.maxConcurrentCalls = options.maxConcurrentCalls;
        }
        // If explicitly set to false then autoComplete is false else true (default).
        this.autoComplete = options.autoComplete === false ? options.autoComplete : true;
        this._onMessage = onMessage;
        this._onError = onError;
        const connectionId = this._context.namespace.connectionId;
        /**
         * Resets the timer when a new message is received for Session Manager.
         * It will close the receiver gracefully, if no
         * messages were received for the configured newMessageWaitTimeoutInSeconds
         */
        const resetTimerOnNewMessageReceived = () => {
            if (this._newMessageReceivedTimer)
                clearTimeout(this._newMessageReceivedTimer);
            if (this.newMessageWaitTimeoutInSeconds) {
                this._newMessageReceivedTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    const msg = `MessageSession '${this.sessionId}' with name '${this.name}' did not receive ` +
                        `any messages in the last ${this.newMessageWaitTimeoutInSeconds} seconds. Hence closing it.`;
                    log.error("[%s] %s", this._context.namespace.connectionId, msg);
                    if (this.callee === SessionCallee.sessionManager) {
                        // The session manager will not forward this error to user.
                        // Instead, this is taken as a indicator to create a new session client for the next session.
                        const error = translate({
                            condition: "com.microsoft:message-wait-timeout",
                            description: msg
                        });
                        this._notifyError(translate(error));
                    }
                    yield this.close();
                }), this.newMessageWaitTimeoutInSeconds * 1000);
            }
        };
        if (this._receiver && this._receiver.isOpen()) {
            const onSessionMessage = (context) => __awaiter(this, void 0, void 0, function* () {
                // If the receiver got closed in PeekLock mode, avoid processing the message as we
                // cannot settle the message.
                if (this.receiveMode === ReceiveMode.peekLock &&
                    (!this._receiver || !this._receiver.isOpen())) {
                    log.error("[%s] Not calling the user's message handler for the current message " +
                        "as the receiver '%s' is closed", connectionId, this.name);
                    return;
                }
                resetTimerOnNewMessageReceived();
                const bMessage = new ServiceBusMessage(this._context, context.message, context.delivery, true);
                try {
                    yield this._onMessage(bMessage);
                }
                catch (err) {
                    // This ensures we call users' error handler when users' message handler throws.
                    if (!isAmqpError(err)) {
                        log.error("[%s] An error occurred while running user's message handler for the message " +
                            "with id '%s' on the receiver '%s': %O", connectionId, bMessage.messageId, this.name, err);
                        this._onError(err);
                    }
                    const error = translate(err);
                    // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                    if (!bMessage.delivery.remote_settled &&
                        this.receiveMode === ReceiveMode.peekLock &&
                        this.isOpen() // only try to abandon the messages if the connection is still open
                    ) {
                        try {
                            log.error("[%s] Abandoning the message with id '%s' on the receiver '%s' since " +
                                "an error occured: %O.", connectionId, bMessage.messageId, this.name, error);
                            yield bMessage.abandon();
                        }
                        catch (abandonError) {
                            const translatedError = translate(abandonError);
                            log.error("[%s] An error occurred while abandoning the message with id '%s' on the " +
                                "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                            this._notifyError(translatedError);
                        }
                    }
                    return;
                }
                finally {
                    if (this._receiver) {
                        this._receiver.addCredit(1);
                    }
                }
                // If we've made it this far, then user's message handler completed fine. Let us try
                // completing the message.
                if (this.autoComplete &&
                    this.receiveMode === ReceiveMode.peekLock &&
                    !bMessage.delivery.remote_settled) {
                    try {
                        log.messageSession("[%s] Auto completing the message with id '%s' on " + "the receiver '%s'.", connectionId, bMessage.messageId, this.name);
                        yield bMessage.complete();
                    }
                    catch (completeError) {
                        const translatedError = translate(completeError);
                        log.error("[%s] An error occurred while completing the message with id '%s' on the " +
                            "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                        this._notifyError(translatedError);
                    }
                }
            });
            // setting the "message" event listener.
            this._receiver.on(ReceiverEvents.message, onSessionMessage);
            // adding credit
            this._receiver.addCredit(this.maxConcurrentCalls);
        }
        else {
            this.isReceivingMessages = false;
            const msg = `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` +
                `has either not been created or is not open.`;
            log.error("[%s] %s", this._context.namespace.connectionId, msg);
            this._notifyError(new Error(msg));
        }
    }
    /**
     * Returns a batch of messages based on given count and timeout over an AMQP receiver link
     * from a Queue/Subscription.
     *
     * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
     * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * - **Default**: `60` seconds.
     * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
     */
    receiveMessages(maxMessageCount, maxWaitTimeInSeconds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (maxWaitTimeInSeconds == null) {
                maxWaitTimeInSeconds = Constants.defaultOperationTimeoutInSeconds;
            }
            const brokeredMessages = [];
            this.isReceivingMessages = true;
            return new Promise((resolve, reject) => {
                let totalWaitTimer;
                const setnewMessageWaitTimeoutInSeconds = (value) => {
                    this.newMessageWaitTimeoutInSeconds = value;
                };
                setnewMessageWaitTimeoutInSeconds(1);
                // Action to be performed on the "receiver_drained" event.
                const onReceiveDrain = () => {
                    this._receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);
                    this._receiver.drain = false;
                    this.isReceivingMessages = false;
                    log.messageSession("[%s] Receiver '%s' drained. Resolving receiveMessages() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                    resolve(brokeredMessages);
                };
                // Action to be performed after the max wait time is over.
                const actionAfterWaitTimeout = () => {
                    log.batching("[%s] Batching Receiver '%s'  max wait time in seconds %d over.", this._context.namespace.connectionId, this.name, maxWaitTimeInSeconds);
                    return finalAction();
                };
                // Action to be performed on the "message" event.
                const onReceiveMessage = (context) => __awaiter(this, void 0, void 0, function* () {
                    resetTimerOnNewMessageReceived();
                    try {
                        const data = new ServiceBusMessage(this._context, context.message, context.delivery, true);
                        if (brokeredMessages.length < maxMessageCount) {
                            brokeredMessages.push(data);
                        }
                    }
                    catch (err) {
                        // Removing listeners, so that the next receiveMessages() call can set them again.
                        if (this._receiver) {
                            this._receiver.removeListener(ReceiverEvents.message, onReceiveMessage);
                            this._receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);
                        }
                        log.error("[%s] Receiver '%s' received an error while converting AmqpMessage to ServiceBusMessage:\n%O", this._context.namespace.connectionId, this.name, err);
                        reject(err instanceof Error ? err : new Error(JSON.stringify(err)));
                    }
                    if (brokeredMessages.length === maxMessageCount) {
                        finalAction();
                    }
                });
                this._onError = (error) => {
                    this.isReceivingMessages = false;
                    // Resetting the newMessageWaitTimeoutInSeconds to undefined since we are done receiving
                    // a batch of messages.
                    setnewMessageWaitTimeoutInSeconds();
                    if (totalWaitTimer) {
                        clearTimeout(totalWaitTimer);
                    }
                    // Removing listeners, so that the next receiveMessages() call can set them again.
                    if (this._receiver) {
                        this._receiver.removeListener(ReceiverEvents.message, onReceiveMessage);
                        this._receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);
                    }
                    reject(error);
                };
                // Final action to be performed after maxMessageCount is reached or the maxWaitTime is over.
                const finalAction = () => {
                    if (this._newMessageReceivedTimer) {
                        clearTimeout(this._newMessageReceivedTimer);
                    }
                    if (totalWaitTimer) {
                        clearTimeout(totalWaitTimer);
                    }
                    // Unsetting the newMessageWaitTimeoutInSeconds to undefined since we are done receiving
                    // a batch of messages.
                    setnewMessageWaitTimeoutInSeconds();
                    // Removing listeners, so that the next receiveMessages() call can set them again.
                    if (this._receiver) {
                        this._receiver.removeListener(ReceiverEvents.message, onReceiveMessage);
                    }
                    if (this._receiver && this._receiver.credit > 0) {
                        log.messageSession("[%s] Receiver '%s': Draining leftover credits(%d).", this._context.namespace.connectionId, this.name, this._receiver.credit);
                        // Setting drain must be accompanied by a flow call (aliased to addCredit in this case).
                        this._receiver.drain = true;
                        this._receiver.addCredit(1);
                    }
                    else {
                        if (this._receiver) {
                            this._receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);
                        }
                        this.isReceivingMessages = false;
                        log.messageSession("[%s] Receiver '%s': Resolving receiveMessages() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                        resolve(brokeredMessages);
                    }
                };
                /**
                 * Resets the timer when a new message is received. If no messages were received for
                 * `newMessageWaitTimeoutInSeconds`, the messages received till now are returned. The
                 * receiver link stays open for the next receive call, but doesnt receive messages until then.
                 * The new message wait timer mechanism is used only in `peekLock` mode.
                 */
                const resetTimerOnNewMessageReceived = this.receiveMode === ReceiveMode.peekLock
                    ? () => {
                        if (this._newMessageReceivedTimer)
                            clearTimeout(this._newMessageReceivedTimer);
                        if (this.newMessageWaitTimeoutInSeconds) {
                            this._newMessageReceivedTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                                const msg = `MessageSession '${this.sessionId}' with name '${this.name}' did not receive ` +
                                    `any messages in the last ${this.newMessageWaitTimeoutInSeconds} seconds. Hence closing it.`;
                                log.error("[%s] %s", this._context.namespace.connectionId, msg);
                                finalAction();
                                if (this.callee === SessionCallee.sessionManager) {
                                    yield this.close();
                                }
                            }), this.newMessageWaitTimeoutInSeconds * 1000);
                        }
                    }
                    : () => { };
                const addCreditAndSetTimer = (reuse) => {
                    log.batching("[%s] Receiver '%s', adding credit for receiving %d messages.", this._context.namespace.connectionId, this.name, maxMessageCount);
                    // By adding credit here, we let the service know that at max we can handle `maxMessageCount`
                    // number of messages concurrently. We will return the user an array of messages that can
                    // be of size upto maxMessageCount. Then the user needs to accordingly dispose
                    // (complete,/abandon/defer/deadletter) the messages from the array.
                    this._receiver.addCredit(maxMessageCount);
                    let msg = "[%s] Setting the wait timer for %d seconds for receiver '%s'.";
                    if (reuse)
                        msg += " Receiver link already present, hence reusing it.";
                    log.batching(msg, this._context.namespace.connectionId, maxWaitTimeInSeconds, this.name);
                    totalWaitTimer = setTimeout(actionAfterWaitTimeout, maxWaitTimeInSeconds * 1000);
                };
                if (this.isOpen()) {
                    this._receiver.on(ReceiverEvents.message, onReceiveMessage);
                    this._receiver.on(ReceiverEvents.receiverDrained, onReceiveDrain);
                    addCreditAndSetTimer(true);
                }
                else {
                    const msg = `MessageSession "${this.name}" with sessionId "${this.sessionId}", ` +
                        `is already closed. Hence cannot receive messages in a batch.`;
                    log.error("[%s] %s", this._context.namespace.connectionId, msg);
                    reject(new Error(msg));
                }
            });
        });
    }
    /**
     * Settles the message with the specified disposition.
     * @param message The ServiceBus Message that needs to be settled.
     * @param operation The disposition type.
     * @param options Optional parameters that can be provided while disposing the message.
     */
    settleMessage(message, operation, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (!options)
                    options = {};
                if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {
                    return reject(new Error(`operation: '${operation}' is not a valid operation.`));
                }
                const delivery = message.delivery;
                const timer = setTimeout(() => {
                    this._deliveryDispositionMap.delete(delivery.id);
                    log.receiver("[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. " +
                        "Hence rejecting the promise with timeout error", this._context.namespace.connectionId, delivery.id, Constants.defaultOperationTimeoutInSeconds * 1000);
                    const e = {
                        condition: ErrorNameConditionMapper.ServiceUnavailableError,
                        description: "Operation to settle the message has timed out. The disposition of the " +
                            "message may or may not be successful"
                    };
                    return reject(translate(e));
                }, Constants.defaultOperationTimeoutInSeconds * 1000);
                this._deliveryDispositionMap.set(delivery.id, {
                    resolve: resolve,
                    reject: reject,
                    timer: timer
                });
                if (operation === DispositionType.complete) {
                    delivery.accept();
                }
                else if (operation === DispositionType.abandon) {
                    const params = {
                        undeliverable_here: false
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.defer) {
                    const params = {
                        undeliverable_here: true
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.deadletter) {
                    delivery.reject(options.error || {});
                }
            });
        });
    }
    /**
     * Creates a new instance of the MessageSession based on the provided parameters.
     * @param context The client entity context
     * @param options Options that can be provided while creating the MessageSession.
     */
    static create(context, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(context.namespace);
            const messageSession = new MessageSession(context, options);
            yield messageSession._init();
            return messageSession;
        });
    }
}
//# sourceMappingURL=messageSession.js.map