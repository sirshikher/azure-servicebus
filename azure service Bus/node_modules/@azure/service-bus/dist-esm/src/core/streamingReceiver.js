// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import { MessageReceiver, ReceiverType } from "./messageReceiver";
import * as log from "../log";
import { throwErrorIfConnectionClosed } from "../util/errors";
/**
 * @internal
 * Describes the streaming receiver where the user can receive the message
 * by providing handler functions.
 * @class StreamingReceiver
 * @extends MessageReceiver
 */
export class StreamingReceiver extends MessageReceiver {
    /**
     * Instantiate a new Streaming receiver for receiving messages with handlers.
     *
     * @constructor
     * @param {ClientEntityContext} context                      The client entity context.
     * @param {ReceiveOptions} [options]                         Options for how you'd like to connect.
     */
    constructor(context, options) {
        super(context, ReceiverType.streaming, options);
        this.resetTimerOnNewMessageReceived = () => {
            if (this._newMessageReceivedTimer)
                clearTimeout(this._newMessageReceivedTimer);
            if (this.newMessageWaitTimeoutInSeconds) {
                this._newMessageReceivedTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    const msg = `StreamingReceiver '${this.name}' did not receive any messages in ` +
                        `the last ${this.newMessageWaitTimeoutInSeconds} seconds. ` +
                        `Hence ending this receive operation.`;
                    log.error("[%s] %s", this._context.namespace.connectionId, msg);
                    yield this.close();
                }), this.newMessageWaitTimeoutInSeconds * 1000);
            }
        };
    }
    /**
     * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.
     *
     * @param {OnMessage} onMessage The message handler to receive servicebus messages.
     * @param {OnError} onError The error handler to receive an error that occurs while receivin messages.
     */
    receive(onMessage, onError) {
        throwErrorIfConnectionClosed(this._context.namespace);
        this._onMessage = onMessage;
        this._onError = onError;
        if (this._receiver) {
            this._receiver.addCredit(this.maxConcurrentCalls);
        }
    }
    /**
     * Creates a streaming receiver.
     * @static
     *
     * @param {ClientEntityContext} context    The connection context.
     * @param {ReceiveOptions} [options]     Receive options.
     * @return {Promise<StreamingReceiver>} A promise that resolves with an instance of StreamingReceiver.
     */
    static create(context, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(context.namespace);
            if (!options)
                options = {};
            if (options.autoComplete == null)
                options.autoComplete = true;
            const sReceiver = new StreamingReceiver(context, options);
            yield sReceiver._init();
            context.streamingReceiver = sReceiver;
            return sReceiver;
        });
    }
}
//# sourceMappingURL=streamingReceiver.js.map