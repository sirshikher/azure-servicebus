// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import * as Constants from "../util/constants";
import { serializeToAtomXmlRequest, deserializeAtomXmlResponse } from "../util/atomXmlHelper";
import { getStringOrUndefined, getCountDetailsOrUndefined, getRawAuthorizationRules, getAuthorizationRulesOrUndefined, getInteger, getBoolean, getString, getBooleanOrUndefined, getIntegerOrUndefined } from "../util/utils";
/**
 * @ignore
 * Builds the queue options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 * @param queueOptions
 */
export function buildQueueOptions(queueOptions) {
    return {
        LockDuration: queueOptions.lockDuration,
        MaxSizeInMegabytes: getStringOrUndefined(queueOptions.maxSizeInMegabytes),
        RequiresDuplicateDetection: getStringOrUndefined(queueOptions.requiresDuplicateDetection),
        RequiresSession: getStringOrUndefined(queueOptions.requiresSession),
        DefaultMessageTimeToLive: queueOptions.defaultMessageTtl,
        DeadLetteringOnMessageExpiration: getStringOrUndefined(queueOptions.deadLetteringOnMessageExpiration),
        DuplicateDetectionHistoryTimeWindow: queueOptions.duplicateDetectionHistoryTimeWindow,
        MaxDeliveryCount: getStringOrUndefined(queueOptions.maxDeliveryCount),
        EnableBatchedOperations: getStringOrUndefined(queueOptions.enableBatchedOperations),
        AuthorizationRules: getRawAuthorizationRules(queueOptions.authorizationRules),
        Status: getStringOrUndefined(queueOptions.status),
        AutoDeleteOnIdle: getStringOrUndefined(queueOptions.autoDeleteOnIdle),
        EnablePartitioning: getStringOrUndefined(queueOptions.enablePartitioning),
        ForwardDeadLetteredMessagesTo: getStringOrUndefined(queueOptions.forwardDeadLetteredMessagesTo),
        ForwardTo: getStringOrUndefined(queueOptions.forwardTo),
        UserMetadata: getStringOrUndefined(queueOptions.userMetadata)
    };
}
/**
 * @ignore
 * Builds the queue object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawQueue
 */
export function buildQueue(rawQueue) {
    return {
        queueName: getString(rawQueue[Constants.QUEUE_NAME], "queueName"),
        forwardTo: getStringOrUndefined(rawQueue[Constants.FORWARD_TO]),
        userMetadata: rawQueue[Constants.USER_METADATA],
        lockDuration: getString(rawQueue[Constants.LOCK_DURATION], "lockDuration"),
        sizeInBytes: getIntegerOrUndefined(rawQueue[Constants.SIZE_IN_BYTES]),
        maxSizeInMegabytes: getInteger(rawQueue[Constants.MAX_SIZE_IN_MEGABYTES], "maxSizeInMegabytes"),
        messageCount: getIntegerOrUndefined(rawQueue[Constants.MESSAGE_COUNT]),
        maxDeliveryCount: getInteger(rawQueue[Constants.MAX_DELIVERY_COUNT], "maxDeliveryCount"),
        enablePartitioning: getBoolean(rawQueue[Constants.ENABLE_PARTITIONING], "enablePartitioning"),
        requiresSession: getBoolean(rawQueue[Constants.REQUIRES_SESSION], "requiresSession"),
        enableBatchedOperations: getBoolean(rawQueue[Constants.ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
        defaultMessageTtl: getString(rawQueue[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTtl"),
        autoDeleteOnIdle: rawQueue[Constants.AUTO_DELETE_ON_IDLE],
        requiresDuplicateDetection: getBoolean(rawQueue[Constants.REQUIRES_DUPLICATE_DETECTION], "requiresDuplicateDetection"),
        duplicateDetectionHistoryTimeWindow: getString(rawQueue[Constants.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW], "duplicateDetectionHistoryTimeWindow"),
        deadLetteringOnMessageExpiration: getBoolean(rawQueue[Constants.DEAD_LETTERING_ON_MESSAGE_EXPIRATION], "deadLetteringOnMessageExpiration"),
        forwardDeadLetteredMessagesTo: getStringOrUndefined(rawQueue[Constants.FORWARD_DEADLETTERED_MESSAGES_TO]),
        messageCountDetails: getCountDetailsOrUndefined(rawQueue[Constants.COUNT_DETAILS]),
        supportOrdering: getBooleanOrUndefined(rawQueue[Constants.SUPPORT_ORDERING]),
        enableExpress: getBooleanOrUndefined(rawQueue[Constants.ENABLE_EXPRESS]),
        authorizationRules: getAuthorizationRulesOrUndefined(rawQueue[Constants.AUTHORIZATION_RULES]),
        isAnonymousAccessible: getBooleanOrUndefined(rawQueue[Constants.IS_ANONYMOUS_ACCESSIBLE]),
        entityAvailabilityStatus: rawQueue[Constants.ENTITY_AVAILABILITY_STATUS],
        status: rawQueue[Constants.STATUS],
        createdOn: rawQueue[Constants.CREATED_AT],
        updatedOn: rawQueue[Constants.UPDATED_AT],
        accessedOn: rawQueue[Constants.ACCESSED_AT]
    };
}
/**
 * @ignore
 * Atom XML Serializer for Queues.
 */
export class QueueResourceSerializer {
    serialize(resource) {
        return serializeToAtomXmlRequest("QueueDescription", resource);
    }
    deserialize(response) {
        return __awaiter(this, void 0, void 0, function* () {
            return deserializeAtomXmlResponse(["QueueName"], response);
        });
    }
}
//# sourceMappingURL=queueResourceSerializer.js.map