// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import * as Constants from "../util/constants";
import { serializeToAtomXmlRequest, deserializeAtomXmlResponse } from "../util/atomXmlHelper";
import { getStringOrUndefined, getIntegerOrUndefined, getBooleanOrUndefined, getCountDetailsOrUndefined, getString, getInteger, getBoolean } from "../util/utils";
/**
 * @ignore
 * Builds the subscription options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 * @param subscriptionOptions
 */
export function buildSubscriptionOptions(subscriptionOptions) {
    return {
        LockDuration: subscriptionOptions.lockDuration,
        RequiresSession: getStringOrUndefined(subscriptionOptions.requiresSession),
        DefaultMessageTimeToLive: getStringOrUndefined(subscriptionOptions.defaultMessageTtl),
        DeadLetteringOnMessageExpiration: getStringOrUndefined(subscriptionOptions.deadLetteringOnMessageExpiration),
        DeadLetteringOnFilterEvaluationExceptions: getStringOrUndefined(subscriptionOptions.deadLetteringOnFilterEvaluationExceptions),
        MaxDeliveryCount: getStringOrUndefined(subscriptionOptions.maxDeliveryCount),
        EnableBatchedOperations: getStringOrUndefined(subscriptionOptions.enableBatchedOperations),
        Status: getStringOrUndefined(subscriptionOptions.status),
        ForwardTo: getStringOrUndefined(subscriptionOptions.forwardTo),
        UserMetadata: getStringOrUndefined(subscriptionOptions.userMetadata),
        ForwardDeadLetteredMessagesTo: getStringOrUndefined(subscriptionOptions.forwardDeadLetteredMessagesTo),
        AutoDeleteOnIdle: getStringOrUndefined(subscriptionOptions.autoDeleteOnIdle)
    };
}
/**
 * @ignore
 * Builds the subscription object from the raw json object gotten after deserializing
 * the response from the service
 * @param rawSubscription
 */
export function buildSubscription(rawSubscription) {
    return {
        subscriptionName: getString(rawSubscription[Constants.SUBSCRIPTION_NAME], "subscriptionName"),
        topicName: getString(rawSubscription[Constants.TOPIC_NAME], "topicName"),
        lockDuration: getString(rawSubscription[Constants.LOCK_DURATION], "lockDuration"),
        sizeInBytes: getIntegerOrUndefined(rawSubscription[Constants.SIZE_IN_BYTES]),
        maxSizeInMegabytes: getIntegerOrUndefined(rawSubscription[Constants.MAX_SIZE_IN_MEGABYTES]),
        messageCount: getInteger(rawSubscription[Constants.MESSAGE_COUNT], "messageCount"),
        maxDeliveryCount: getInteger(rawSubscription[Constants.MAX_DELIVERY_COUNT], "maxDeliveryCount"),
        enablePartitioning: getBooleanOrUndefined(rawSubscription[Constants.ENABLE_PARTITIONING]),
        requiresSession: getBoolean(rawSubscription[Constants.REQUIRES_SESSION], "requiresSession"),
        enableBatchedOperations: getBoolean(rawSubscription[Constants.ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
        defaultMessageTtl: getString(rawSubscription[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTtl"),
        autoDeleteOnIdle: getString(rawSubscription[Constants.AUTO_DELETE_ON_IDLE], "autoDeleteOnIdle"),
        deadLetteringOnMessageExpiration: getBoolean(rawSubscription[Constants.DEAD_LETTERING_ON_MESSAGE_EXPIRATION], "deadLetteringOnMessageExpiration"),
        deadLetteringOnFilterEvaluationExceptions: getBoolean(rawSubscription[Constants.DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS], "deadLetteringOnFilterEvaluationExceptions"),
        forwardDeadLetteredMessagesTo: getStringOrUndefined(rawSubscription[Constants.FORWARD_DEADLETTERED_MESSAGES_TO]),
        defaultRuleDescription: rawSubscription[Constants.DEFAULT_RULE_DESCRIPTION],
        messageCountDetails: getCountDetailsOrUndefined(rawSubscription[Constants.COUNT_DETAILS]),
        forwardTo: getStringOrUndefined(rawSubscription[Constants.FORWARD_TO]),
        userMetadata: rawSubscription[Constants.USER_METADATA],
        entityAvailabilityStatus: getString(rawSubscription[Constants.ENTITY_AVAILABILITY_STATUS], "entityAvailabilityStatus"),
        status: getString(rawSubscription[Constants.STATUS], "status"),
        createdOn: getString(rawSubscription[Constants.CREATED_AT], "createdOn"),
        updatedOn: getString(rawSubscription[Constants.UPDATED_AT], "updatedOn"),
        accessedOn: rawSubscription[Constants.ACCESSED_AT]
    };
}
/**
 * @ignore
 * SubscriptionResourceSerializer for serializing / deserializing Subscription entities
 */
export class SubscriptionResourceSerializer {
    serialize(resource) {
        return serializeToAtomXmlRequest("SubscriptionDescription", resource);
    }
    deserialize(response) {
        return __awaiter(this, void 0, void 0, function* () {
            return deserializeAtomXmlResponse(["TopicName", "SubscriptionName"], response);
        });
    }
}
//# sourceMappingURL=subscriptionResourceSerializer.js.map