// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import * as Constants from "../util/constants";
import { serializeToAtomXmlRequest, deserializeAtomXmlResponse } from "../util/atomXmlHelper";
import { getStringOrUndefined, getIntegerOrUndefined, getCountDetailsOrUndefined, getRawAuthorizationRules, getAuthorizationRulesOrUndefined, getString, getInteger, getBoolean, getBooleanOrUndefined } from "../util/utils";
/**
 * @ignore
 * Builds the topic options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 * @param topicOptions
 */
export function buildTopicOptions(topicOptions) {
    return {
        DefaultMessageTimeToLive: topicOptions.defaultMessageTtl,
        MaxSizeInMegabytes: getStringOrUndefined(topicOptions.maxSizeInMegabytes),
        RequiresDuplicateDetection: getStringOrUndefined(topicOptions.requiresDuplicateDetection),
        DuplicateDetectionHistoryTimeWindow: topicOptions.duplicateDetectionHistoryTimeWindow,
        EnableBatchedOperations: getStringOrUndefined(topicOptions.enableBatchedOperations),
        AuthorizationRules: getRawAuthorizationRules(topicOptions.authorizationRules),
        Status: getStringOrUndefined(topicOptions.status),
        UserMetadata: getStringOrUndefined(topicOptions.userMetadata),
        SupportOrdering: getStringOrUndefined(topicOptions.supportOrdering),
        AutoDeleteOnIdle: getStringOrUndefined(topicOptions.autoDeleteOnIdle),
        EnablePartitioning: getStringOrUndefined(topicOptions.enablePartitioning)
    };
}
/**
 * @ignore
 * Builds the topic object from the raw json object gotten after deserializing the
 * response from the service
 * @param rawTopic
 */
export function buildTopic(rawTopic) {
    return {
        topicName: getString(rawTopic[Constants.TOPIC_NAME], "topicName"),
        sizeInBytes: getIntegerOrUndefined(rawTopic[Constants.SIZE_IN_BYTES]),
        maxSizeInMegabytes: getInteger(rawTopic[Constants.MAX_SIZE_IN_MEGABYTES], "maxSizeInMegabytes"),
        messageCount: getIntegerOrUndefined(rawTopic[Constants.MESSAGE_COUNT]),
        maxDeliveryCount: getIntegerOrUndefined(rawTopic[Constants.MAX_DELIVERY_COUNT]),
        subscriptionCount: getIntegerOrUndefined(rawTopic[Constants.SUBSCRIPTION_COUNT]),
        enablePartitioning: getBoolean(rawTopic[Constants.ENABLE_PARTITIONING], "enablePartitioning"),
        supportOrdering: getBoolean(rawTopic[Constants.SUPPORT_ORDERING], "supportOrdering"),
        enableBatchedOperations: getBoolean(rawTopic[Constants.ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
        defaultMessageTtl: getString(rawTopic[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTtl"),
        autoDeleteOnIdle: getStringOrUndefined(rawTopic[Constants.AUTO_DELETE_ON_IDLE]),
        requiresDuplicateDetection: getBoolean(rawTopic[Constants.REQUIRES_DUPLICATE_DETECTION], "requiresDuplicateDetection"),
        duplicateDetectionHistoryTimeWindow: getString(rawTopic[Constants.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW], "duplicateDetectionHistoryTimeWindow"),
        filteringMessagesBeforePublishing: getBooleanOrUndefined(rawTopic[Constants.FILTER_MESSAGES_BEFORE_PUBLISHING]),
        enableSubscriptionPartitioning: getBooleanOrUndefined(rawTopic[Constants.ENABLE_SUBSCRIPTION_PARTITIONING]),
        messageCountDetails: getCountDetailsOrUndefined(rawTopic[Constants.COUNT_DETAILS]),
        isExpress: getBooleanOrUndefined(rawTopic[Constants.IS_EXPRESS]),
        enableExpress: getBooleanOrUndefined(rawTopic[Constants.ENABLE_EXPRESS]),
        authorizationRules: getAuthorizationRulesOrUndefined(rawTopic[Constants.AUTHORIZATION_RULES]),
        isAnonymousAccessible: getBooleanOrUndefined(rawTopic[Constants.IS_ANONYMOUS_ACCESSIBLE]),
        userMetadata: rawTopic[Constants.USER_METADATA],
        entityAvailabilityStatus: rawTopic[Constants.ENTITY_AVAILABILITY_STATUS],
        status: rawTopic[Constants.STATUS],
        createdOn: rawTopic[Constants.CREATED_AT],
        updatedOn: rawTopic[Constants.UPDATED_AT],
        accessedOn: rawTopic[Constants.ACCESSED_AT]
    };
}
/**
 * @ignore TopicResourceSerializer for serializing / deserializing Topic entities
 */
export class TopicResourceSerializer {
    serialize(resource) {
        return serializeToAtomXmlRequest("TopicDescription", resource);
    }
    deserialize(response) {
        return __awaiter(this, void 0, void 0, function* () {
            return deserializeAtomXmlResponse(["TopicName"], response);
        });
    }
}
//# sourceMappingURL=topicResourceSerializer.js.map