// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import * as log from "./log";
import { Receiver, SessionReceiver } from "./receiver";
import { ClientType } from "./client";
import { getOpenReceiverErrorMsg, throwErrorIfClientOrConnectionClosed, throwErrorIfConnectionClosed } from "./util/errors";
import { generate_uuid } from "rhea-promise";
import { ClientEntityContext } from "./clientEntityContext";
/**
 * Describes the client that allows interacting with a Service Bus Subscription.
 * Use the `createSubscriptionClient` function on the ServiceBusClient object to instantiate a
 * SubscriptionClient
 * @class SubscriptionClient
 */
export class SubscriptionClient {
    /**
     * Constructor for SubscriptionClient.
     * This is not meant for the user to call directly.
     * The user should use the `createSubscriptionClient` on the Namespace instead.
     *
     * @constructor
     * @internal
     * @param topicName - The Topic name.
     * @param subscriptionName - The Subscription name.
     * @param context - The connection context to create the SubscriptionClient.
     * @throws Error if the underlying connection is closed.
     */
    constructor(topicName, subscriptionName, context) {
        /**
         * @readonly
         * @property The name of the default rule on the subscription.
         */
        this.defaultRuleName = "$Default";
        throwErrorIfConnectionClosed(context);
        this.topicName = String(topicName);
        this.subscriptionName = String(subscriptionName);
        this.entityPath = `${topicName}/Subscriptions/${subscriptionName}`;
        this.id = `${this.entityPath}/${generate_uuid()}`;
        this._context = ClientEntityContext.create(this.entityPath, ClientType.SubscriptionClient, context, this.id);
    }
    /**
     * Closes the AMQP link for the receivers created by this client.
     * Once closed, neither the SubscriptionClient nor its receivers can be used for any
     * further operations.
     *
     * @returns {Promise<void>}
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Close the corresponding client context which will take care of closing all AMQP links
                // associated with this client
                yield this._context.close();
            }
            catch (err) {
                log.error("[%s] An error occurred while closing the SubscriptionClient for %s: %O", this._context.namespace.connectionId, this.id, err);
                throw err;
            }
        });
    }
    createReceiver(receiveMode, sessionOptions) {
        throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
        // Receiver for Subscription where sessions are not enabled
        if (!sessionOptions) {
            if (!this._currentReceiver || this._currentReceiver.isClosed) {
                this._currentReceiver = new Receiver(this._context, receiveMode);
                return this._currentReceiver;
            }
            const errorMessage = getOpenReceiverErrorMsg(ClientType.SubscriptionClient, this.entityPath);
            const error = new Error(errorMessage);
            log.error(`[${this._context.namespace.connectionId}] %O`, error);
            throw error;
        }
        return new SessionReceiver(this._context, receiveMode, sessionOptions);
    }
    /**
     * Fetches the next batch of active messages (including deferred but not deadlettered messages).
     * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the
     * subsequent message.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peek(maxMessageCount) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.peek(maxMessageCount);
        });
    }
    /**
     * Peeks the desired number of active messages (including deferred but not deadlettered messages)
     * from the specified sequence number.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peekBySequenceNumber(fromSequenceNumber, maxMessageCount) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.peekBySequenceNumber(fromSequenceNumber, maxMessageCount);
        });
    }
    // #region topic-filters
    /**
     * Gets all rules associated with the subscription
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while retrieving rules.
     */
    getRules() {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.getRules();
        });
    }
    /**
     * Removes the rule on the subscription identified by the given rule name.
     *
     * **Caution**: If all rules on a subscription are removed, then the subscription will not receive
     * any more messages.
     * @param ruleName
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while removing rules.
     */
    removeRule(ruleName) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.removeRule(ruleName);
        });
    }
    /**
     * Adds a rule on the subscription as defined by the given rule name, filter and action.
     *
     * **Note**: Remove the default true filter on the subscription before adding a rule.
     * Otherwise, the added rule will have no affect as the true filter will always result in
     * the subscription receiving all messages.
     * @param ruleName Name of the rule
     * @param filter A Boolean, SQL expression or a Correlation filter. For SQL Filter syntax, see
     * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-filter SQLFilter syntax}.
     * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression. For SQL Rule Action syntax,
     * see {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-rule-action SQLRuleAction syntax}.
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while adding rules.
     */
    addRule(ruleName, filter, sqlRuleActionExpression) {
        return __awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.addRule(ruleName, filter, sqlRuleActionExpression);
        });
    }
}
//# sourceMappingURL=subscriptionClient.js.map