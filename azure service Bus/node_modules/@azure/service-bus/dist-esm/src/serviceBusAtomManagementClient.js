// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import { WebResource, ServiceClient, signingPolicy, proxyPolicy, URLBuilder, stripRequest, stripResponse, RestError } from "@azure/core-http";
import { SasTokenProvider, parseConnectionString } from "@azure/amqp-common";
import { executeAtomXmlOperation } from "./util/atomXmlHelper";
import * as log from "./log";
import { SasServiceClientCredentials } from "./util/sasServiceClientCredentials";
import * as Constants from "./util/constants";
import { QueueResourceSerializer, buildQueueOptions, buildQueue } from "./serializers/queueResourceSerializer";
import { TopicResourceSerializer, buildTopicOptions, buildTopic } from "./serializers/topicResourceSerializer";
import { SubscriptionResourceSerializer, buildSubscriptionOptions, buildSubscription } from "./serializers/subscriptionResourceSerializer";
import { RuleResourceSerializer, buildRuleOptions, buildRule } from "./serializers/ruleResourceSerializer";
import { isJSONLikeObject, isAbsoluteUrl } from "./util/utils";
/**
 * All operations return promises that resolve to an object that has the relevant output.
 * These objects also have a property called `_response` that you can use if you want to
 * access the direct response from the service.
 */
export class ServiceBusAtomManagementClient extends ServiceClient {
    /**
     * Initializes a new instance of the ServiceBusManagementClient class.
     * @param connectionString The connection string needed for the client to connect to Azure.
     * @param options ServiceBusAtomManagementClientOptions
     */
    constructor(connectionString, options) {
        const connectionStringObj = parseConnectionString(connectionString);
        if (connectionStringObj.Endpoint == undefined) {
            throw new Error("Missing Endpoint in connection string.");
        }
        const credentials = new SasServiceClientCredentials(connectionStringObj.SharedAccessKeyName, connectionStringObj.SharedAccessKey);
        const requestPolicyFactories = [];
        requestPolicyFactories.push(signingPolicy(credentials));
        if (options && options.proxySettings) {
            requestPolicyFactories.push(proxyPolicy(options.proxySettings));
        }
        const serviceClientOptions = {
            requestPolicyFactories: requestPolicyFactories
        };
        super(credentials, serviceClientOptions);
        this.queueResourceSerializer = new QueueResourceSerializer();
        this.topicResourceSerializer = new TopicResourceSerializer();
        this.subscriptionResourceSerializer = new SubscriptionResourceSerializer();
        this.ruleResourceSerializer = new RuleResourceSerializer();
        this.endpoint = (connectionString.match("Endpoint=sb://(.*)/;") || "")[1];
        this.endpointWithProtocol = connectionStringObj.Endpoint;
        this.sasTokenProvider = new SasTokenProvider(connectionStringObj.Endpoint, connectionStringObj.SharedAccessKeyName, connectionStringObj.SharedAccessKey);
    }
    /**
     * Creates a queue with given name, configured using the given options
     * @param queueName
     * @param queueOptions Options to configure the Queue being created.
     * For example, you can configure a queue to support partitions or sessions.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    createQueue(queueName, queueOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - createQueue() for "${queueName}" with options: ${queueOptions}`);
            const response = yield this.putResource(queueName, buildQueueOptions(queueOptions || {}), this.queueResourceSerializer, false);
            return this.buildQueueResponse(response);
        });
    }
    /**
     * Returns an object representing the Queue with the given name along with all its properties
     * @param queueName
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    getQueueDetails(queueName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - getQueue() for "${queueName}"`);
            const response = yield this.getResource(queueName, this.queueResourceSerializer);
            return this.buildQueueResponse(response);
        });
    }
    /**
     * Lists existing queues.
     * @param listRequestOptions
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    listQueues(listRequestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - listQueues() with options: ${listRequestOptions}`);
            const response = yield this.listResources("$Resources/Queues", listRequestOptions, this.queueResourceSerializer);
            return this.buildListQueuesResponse(response);
        });
    }
    /**
     * Updates properties on the Queue by the given name based on the given options
     * @param queueName
     * @param queueOptions Options to configure the Queue being updated.
     * For example, you can configure a queue to support partitions or sessions.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    updateQueue(queueName, queueOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - updateQueue() for "${queueName}" with options: ${queueOptions}`);
            if (!isJSONLikeObject(queueOptions) || queueOptions === null) {
                throw new TypeError(`Parameter "queueOptions" must be an object of type "QueueOptions" and cannot be undefined or null.`);
            }
            const finalQueueOptions = {};
            const getQueueResult = yield this.getQueueDetails(queueName);
            Object.assign(finalQueueOptions, getQueueResult, queueOptions);
            const response = yield this.putResource(queueName, buildQueueOptions(finalQueueOptions), this.queueResourceSerializer, true);
            return this.buildQueueResponse(response);
        });
    }
    /**
     * Deletes a queue.
     * @param queueName
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    deleteQueue(queueName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - deleteQueue() for "${queueName}"`);
            const response = yield this.deleteResource(queueName, this.queueResourceSerializer);
            return { _response: response };
        });
    }
    /**
     * Creates a topic with given name, configured using the given options
     * @param topicName
     * @param topicOptions Options to configure the Topic being created.
     * For example, you can configure a topic to support partitions or sessions.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    createTopic(topicName, topicOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - createTopic() for "${topicName}" with options: ${topicOptions}`);
            const response = yield this.putResource(topicName, buildTopicOptions(topicOptions || {}), this.topicResourceSerializer, false);
            return this.buildTopicResponse(response);
        });
    }
    /**
     * Returns an object representing the Topic with the given name along with all its properties
     * @param topicName
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    getTopicDetails(topicName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - getTopic() for "${topicName}"`);
            const response = yield this.getResource(topicName, this.topicResourceSerializer);
            return this.buildTopicResponse(response);
        });
    }
    /**
     * Lists existing topics.
     * @param listRequestOptions
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    listTopics(listRequestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - listTopics() with options: ${listRequestOptions}`);
            const response = yield this.listResources("$Resources/Topics", listRequestOptions, this.topicResourceSerializer);
            return this.buildListTopicsResponse(response);
        });
    }
    /**
     * Updates properties on the Topic by the given name based on the given options
     * @param topicName
     * @param topicOptions Options to configure the Topic being updated.
     * For example, you can configure a topic to support partitions or sessions.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    updateTopic(topicName, topicOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - updateTopic() for "${topicName}" with options: ${topicOptions}`);
            if (!isJSONLikeObject(topicOptions) || topicOptions === null) {
                throw new TypeError(`Parameter "topicOptions" must be an object of type "TopicOptions" and cannot be undefined or null.`);
            }
            const finalTopicOptions = {};
            const getTopicResult = yield this.getTopicDetails(topicName);
            Object.assign(finalTopicOptions, getTopicResult, topicOptions);
            const response = yield this.putResource(topicName, buildTopicOptions(finalTopicOptions), this.topicResourceSerializer, true);
            return this.buildTopicResponse(response);
        });
    }
    /**
     * Deletes a topic.
     * @param topicName
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    deleteTopic(topicName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - deleteTopic() for "${topicName}"`);
            const response = yield this.deleteResource(topicName, this.topicResourceSerializer);
            return { _response: response };
        });
    }
    /**
     * Creates a subscription with given name, configured using the given options
     * @param topicName
     * @param subscriptionName
     * @param subscriptionOptions Options to configure the Subscription being created.
     * For example, you can configure a Subscription to support partitions or sessions.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    createSubscription(topicName, subscriptionName, subscriptionOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - createSubscription() for "${subscriptionName}" with options: ${subscriptionOptions}`);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const response = yield this.putResource(fullPath, buildSubscriptionOptions(subscriptionOptions || {}), this.subscriptionResourceSerializer, false);
            return this.buildSubscriptionResponse(response);
        });
    }
    /**
     * Returns an object representing the Subscription with the given name along with all its properties
     * @param topicName
     * @param subscriptionName
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    getSubscriptionDetails(topicName, subscriptionName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - getSubscription() for "${subscriptionName}"`);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const response = yield this.getResource(fullPath, this.subscriptionResourceSerializer);
            return this.buildSubscriptionResponse(response);
        });
    }
    /**
     * Lists existing subscriptions.
     * @param topicName
     * @param listRequestOptions
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    listSubscriptions(topicName, listRequestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - listSubscriptions() with options: ${listRequestOptions}`);
            const response = yield this.listResources(topicName + "/Subscriptions/", listRequestOptions, this.subscriptionResourceSerializer);
            return this.buildListSubscriptionsResponse(response);
        });
    }
    /**
     * Updates properties on the Subscription by the given name based on the given options
     * @param topicName
     * @param subscriptionName
     * @param subscriptionOptions Options to configure the Subscription being updated.
     * For example, you can configure a Subscription to support partitions or sessions.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    updateSubscription(topicName, subscriptionName, subscriptionOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - updateSubscription() for "${subscriptionName}" with options: ${subscriptionOptions}`);
            if (!isJSONLikeObject(subscriptionOptions) || subscriptionOptions === null) {
                throw new TypeError(`Parameter "subscriptionOptions" must be an object of type "SubscriptionOptions" and cannot be undefined or null.`);
            }
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const finalSubscriptionOptions = {};
            const getSubscriptionResult = yield this.getSubscriptionDetails(topicName, subscriptionName);
            Object.assign(finalSubscriptionOptions, getSubscriptionResult, subscriptionOptions);
            const response = yield this.putResource(fullPath, buildSubscriptionOptions(finalSubscriptionOptions), this.subscriptionResourceSerializer, true);
            return this.buildSubscriptionResponse(response);
        });
    }
    /**
     * Deletes a subscription.
     * @param topicName
     * @param subscriptionName
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    deleteSubscription(topicName, subscriptionName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - deleteSubscription() for "${subscriptionName}"`);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const response = yield this.deleteResource(fullPath, this.subscriptionResourceSerializer);
            return { _response: response };
        });
    }
    /**
     * Creates a rule with given name, configured using the given options.
     * @param topicName
     * @param subscriptionName
     * @param ruleName
     * @param ruleOptions
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    createRule(topicName, subscriptionName, ruleName, ruleOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - createRule() for "${ruleName}" with options: "${ruleOptions}"`);
            const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
            const response = yield this.putResource(fullPath, buildRuleOptions(ruleName, ruleOptions), this.ruleResourceSerializer, false);
            return this.buildRuleResponse(response);
        });
    }
    /**
     * Returns an object representing the Rule with the given name along with all its properties.
     * @param topicName
     * @param subscriptioName
     * @param ruleName
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    getRuleDetails(topicName, subscriptioName, ruleName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - getRule() for "${ruleName}"`);
            const fullPath = this.getRulePath(topicName, subscriptioName, ruleName);
            const response = yield this.getResource(fullPath, this.ruleResourceSerializer);
            return this.buildRuleResponse(response);
        });
    }
    /**
     * Lists existing rules.
     * @param topicName
     * @param subscriptionName
     * @param listRequestOptions
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    listRules(topicName, subscriptionName, listRequestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - listRules() with options: ${listRequestOptions}`);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName) + "/Rules/";
            const response = yield this.listResources(fullPath, listRequestOptions, this.ruleResourceSerializer);
            return this.buildListRulesResponse(response);
        });
    }
    /**
     * Updates properties on the Rule by the given name based on the given options.
     * @param topicName
     * @param subscriptionName
     * @param ruleName
     * @param ruleOptions Options to configure the Rule being updated.
     * For example, you can configure the filter to apply on associated Topic/Subscription.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    updateRule(topicName, subscriptionName, ruleName, ruleOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - updateRule() for "${ruleName}" with options: ${ruleOptions}`);
            if (!isJSONLikeObject(ruleOptions) || ruleOptions === null) {
                throw new TypeError(`Parameter "ruleOptions" must be an object of type "RuleOptions" and cannot be undefined or null.`);
            }
            const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
            const response = yield this.putResource(fullPath, buildRuleOptions(ruleName, ruleOptions), this.ruleResourceSerializer, true);
            return this.buildRuleResponse(response);
        });
    }
    /**
     * Deletes a rule.
     * @param topicName
     * @param subscriptionName
     * @param ruleName
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code that is a value from the standard set of HTTP status codes as documented at
     * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
     */
    deleteRule(topicName, subscriptionName, ruleName) {
        return __awaiter(this, void 0, void 0, function* () {
            log.httpAtomXml(`Performing management operation - deleteRule() for "${ruleName}"`);
            const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
            const response = yield this.deleteResource(fullPath, this.ruleResourceSerializer);
            return { _response: response };
        });
    }
    /**
     * Creates or updates a resource based on `isUpdate` parameter.
     * @param name
     * @param entityFields
     * @param isUpdate
     * @param serializer
     */
    putResource(name, entityFields, serializer, isUpdate = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const webResource = new WebResource(this.getUrl(name), "PUT");
            webResource.body = entityFields;
            if (isUpdate) {
                webResource.headers.set("If-Match", "*");
            }
            const queueOrSubscriptionFields = entityFields;
            if (queueOrSubscriptionFields.ForwardTo ||
                queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {
                const token = (yield this.sasTokenProvider.getToken(this.endpoint)).token;
                if (queueOrSubscriptionFields.ForwardTo) {
                    webResource.headers.set("ServiceBusSupplementaryAuthorization", token);
                    if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardTo)) {
                        queueOrSubscriptionFields.ForwardTo = this.endpointWithProtocol.concat(queueOrSubscriptionFields.ForwardTo);
                    }
                }
                if (queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {
                    webResource.headers.set("ServiceBusDlqSupplementaryAuthorization", token);
                    if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo)) {
                        queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo = this.endpointWithProtocol.concat(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo);
                    }
                }
            }
            webResource.headers.set("content-type", "application/atom+xml;type=entry;charset=utf-8");
            return executeAtomXmlOperation(this, webResource, serializer);
        });
    }
    /**
     * Gets a resource.
     * @param name
     * @param serializer
     */
    getResource(name, serializer) {
        return __awaiter(this, void 0, void 0, function* () {
            const webResource = new WebResource(this.getUrl(name), "GET");
            const response = yield executeAtomXmlOperation(this, webResource, serializer);
            if (response.parsedBody == undefined ||
                (Array.isArray(response.parsedBody) && response.parsedBody.length == 0)) {
                const err = new RestError(`The messaging entity "${name}" being requested cannot be found.`, "MessageEntityNotFoundError", 404, stripRequest(webResource), stripResponse(response));
                throw err;
            }
            return response;
        });
    }
    /**
     * Lists existing resources
     * @param name
     * @param listRequestOptions
     * @param serializer
     */
    listResources(name, listRequestOptions, serializer) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParams = {};
            if (listRequestOptions) {
                if (listRequestOptions.skip) {
                    queryParams["$skip"] = listRequestOptions.skip.toString();
                }
                if (listRequestOptions.top) {
                    queryParams["$top"] = listRequestOptions.top.toString();
                }
            }
            const webResource = new WebResource(this.getUrl(name, queryParams), "GET");
            return executeAtomXmlOperation(this, webResource, serializer);
        });
    }
    /**
     * Deletes a resource.
     * @param name
     */
    deleteResource(name, serializer) {
        return __awaiter(this, void 0, void 0, function* () {
            const webResource = new WebResource(this.getUrl(name), "DELETE");
            return executeAtomXmlOperation(this, webResource, serializer);
        });
    }
    getUrl(path, queryParams) {
        const baseUri = `https://${this.endpoint}/${path}`;
        const requestUrl = URLBuilder.parse(baseUri);
        requestUrl.setQueryParameter(Constants.API_VERSION_QUERY_KEY, Constants.CURRENT_API_VERSION);
        if (queryParams) {
            for (const key of Object.keys(queryParams)) {
                requestUrl.setQueryParameter(key, queryParams[key]);
            }
        }
        return requestUrl.toString();
    }
    getSubscriptionPath(topicName, subscriptionName) {
        return topicName + "/Subscriptions/" + subscriptionName;
    }
    getRulePath(topicName, subscriptionName, ruleName) {
        return topicName + "/Subscriptions/" + subscriptionName + "/Rules/" + ruleName;
    }
    buildListQueuesResponse(response) {
        try {
            const queues = [];
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawQueueArray = response.parsedBody;
            for (let i = 0; i < rawQueueArray.length; i++) {
                const queue = buildQueue(rawQueueArray[i]);
                if (queue) {
                    queues.push(queue);
                }
            }
            const listQueuesResponse = Object.assign(queues, {
                _response: response
            });
            return listQueuesResponse;
        }
        catch (err) {
            log.warning("Failure parsing response from service - %0 ", err);
            throw new RestError(`Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`, RestError.PARSE_ERROR, response.status, stripRequest(response.request), stripResponse(response));
        }
    }
    buildQueueResponse(response) {
        try {
            const queue = buildQueue(response.parsedBody);
            const queueResponse = Object.assign(queue || {}, {
                _response: response
            });
            return queueResponse;
        }
        catch (err) {
            log.warning("Failure parsing response from service - %0 ", err);
            throw new RestError(`Error occurred while parsing the response body - cannot form a queue object using the response from the service.`, RestError.PARSE_ERROR, response.status, stripRequest(response.request), stripResponse(response));
        }
    }
    buildListTopicsResponse(response) {
        try {
            const topics = [];
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawTopicArray = response.parsedBody;
            for (let i = 0; i < rawTopicArray.length; i++) {
                const topic = buildTopic(rawTopicArray[i]);
                if (topic) {
                    topics.push(topic);
                }
            }
            const listTopicsResponse = Object.assign(topics, {
                _response: response
            });
            return listTopicsResponse;
        }
        catch (err) {
            log.warning("Failure parsing response from service - %0 ", err);
            throw new RestError(`Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`, RestError.PARSE_ERROR, response.status, stripRequest(response.request), stripResponse(response));
        }
    }
    buildTopicResponse(response) {
        try {
            const topic = buildTopic(response.parsedBody);
            const topicResponse = Object.assign(topic || {}, {
                _response: response
            });
            return topicResponse;
        }
        catch (err) {
            log.warning("Failure parsing response from service - %0 ", err);
            throw new RestError(`Error occurred while parsing the response body - cannot form a topic object using the response from the service.`, RestError.PARSE_ERROR, response.status, stripRequest(response.request), stripResponse(response));
        }
    }
    buildListSubscriptionsResponse(response) {
        try {
            const subscriptions = [];
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawSubscriptionArray = response.parsedBody;
            for (let i = 0; i < rawSubscriptionArray.length; i++) {
                const subscription = buildSubscription(rawSubscriptionArray[i]);
                if (subscription) {
                    subscriptions.push(subscription);
                }
            }
            const listSubscriptionsResponse = Object.assign(subscriptions, {
                _response: response
            });
            return listSubscriptionsResponse;
        }
        catch (err) {
            log.warning("Failure parsing response from service - %0 ", err);
            throw new RestError(`Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`, RestError.PARSE_ERROR, response.status, stripRequest(response.request), stripResponse(response));
        }
    }
    buildSubscriptionResponse(response) {
        try {
            const subscription = buildSubscription(response.parsedBody);
            const subscriptionResponse = Object.assign(subscription || {}, {
                _response: response
            });
            return subscriptionResponse;
        }
        catch (err) {
            log.warning("Failure parsing response from service - %0 ", err);
            throw new RestError(`Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`, RestError.PARSE_ERROR, response.status, stripRequest(response.request), stripResponse(response));
        }
    }
    buildListRulesResponse(response) {
        try {
            const rules = [];
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawRuleArray = response.parsedBody;
            for (let i = 0; i < rawRuleArray.length; i++) {
                const rule = buildRule(rawRuleArray[i]);
                if (rule) {
                    rules.push(rule);
                }
            }
            const listRulesResponse = Object.assign(rules, {
                _response: response
            });
            return listRulesResponse;
        }
        catch (err) {
            log.warning("Failure parsing response from service - %0 ", err);
            throw new RestError(`Error occurred while parsing the response body - cannot form a list of rules using the response from the service.`, RestError.PARSE_ERROR, response.status, stripRequest(response.request), stripResponse(response));
        }
    }
    buildRuleResponse(response) {
        try {
            const rule = buildRule(response.parsedBody);
            const ruleResponse = Object.assign(rule || {}, { _response: response });
            return ruleResponse;
        }
        catch (err) {
            log.warning("Failure parsing response from service - %0 ", err);
            throw new RestError(`Error occurred while parsing the response body - cannot form a rule object using the response from the service.`, RestError.PARSE_ERROR, response.status, stripRequest(response.request), stripResponse(response));
        }
    }
}
//# sourceMappingURL=serviceBusAtomManagementClient.js.map