// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import Long from "long";
import { uuid_to_string } from "rhea-promise";
import { Constants, translate, ErrorNameConditionMapper } from "@azure/amqp-common";
import * as log from "./log";
import { reorderLockToken } from "../src/util/utils";
import { getErrorMessageNotSupportedInReceiveAndDeleteMode } from "./util/errors";
import { Buffer } from "buffer";
/**
 * The mode in which messages should be received. The 2 modes are `peekLock` and `receiveAndDelete`.
 */
export var ReceiveMode;
(function (ReceiveMode) {
    /**
     * Once a message is received in this mode, the receiver has a lock on the message for a
     * particular duration. If the message is not settled by this time, it lands back on Service Bus
     * to be fetched by the next receive operation.
     * @type {Number}
     */
    ReceiveMode[ReceiveMode["peekLock"] = 1] = "peekLock";
    /**
     * Messages received in this mode get automatically removed from Service Bus.
     * @type {Number}
     */
    ReceiveMode[ReceiveMode["receiveAndDelete"] = 2] = "receiveAndDelete";
})(ReceiveMode || (ReceiveMode = {}));
/**
 * @internal
 */
export var DispositionType;
(function (DispositionType) {
    DispositionType["complete"] = "complete";
    DispositionType["deadletter"] = "deadletter";
    DispositionType["abandon"] = "abandon";
    DispositionType["defer"] = "defer";
})(DispositionType || (DispositionType = {}));
/**
 * @internal
 */
export var DispositionStatus;
(function (DispositionStatus) {
    DispositionStatus["completed"] = "completed";
    DispositionStatus["defered"] = "defered";
    DispositionStatus["suspended"] = "suspended";
    DispositionStatus["abandoned"] = "abandoned";
    DispositionStatus["renewed"] = "renewed";
})(DispositionStatus || (DispositionStatus = {}));
/**
 * @internal
 * Gets the error message for when a property on given message is not of expected type
 */
export function getMessagePropertyTypeMismatchError(msg) {
    if (msg.contentType != null && typeof msg.contentType !== "string") {
        return new TypeError("The property 'contentType' on the message must be of type 'string'");
    }
    if (msg.label != null && typeof msg.label !== "string") {
        return new TypeError("The property 'label' on the message must be of type 'string'");
    }
    if (msg.to != null && typeof msg.to !== "string") {
        return new TypeError("The property 'to' on the message must be of type 'string'");
    }
    if (msg.replyTo != null && typeof msg.replyTo !== "string") {
        return new TypeError("The property 'replyTo' on the message must be of type 'string'");
    }
    if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== "string") {
        return new TypeError("The property 'replyToSessionId' on the message must be of type 'string'");
    }
    if (msg.timeToLive != null && typeof msg.timeToLive !== "number") {
        return new TypeError("The property 'timeToLive' on the message must be of type 'number'");
    }
    if (msg.sessionId != null && typeof msg.sessionId !== "string") {
        return new TypeError("The property 'sessionId' on the message must be of type 'string'");
    }
    if (msg.messageId != null &&
        typeof msg.messageId !== "string" &&
        typeof msg.messageId !== "number" &&
        !Buffer.isBuffer(msg.messageId)) {
        return new TypeError("The property 'messageId' on the message must be of type string, number or Buffer");
    }
    if (msg.correlationId != null &&
        typeof msg.correlationId !== "string" &&
        typeof msg.correlationId !== "number" &&
        !Buffer.isBuffer(msg.correlationId)) {
        return new TypeError("The property 'correlationId' on the message must be of type string, number or Buffer");
    }
    return;
}
/**
 * @internal
 * Converts given SendableMessageInfo to AmqpMessage
 */
export function toAmqpMessage(msg) {
    const amqpMsg = {
        body: msg.body,
        message_annotations: {}
    };
    if (msg.userProperties != null) {
        amqpMsg.application_properties = msg.userProperties;
    }
    if (msg.contentType != null) {
        amqpMsg.content_type = msg.contentType;
    }
    if (msg.sessionId != null) {
        if (msg.sessionId.length > Constants.maxSessionIdLength) {
            throw new Error("Length of 'sessionId' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.group_id = msg.sessionId;
    }
    if (msg.replyTo != null) {
        amqpMsg.reply_to = msg.replyTo;
    }
    if (msg.to != null) {
        amqpMsg.to = msg.to;
    }
    if (msg.label != null) {
        amqpMsg.subject = msg.label;
    }
    if (msg.messageId != null) {
        if (typeof msg.messageId === "string" && msg.messageId.length > Constants.maxMessageIdLength) {
            throw new Error("Length of 'messageId' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.message_id = msg.messageId;
    }
    if (msg.correlationId != null) {
        amqpMsg.correlation_id = msg.correlationId;
    }
    if (msg.replyToSessionId != null) {
        amqpMsg.reply_to_group_id = msg.replyToSessionId;
    }
    if (msg.timeToLive != null && msg.timeToLive !== Constants.maxDurationValue) {
        amqpMsg.ttl = msg.timeToLive;
        amqpMsg.creation_time = Date.now();
        if (Constants.maxAbsoluteExpiryTime - amqpMsg.creation_time > amqpMsg.ttl) {
            amqpMsg.absolute_expiry_time = amqpMsg.creation_time + amqpMsg.ttl;
        }
        else {
            amqpMsg.absolute_expiry_time = Constants.maxAbsoluteExpiryTime;
        }
    }
    if (msg.partitionKey != null) {
        if (msg.partitionKey.length > Constants.maxPartitionKeyLength) {
            throw new Error("Length of 'partitionKey' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.message_annotations[Constants.partitionKey] = msg.partitionKey;
    }
    if (msg.viaPartitionKey != null) {
        if (msg.viaPartitionKey.length > Constants.maxPartitionKeyLength) {
            throw new Error("Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.message_annotations[Constants.viaPartitionKey] = msg.viaPartitionKey;
    }
    if (msg.scheduledEnqueueTimeUtc != null) {
        amqpMsg.message_annotations[Constants.scheduledEnqueueTime] = msg.scheduledEnqueueTimeUtc;
    }
    log.message("SBMessage to AmqpMessage: %O", amqpMsg);
    return amqpMsg;
}
/**
 * @ignore
 * Converts given AmqpMessage to ReceivedMessageInfo
 */
export function fromAmqpMessage(msg, delivery, shouldReorderLockToken) {
    if (!msg) {
        msg = {
            body: undefined
        };
    }
    const sbmsg = {
        body: msg.body
    };
    if (msg.application_properties != null) {
        sbmsg.userProperties = msg.application_properties;
    }
    if (msg.content_type != null) {
        sbmsg.contentType = msg.content_type;
    }
    if (msg.group_id != null) {
        sbmsg.sessionId = msg.group_id;
    }
    if (msg.reply_to != null) {
        sbmsg.replyTo = msg.reply_to;
    }
    if (msg.to != null) {
        sbmsg.to = msg.to;
    }
    if (msg.ttl != null) {
        sbmsg.timeToLive = msg.ttl;
    }
    if (msg.subject != null) {
        sbmsg.label = msg.subject;
    }
    if (msg.message_id != null) {
        sbmsg.messageId = msg.message_id;
    }
    if (msg.correlation_id != null) {
        sbmsg.correlationId = msg.correlation_id;
    }
    if (msg.reply_to_group_id != null) {
        sbmsg.replyToSessionId = msg.reply_to_group_id;
    }
    if (msg.message_annotations != null) {
        if (msg.message_annotations[Constants.partitionKey] != null) {
            sbmsg.partitionKey = msg.message_annotations[Constants.partitionKey];
        }
        if (msg.message_annotations[Constants.viaPartitionKey] != null) {
            sbmsg.viaPartitionKey = msg.message_annotations[Constants.viaPartitionKey];
        }
        if (msg.message_annotations[Constants.scheduledEnqueueTime] != null) {
            sbmsg.scheduledEnqueueTimeUtc = msg.message_annotations[Constants.scheduledEnqueueTime];
        }
    }
    const props = {};
    if (msg.message_annotations != null) {
        if (msg.message_annotations[Constants.deadLetterSource] != null) {
            props.deadLetterSource = msg.message_annotations[Constants.deadLetterSource];
        }
        if (msg.message_annotations[Constants.enqueueSequenceNumber] != null) {
            props.enqueuedSequenceNumber = msg.message_annotations[Constants.enqueueSequenceNumber];
        }
        if (msg.message_annotations[Constants.sequenceNumber] != null) {
            if (Buffer.isBuffer(msg.message_annotations[Constants.sequenceNumber])) {
                props.sequenceNumber = Long.fromBytesBE(msg.message_annotations[Constants.sequenceNumber]);
            }
            else {
                props.sequenceNumber = Long.fromNumber(msg.message_annotations[Constants.sequenceNumber]);
            }
        }
        if (msg.message_annotations[Constants.enqueuedTime] != null) {
            props.enqueuedTimeUtc = new Date(msg.message_annotations[Constants.enqueuedTime]);
        }
        if (msg.message_annotations[Constants.lockedUntil] != null) {
            props.lockedUntilUtc = new Date(msg.message_annotations[Constants.lockedUntil]);
        }
    }
    if (msg.ttl != null && msg.ttl >= Constants.maxDurationValue - props.enqueuedTimeUtc.getTime()) {
        props.expiresAtUtc = new Date(Constants.maxDurationValue);
    }
    else {
        props.expiresAtUtc = new Date(props.enqueuedTimeUtc.getTime() + msg.ttl);
    }
    const rcvdsbmsg = Object.assign(Object.assign({ _amqpMessage: msg, _delivery: delivery, deliveryCount: msg.delivery_count, lockToken: delivery && delivery.tag && delivery.tag.length !== 0
            ? uuid_to_string(shouldReorderLockToken === true
                ? reorderLockToken(typeof delivery.tag === "string" ? Buffer.from(delivery.tag) : delivery.tag)
                : typeof delivery.tag === "string"
                    ? Buffer.from(delivery.tag)
                    : delivery.tag)
            : undefined }, sbmsg), props);
    log.message("AmqpMessage to ReceivedSBMessage: %O", rcvdsbmsg);
    return rcvdsbmsg;
}
/**
 * Describes the message received from Service Bus.
 * @class ServiceBusMessage
 */
export class ServiceBusMessage {
    /**
     * @internal
     */
    constructor(context, msg, delivery, shouldReorderLockToken) {
        Object.assign(this, fromAmqpMessage(msg, delivery, shouldReorderLockToken));
        this._context = context;
        if (msg.body) {
            this.body = this._context.namespace.dataTransformer.decode(msg.body);
        }
        this._amqpMessage = msg;
        this.delivery = delivery;
    }
    /**
     * @property Boolean denoting if the message has already been settled.
     * @readonly
     */
    get isSettled() {
        return this.delivery.remote_settled;
    }
    /**
     * Removes the message from Service Bus.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @returns Promise<void>.
     */
    complete() {
        return __awaiter(this, void 0, void 0, function* () {
            log.message("[%s] Completing the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.completed, {
                    sessionId: this.sessionId
                });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            this.throwIfMessageCannotBeSettled(receiver, DispositionType.complete);
            return receiver.settleMessage(this, DispositionType.complete);
        });
    }
    /**
     * The lock held on the message by the receiver is let go, making the message available again in
     * Service Bus for another receive operation.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param propertiesToModify The properties of the message to modify while abandoning the message.
     *
     * @return Promise<void>.
     */
    abandon(propertiesToModify) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Figure out a mechanism to convert specified properties to message_annotations.
            log.message("[%s] Abandoning the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.abandoned, { propertiesToModify: propertiesToModify, sessionId: this.sessionId });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            this.throwIfMessageCannotBeSettled(receiver, DispositionType.abandon);
            return receiver.settleMessage(this, DispositionType.abandon, {
                propertiesToModify: propertiesToModify
            });
        });
    }
    /**
     * Defers the processing of the message. Save the `sequenceNumber` of the message, in order to
     * receive it message again in the future using the `receiveDeferredMessage` method.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param propertiesToModify The properties of the message to modify while deferring the message
     *
     * @returns Promise<void>
     */
    defer(propertiesToModify) {
        return __awaiter(this, void 0, void 0, function* () {
            log.message("[%s] Deferring the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.defered, { propertiesToModify: propertiesToModify, sessionId: this.sessionId });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            this.throwIfMessageCannotBeSettled(receiver, DispositionType.defer);
            return receiver.settleMessage(this, DispositionType.defer, {
                propertiesToModify: propertiesToModify
            });
        });
    }
    /**
     * Moves the message to the deadletter sub-queue. To receive a deadletted message, create a new
     * QueueClient/SubscriptionClient using the path for the deadletter sub-queue.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param options The DeadLetter options that can be provided while
     * rejecting the message.
     *
     * @returns Promise<void>
     */
    deadLetter(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const error = {
                condition: Constants.deadLetterName
            };
            if (options) {
                error.info = {
                    DeadLetterReason: options.deadletterReason,
                    DeadLetterErrorDescription: options.deadLetterErrorDescription
                };
            }
            log.message("[%s] Deadlettering the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.suspended, {
                    deadLetterReason: error.condition,
                    deadLetterDescription: error.description,
                    sessionId: this.sessionId
                });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            this.throwIfMessageCannotBeSettled(receiver, DispositionType.deadletter);
            return receiver.settleMessage(this, DispositionType.deadletter, {
                error: error
            });
        });
    }
    /**
     * Creates a clone of the current message to allow it to be re-sent to the queue
     * @returns ServiceBusMessage
     */
    clone() {
        // We are returning a SendableMessageInfo object because that object can then be sent to Service Bus
        const clone = {
            body: this.body,
            contentType: this.contentType,
            correlationId: this.correlationId,
            label: this.label,
            messageId: this.messageId,
            partitionKey: this.partitionKey,
            replyTo: this.replyTo,
            replyToSessionId: this.replyToSessionId,
            scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,
            sessionId: this.sessionId,
            timeToLive: this.timeToLive,
            to: this.to,
            userProperties: this.userProperties,
            viaPartitionKey: this.viaPartitionKey
        };
        return clone;
    }
    /**
     * @private
     * Logs and Throws an error if the given message cannot be settled.
     * @param receiver Receiver to be used to settle this message
     * @param operation Settle operation: complete, abandon, defer or deadLetter
     */
    throwIfMessageCannotBeSettled(receiver, operation) {
        let error;
        if (receiver && receiver.receiveMode !== ReceiveMode.peekLock) {
            error = new Error(getErrorMessageNotSupportedInReceiveAndDeleteMode(`${operation} the message`));
        }
        else if (this.delivery.remote_settled) {
            error = new Error(`Failed to ${operation} the message as this message is already settled.`);
        }
        else if (!receiver || !receiver.isOpen()) {
            const errorMessage = `Failed to ${operation} the message as the AMQP link with which the message was ` +
                `received is no longer alive.`;
            if (this.sessionId != undefined) {
                error = translate({
                    description: errorMessage,
                    condition: ErrorNameConditionMapper.SessionLockLostError
                });
            }
            else {
                error = translate({
                    description: errorMessage,
                    condition: ErrorNameConditionMapper.MessageLockLostError
                });
            }
        }
        if (!error) {
            return;
        }
        log.error("[%s] An error occured when settling a message with id '%s'. " +
            "This message was received using the receiver %s which %s currently open: %O", this._context.namespace.connectionId, this.messageId, this.delivery.link.name, this.delivery.link.is_open() ? "is" : "is not", error);
        throw error;
    }
}
//# sourceMappingURL=serviceBusMessage.js.map