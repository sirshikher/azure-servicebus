'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var debugModule = _interopDefault(require('debug'));
var os = require('os');
var amqpCommon = require('@azure/amqp-common');
var rheaPromise = require('rhea-promise');
var Long = _interopDefault(require('long'));
var isBuffer = _interopDefault(require('is-buffer'));
var buffer = require('buffer');

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * log statements for linkEntity
 */
const link = debugModule("azure:service-bus:linkEntity");
/**
 * @internal
 * log statements for error
 */
const error = debugModule("azure:service-bus:error");
/**
 * @internal
 * log statements for warning
 */
const warning = debugModule("azure:service-bus:warning");
/**
 * @internal
 * log statements for management
 */
const mgmt = debugModule("azure:service-bus:management");
/**
 * @internal
 * log statements for sender
 */
const sender = debugModule("azure:service-bus:sender");
/**
 * @internal
 * log statements for receiver
 */
const receiver = debugModule("azure:service-bus:receiver");
/**
 * @internal
 * log statements for receiverbatching
 */
const batching = debugModule("azure:service-bus:receiverbatching");
/**
 * @internal
 * log statements for receiverstreaming
 */
const streaming = debugModule("azure:service-bus:receiverstreaming");
/**
 * @internal
 * log statements for connectionContext
 */
const connectionCtxt = debugModule("azure:service-bus:connectionContext");
/**
 * @internal
 * log statements for clientEntityContext
 */
const entityCtxt = debugModule("azure:service-bus:clientEntityContext");
/**
 * @internal
 * log statements for namespace
 */
const ns = debugModule("azure:service-bus:namespace");
/**
 * @internal
 * log statements for servicebusMessage
 */
const message = debugModule("azure:service-bus:servicebusMessage");
/**
 * @internal
 * log statements for map
 */
const map = debugModule("azure:service-bus:concurrentMap");
/**
 * @internal
 * log statements for utils
 */
const utils = debugModule("azure:service-bus:utils");
/**
 * @internal
 * log statements for messageSession
 */
const messageSession = debugModule("azure:service-bus:messageSession");
/**
 * @internal
 * log statements for semaphore
 */
const semaphore = debugModule("azure:service-bus:semaphore");
/**
 * @internal
 * log statements for sessionManager
 */
const sessionManager = debugModule("azure:service-bus:sessionManager");
/**
 * @internal
 * log statements for Atom XML management API over HTTP
 */
const httpAtomXml = debugModule("azure:service-bus:atom-xml");

var log = /*#__PURE__*/Object.freeze({
    __proto__: null,
    link: link,
    error: error,
    warning: warning,
    mgmt: mgmt,
    sender: sender,
    receiver: receiver,
    batching: batching,
    streaming: streaming,
    connectionCtxt: connectionCtxt,
    entityCtxt: entityCtxt,
    ns: ns,
    message: message,
    map: map,
    utils: utils,
    messageSession: messageSession,
    semaphore: semaphore,
    sessionManager: sessionManager,
    httpAtomXml: httpAtomXml
});

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const packageJsonInfo = {
    name: "@azure/service-bus",
    version: "1.1.4"
};
const max32BitNumber = Math.pow(2, 31) - 1;

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 */
var ConnectionContext;
(function (ConnectionContext) {
    /**
     * @property {string} userAgent The user agent string for the ServiceBus client.
     * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk
     */
    ConnectionContext.userAgent = `azsdk-js-azureservicebus/${packageJsonInfo.version} (NODE-VERSION ${process.version}; ${os.type()} ${os.release()})`;
    function create(config, tokenProvider, options) {
        if (!options)
            options = {};
        const parameters = {
            config: config,
            tokenProvider: tokenProvider,
            dataTransformer: options.dataTransformer,
            isEntityPathRequired: false,
            connectionProperties: {
                product: "MSJSClient",
                userAgent: ConnectionContext.userAgent,
                version: packageJsonInfo.version
            }
        };
        // Let us create the base context and then add ServiceBus specific ConnectionContext properties.
        const connectionContext = amqpCommon.ConnectionContextBase.create(parameters);
        connectionContext.clientContexts = {};
        // Define listeners to be added to the connection object for
        // "connection_open" and "connection_error" events.
        const onConnectionOpen = (context) => {
            connectionContext.wasConnectionCloseCalled = false;
            connectionCtxt("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        const disconnected = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const connectionError = context.connection && context.connection.error ? context.connection.error : undefined;
            if (connectionError) {
                error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, connectionError);
            }
            const contextError = context.error;
            if (contextError) {
                error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, contextError);
            }
            const state = {
                wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                numClients: Object.keys(connectionContext.clientContexts).length
            };
            // Clear internal map maintained by rhea to avoid reconnecting of old links once the
            // connection is back up.
            connectionContext.connection.removeAllSessions();
            // Close the cbs session to ensure all the event handlers are released.
            yield connectionContext.cbsSession.close();
            // Close the management sessions to ensure all the event handlers are released.
            for (const id of Object.keys(connectionContext.clientContexts)) {
                const clientContext = connectionContext.clientContexts[id];
                if (clientContext.managementClient) {
                    yield clientContext.managementClient.close();
                }
            }
            // The connection should always be brought back up if the sdk did not call connection.close()
            // and there was atleast one sender/receiver link on the connection before it went down.
            error("[%s] state: %O", connectionContext.connectionId, state);
            if (!state.wasConnectionCloseCalled && state.numClients) {
                error("[%s] connection.close() was not called from the sdk and there were some " +
                    "clients. We should reconnect.", connectionContext.connection.id);
                yield amqpCommon.delay(amqpCommon.Constants.connectionReconnectDelay);
                // reconnect clients if any
                for (const id of Object.keys(connectionContext.clientContexts)) {
                    const clientContext = connectionContext.clientContexts[id];
                    error("[%s] calling detached on client '%s'.", connectionContext.connection.id, clientContext.clientId);
                    clientContext.onDetached(connectionError || contextError).catch((err) => {
                        error("[%s] An error occurred while reconnecting the sender '%s': %O.", connectionContext.connection.id, clientContext.clientId, err);
                    });
                }
            }
        });
        const protocolError = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            if (context.connection && context.connection.error) {
                error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.error);
            }
        });
        const error$1 = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            if (context.connection && context.connection.error) {
                error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.error);
            }
        });
        // Add listeners on the connection object.
        connectionContext.connection.on(rheaPromise.ConnectionEvents.connectionOpen, onConnectionOpen);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.disconnected, disconnected);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.protocolError, protocolError);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.error, error$1);
        connectionCtxt("[%s] Created connection context successfully.", connectionContext.connectionId);
        return connectionContext;
    }
    ConnectionContext.create = create;
})(ConnectionContext || (ConnectionContext = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * @internal
 */
var ClientType;
(function (ClientType) {
    ClientType["QueueClient"] = "QueueClient";
    ClientType["TopicClient"] = "TopicClient";
    ClientType["SubscriptionClient"] = "SubscriptionClient";
})(ClientType || (ClientType = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * Provides a uniue name by appending a string guid to the given string in the following format:
 * `{name}-{uuid}`.
 * @param name The nme of the entity
 */
function getUniqueName(name) {
    return `${name}-${rheaPromise.generate_uuid()}`;
}
/**
 * @internal
 * If you try to turn a Guid into a Buffer in .NET, the bytes of the first three groups get
 * flipped within the group, but the last two groups don't get flipped, so we end up with a
 * different byte order. This is the order of bytes needed to make Service Bus recognize the token.
 *
 * @param lockToken The lock token whose bytes need to be reorded.
 * @returns Buffer - Buffer representing reordered bytes.
 */
function reorderLockToken(lockTokenBytes) {
    if (!lockTokenBytes || !buffer.Buffer.isBuffer(lockTokenBytes)) {
        return lockTokenBytes;
    }
    return buffer.Buffer.from([
        lockTokenBytes[3],
        lockTokenBytes[2],
        lockTokenBytes[1],
        lockTokenBytes[0],
        lockTokenBytes[5],
        lockTokenBytes[4],
        lockTokenBytes[7],
        lockTokenBytes[6],
        lockTokenBytes[8],
        lockTokenBytes[9],
        lockTokenBytes[10],
        lockTokenBytes[11],
        lockTokenBytes[12],
        lockTokenBytes[13],
        lockTokenBytes[14],
        lockTokenBytes[15]
    ]);
}
/**
 * @internal
 * Provides the time in milliseconds after which the lock renewal should occur.
 * @param lockedUntilUtc - The time until which the message is locked.
 */
function calculateRenewAfterDuration(lockedUntilUtc) {
    const now = Date.now();
    const lockedUntil = lockedUntilUtc.getTime();
    const remainingTime = lockedUntil - now;
    utils("Locked until utc  : %d", lockedUntil);
    utils("Current time is   : %d", now);
    utils("Remaining time is : %d", remainingTime);
    if (remainingTime < 1000) {
        return 0;
    }
    const buffer = Math.min(remainingTime / 2, 10000); // 10 seconds
    const renewAfter = remainingTime - buffer;
    utils("Renew after       : %d", renewAfter);
    return renewAfter;
}
/**
 * @internal
 * Converts the .net ticks to a JS Date object.
 *
 * - The epoch for the DateTimeOffset type is `0000-01-01`, while the epoch for JS Dates is
 * `1970-01-01`.
 * - The DateTimeOffset ticks value for the date `1970-01-01` is `621355968000000000`.
 *   - Hence, to convert it to the JS epoch; we `subtract` the delta from the given value.
 * - Ticks in DateTimeOffset is `1/10000000` second, while ticks in JS Date is `1/1000` second.
 *   - Thus, we `divide` the value by `10000` to convert it to JS Date ticks.
 *
 * @param buf Input as a Buffer
 * @returns Date The JS Date object.
 */
function convertTicksToDate(buf) {
    const epochMicroDiff = 621355968000000000;
    const longValue = Long.fromBytesBE(buf);
    const timeInMS = longValue
        .sub(epochMicroDiff)
        .div(10000)
        .toNumber();
    const result = new Date(timeInMS);
    utils("The converted date is: %s", result.toString());
    return result;
}
/**
 * @internal
 * Returns the number of logical processors in the system.
 */
function getProcessorCount() {
    {
        const os = require("os");
        return os.cpus().length;
    }
}
/**
 * @internal
 * Converts any given input to a Buffer.
 * @param input The input that needs to be converted to a Buffer.
 */
function toBuffer(input) {
    let result;
    utils("[utils.toBuffer] The given message body that needs to be converted to buffer is: ", input);
    if (isBuffer(input)) {
        result = input;
    }
    else {
        // string, undefined, null, boolean, array, object, number should end up here
        // coercing undefined to null as that will ensure that null value will be given to the
        // customer on receive.
        if (input === undefined)
            input = null;
        try {
            const inputStr = JSON.stringify(input);
            result = buffer.Buffer.from(inputStr, "utf8");
        }
        catch (err) {
            const msg = `An error occurred while executing JSON.stringify() on the given input ` +
                input +
                `${err instanceof Error ? err.stack : JSON.stringify(err)}`;
            error("[utils.toBuffer] " + msg);
            throw err instanceof Error ? err : new Error(msg);
        }
    }
    utils("[utils.toBuffer] The converted buffer is: %O.", result);
    return result;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * Logs and throws Error if the current AMQP connection is closed.
 * @param context The ConnectionContext associated with the current AMQP connection.
 */
function throwErrorIfConnectionClosed(context) {
    if (context && context.wasConnectionCloseCalled) {
        const errorMessage = "The underlying AMQP connection is closed.";
        const error$1 = new Error(errorMessage);
        error(`[${context.connectionId}] %O`, error$1);
        throw error$1;
    }
}
/**
 * @internal
 * Logs and throws error if the underlying AMQP connection or if the client is closed
 * @param context The ConnectionContext associated with the current AMQP connection.
 * @param entityPath Entity Path of the client which denotes the name of the Queue/Topic/Subscription
 * @param isClientClosed Boolean denoting if the client is closed or not
 */
function throwErrorIfClientOrConnectionClosed(context, entityPath, isClientClosed) {
    throwErrorIfConnectionClosed(context);
    if (context && isClientClosed) {
        const errorMessage = getClientClosedErrorMsg(entityPath);
        const error$1 = new Error(errorMessage);
        error(`[${context.connectionId}] %O`, error$1);
        throw error$1;
    }
}
/**
 * @internal
 * Gets the error message when an open sender exists, but a new one is asked for on the same client
 * @param clientType 'QueueClient' or 'TopicClient'
 * @param entityPath  Value of the `entityPath` property on the client which denotes its name
 */
function getOpenSenderErrorMsg(clientType, entityPath) {
    return (`An open sender already exists on the ${clientType} for "${entityPath}". ` +
        `Please close it and try again or use a new ${clientType} instance.`);
}
/**
 * @internal
 * Gets the error message when an open receiver exists, but a new one is asked for on the same client
 * @param clientType 'QueueClient' or 'SubscriptionClient'
 * @param entityPath  Value of the `entityPath` property on the client which denotes its name
 * @param sessionId If using session receiver, then the id of the session
 */
function getOpenReceiverErrorMsg(clientType, entityPath, sessionId) {
    if (!sessionId) {
        return (`An open receiver already exists on the ${clientType} for "${entityPath}". ` +
            `Please close it and try again or use a new ${clientType} instance.`);
    }
    return (`An open receiver already exists for the session "${sessionId}" on the ${clientType} for ` +
        `"${entityPath}". Please close it and try again or use a new ${clientType} instance.`);
}
/**
 * @internal
 * Gets the error message when a client is used when its already closed
 * @param entityPath Value of the `entityPath` property on the client which denotes its name
 */
function getClientClosedErrorMsg(entityPath) {
    return (`The client for "${entityPath}" has been closed and can no longer be used. ` +
        `Please create a new client using an instance of ServiceBusClient.`);
}
/**
 * @internal
 * Gets the error message when a sender is used when its already closed
 * @param entityPath Value of the `entityPath` property on the client which denotes its name
 * @param clientType One of "QueueClient", "TopicClient" or "SubscriptionClient", used for logging
 * @param isClientClosed Denotes if the close() was called on the client that created the sender
 */
function getSenderClosedErrorMsg(entityPath, clientType, isClientClosed) {
    if (isClientClosed) {
        return (`The client for "${entityPath}" has been closed. The sender created by it can no longer be used. ` +
            `Please create a new client using an instance of ServiceBusClient.`);
    }
    return (`The sender for "${entityPath}" has been closed and can no longer be used. ` +
        `Please create a new sender using the "createSender" function on the ${clientType}.`);
}
/**
 * @internal
 * Gets the error message when a receiver is used when its already closed
 * @param entityPath Value of the `entityPath` property on the client which denotes its name
 * @param clientType One of "QueueClient", "TopicClient" or "SubscriptionClient", used for logging
 * @param isClientClosed Denotes if the close() was called on the client that created the sender
 * @param sessionId If using session receiver, then the id of the session
 */
function getReceiverClosedErrorMsg(entityPath, clientType, isClientClosed, sessionId) {
    if (isClientClosed) {
        return (`The client for "${entityPath}" has been closed. The receiver created by it can no longer be used. ` +
            `Please create a new client using an instance of ServiceBusClient.`);
    }
    if (sessionId == undefined) {
        return (`The receiver for "${entityPath}" has been closed and can no longer be used. ` +
            `Please create a new receiver using the "createReceiver" function on the ${clientType}.`);
    }
    return (`The receiver for session "${sessionId}" in "${entityPath}" has been closed and can no ` +
        `longer be used. Please create a new receiver using the "createReceiver" function.`);
}
/**
 * @internal
 * @param entityPath Value of the `entityPath` property on the client which denotes its name
 * @param sessionId If using session receiver, then the id of the session
 */
function getAlreadyReceivingErrorMsg(entityPath, sessionId) {
    if (sessionId == undefined) {
        return `The receiver for "${entityPath}" is already receiving messages.`;
    }
    return `The receiver for session "${sessionId}" for "${entityPath}" is already receiving messages.`;
}
/**
 * @internal
 * Logs and Throws TypeError if given parameter is undefined or null
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to check
 * @param parameterValue Value of the parameter to check
 */
function throwTypeErrorIfParameterMissing(connectionId, parameterName, parameterValue) {
    if (parameterValue === undefined || parameterValue === null) {
        const error$1 = new TypeError(`Missing parameter "${parameterName}"`);
        error(`[${connectionId}] %O`, error$1);
        throw error$1;
    }
}
/**
 * @internal
 * Logs and Throws TypeError if given parameter is not of expected type
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 * @param expectedType Expected type of the parameter
 */
function throwTypeErrorIfParameterTypeMismatch(connectionId, parameterName, parameterValue, expectedType) {
    if (typeof parameterValue !== expectedType) {
        const error$1 = new TypeError(`The parameter "${parameterName}" should be of type "${expectedType}"`);
        error(`[${connectionId}] %O`, error$1);
        throw error$1;
    }
}
/**
 * @internal
 * Logs and Throws TypeError if given parameter is not of type `Long`
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 */
function throwTypeErrorIfParameterNotLong(connectionId, parameterName, parameterValue) {
    if (Long.isLong(parameterValue)) {
        return;
    }
    const error$1 = new TypeError(`The parameter "${parameterName}" should be of type "Long"`);
    error(`[${connectionId}] %O`, error$1);
    throw error$1;
}
/**
 * @internal
 * Logs and Throws TypeError if given parameter is not an array of type `Long`
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 */
function throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue) {
    if (parameterValue.every((item) => Long.isLong(item))) {
        return;
    }
    const error$1 = new TypeError(`The parameter "${parameterName}" should be an array of type "Long"`);
    error(`[${connectionId}] %O`, error$1);
    throw error$1;
}
/**
 * @internal
 * Logs and Throws TypeError if given parameter is an empty string
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to type check
 * @param parameterValue Value of the parameter to type check
 */
function throwTypeErrorIfParameterIsEmptyString(connectionId, parameterName, parameterValue) {
    if (parameterValue !== "") {
        return;
    }
    const error$1 = new TypeError(`Empty string not allowed in parameter "${parameterName}"`);
    error(`[${connectionId}] %O`, error$1);
    throw error$1;
}
/**
 * @internal
 * Gets error message for when an operation is not supported in ReceiveAndDelete mode
 * @param failedToDo A string to add to the placeholder in the error message. Denotes the action
 * that is not supported in ReceiveAndDelete mode
 */
function getErrorMessageNotSupportedInReceiveAndDeleteMode(failedToDo) {
    return `Failed to ${failedToDo} as the operation is only supported in 'PeekLock' recieve mode.`;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (ReceiveMode) {
    /**
     * Once a message is received in this mode, the receiver has a lock on the message for a
     * particular duration. If the message is not settled by this time, it lands back on Service Bus
     * to be fetched by the next receive operation.
     * @type {Number}
     */
    ReceiveMode[ReceiveMode["peekLock"] = 1] = "peekLock";
    /**
     * Messages received in this mode get automatically removed from Service Bus.
     * @type {Number}
     */
    ReceiveMode[ReceiveMode["receiveAndDelete"] = 2] = "receiveAndDelete";
})(exports.ReceiveMode || (exports.ReceiveMode = {}));
/**
 * @internal
 */
var DispositionType;
(function (DispositionType) {
    DispositionType["complete"] = "complete";
    DispositionType["deadletter"] = "deadletter";
    DispositionType["abandon"] = "abandon";
    DispositionType["defer"] = "defer";
})(DispositionType || (DispositionType = {}));
/**
 * @internal
 */
var DispositionStatus;
(function (DispositionStatus) {
    DispositionStatus["completed"] = "completed";
    DispositionStatus["defered"] = "defered";
    DispositionStatus["suspended"] = "suspended";
    DispositionStatus["abandoned"] = "abandoned";
    DispositionStatus["renewed"] = "renewed";
})(DispositionStatus || (DispositionStatus = {}));
/**
 * @internal
 * Gets the error message for when a property on given message is not of expected type
 */
function getMessagePropertyTypeMismatchError(msg) {
    if (msg.contentType != null && typeof msg.contentType !== "string") {
        return new TypeError("The property 'contentType' on the message must be of type 'string'");
    }
    if (msg.label != null && typeof msg.label !== "string") {
        return new TypeError("The property 'label' on the message must be of type 'string'");
    }
    if (msg.to != null && typeof msg.to !== "string") {
        return new TypeError("The property 'to' on the message must be of type 'string'");
    }
    if (msg.replyTo != null && typeof msg.replyTo !== "string") {
        return new TypeError("The property 'replyTo' on the message must be of type 'string'");
    }
    if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== "string") {
        return new TypeError("The property 'replyToSessionId' on the message must be of type 'string'");
    }
    if (msg.timeToLive != null && typeof msg.timeToLive !== "number") {
        return new TypeError("The property 'timeToLive' on the message must be of type 'number'");
    }
    if (msg.sessionId != null && typeof msg.sessionId !== "string") {
        return new TypeError("The property 'sessionId' on the message must be of type 'string'");
    }
    if (msg.messageId != null &&
        typeof msg.messageId !== "string" &&
        typeof msg.messageId !== "number" &&
        !buffer.Buffer.isBuffer(msg.messageId)) {
        return new TypeError("The property 'messageId' on the message must be of type string, number or Buffer");
    }
    if (msg.correlationId != null &&
        typeof msg.correlationId !== "string" &&
        typeof msg.correlationId !== "number" &&
        !buffer.Buffer.isBuffer(msg.correlationId)) {
        return new TypeError("The property 'correlationId' on the message must be of type string, number or Buffer");
    }
    return;
}
/**
 * @internal
 * Converts given SendableMessageInfo to AmqpMessage
 */
function toAmqpMessage(msg) {
    const amqpMsg = {
        body: msg.body,
        message_annotations: {}
    };
    if (msg.userProperties != null) {
        amqpMsg.application_properties = msg.userProperties;
    }
    if (msg.contentType != null) {
        amqpMsg.content_type = msg.contentType;
    }
    if (msg.sessionId != null) {
        if (msg.sessionId.length > amqpCommon.Constants.maxSessionIdLength) {
            throw new Error("Length of 'sessionId' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.group_id = msg.sessionId;
    }
    if (msg.replyTo != null) {
        amqpMsg.reply_to = msg.replyTo;
    }
    if (msg.to != null) {
        amqpMsg.to = msg.to;
    }
    if (msg.label != null) {
        amqpMsg.subject = msg.label;
    }
    if (msg.messageId != null) {
        if (typeof msg.messageId === "string" && msg.messageId.length > amqpCommon.Constants.maxMessageIdLength) {
            throw new Error("Length of 'messageId' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.message_id = msg.messageId;
    }
    if (msg.correlationId != null) {
        amqpMsg.correlation_id = msg.correlationId;
    }
    if (msg.replyToSessionId != null) {
        amqpMsg.reply_to_group_id = msg.replyToSessionId;
    }
    if (msg.timeToLive != null && msg.timeToLive !== amqpCommon.Constants.maxDurationValue) {
        amqpMsg.ttl = msg.timeToLive;
        amqpMsg.creation_time = Date.now();
        if (amqpCommon.Constants.maxAbsoluteExpiryTime - amqpMsg.creation_time > amqpMsg.ttl) {
            amqpMsg.absolute_expiry_time = amqpMsg.creation_time + amqpMsg.ttl;
        }
        else {
            amqpMsg.absolute_expiry_time = amqpCommon.Constants.maxAbsoluteExpiryTime;
        }
    }
    if (msg.partitionKey != null) {
        if (msg.partitionKey.length > amqpCommon.Constants.maxPartitionKeyLength) {
            throw new Error("Length of 'partitionKey' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.message_annotations[amqpCommon.Constants.partitionKey] = msg.partitionKey;
    }
    if (msg.viaPartitionKey != null) {
        if (msg.viaPartitionKey.length > amqpCommon.Constants.maxPartitionKeyLength) {
            throw new Error("Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.message_annotations[amqpCommon.Constants.viaPartitionKey] = msg.viaPartitionKey;
    }
    if (msg.scheduledEnqueueTimeUtc != null) {
        amqpMsg.message_annotations[amqpCommon.Constants.scheduledEnqueueTime] = msg.scheduledEnqueueTimeUtc;
    }
    message("SBMessage to AmqpMessage: %O", amqpMsg);
    return amqpMsg;
}
/**
 * @ignore
 * Converts given AmqpMessage to ReceivedMessageInfo
 */
function fromAmqpMessage(msg, delivery, shouldReorderLockToken) {
    if (!msg) {
        msg = {
            body: undefined
        };
    }
    const sbmsg = {
        body: msg.body
    };
    if (msg.application_properties != null) {
        sbmsg.userProperties = msg.application_properties;
    }
    if (msg.content_type != null) {
        sbmsg.contentType = msg.content_type;
    }
    if (msg.group_id != null) {
        sbmsg.sessionId = msg.group_id;
    }
    if (msg.reply_to != null) {
        sbmsg.replyTo = msg.reply_to;
    }
    if (msg.to != null) {
        sbmsg.to = msg.to;
    }
    if (msg.ttl != null) {
        sbmsg.timeToLive = msg.ttl;
    }
    if (msg.subject != null) {
        sbmsg.label = msg.subject;
    }
    if (msg.message_id != null) {
        sbmsg.messageId = msg.message_id;
    }
    if (msg.correlation_id != null) {
        sbmsg.correlationId = msg.correlation_id;
    }
    if (msg.reply_to_group_id != null) {
        sbmsg.replyToSessionId = msg.reply_to_group_id;
    }
    if (msg.message_annotations != null) {
        if (msg.message_annotations[amqpCommon.Constants.partitionKey] != null) {
            sbmsg.partitionKey = msg.message_annotations[amqpCommon.Constants.partitionKey];
        }
        if (msg.message_annotations[amqpCommon.Constants.viaPartitionKey] != null) {
            sbmsg.viaPartitionKey = msg.message_annotations[amqpCommon.Constants.viaPartitionKey];
        }
        if (msg.message_annotations[amqpCommon.Constants.scheduledEnqueueTime] != null) {
            sbmsg.scheduledEnqueueTimeUtc = msg.message_annotations[amqpCommon.Constants.scheduledEnqueueTime];
        }
    }
    const props = {};
    if (msg.message_annotations != null) {
        if (msg.message_annotations[amqpCommon.Constants.deadLetterSource] != null) {
            props.deadLetterSource = msg.message_annotations[amqpCommon.Constants.deadLetterSource];
        }
        if (msg.message_annotations[amqpCommon.Constants.enqueueSequenceNumber] != null) {
            props.enqueuedSequenceNumber = msg.message_annotations[amqpCommon.Constants.enqueueSequenceNumber];
        }
        if (msg.message_annotations[amqpCommon.Constants.sequenceNumber] != null) {
            if (buffer.Buffer.isBuffer(msg.message_annotations[amqpCommon.Constants.sequenceNumber])) {
                props.sequenceNumber = Long.fromBytesBE(msg.message_annotations[amqpCommon.Constants.sequenceNumber]);
            }
            else {
                props.sequenceNumber = Long.fromNumber(msg.message_annotations[amqpCommon.Constants.sequenceNumber]);
            }
        }
        if (msg.message_annotations[amqpCommon.Constants.enqueuedTime] != null) {
            props.enqueuedTimeUtc = new Date(msg.message_annotations[amqpCommon.Constants.enqueuedTime]);
        }
        if (msg.message_annotations[amqpCommon.Constants.lockedUntil] != null) {
            props.lockedUntilUtc = new Date(msg.message_annotations[amqpCommon.Constants.lockedUntil]);
        }
    }
    if (msg.ttl != null && msg.ttl >= amqpCommon.Constants.maxDurationValue - props.enqueuedTimeUtc.getTime()) {
        props.expiresAtUtc = new Date(amqpCommon.Constants.maxDurationValue);
    }
    else {
        props.expiresAtUtc = new Date(props.enqueuedTimeUtc.getTime() + msg.ttl);
    }
    const rcvdsbmsg = Object.assign(Object.assign({ _amqpMessage: msg, _delivery: delivery, deliveryCount: msg.delivery_count, lockToken: delivery && delivery.tag && delivery.tag.length !== 0
            ? rheaPromise.uuid_to_string(shouldReorderLockToken === true
                ? reorderLockToken(typeof delivery.tag === "string" ? buffer.Buffer.from(delivery.tag) : delivery.tag)
                : typeof delivery.tag === "string"
                    ? buffer.Buffer.from(delivery.tag)
                    : delivery.tag)
            : undefined }, sbmsg), props);
    message("AmqpMessage to ReceivedSBMessage: %O", rcvdsbmsg);
    return rcvdsbmsg;
}
/**
 * Describes the message received from Service Bus.
 * @class ServiceBusMessage
 */
class ServiceBusMessage {
    /**
     * @internal
     */
    constructor(context, msg, delivery, shouldReorderLockToken) {
        Object.assign(this, fromAmqpMessage(msg, delivery, shouldReorderLockToken));
        this._context = context;
        if (msg.body) {
            this.body = this._context.namespace.dataTransformer.decode(msg.body);
        }
        this._amqpMessage = msg;
        this.delivery = delivery;
    }
    /**
     * @property Boolean denoting if the message has already been settled.
     * @readonly
     */
    get isSettled() {
        return this.delivery.remote_settled;
    }
    /**
     * Removes the message from Service Bus.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @returns Promise<void>.
     */
    complete() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            message("[%s] Completing the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.completed, {
                    sessionId: this.sessionId
                });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            this.throwIfMessageCannotBeSettled(receiver, DispositionType.complete);
            return receiver.settleMessage(this, DispositionType.complete);
        });
    }
    /**
     * The lock held on the message by the receiver is let go, making the message available again in
     * Service Bus for another receive operation.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param propertiesToModify The properties of the message to modify while abandoning the message.
     *
     * @return Promise<void>.
     */
    abandon(propertiesToModify) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // TODO: Figure out a mechanism to convert specified properties to message_annotations.
            message("[%s] Abandoning the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.abandoned, { propertiesToModify: propertiesToModify, sessionId: this.sessionId });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            this.throwIfMessageCannotBeSettled(receiver, DispositionType.abandon);
            return receiver.settleMessage(this, DispositionType.abandon, {
                propertiesToModify: propertiesToModify
            });
        });
    }
    /**
     * Defers the processing of the message. Save the `sequenceNumber` of the message, in order to
     * receive it message again in the future using the `receiveDeferredMessage` method.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param propertiesToModify The properties of the message to modify while deferring the message
     *
     * @returns Promise<void>
     */
    defer(propertiesToModify) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            message("[%s] Deferring the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.defered, { propertiesToModify: propertiesToModify, sessionId: this.sessionId });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            this.throwIfMessageCannotBeSettled(receiver, DispositionType.defer);
            return receiver.settleMessage(this, DispositionType.defer, {
                propertiesToModify: propertiesToModify
            });
        });
    }
    /**
     * Moves the message to the deadletter sub-queue. To receive a deadletted message, create a new
     * QueueClient/SubscriptionClient using the path for the deadletter sub-queue.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param options The DeadLetter options that can be provided while
     * rejecting the message.
     *
     * @returns Promise<void>
     */
    deadLetter(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const error = {
                condition: amqpCommon.Constants.deadLetterName
            };
            if (options) {
                error.info = {
                    DeadLetterReason: options.deadletterReason,
                    DeadLetterErrorDescription: options.deadLetterErrorDescription
                };
            }
            message("[%s] Deadlettering the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
            if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.suspended, {
                    deadLetterReason: error.condition,
                    deadLetterDescription: error.description,
                    sessionId: this.sessionId
                });
                // Remove the message from the internal map of deferred messages
                this._context.requestResponseLockedMessages.delete(this.lockToken);
                return;
            }
            const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
            this.throwIfMessageCannotBeSettled(receiver, DispositionType.deadletter);
            return receiver.settleMessage(this, DispositionType.deadletter, {
                error: error
            });
        });
    }
    /**
     * Creates a clone of the current message to allow it to be re-sent to the queue
     * @returns ServiceBusMessage
     */
    clone() {
        // We are returning a SendableMessageInfo object because that object can then be sent to Service Bus
        const clone = {
            body: this.body,
            contentType: this.contentType,
            correlationId: this.correlationId,
            label: this.label,
            messageId: this.messageId,
            partitionKey: this.partitionKey,
            replyTo: this.replyTo,
            replyToSessionId: this.replyToSessionId,
            scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,
            sessionId: this.sessionId,
            timeToLive: this.timeToLive,
            to: this.to,
            userProperties: this.userProperties,
            viaPartitionKey: this.viaPartitionKey
        };
        return clone;
    }
    /**
     * @private
     * Logs and Throws an error if the given message cannot be settled.
     * @param receiver Receiver to be used to settle this message
     * @param operation Settle operation: complete, abandon, defer or deadLetter
     */
    throwIfMessageCannotBeSettled(receiver, operation) {
        let error$1;
        if (receiver && receiver.receiveMode !== exports.ReceiveMode.peekLock) {
            error$1 = new Error(getErrorMessageNotSupportedInReceiveAndDeleteMode(`${operation} the message`));
        }
        else if (this.delivery.remote_settled) {
            error$1 = new Error(`Failed to ${operation} the message as this message is already settled.`);
        }
        else if (!receiver || !receiver.isOpen()) {
            const errorMessage = `Failed to ${operation} the message as the AMQP link with which the message was ` +
                `received is no longer alive.`;
            if (this.sessionId != undefined) {
                error$1 = amqpCommon.translate({
                    description: errorMessage,
                    condition: amqpCommon.ErrorNameConditionMapper.SessionLockLostError
                });
            }
            else {
                error$1 = amqpCommon.translate({
                    description: errorMessage,
                    condition: amqpCommon.ErrorNameConditionMapper.MessageLockLostError
                });
            }
        }
        if (!error$1) {
            return;
        }
        error("[%s] An error occured when settling a message with id '%s'. " +
            "This message was received using the receiver %s which %s currently open: %O", this._context.namespace.connectionId, this.messageId, this.delivery.link.name, this.delivery.link.is_open() ? "is" : "is not", error$1);
        throw error$1;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * Describes the base class for entities like MessageSender, MessageReceiver and Management client.
 * @class ClientEntity
 */
class LinkEntity {
    /**
     * Creates a new ClientEntity instance.
     * @constructor
     * @param {ClientEntityContext} context The connection context.
     * @param {LinkEntityOptions} [options] Options that can be provided while creating the LinkEntity.
     */
    constructor(name, context, options) {
        /**
         * @property {boolean} isConnecting Indicates whether the link is in the process of connecting
         * (establishing) itself. Default value: `false`.
         */
        this.isConnecting = false;
        if (!options)
            options = {};
        this._context = context;
        this.address = options.address || "";
        this.audience = options.audience || "";
        this.name = getUniqueName(name);
    }
    /**
     * Negotiates the cbs claim for the ClientEntity.
     * @protected
     * @param {boolean} [setTokenRenewal] Set the token renewal timer. Default false.
     * @return {Promise<void>} Promise<void>
     */
    _negotiateClaim(setTokenRenewal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Acquire the lock and establish a cbs session if it does not exist on the connection.
            // Although node.js is single threaded, we need a locking mechanism to ensure that a
            // race condition does not happen while creating a shared resource (in this case the
            // cbs session, since we want to have exactly 1 cbs session per connection).
            link("[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: " +
                "'%s' with address: '%s'.", this._context.namespace.connectionId, this._context.namespace.cbsSession.cbsLock, this._type, this.name, this.address);
            yield amqpCommon.defaultLock.acquire(this._context.namespace.cbsSession.cbsLock, () => {
                return this._context.namespace.cbsSession.init();
            });
            const tokenObject = yield this._context.namespace.tokenProvider.getToken(this.audience);
            link("[%s] %s: calling negotiateClaim for audience '%s'.", this._context.namespace.connectionId, this._type, this.audience);
            // Acquire the lock to negotiate the CBS claim.
            link("[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.", this._context.namespace.connectionId, this._context.namespace.negotiateClaimLock, this._type, this.name, this.address);
            yield amqpCommon.defaultLock.acquire(this._context.namespace.negotiateClaimLock, () => {
                return this._context.namespace.cbsSession.negotiateClaim(this.audience, tokenObject);
            });
            link("[%s] Negotiated claim for %s '%s' with with address: %s", this._context.namespace.connectionId, this._type, this.name, this.address);
            if (setTokenRenewal) {
                yield this._ensureTokenRenewal();
            }
        });
    }
    /**
     * Ensures that the token is renewed within the predefined renewal margin.
     * @protected
     * @returns {void}
     */
    _ensureTokenRenewal() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const tokenValidTimeInSeconds = this._context.namespace.tokenProvider.tokenValidTimeInSeconds;
            const tokenRenewalMarginInSeconds = this._context.namespace.tokenProvider
                .tokenRenewalMarginInSeconds;
            const nextRenewalTimeout = (tokenValidTimeInSeconds - tokenRenewalMarginInSeconds) * 1000;
            this._tokenRenewalTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield this._negotiateClaim(true);
                }
                catch (err) {
                    // TODO: May be add some retries over here before emitting the error.
                    error("[%s] %s '%s' with address %s, an error occurred while renewing the token: %O", this._context.namespace.connectionId, this._type, this.name, this.address, err);
                }
            }), nextRenewalTimeout);
            link("[%s] %s '%s' with address %s, has next token renewal in %d seconds @(%s).", this._context.namespace.connectionId, this._type, this.name, this.address, nextRenewalTimeout / 1000, new Date(Date.now() + nextRenewalTimeout).toString());
        });
    }
    /**
     * Closes the Sender|Receiver link and it's underlying session and also removes it from the
     * internal map.
     *
     * @param {Sender | Receiver} [link] The Sender or Receiver link that needs to be closed and
     * removed.
     */
    _closeLink(link$1) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            clearTimeout(this._tokenRenewalTimer);
            if (link$1) {
                try {
                    // This should take care of closing the link and it's underlying session. This should also
                    // remove them from the internal map.
                    yield link$1.close();
                    link("[%s] %s '%s' with address '%s' closed.", this._context.namespace.connectionId, this._type, this.name, this.address);
                }
                catch (err) {
                    error("[%s] An error occurred while closing the %s '%s': %O", this._context.namespace.connectionId, this._type, this.name, this.address, err);
                }
            }
        });
    }
    /**
     * Provides the current type of the ClientEntity.
     * @return {string} The entity type.
     */
    get _type() {
        let result = "LinkEntity";
        if (this.constructor && this.constructor.name) {
            result = this.constructor.name;
        }
        return result;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * Describes the MessageSender that will send messages to ServiceBus.
 * @class MessageSender
 */
class MessageSender extends LinkEntity {
    /**
     * Creates a new MessageSender instance.
     * @constructor
     * @param {ClientEntityContext} context The client entity context.
     */
    constructor(context) {
        super(context.entityPath, context, {
            address: context.entityPath,
            audience: `${context.namespace.config.endpoint}${context.entityPath}`
        });
        /**
         * @property {string} senderLock The unqiue lock name per connection that is used to acquire the
         * lock for establishing a sender link by an entity on that connection.
         * @readonly
         */
        this.senderLock = `sender-${rheaPromise.generate_uuid()}`;
        this._onAmqpError = (context) => {
            const senderError = context.sender && context.sender.error;
            if (senderError) {
                const err = amqpCommon.translate(senderError);
                error("[%s] An error occurred for sender '%s': %O.", this._context.namespace.connectionId, this.name, err);
            }
        };
        this._onSessionError = (context) => {
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const err = amqpCommon.translate(sessionError);
                error("[%s] An error occurred on the session of sender '%s': %O.", this._context.namespace.connectionId, this.name, err);
            }
        };
        this._onAmqpClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const sender = this._sender || context.sender;
            const senderError = context.sender && context.sender.error;
            if (senderError) {
                error("[%s] 'sender_close' event occurred for sender '%s' with address '%s'. " +
                    "The associated error is: %O", this._context.namespace.connectionId, this.name, this.address, senderError);
            }
            if (sender && !sender.isItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                        "and the sdk did not initiate this. The sender is not reconnecting. Hence, calling " +
                        "detached from the _onAmqpClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                    yield this.onDetached(senderError);
                }
                else {
                    error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                        "and the sdk did not initate this. Moreover the sender is already re-connecting. " +
                        "Hence not calling detached from the _onAmqpClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                    "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                    "() handler.", this._context.namespace.connectionId, this.name, this.address);
            }
        });
        this._onSessionClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const sender = this._sender || context.sender;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                error("[%s] 'session_close' event occurred for sender '%s' with address '%s'. " +
                    "The associated error is: %O", this._context.namespace.connectionId, this.name, this.address, sessionError);
            }
            if (sender && !sender.isSessionItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'session_close' event occurred on the session of sender '%s' with " +
                        "address '%s' and the sdk did not initiate this. Hence calling detached from the " +
                        "_onSessionClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                    yield this.onDetached(sessionError);
                }
                else {
                    error("[%s] 'session_close' event occurred on the session of sender '%s' with " +
                        "address '%s' and the sdk did not initiate this. Moreover the sender is already " +
                        "re-connecting. Hence not calling detached from the _onSessionClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'session_close' event occurred on the session of sender '%s' with address " +
                    "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                    "() handler.", this._context.namespace.connectionId, this.name, this.address);
            }
        });
    }
    _deleteFromCache() {
        this._sender = undefined;
        delete this._context.sender;
        error("[%s] Deleted the sender '%s' with address '%s' from the client cache.", this._context.namespace.connectionId, this.name, this.address);
    }
    _createSenderOptions(options) {
        if (options.newName)
            this.name = getUniqueName(this._context.entityPath);
        const srOptions = {
            name: this.name,
            target: {
                address: this.address
            },
            onError: this._onAmqpError,
            onClose: this._onAmqpClose,
            onSessionError: this._onSessionError,
            onSessionClose: this._onSessionClose
        };
        sender("Creating sender with options: %O", srOptions);
        return srOptions;
    }
    /**
     * Tries to send the message to ServiceBus if there is enough credit to send them
     * and the circular buffer has available space to settle the message after sending them.
     *
     * We have implemented a synchronous send over here in the sense that we shall be waiting
     * for the message to be accepted or rejected and accordingly resolve or reject the promise.
     *
     * @param encodedMessage The encoded message to be sent to ServiceBus.
     * @param sendBatch Boolean indicating whether the encoded message represents a batch of messages or not
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    _trySend(encodedMessage, sendBatch) {
        const sendEventPromise = () => new Promise((resolve, reject) => tslib.__awaiter(this, void 0, void 0, function* () {
            let waitTimer;
            sender("[%s] Sender '%s', credit: %d available: %d", this._context.namespace.connectionId, this.name, this._sender.credit, this._sender.session.outgoing.available());
            if (!this._sender.sendable()) {
                sender("[%s] Sender '%s', waiting for 1 second for sender to become sendable", this._context.namespace.connectionId, this.name);
                yield amqpCommon.delay(1000);
                sender("[%s] Sender '%s' after waiting for a second, credit: %d available: %d", this._context.namespace.connectionId, this.name, this._sender.credit, this._sender.session.outgoing.available());
            }
            if (this._sender.sendable()) {
                let onRejected;
                let onReleased;
                let onModified;
                let onAccepted;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    // When `removeListeners` is called on timeout, the sender might be closed and cleared
                    // So, check if it exists, before removing listeners from it.
                    if (this._sender) {
                        this._sender.removeListener(rheaPromise.SenderEvents.rejected, onRejected);
                        this._sender.removeListener(rheaPromise.SenderEvents.accepted, onAccepted);
                        this._sender.removeListener(rheaPromise.SenderEvents.released, onReleased);
                        this._sender.removeListener(rheaPromise.SenderEvents.modified, onModified);
                    }
                };
                onAccepted = (context) => {
                    // Since we will be adding listener for accepted and rejected event every time
                    // we send a message, we need to remove listener for both the events.
                    // This will ensure duplicate listeners are not added for the same event.
                    removeListeners();
                    sender("[%s] Sender '%s', got event accepted.", this._context.namespace.connectionId, this.name);
                    resolve();
                };
                onRejected = (context) => {
                    removeListeners();
                    error("[%s] Sender '%s', got event rejected.", this._context.namespace.connectionId, this.name);
                    const err = amqpCommon.translate(context.delivery.remote_state.error);
                    reject(err);
                };
                onReleased = (context) => {
                    removeListeners();
                    error("[%s] Sender '%s', got event released.", this._context.namespace.connectionId, this.name);
                    let err;
                    if (context.delivery.remote_state.error) {
                        err = amqpCommon.translate(context.delivery.remote_state.error);
                    }
                    else {
                        err = new Error(`[${this._context.namespace.connectionId}]Sender '${this.name}', ` +
                            `received a release disposition.Hence we are rejecting the promise.`);
                    }
                    reject(err);
                };
                onModified = (context) => {
                    removeListeners();
                    error("[%s] Sender '%s', got event modified.", this._context.namespace.connectionId, this.name);
                    let err;
                    if (context.delivery.remote_state.error) {
                        err = amqpCommon.translate(context.delivery.remote_state.error);
                    }
                    else {
                        err = new Error(`[${this._context.namespace.connectionId}]Sender "${this.name}", ` +
                            `received a modified disposition.Hence we are rejecting the promise.`);
                    }
                    reject(err);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const desc = `[${this._context.namespace.connectionId}] Sender "${this.name}" ` +
                        `with address "${this.address}", was not able to send the message right now, due ` +
                        `to operation timeout.`;
                    error(desc);
                    const e = {
                        condition: amqpCommon.ErrorNameConditionMapper.ServiceUnavailableError,
                        description: desc
                    };
                    return reject(amqpCommon.translate(e));
                };
                this._sender.on(rheaPromise.SenderEvents.accepted, onAccepted);
                this._sender.on(rheaPromise.SenderEvents.rejected, onRejected);
                this._sender.on(rheaPromise.SenderEvents.modified, onModified);
                this._sender.on(rheaPromise.SenderEvents.released, onReleased);
                waitTimer = setTimeout(actionAfterTimeout, amqpCommon.Constants.defaultOperationTimeoutInSeconds * 1000);
                try {
                    const delivery = this._sender.send(encodedMessage, undefined, sendBatch ? 0x80013700 : 0);
                    sender("[%s] Sender '%s', sent message with delivery id: %d", this._context.namespace.connectionId, this.name, delivery.id);
                }
                catch (error) {
                    removeListeners();
                    return reject(error);
                }
            }
            else {
                // let us retry to send the message after some time.
                const msg = `[${this._context.namespace.connectionId}] Sender "${this.name}", ` +
                    `cannot send the message right now. Please try later.`;
                error(msg);
                const amqpError = {
                    condition: amqpCommon.ErrorNameConditionMapper.SenderBusyError,
                    description: msg
                };
                reject(amqpCommon.translate(amqpError));
            }
        }));
        const jitterInSeconds = amqpCommon.randomNumberFromInterval(1, 4);
        const config = {
            operation: sendEventPromise,
            connectionId: this._context.namespace.connectionId,
            operationType: amqpCommon.RetryOperationType.sendMessage,
            times: amqpCommon.Constants.defaultRetryAttempts,
            delayInSeconds: amqpCommon.Constants.defaultDelayBetweenOperationRetriesInSeconds + jitterInSeconds
        };
        return amqpCommon.retry(config);
    }
    /**
     * Initializes the sender session on the connection.
     */
    _init(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                // isOpen isConnecting  Should establish
                // true     false          No
                // true     true           No
                // false    true           No
                // false    false          Yes
                if (!this.isOpen()) {
                    error("[%s] The sender '%s' with address '%s' is not open and is not currently " +
                        "establishing itself. Hence let's try to connect.", this._context.namespace.connectionId, this.name, this.address);
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    error("[%s] Trying to create sender '%s'...", this._context.namespace.connectionId, this.name);
                    if (!options) {
                        options = this._createSenderOptions({});
                    }
                    this._sender = yield this._context.namespace.connection.createSender(options);
                    this.isConnecting = false;
                    error("[%s] Sender '%s' with address '%s' has established itself.", this._context.namespace.connectionId, this.name, this.address);
                    this._sender.setMaxListeners(1000);
                    error("[%s] Promise to create the sender resolved. Created sender with name: %s", this._context.namespace.connectionId, this.name);
                    error("[%s] Sender '%s' created with sender options: %O", this._context.namespace.connectionId, this.name, options);
                    // It is possible for someone to close the sender and then start it again.
                    // Thus make sure that the sender is present in the client cache.
                    if (!this._sender)
                        this._context.sender = this;
                    yield this._ensureTokenRenewal();
                }
            }
            catch (err) {
                err = amqpCommon.translate(err);
                error("[%s] An error occurred while creating the sender %s", this._context.namespace.connectionId, this.name, err);
                throw err;
            }
        });
    }
    /**
     * Will reconnect the sender link if necessary.
     * @param {AmqpError | Error} [senderError] The sender error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    onDetached(senderError) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const wasCloseInitiated = this._sender && this._sender.isItselfClosed();
                // Clears the token renewal timer. Closes the link and its session if they are open.
                // Removes the link and its session if they are present in rhea's cache.
                yield this._closeLink(this._sender);
                // We should attempt to reopen only when the sender(sdk) did not initiate the close
                let shouldReopen = false;
                if (senderError && !wasCloseInitiated) {
                    const translatedError = amqpCommon.translate(senderError);
                    if (translatedError.retryable) {
                        shouldReopen = true;
                        error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                            "was an accompanying error an it is retryable. This is a candidate for re-establishing " +
                            "the sender link.", this._context.namespace.connectionId, this.name, this.address);
                    }
                    else {
                        error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is NOT retryable. Hence NOT re-establishing " +
                            "the sender link.", this._context.namespace.connectionId, this.name, this.address);
                    }
                }
                else if (!wasCloseInitiated) {
                    shouldReopen = true;
                    error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                        "was no accompanying error as well. This is a candidate for re-establishing " +
                        "the sender link.", this._context.namespace.connectionId, this.name, this.address);
                }
                else {
                    const state = {
                        wasCloseInitiated: wasCloseInitiated,
                        senderError: senderError,
                        _sender: this._sender
                    };
                    error("[%s] Something went wrong. State of sender '%s' with address '%s' is: %O", this._context.namespace.connectionId, this.name, this.address, state);
                }
                if (shouldReopen) {
                    yield amqpCommon.defaultLock.acquire(this.senderLock, () => {
                        const options = this._createSenderOptions({
                            newName: true
                        });
                        // shall retry forever at an interval of 15 seconds if the error is a retryable error
                        // else bail out when the error is not retryable or the oepration succeeds.
                        const config = {
                            operation: () => this._init(options),
                            connectionId: this._context.namespace.connectionId,
                            operationType: amqpCommon.RetryOperationType.senderLink,
                            times: amqpCommon.Constants.defaultConnectionRetryAttempts,
                            connectionHost: this._context.namespace.config.host,
                            delayInSeconds: 15
                        };
                        return amqpCommon.retry(config);
                    });
                }
            }
            catch (err) {
                error("[%s] An error occurred while processing detached() of Sender '%s' with address " +
                    "'%s': %O", this._context.namespace.connectionId, this.name, this.address, err);
            }
        });
    }
    /**
     * Deletes the sender fromt the context. Clears the token renewal timer. Closes the sender link.
     * @return {Promise<void>} Promise<void>
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._sender) {
                sender("[%s] Closing the Sender for the entity '%s'.", this._context.namespace.connectionId, this._context.entityPath);
                const senderLink = this._sender;
                this._deleteFromCache();
                yield this._closeLink(senderLink);
            }
        });
    }
    /**
     * Determines whether the AMQP sender link is open. If open then returns true else returns false.
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this._sender && this._sender.isOpen();
        error("[%s] Sender '%s' with address '%s' is open? -> %s", this._context.namespace.connectionId, this.name, this.address, result);
        return result;
    }
    /**
     * Sends the given message, with the given options on this link
     *
     * @param {SendableMessageInfo} data Message to send.  Will be sent as UTF8-encoded JSON string.
     * @returns {Promise<void>}
     */
    send(data) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            try {
                if (!this.isOpen()) {
                    sender("Acquiring lock %s for initializing the session, sender and " +
                        "possibly the connection.", this.senderLock);
                    yield amqpCommon.defaultLock.acquire(this.senderLock, () => {
                        return this._init();
                    });
                }
                const amqpMessage = toAmqpMessage(data);
                amqpMessage.body = this._context.namespace.dataTransformer.encode(data.body);
                let encodedMessage;
                try {
                    encodedMessage = rheaPromise.message.encode(amqpMessage);
                }
                catch (error) {
                    if (error instanceof TypeError || error.name === "TypeError") {
                        // `RheaMessageUtil.encode` can fail if message properties are of invalid type
                        // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too
                        // Errors in such cases do not have user friendy message or call stack
                        // So use `getMessagePropertyTypeMismatchError` to get a better error message
                        throw getMessagePropertyTypeMismatchError(data) || error;
                    }
                    throw error;
                }
                sender("[%s] Sender '%s', trying to send message: %O", this._context.namespace.connectionId, this.name, data);
                return yield this._trySend(encodedMessage);
            }
            catch (err) {
                error("[%s] Sender '%s': An error occurred while sending the message: %O\nError: %O", this._context.namespace.connectionId, this.name, data, err);
                throw err;
            }
        });
    }
    /**
     * Send a batch of Message to the ServiceBus in a single AMQP message. The "message_annotations",
     * "application_properties" and "properties" of the first message will be set as that
     * of the envelope (batch message).
     * @param {Array<Message>} inputMessages  An array of Message objects to be sent in a
     * Batch message.
     * @return {Promise<void>}
     */
    sendBatch(inputMessages) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            try {
                if (!Array.isArray(inputMessages)) {
                    inputMessages = [inputMessages];
                }
                if (!this.isOpen()) {
                    sender("Acquiring lock %s for initializing the session, sender and " +
                        "possibly the connection.", this.senderLock);
                    yield amqpCommon.defaultLock.acquire(this.senderLock, () => {
                        return this._init();
                    });
                }
                sender("[%s] Sender '%s', trying to send Message[]: %O", this._context.namespace.connectionId, this.name, inputMessages);
                const amqpMessages = [];
                const encodedMessages = [];
                // Convert Message to AmqpMessage.
                for (let i = 0; i < inputMessages.length; i++) {
                    const amqpMessage = toAmqpMessage(inputMessages[i]);
                    amqpMessage.body = this._context.namespace.dataTransformer.encode(inputMessages[i].body);
                    amqpMessages[i] = amqpMessage;
                    try {
                        encodedMessages[i] = rheaPromise.message.encode(amqpMessage);
                    }
                    catch (error) {
                        if (error instanceof TypeError || error.name === "TypeError") {
                            throw getMessagePropertyTypeMismatchError(inputMessages[i]) || error;
                        }
                        throw error;
                    }
                }
                // Convert every encoded message to amqp data section
                const batchMessage = {
                    body: rheaPromise.message.data_sections(encodedMessages)
                };
                // Set message_annotations, application_properties and properties of the first message as
                // that of the envelope (batch message).
                if (amqpMessages[0].message_annotations) {
                    batchMessage.message_annotations = amqpMessages[0].message_annotations;
                }
                if (amqpMessages[0].application_properties) {
                    batchMessage.application_properties = amqpMessages[0].application_properties;
                }
                for (const prop of rheaPromise.messageProperties) {
                    if (amqpMessages[0][prop]) {
                        batchMessage[prop] = amqpMessages[0][prop];
                    }
                }
                // Finally encode the envelope (batch message).
                const encodedBatchMessage = rheaPromise.message.encode(batchMessage);
                sender("[%s]Sender '%s', sending encoded batch message.", this._context.namespace.connectionId, this.name, encodedBatchMessage);
                return yield this._trySend(encodedBatchMessage, true);
            }
            catch (err) {
                error("[%s] Sender '%s': An error occurred while sending the messages: %O\nError: %O", this._context.namespace.connectionId, this.name, inputMessages, err);
                throw err;
            }
        });
    }
    /**
     * Creates a new sender to the specifiec ServiceBus entity, and optionally to a given
     * partition if it is not present in the context or returns the one present in the context.
     * @static
     * @returns {Promise<MessageSender>}
     */
    static create(context) {
        throwErrorIfConnectionClosed(context.namespace);
        if (!context.sender) {
            context.sender = new MessageSender(context);
        }
        return context.sender;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * The Sender class can be used to send messages, schedule messages to be sent at a later time
 * and cancel such scheduled messages.
 * Use the `createSender` function on the QueueClient or TopicClient to instantiate a Sender.
 * The Sender class is an abstraction over the underlying AMQP sender link.
 * @class Sender
 */
class Sender {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     */
    constructor(context) {
        /**
         * @property Denotes if close() was called on this sender
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(context.namespace);
        this._context = context;
    }
    _throwIfSenderOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (this.isClosed) {
            const errorMessage = getSenderClosedErrorMsg(this._context.entityPath, this._context.clientType, this._context.isClosed);
            const error$1 = new Error(errorMessage);
            error(`[${this._context.namespace.connectionId}] %O`, error$1);
            throw error$1;
        }
    }
    /**
     * @property Returns `true` if either the sender or the client that created it has been closed
     * @readonly
     */
    get isClosed() {
        return this._isClosed || this._context.isClosed;
    }
    /**
     * Sends the given message after creating an AMQP Sender link if it doesnt already exists.
     *
     * To send a message to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`
     * and/or `partitionKey` properties respectively on the message.
     *
     * @param message - Message to send.
     * @returns Promise<void>
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while sending messages to the service.
     */
    send(message) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "message", message);
            const sender = MessageSender.create(this._context);
            return sender.send(message);
        });
    }
    /**
     * Sends the given messages in a single batch i.e. in a single AMQP message after creating an AMQP
     * Sender link if it doesnt already exists.
     *
     * - To send messages to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`
     * and/or `partitionKey` properties respectively on the messages.
     * - When doing so, all
     * messages in the batch should have the same `sessionId` (if using sessions) and the same
     * `parititionKey` (if using paritions).
     *
     * @param messages - An array of SendableMessageInfo objects to be sent in a Batch message.
     * @return Promise<void>
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while sending messages to the service.
     */
    sendBatch(messages) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "messages", messages);
            if (!Array.isArray(messages)) {
                messages = [messages];
            }
            const sender = MessageSender.create(this._context);
            return sender.sendBatch(messages);
        });
    }
    /**
     * Schedules given message to appear on Service Bus Queue/Subscription at a later time.
     *
     * Please note that you need to explicitly encode the message body if you intend to receive the message using a tool or library other than this library.
     * For example:
     *  1. Import DefaultDataTransformer and instantiate.
     *      ```js
     *        const dt = new DefaultDataTransformer();
     *      ```
     *  2. Use the `encode` method on the transformer to encode the message body before calling the scheduleMessage() method
     *      ```js
     *        message.body = dt.encode(message.body);
     *      ```
     *
     * @param scheduledEnqueueTimeUtc - The UTC time at which the message should be enqueued.
     * @param message - The message that needs to be scheduled.
     * @returns Promise<Long> - The sequence number of the message that was scheduled.
     * You will need the sequence number if you intend to cancel the scheduling of the message.
     * Save the `Long` type as-is in your application without converting to number. Since JavaScript
     * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while scheduling a message.
     */
    scheduleMessage(scheduledEnqueueTimeUtc, message) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "scheduledEnqueueTimeUtc", scheduledEnqueueTimeUtc);
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "message", message);
            const messages = [message];
            const result = yield this._context.managementClient.scheduleMessages(scheduledEnqueueTimeUtc, messages);
            return result[0];
        });
    }
    /**
     * Schedules given messages to appear on Service Bus Queue/Subscription at a later time.
     *
     * Please note that you need to explicitly encode the message body if you intend to receive the message using a tool or library other than this library.
     * For example:
     *  1. Import DefaultDataTransformer and instantiate.
     *      ```js
     *        const dt = new DefaultDataTransformer();
     *      ```
     *  2. Use the `encode` method on the transformer to encode the message body before calling the scheduleMessage() method
     *      ```js
     *        message.body = dt.encode(message.body);
     *      ```
     *
     * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
     * @param messages - Array of Messages that need to be scheduled.
     * @returns Promise<Long[]> - The sequence numbers of messages that were scheduled.
     * You will need the sequence number if you intend to cancel the scheduling of the messages.
     * Save the `Long` type as-is in your application without converting to number. Since JavaScript
     * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while scheduling messages.
     */
    scheduleMessages(scheduledEnqueueTimeUtc, messages) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "scheduledEnqueueTimeUtc", scheduledEnqueueTimeUtc);
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "messages", messages);
            if (!Array.isArray(messages)) {
                messages = [messages];
            }
            return this._context.managementClient.scheduleMessages(scheduledEnqueueTimeUtc, messages);
        });
    }
    /**
     * Cancels a message that was scheduled to appear on a ServiceBus Queue/Subscription.
     * @param sequenceNumber - The sequence number of the message to be cancelled.
     * @returns Promise<void>
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while canceling a scheduled message.
     */
    cancelScheduledMessage(sequenceNumber) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
            throwTypeErrorIfParameterNotLong(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
            return this._context.managementClient.cancelScheduledMessages([sequenceNumber]);
        });
    }
    /**
     * Cancels multiple messages that were scheduled to appear on a ServiceBus Queue/Subscription.
     * @param sequenceNumbers - An Array of sequence numbers of the messages to be cancelled.
     * @returns Promise<void>
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while canceling scheduled messages.
     */
    cancelScheduledMessages(sequenceNumbers) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
            if (!Array.isArray(sequenceNumbers)) {
                sequenceNumbers = [sequenceNumbers];
            }
            throwTypeErrorIfParameterNotLongArray(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
            return this._context.managementClient.cancelScheduledMessages(sequenceNumbers);
        });
    }
    /**
     * Closes the underlying AMQP sender link.
     * Once closed, the sender cannot be used for any further operations.
     * Use the `createSender` function on the QueueClient or TopicClient to instantiate a new Sender
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                this._isClosed = true;
                if (this._context.namespace.connection &&
                    this._context.namespace.connection.isOpen() &&
                    this._context.sender) {
                    yield this._context.sender.close();
                }
            }
            catch (err) {
                error("[%s] An error occurred while closing the Sender for %s: %O", this._context.namespace.connectionId, this._context.entityPath, err);
                throw err;
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 */
var ReceiverType;
(function (ReceiverType) {
    ReceiverType["batching"] = "batching";
    ReceiverType["streaming"] = "streaming";
})(ReceiverType || (ReceiverType = {}));
/**
 * @internal
 * Describes the MessageReceiver that will receive messages from ServiceBus.
 * @class MessageReceiver
 */
class MessageReceiver extends LinkEntity {
    constructor(context, receiverType, options) {
        super(context.entityPath, context, {
            address: context.entityPath,
            audience: `${context.namespace.config.endpoint}${context.entityPath}`
        });
        /**
         * @property {number} [maxConcurrentCalls] The maximum number of messages that should be
         * processed concurrently while in streaming mode. Once this limit has been reached, more
         * messages will not be received until the user's message handler has completed processing current message.
         * Default: 1
         */
        this.maxConcurrentCalls = 1;
        /**
         * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that
         * are being actively disposed. It acts as a store for correlating the responses received for
         * active dispositions.
         */
        this._deliveryDispositionMap = new Map();
        /**
         * @property {Map<string, Function>} _messageRenewLockTimers Maintains a map of messages for which
         * the lock is automatically renewed.
         * @protected
         */
        this._messageRenewLockTimers = new Map();
        if (!options)
            options = {};
        this.wasCloseInitiated = false;
        this.receiverType = receiverType;
        this.receiveMode = options.receiveMode || exports.ReceiveMode.peekLock;
        if (typeof options.maxConcurrentCalls === "number" && options.maxConcurrentCalls > 0) {
            this.maxConcurrentCalls = options.maxConcurrentCalls;
        }
        this.resetTimerOnNewMessageReceived = () => {
            /** */
        };
        // If explicitly set to false then autoComplete is false else true (default).
        this.autoComplete = options.autoComplete === false ? options.autoComplete : true;
        this.maxAutoRenewDurationInSeconds =
            options.maxMessageAutoRenewLockDurationInSeconds != null
                ? options.maxMessageAutoRenewLockDurationInSeconds
                : 300;
        this.autoRenewLock =
            this.maxAutoRenewDurationInSeconds > 0 && this.receiveMode === exports.ReceiveMode.peekLock;
        this._clearMessageLockRenewTimer = (messageId) => {
            if (this._messageRenewLockTimers.has(messageId)) {
                clearTimeout(this._messageRenewLockTimers.get(messageId));
                receiver("[%s] Cleared the message renew lock timer for message with id '%s'.", this._context.namespace.connectionId, messageId);
                this._messageRenewLockTimers.delete(messageId);
            }
        };
        this._clearAllMessageLockRenewTimers = () => {
            receiver("[%s] Clearing message renew lock timers for all the active messages.", this._context.namespace.connectionId);
            for (const messageId of this._messageRenewLockTimers.keys()) {
                this._clearMessageLockRenewTimer(messageId);
            }
        };
        // setting all the handlers
        this._onSettled = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const delivery = context.delivery;
            if (delivery) {
                const id = delivery.id;
                const state = delivery.remote_state;
                const settled = delivery.remote_settled;
                receiver("[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been " + "received.", connectionId, id, settled, state && state.error ? state.error : state);
                if (settled && this._deliveryDispositionMap.has(id)) {
                    const promise = this._deliveryDispositionMap.get(id);
                    clearTimeout(promise.timer);
                    receiver("[%s] Found the delivery with id %d in the map and cleared the timer.", connectionId, id);
                    const deleteResult = this._deliveryDispositionMap.delete(id);
                    receiver("[%s] Successfully deleted the delivery with id %d from the map.", connectionId, id, deleteResult);
                    if (state && state.error && (state.error.condition || state.error.description)) {
                        const error = amqpCommon.translate(state.error);
                        return promise.reject(error);
                    }
                    return promise.resolve();
                }
            }
        };
        this._onAmqpMessage = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            // If the receiver got closed in PeekLock mode, avoid processing the message as we
            // cannot settle the message.
            if (this.receiveMode === exports.ReceiveMode.peekLock &&
                (!this._receiver || !this._receiver.isOpen())) {
                error("[%s] Not calling the user's message handler for the current message " +
                    "as the receiver '%s' is closed", this._context.namespace.connectionId, this.name);
                return;
            }
            this.resetTimerOnNewMessageReceived();
            const connectionId = this._context.namespace.connectionId;
            const bMessage = new ServiceBusMessage(this._context, context.message, context.delivery, true);
            if (this.autoRenewLock && bMessage.lockToken) {
                const lockToken = bMessage.lockToken;
                // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.
                // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInSeconds
                // - We should be able to clear the renewal timer when the user's message handler
                // is done (whether it succeeds or fails).
                // Setting the messageId with undefined value in the _messageRenewockTimers Map because we
                // track state by checking the presence of messageId in the map. It is removed from the map
                // when an attempt is made to settle the message (either by the user or by the sdk) OR
                // when the execution of user's message handler completes.
                this._messageRenewLockTimers.set(bMessage.messageId, undefined);
                receiver("[%s] message with id '%s' is locked until %s.", connectionId, bMessage.messageId, bMessage.lockedUntilUtc.toString());
                const totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;
                receiver("[%s] Total autolockrenew duration for message with id '%s' is: ", connectionId, bMessage.messageId, new Date(totalAutoLockRenewDuration).toString());
                const autoRenewLockTask = () => {
                    if (new Date(totalAutoLockRenewDuration) > bMessage.lockedUntilUtc &&
                        Date.now() < totalAutoLockRenewDuration) {
                        if (this._messageRenewLockTimers.has(bMessage.messageId)) {
                            // TODO: We can run into problems with clock skew between the client and the server.
                            // It would be better to calculate the duration based on the "lockDuration" property
                            // of the queue. However, we do not have the management plane of the client ready for
                            // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.
                            const amount = calculateRenewAfterDuration(bMessage.lockedUntilUtc);
                            receiver("[%s] Sleeping for %d milliseconds while renewing the lock for " +
                                "message with id '%s' is: ", connectionId, amount, bMessage.messageId);
                            // Setting the value of the messageId to the actual timer. This will be cleared when
                            // an attempt is made to settle the message (either by the user or by the sdk) OR
                            // when the execution of user's message handler completes.
                            this._messageRenewLockTimers.set(bMessage.messageId, setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
                                try {
                                    receiver("[%s] Attempting to renew the lock for message with id '%s'.", connectionId, bMessage.messageId);
                                    bMessage.lockedUntilUtc = yield this._context.managementClient.renewLock(lockToken);
                                    receiver("[%s] Successfully renewed the lock for message with id '%s'.", connectionId, bMessage.messageId);
                                    receiver("[%s] Calling the autorenewlock task again for message with " + "id '%s'.", connectionId, bMessage.messageId);
                                    autoRenewLockTask();
                                }
                                catch (err) {
                                    error("[%s] An error occured while auto renewing the message lock '%s' " +
                                        "for message with id '%s': %O.", connectionId, bMessage.lockToken, bMessage.messageId, err);
                                    // Let the user know that there was an error renewing the message lock.
                                    this._onError(err);
                                }
                            }), amount));
                        }
                        else {
                            receiver("[%s] Looks like the message lock renew timer has already been " +
                                "cleared for message with id '%s'.", connectionId, bMessage.messageId);
                        }
                    }
                    else {
                        receiver("[%s] Current time %s exceeds the total autolockrenew duration %s for " +
                            "message with messageId '%s'. Hence we will stop the autoLockRenewTask.", connectionId, new Date(Date.now()).toString(), new Date(totalAutoLockRenewDuration).toString(), bMessage.messageId);
                        this._clearMessageLockRenewTimer(bMessage.messageId);
                    }
                };
                // start
                autoRenewLockTask();
            }
            try {
                yield this._onMessage(bMessage);
                this._clearMessageLockRenewTimer(bMessage.messageId);
            }
            catch (err) {
                // This ensures we call users' error handler when users' message handler throws.
                if (!rheaPromise.isAmqpError(err)) {
                    error("[%s] An error occurred while running user's message handler for the message " +
                        "with id '%s' on the receiver '%s': %O", connectionId, bMessage.messageId, this.name, err);
                    this._onError(err);
                }
                // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,
                // doing this here. Otherwise, this should be done in finally.
                this._clearMessageLockRenewTimer(bMessage.messageId);
                const error$1 = amqpCommon.translate(err);
                // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                if (!bMessage.delivery.remote_settled &&
                    error$1.name !== amqpCommon.ConditionErrorNameMapper["com.microsoft:message-lock-lost"] &&
                    this.receiveMode === exports.ReceiveMode.peekLock &&
                    this.isOpen() // only try to abandon the messages if the connection is still open
                ) {
                    try {
                        error("[%s] Abandoning the message with id '%s' on the receiver '%s' since " +
                            "an error occured: %O.", connectionId, bMessage.messageId, this.name, error$1);
                        yield bMessage.abandon();
                    }
                    catch (abandonError) {
                        const translatedError = amqpCommon.translate(abandonError);
                        error("[%s] An error occurred while abandoning the message with id '%s' on the " +
                            "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                        this._onError(translatedError);
                    }
                }
                return;
            }
            finally {
                if (this._receiver) {
                    this._receiver.addCredit(1);
                }
            }
            // If we've made it this far, then user's message handler completed fine. Let us try
            // completing the message.
            if (this.autoComplete &&
                this.receiveMode === exports.ReceiveMode.peekLock &&
                !bMessage.delivery.remote_settled) {
                try {
                    log[this.receiverType]("[%s] Auto completing the message with id '%s' on " + "the receiver '%s'.", connectionId, bMessage.messageId, this.name);
                    yield bMessage.complete();
                }
                catch (completeError) {
                    const translatedError = amqpCommon.translate(completeError);
                    error("[%s] An error occurred while completing the message with id '%s' on the " +
                        "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                    this._onError(translatedError);
                }
            }
        });
        this._onAmqpError = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const receiver = this._receiver || context.receiver;
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const sbError = amqpCommon.translate(receiverError);
                error("[%s] An error occurred for Receiver '%s': %O.", connectionId, this.name, sbError);
                if (!sbError.retryable) {
                    if (receiver && !receiver.isItselfClosed()) {
                        error("[%s] Since the user did not close the receiver and the error is not " +
                            "retryable, we let the user know about it by calling the user's error handler.", connectionId);
                        this._onError(sbError);
                    }
                    else {
                        error("[%s] The received error is not retryable. However, the receiver was " +
                            "closed by the user. Hence not notifying the user's error handler.", connectionId);
                    }
                }
                else {
                    error("[%s] Since received error is retryable, we will NOT notify the user's " +
                        "error handler.", connectionId);
                }
            }
            if (this._newMessageReceivedTimer) {
                clearTimeout(this._newMessageReceivedTimer);
            }
        };
        this._onSessionError = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const receiver = this._receiver || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = amqpCommon.translate(sessionError);
                error("[%s] An error occurred on the session for Receiver '%s': %O.", connectionId, this.name, sbError);
                if (receiver && !receiver.isSessionItselfClosed() && !sbError.retryable) {
                    error("[%s] Since the user did not close the receiver and the session error is not " +
                        "retryable, we let the user know about it by calling the user's error handler.", connectionId);
                    this._onError(sbError);
                }
            }
            if (this._newMessageReceivedTimer) {
                clearTimeout(this._newMessageReceivedTimer);
            }
        };
        this._onAmqpClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            const receiverError = context.receiver && context.receiver.error;
            const receiver = this._receiver || context.receiver;
            if (receiverError) {
                error("[%s] 'receiver_close' event occurred for receiver '%s' with address '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.address, receiverError);
            }
            this._clearAllMessageLockRenewTimers();
            if (receiver && !receiver.isItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                        "and the sdk did not initiate this. The receiver is not reconnecting. Hence, calling " +
                        "detached from the _onAmqpClose() handler.", connectionId, this.name, this.address);
                    yield this.onDetached(receiverError);
                }
                else {
                    error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                        "and the sdk did not initate this. Moreover the receiver is already re-connecting. " +
                        "Hence not calling detached from the _onAmqpClose() handler.", connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                    "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                    "() handler.", connectionId, this.name, this.address);
            }
        });
        this._onSessionClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            const receiver = this._receiver || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                error("[%s] 'session_close' event occurred for receiver '%s' with address '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.address, sessionError);
            }
            this._clearAllMessageLockRenewTimers();
            if (receiver && !receiver.isSessionItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                        "address '%s' and the sdk did not initiate this. Hence calling detached from the " +
                        "_onSessionClose() handler.", connectionId, this.name, this.address);
                    yield this.onDetached(sessionError);
                }
                else {
                    error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                        "address '%s' and the sdk did not initiate this. Moreover the receiver is already " +
                        "re-connecting. Hence not calling detached from the _onSessionClose() handler.", connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'session_close' event occurred on the session of receiver '%s' with address " +
                    "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                    "() handler.", connectionId, this.name, this.address);
            }
        });
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */
    _createReceiverOptions(useNewName, options) {
        if (!options) {
            options = {
                onMessage: (context) => this._onAmqpMessage(context).catch(() => {
                    /* */
                }),
                onClose: (context) => this._onAmqpClose(context).catch(() => {
                    /* */
                }),
                onSessionClose: (context) => this._onSessionClose(context).catch(() => {
                    /* */
                }),
                onError: this._onAmqpError,
                onSessionError: this._onSessionError,
                onSettled: this._onSettled
            };
        }
        const rcvrOptions = Object.assign({ name: useNewName ? getUniqueName(this._context.entityPath) : this.name, autoaccept: this.receiveMode === exports.ReceiveMode.receiveAndDelete ? true : false, 
            // receiveAndDelete -> first(0), peekLock -> second (1)
            rcv_settle_mode: this.receiveMode === exports.ReceiveMode.receiveAndDelete ? 0 : 1, 
            // receiveAndDelete -> settled (1), peekLock -> unsettled (0)
            snd_settle_mode: this.receiveMode === exports.ReceiveMode.receiveAndDelete ? 1 : 0, source: {
                address: this.address
            }, credit_window: 0 }, options);
        return rcvrOptions;
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     * @protected
     *
     * @returns {Promise<void>} Promise<void>.
     */
    _init(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            try {
                if (!this.isOpen() && !this.isConnecting) {
                    error("[%s] The receiver '%s' with address '%s' is not open and is not currently " +
                        "establishing itself. Hence let's try to connect.", connectionId, this.name, this.address);
                    if (options && options.name) {
                        this.name = options.name;
                    }
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    if (!options) {
                        options = this._createReceiverOptions();
                    }
                    error("[%s] Trying to create receiver '%s' with options %O", connectionId, this.name, options);
                    this._receiver = yield this._context.namespace.connection.createReceiver(options);
                    this.isConnecting = false;
                    error("[%s] Receiver '%s' with address '%s' has established itself.", connectionId, this.name, this.address);
                    log[this.receiverType]("Promise to create the receiver resolved. " + "Created receiver with name: ", this.name);
                    log[this.receiverType]("[%s] Receiver '%s' created with receiver options: %O", connectionId, this.name, options);
                    // It is possible for someone to close the receiver and then start it again.
                    // Thus make sure that the receiver is present in the client cache.
                    if (this.receiverType === ReceiverType.streaming && !this._context.streamingReceiver) {
                        this._context.streamingReceiver = this;
                    }
                    else if (this.receiverType === ReceiverType.batching && !this._context.batchingReceiver) {
                        this._context.batchingReceiver = this;
                    }
                    yield this._ensureTokenRenewal();
                }
                else {
                    error("[%s] The receiver '%s' with address '%s' is open -> %s and is connecting " +
                        "-> %s. Hence not reconnecting.", connectionId, this.name, this.address, this.isOpen(), this.isConnecting);
                }
            }
            catch (err) {
                this.isConnecting = false;
                err = amqpCommon.translate(err);
                error("[%s] An error occured while creating the receiver '%s': %O", this._context.namespace.connectionId, this.name, err);
                throw err;
            }
        });
    }
    _deleteFromCache() {
        this._receiver = undefined;
        if (this.receiverType === ReceiverType.streaming) {
            this._context.streamingReceiver = undefined;
        }
        else if (this.receiverType === ReceiverType.batching) {
            this._context.batchingReceiver = undefined;
        }
        error("[%s] Deleted the receiver '%s' from the client cache.", this._context.namespace.connectionId, this.name);
    }
    /**
     * Will reconnect the receiver link if necessary.
     * @param {AmqpError | Error} [receiverError] The receiver error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    onDetached(receiverError) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            try {
                // Local 'wasCloseInitiated' serves same purpose as {this.wasCloseInitiated}
                // but the condition is inferred based on state of receiver in context of network disconnect scenario
                const wasCloseInitiated = this._receiver && this._receiver.isItselfClosed();
                // Clears the token renewal timer. Closes the link and its session if they are open.
                // Removes the link and its session if they are present in rhea's cache.
                yield this._closeLink(this._receiver);
                if (this.receiverType === ReceiverType.batching) {
                    error("[%s] Receiver '%s' with address '%s' is a Batching Receiver, so we will not be " +
                        "re-establishing the receiver link.", connectionId, this.name, this.address);
                    return;
                }
                // We should attempt to reopen only when the receiver(sdk) did not initiate the close
                let shouldReopen = false;
                if (receiverError && !wasCloseInitiated) {
                    const translatedError = amqpCommon.translate(receiverError);
                    if (translatedError.retryable) {
                        shouldReopen = true;
                        error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is retryable. This is a candidate for re-establishing " +
                            "the receiver link.", connectionId, this.name, this.address);
                    }
                    else {
                        error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is NOT retryable. Hence NOT re-establishing " +
                            "the receiver link.", connectionId, this.name, this.address);
                    }
                }
                else if (!wasCloseInitiated) {
                    shouldReopen = true;
                    error("[%s] close() method of Receiver '%s' with address '%s' was not called. " +
                        "There was no accompanying error as well. This is a candidate for re-establishing " +
                        "the receiver link.", connectionId, this.name, this.address);
                }
                else {
                    const state = {
                        wasCloseInitiated: wasCloseInitiated,
                        receiverError: receiverError,
                        _receiver: this._receiver
                    };
                    error("[%s] Something went wrong. State of Receiver '%s' with address '%s' is: %O", connectionId, this.name, this.address, state);
                }
                if (shouldReopen) {
                    // provide a new name to the link while re-connecting it. This ensures that
                    // the service does not send an error stating that the link is still open.
                    const options = this._createReceiverOptions(true);
                    // shall retry forever at an interval of 15 seconds if the error is a retryable error
                    // else bail out when the error is not retryable or the oepration succeeds.
                    const config = {
                        operation: () => this._init(options).then(() => tslib.__awaiter(this, void 0, void 0, function* () {
                            if (this.wasCloseInitiated) {
                                error("[%s] close() method of Receiver '%s' with address '%s' was called. " +
                                    "by the time the receiver finished getting created. Hence, disallowing messages from being received. ", connectionId, this.name, this.address);
                                yield this.close();
                            }
                            else {
                                if (this._receiver && this.receiverType === ReceiverType.streaming) {
                                    this._receiver.addCredit(this.maxConcurrentCalls);
                                }
                            }
                            return;
                        })),
                        connectionId: connectionId,
                        operationType: amqpCommon.RetryOperationType.receiverLink,
                        times: amqpCommon.Constants.defaultConnectionRetryAttempts,
                        connectionHost: this._context.namespace.config.host,
                        delayInSeconds: 15
                    };
                    if (!this.wasCloseInitiated) {
                        yield amqpCommon.retry(config);
                    }
                }
            }
            catch (err) {
                error("[%s] An error occurred while processing detached() of Receiver '%s': %O ", connectionId, this.name, this.address, err);
                if (typeof this._onError === "function") {
                    error("[%s] Unable to automatically reconnect Receiver '%s' with address '%s'.", connectionId, this.name, this.address);
                    try {
                        this._onError(err);
                    }
                    catch (err) {
                        error("[%s] User-code error in error handler called after disconnect: %O", connectionId, err);
                    }
                }
            }
        });
    }
    /**
     * Closes the underlying AMQP receiver.
     * @return {Promise<void>} Promise<void>.
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this.wasCloseInitiated = true;
            receiver("[%s] Closing the [%s]Receiver for entity '%s'.", this._context.namespace.connectionId, this.receiverType, this._context.entityPath);
            if (this._newMessageReceivedTimer)
                clearTimeout(this._newMessageReceivedTimer);
            this._clearAllMessageLockRenewTimers();
            if (this._receiver) {
                const receiverLink = this._receiver;
                this._deleteFromCache();
                yield this._closeLink(receiverLink);
            }
        });
    }
    /**
     * Settles the message with the specified disposition.
     * @param message The ServiceBus Message that needs to be settled.
     * @param operation The disposition type.
     * @param options Optional parameters that can be provided while disposing the message.
     */
    settleMessage(message, operation, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (!options)
                    options = {};
                if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {
                    return reject(new Error(`operation: '${operation}' is not a valid operation.`));
                }
                this._clearMessageLockRenewTimer(message.messageId);
                const delivery = message.delivery;
                const timer = setTimeout(() => {
                    this._deliveryDispositionMap.delete(delivery.id);
                    receiver("[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. " +
                        "Hence rejecting the promise with timeout error.", this._context.namespace.connectionId, delivery.id, amqpCommon.Constants.defaultOperationTimeoutInSeconds * 1000);
                    const e = {
                        condition: amqpCommon.ErrorNameConditionMapper.ServiceUnavailableError,
                        description: "Operation to settle the message has timed out. The disposition of the " +
                            "message may or may not be successful"
                    };
                    return reject(amqpCommon.translate(e));
                }, amqpCommon.Constants.defaultOperationTimeoutInSeconds * 1000);
                this._deliveryDispositionMap.set(delivery.id, {
                    resolve: resolve,
                    reject: reject,
                    timer: timer
                });
                if (operation === DispositionType.complete) {
                    delivery.accept();
                }
                else if (operation === DispositionType.abandon) {
                    const params = {
                        undeliverable_here: false
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.defer) {
                    const params = {
                        undeliverable_here: true
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.deadletter) {
                    delivery.reject(options.error || {});
                }
            });
        });
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this._receiver && this._receiver.isOpen();
        error("[%s] Receiver '%s' with address '%s' is open? -> %s", this._context.namespace.connectionId, this.name, this.address, result);
        return result;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * Describes the streaming receiver where the user can receive the message
 * by providing handler functions.
 * @class StreamingReceiver
 * @extends MessageReceiver
 */
class StreamingReceiver extends MessageReceiver {
    /**
     * Instantiate a new Streaming receiver for receiving messages with handlers.
     *
     * @constructor
     * @param {ClientEntityContext} context                      The client entity context.
     * @param {ReceiveOptions} [options]                         Options for how you'd like to connect.
     */
    constructor(context, options) {
        super(context, ReceiverType.streaming, options);
        this.resetTimerOnNewMessageReceived = () => {
            if (this._newMessageReceivedTimer)
                clearTimeout(this._newMessageReceivedTimer);
            if (this.newMessageWaitTimeoutInSeconds) {
                this._newMessageReceivedTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
                    const msg = `StreamingReceiver '${this.name}' did not receive any messages in ` +
                        `the last ${this.newMessageWaitTimeoutInSeconds} seconds. ` +
                        `Hence ending this receive operation.`;
                    error("[%s] %s", this._context.namespace.connectionId, msg);
                    yield this.close();
                }), this.newMessageWaitTimeoutInSeconds * 1000);
            }
        };
    }
    /**
     * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.
     *
     * @param {OnMessage} onMessage The message handler to receive servicebus messages.
     * @param {OnError} onError The error handler to receive an error that occurs while receivin messages.
     */
    receive(onMessage, onError) {
        throwErrorIfConnectionClosed(this._context.namespace);
        this._onMessage = onMessage;
        this._onError = onError;
        if (this._receiver) {
            this._receiver.addCredit(this.maxConcurrentCalls);
        }
    }
    /**
     * Creates a streaming receiver.
     * @static
     *
     * @param {ClientEntityContext} context    The connection context.
     * @param {ReceiveOptions} [options]     Receive options.
     * @return {Promise<StreamingReceiver>} A promise that resolves with an instance of StreamingReceiver.
     */
    static create(context, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(context.namespace);
            if (!options)
                options = {};
            if (options.autoComplete == null)
                options.autoComplete = true;
            const sReceiver = new StreamingReceiver(context, options);
            yield sReceiver._init();
            context.streamingReceiver = sReceiver;
            return sReceiver;
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the batching receiver where the user can receive a specified number of messages for
 * a predefined time.
 * @internal
 * @class BatchingReceiver
 * @extends MessageReceiver
 */
class BatchingReceiver extends MessageReceiver {
    /**
     * Instantiate a new BatchingReceiver.
     *
     * @constructor
     * @param {ClientEntityContext} context The client entity context.
     * @param {ReceiveOptions} [options]  Options for how you'd like to connect.
     */
    constructor(context, options) {
        super(context, ReceiverType.batching, options);
        /**
         * @property {boolean} isReceivingMessages Indicates whether the link is actively receiving
         * messages. Default: false.
         */
        this.isReceivingMessages = false;
        /**
         * @property {AmqpError | Error | undefined} detachedError Error that occured when receiver
         * got detached. Not applicable when onReceiveError is called.
         *  Default: undefined.
         */
        this.detachedError = undefined;
        this._finalActionHandler = undefined;
        this.newMessageWaitTimeoutInSeconds = 1;
    }
    /**
     * Clear the token renewal timer and set the `detachedError` property.
     * @param {AmqpError | Error} [receiverError] The receiver error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    onDetached(receiverError) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Clears the token renewal timer. Closes the link and its session if they are open.
            yield this._closeLink(this._receiver);
            this.detachedError = receiverError;
            if (this.isReceivingMessages && typeof this._finalActionHandler === "function") {
                this._finalActionHandler();
            }
        });
    }
    /**
     * Receives a batch of messages from a ServiceBus Queue/Topic.
     * @param maxMessageCount The maximum number of messages to receive.
     * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.
     * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * - **Default**: `60` seconds.
     * @returns {Promise<ServiceBusMessage[]>} A promise that resolves with an array of Message objects.
     */
    receive(maxMessageCount, maxWaitTimeInSeconds) {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (maxWaitTimeInSeconds == null) {
            maxWaitTimeInSeconds = amqpCommon.Constants.defaultOperationTimeoutInSeconds;
        }
        const brokeredMessages = [];
        this.isReceivingMessages = true;
        return new Promise((resolve, reject) => {
            let totalWaitTimer;
            const onSessionError = (context) => {
                this.isReceivingMessages = false;
                const receiver = this._receiver || context.receiver;
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                receiver.session.removeListener(rheaPromise.SessionEvents.sessionError, onSessionError);
                const sessionError = context.session && context.session.error;
                let error$1 = new amqpCommon.MessagingError("An error occurred while receiving messages.");
                if (sessionError) {
                    error$1 = amqpCommon.translate(sessionError);
                    error("[%s] 'session_close' event occurred for Receiver '%s' received an error:\n%O", this._context.namespace.connectionId, this.name, error$1);
                }
                if (totalWaitTimer) {
                    clearTimeout(totalWaitTimer);
                }
                if (this._newMessageReceivedTimer) {
                    clearTimeout(this._newMessageReceivedTimer);
                }
                reject(error$1);
            };
            // Final action to be performed after maxMessageCount is reached or the maxWaitTime is over.
            const finalAction = (this._finalActionHandler = () => {
                // clear finalActionHandler so that it can't be called multiple times.
                this._finalActionHandler = undefined;
                if (this._newMessageReceivedTimer) {
                    clearTimeout(this._newMessageReceivedTimer);
                }
                if (totalWaitTimer) {
                    clearTimeout(totalWaitTimer);
                }
                // Removing listeners, so that the next receiveMessages() call can set them again.
                if (this._receiver) {
                    this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                    this._receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                    this._receiver.session.removeListener(rheaPromise.SessionEvents.sessionError, onSessionError);
                }
                // When receiveMode is in receiveAndDelete mode, we should return those messages to the user
                // because they have already been removed from service bus and are safe to handle.
                // If there haven't been any received messages, then it's safe to reject the promise
                // so that the user knows there was an underlying issue that prevented receiving messages.
                if (this.detachedError &&
                    (this.receiveMode !== exports.ReceiveMode.receiveAndDelete || brokeredMessages.length === 0)) {
                    if (this._receiver) {
                        this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    }
                    this.isReceivingMessages = false;
                    const err = amqpCommon.translate(this.detachedError);
                    return reject(err);
                }
                // If the receiver has been detached, there is no need to drain.
                if (this._receiver && this._receiver.credit > 0 && !this.detachedError) {
                    batching("[%s] Receiver '%s': Draining leftover credits(%d).", this._context.namespace.connectionId, this.name, this._receiver.credit);
                    // Setting drain must be accompanied by a flow call (aliased to addCredit in this case).
                    this._receiver.drain = true;
                    this._receiver.addCredit(1);
                }
                else {
                    if (this._receiver) {
                        this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    }
                    this.isReceivingMessages = false;
                    batching("[%s] Receiver '%s': Resolving receiveMessages() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                    resolve(brokeredMessages);
                }
            });
            // Action to be performed on the "message" event.
            const onReceiveMessage = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                this.resetTimerOnNewMessageReceived();
                try {
                    const data = new ServiceBusMessage(this._context, context.message, context.delivery, true);
                    if (brokeredMessages.length < maxMessageCount) {
                        brokeredMessages.push(data);
                    }
                }
                catch (err) {
                    const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));
                    error("[%s] Receiver '%s' received an error while converting AmqpMessage to ServiceBusMessage:\n%O", this._context.namespace.connectionId, this.name, errObj);
                    reject(errObj);
                }
                if (brokeredMessages.length === maxMessageCount) {
                    finalAction();
                }
            });
            const onSessionClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    this.isReceivingMessages = false;
                    const sessionError = context.session && context.session.error;
                    if (sessionError) {
                        error("[%s] 'session_close' event occurred for receiver '%s'. The associated error is: %O", this._context.namespace.connectionId, this.name, sessionError);
                    }
                }
                catch (err) {
                    error("[%s] Receiver '%s' error in onSessionClose handler:\n%O", this._context.namespace.connectionId, this.name, amqpCommon.translate(err));
                }
            });
            // Action to be performed on the "receiver_drained" event.
            const onReceiveDrain = () => {
                if (this._receiver) {
                    this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    this._receiver.drain = false;
                }
                this.isReceivingMessages = false;
                batching("[%s] Receiver '%s' drained. Resolving receiveMessages() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                resolve(brokeredMessages);
            };
            const onReceiveClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    this.isReceivingMessages = false;
                    const receiverError = context.receiver && context.receiver.error;
                    if (receiverError) {
                        error("[%s] 'receiver_close' event occurred. The associated error is: %O", this._context.namespace.connectionId, receiverError);
                    }
                }
                catch (err) {
                    error("[%s] Receiver '%s' error in onClose handler:\n%O", this._context.namespace.connectionId, this.name, amqpCommon.translate(err));
                }
            });
            // Action to be taken when an error is received.
            const onReceiveError = (context) => {
                this.isReceivingMessages = false;
                const receiver = this._receiver || context.receiver;
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                receiver.session.removeListener(rheaPromise.SessionEvents.sessionError, onSessionError);
                const receiverError = context.receiver && context.receiver.error;
                let error$1 = new amqpCommon.MessagingError("An error occurred while receiving messages.");
                if (receiverError) {
                    error$1 = amqpCommon.translate(receiverError);
                    error("[%s] Receiver '%s' received an error:\n%O", this._context.namespace.connectionId, this.name, error$1);
                }
                if (totalWaitTimer) {
                    clearTimeout(totalWaitTimer);
                }
                if (this._newMessageReceivedTimer) {
                    clearTimeout(this._newMessageReceivedTimer);
                }
                reject(error$1);
            };
            // Use new message wait timer only in peekLock mode
            if (this.receiveMode === exports.ReceiveMode.peekLock) {
                /**
                 * Resets the timer when a new message is received. If no messages were received for
                 * `newMessageWaitTimeoutInSeconds`, the messages received till now are returned. The
                 * receiver link stays open for the next receive call, but doesnt receive messages until then.
                 */
                this.resetTimerOnNewMessageReceived = () => {
                    if (this._newMessageReceivedTimer)
                        clearTimeout(this._newMessageReceivedTimer);
                    if (this.newMessageWaitTimeoutInSeconds) {
                        this._newMessageReceivedTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
                            const msg = `BatchingReceiver '${this.name}' did not receive any messages in the last ` +
                                `${this.newMessageWaitTimeoutInSeconds} seconds. ` +
                                `Hence ending this batch receive operation.`;
                            error("[%s] %s", this._context.namespace.connectionId, msg);
                            finalAction();
                        }), this.newMessageWaitTimeoutInSeconds * 1000);
                    }
                };
            }
            // Action to be performed after the max wait time is over.
            const actionAfterWaitTimeout = () => {
                batching("[%s] Batching Receiver '%s'  max wait time in seconds %d over.", this._context.namespace.connectionId, this.name, maxWaitTimeInSeconds);
                return finalAction();
            };
            const onSettled = (context) => {
                const connectionId = this._context.namespace.connectionId;
                const delivery = context.delivery;
                if (delivery) {
                    const id = delivery.id;
                    const state = delivery.remote_state;
                    const settled = delivery.remote_settled;
                    receiver("[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been " +
                        "received.", connectionId, id, settled, state && state.error ? state.error : state);
                    if (settled && this._deliveryDispositionMap.has(id)) {
                        const promise = this._deliveryDispositionMap.get(id);
                        clearTimeout(promise.timer);
                        receiver("[%s] Found the delivery with id %d in the map and cleared the timer.", connectionId, id);
                        const deleteResult = this._deliveryDispositionMap.delete(id);
                        receiver("[%s] Successfully deleted the delivery with id %d from the map.", connectionId, id, deleteResult);
                        if (state && state.error && (state.error.condition || state.error.description)) {
                            const error = amqpCommon.translate(state.error);
                            return promise.reject(error);
                        }
                        return promise.resolve();
                    }
                }
            };
            const addCreditAndSetTimer = (reuse) => {
                batching("[%s] Receiver '%s', adding credit for receiving %d messages.", this._context.namespace.connectionId, this.name, maxMessageCount);
                // By adding credit here, we let the service know that at max we can handle `maxMessageCount`
                // number of messages concurrently. We will return the user an array of messages that can
                // be of size upto maxMessageCount. Then the user needs to accordingly dispose
                // (complete/abandon/defer/deadletter) the messages from the array.
                this._receiver.addCredit(maxMessageCount);
                let msg = "[%s] Setting the wait timer for %d seconds for receiver '%s'.";
                if (reuse)
                    msg += " Receiver link already present, hence reusing it.";
                batching(msg, this._context.namespace.connectionId, maxWaitTimeInSeconds, this.name);
                totalWaitTimer = setTimeout(actionAfterWaitTimeout, maxWaitTimeInSeconds * 1000);
                // TODO: Disabling this for now. We would want to give the user a decent chance to receive
                // the first message and only timeout faster if successive messages from there onwards are
                // not received quickly. However, it may be possible that there are no pending messages
                // currently on the queue. In that case waiting for idleTimeoutInSeconds would be
                // unnecessary.
                // There is a management plane API to get runtimeInfo of the Queue which provides
                // information about active messages on the Queue and it's sub Queues. However, this adds
                // a little complexity. If the first message was delayed due to network latency then there
                // are bright chances that the management plane api would receive the same fate.
                // It would be better to weigh all the options before making a decision.
                // resetTimerOnNewMessageReceived();
            };
            if (!this.isOpen()) {
                // clear detachedError since we are reconnecting.
                this.detachedError = undefined;
                batching("[%s] Receiver '%s', setting max concurrent calls to 0.", this._context.namespace.connectionId, this.name);
                // while creating the receiver link for batching receiver the max concurrent calls
                // i.e. the credit_window on the link is set to zero. After the link is created
                // successfully, we add credit which is the maxMessageCount specified by the user.
                this.maxConcurrentCalls = 0;
                const rcvrOptions = this._createReceiverOptions(false, {
                    onMessage: onReceiveMessage,
                    onError: onReceiveError,
                    onSessionError: onSessionError,
                    onSettled: onSettled,
                    onClose: onReceiveClose,
                    onSessionClose: onSessionClose
                });
                this._init(rcvrOptions)
                    .then(() => {
                    this._receiver.on(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    addCreditAndSetTimer();
                    return;
                })
                    .catch(reject);
            }
            else {
                addCreditAndSetTimer(true);
                this._receiver.on(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                this._receiver.on(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                this._receiver.on(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                this._receiver.session.on(rheaPromise.SessionEvents.sessionError, onSessionError);
            }
        });
    }
    /**
     * Creates a batching receiver.
     * @static
     *
     * @param {ClientEntityContext} context    The connection context.
     * @param {ReceiveOptions} [options]     Receive options.
     */
    static create(context, options) {
        throwErrorIfConnectionClosed(context.namespace);
        const bReceiver = new BatchingReceiver(context, options);
        context.batchingReceiver = bReceiver;
        return bReceiver;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Enum to denote who is calling the session receiver
 * @internal
 */
var SessionCallee;
(function (SessionCallee) {
    SessionCallee["standalone"] = "standalone";
    SessionCallee["sessionManager"] = "sessionManager";
})(SessionCallee || (SessionCallee = {}));
/**
 * @internal
 * Describes the receiver for a Message Session.
 */
class MessageSession extends LinkEntity {
    constructor(context, options) {
        super(context.entityPath, context, {
            address: context.entityPath,
            audience: `${context.namespace.config.endpoint}${context.entityPath}`
        });
        /**
         * @property {number} [maxConcurrentCalls] The maximum number of messages that should be
         * processed concurrently in a session while in streaming mode. Once this limit has been reached,
         * more messages will not be received until the user's message handler has completed processing current message.
         * - **Default**: `1` (message in a session at a time).
         */
        this.maxConcurrentCalls = 1;
        /**
         * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that
         * are being actively disposed. It acts as a store for correlating the responses received for
         * active dispositions.
         */
        this._deliveryDispositionMap = new Map();
        this._context.isSessionEnabled = true;
        this.isReceivingMessages = false;
        if (!options)
            options = { sessionId: undefined };
        this.autoComplete = false;
        this.sessionId = options.sessionId;
        this.receiveMode = options.receiveMode || exports.ReceiveMode.peekLock;
        this.callee = options.callee || SessionCallee.standalone;
        this.maxAutoRenewDurationInSeconds =
            options.maxSessionAutoRenewLockDurationInSeconds != null
                ? options.maxSessionAutoRenewLockDurationInSeconds
                : 300;
        this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;
        this.autoRenewLock =
            this.maxAutoRenewDurationInSeconds > 0 && this.receiveMode === exports.ReceiveMode.peekLock;
        // setting all the handlers
        this._onSettled = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const delivery = context.delivery;
            if (delivery) {
                const id = delivery.id;
                const state = delivery.remote_state;
                const settled = delivery.remote_settled;
                receiver("[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been " + "received.", connectionId, id, settled, state && state.error ? state.error : state);
                if (settled && this._deliveryDispositionMap.has(id)) {
                    const promise = this._deliveryDispositionMap.get(id);
                    clearTimeout(promise.timer);
                    receiver("[%s] Found the delivery with id %d in the map and cleared the timer.", connectionId, id);
                    const deleteResult = this._deliveryDispositionMap.delete(id);
                    receiver("[%s] Successfully deleted the delivery with id %d from the map.", connectionId, id, deleteResult);
                    if (state && state.error && (state.error.condition || state.error.description)) {
                        const error = amqpCommon.translate(state.error);
                        return promise.reject(error);
                    }
                    return promise.resolve();
                }
            }
        };
        this._notifyError = (error$1) => {
            if (this._onError) {
                this._onError(error$1);
                error("[%s] Notified the user's error handler about the error received by the " +
                    "Receiver '%s'.", this._context.namespace.connectionId, this.name);
            }
        };
        this._onAmqpError = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const sbError = amqpCommon.translate(receiverError);
                if (sbError.name === "SessionLockLostError") {
                    this._context.expiredMessageSessions[this.sessionId] = true;
                    sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;
                }
                error("[%s] An error occurred for Receiver '%s': %O.", connectionId, this.name, sbError);
                this._notifyError(sbError);
            }
        };
        this._onSessionError = (context) => {
            const connectionId = this._context.namespace.connectionId;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = amqpCommon.translate(sessionError);
                error("[%s] An error occurred on the session for Receiver '%s': %O.", connectionId, this.name, sbError);
                this._notifyError(sbError);
            }
        };
        this._onAmqpClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            const receiverError = context.receiver && context.receiver.error;
            const receiver = this._receiver || context.receiver;
            let isClosedDueToExpiry = false;
            if (receiverError) {
                const sbError = amqpCommon.translate(receiverError);
                if (sbError.name === "SessionLockLostError") {
                    isClosedDueToExpiry = true;
                }
                error("[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.sessionId, sbError);
                // no need to notify the user's error handler since rhea guarantees that receiver_error
                // will always be emitted before receiver_close.
            }
            if (receiver && !receiver.isItselfClosed()) {
                error("[%s] 'receiver_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", connectionId, this.name, this.sessionId);
                try {
                    yield this.close(isClosedDueToExpiry);
                }
                catch (err) {
                    error("[%s] An error occurred while closing the receiver '%s' for sessionId '%s': %O.", connectionId, this.name, this.sessionId, err);
                }
            }
            else {
                error("[%s] 'receiver_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "because the sdk initiated it. Hence no need to gracefully close the receiver", connectionId, this.name, this.sessionId);
            }
        });
        this._onSessionClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            const receiver = this._receiver || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = amqpCommon.translate(sessionError);
                error("[%s] 'session_close' event occurred for receiver '%s' for sessionId '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.sessionId, sbError);
                // no need to notify the user's error handler since rhea guarantees that session_error
                // will always be emitted before session_close.
            }
            if (receiver && !receiver.isSessionItselfClosed()) {
                error("[%s] 'session_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", connectionId, this.name, this.sessionId);
                try {
                    yield this.close();
                }
                catch (err) {
                    error("[%s] An error occurred while closing the receiver '%s' for sessionId '%s': %O.", connectionId, this.name, this.sessionId, err);
                }
            }
            else {
                error("[%s] 'session_close' event occurred on the receiver '%s' for sessionId '%s' " +
                    "because the sdk initiated it. Hence no need to gracefully close the receiver", connectionId, this.name, this.sessionId);
            }
        });
    }
    /**
     * Ensures that the session lock is renewed before it expires. The lock will not be renewed for
     * more than the configured totalAutoLockRenewDuration.
     */
    _ensureSessionLockRenewal() {
        if (this.autoRenewLock &&
            new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc &&
            Date.now() < this._totalAutoLockRenewDuration &&
            this.isOpen()) {
            const connectionId = this._context.namespace.connectionId;
            const nextRenewalTimeout = calculateRenewAfterDuration(this.sessionLockedUntilUtc);
            this._sessionLockRenewalTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    messageSession("[%s] Attempting to renew the session lock for MessageSession '%s' " +
                        "with name '%s'.", connectionId, this.sessionId, this.name);
                    this.sessionLockedUntilUtc = yield this._context.managementClient.renewSessionLock(this.sessionId, {
                        delayInSeconds: 0,
                        timeoutInSeconds: 10,
                        times: 4
                    });
                    receiver("[%s] Successfully renewed the session lock for MessageSession '%s' " +
                        "with name '%s'.", connectionId, this.sessionId, this.name);
                    receiver("[%s] Calling _ensureSessionLockRenewal() again for MessageSession '%s'.", connectionId, this.sessionId);
                    this._ensureSessionLockRenewal();
                }
                catch (err) {
                    error("[%s] An error occurred while renewing the session lock for MessageSession " +
                        "'%s' with name '%s': %O", this._context.namespace.connectionId, this.sessionId, this.name, err);
                }
            }), nextRenewalTimeout);
            messageSession("[%s] MessageSession '%s' with name '%s', has next session lock renewal " +
                "in %d seconds @(%s).", this._context.namespace.connectionId, this.sessionId, this.name, nextRenewalTimeout / 1000, new Date(Date.now() + nextRenewalTimeout).toString());
        }
    }
    /**
     * Deletes the MessageSession from the internal cache.
     */
    _deleteFromCache() {
        this._receiver = undefined;
        delete this._context.messageSessions[this.sessionId];
        error("[%s] Deleted the receiver '%s' with sessionId '%s' from the client cache.", this._context.namespace.connectionId, this.name, this.sessionId);
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     */
    _init() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const connectionId = this._context.namespace.connectionId;
            try {
                if (!this.isOpen() && !this.isConnecting) {
                    error("[%s] The receiver '%s' with address '%s' is not open and is not currently " +
                        "establishing itself. Hence let's try to connect.", connectionId, this.name, this.address);
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    const options = this._createMessageSessionOptions();
                    error("[%s] Trying to create receiver '%s' with options %O", connectionId, this.name, options);
                    this._receiver = yield this._context.namespace.connection.createReceiver(options);
                    this.isConnecting = false;
                    const receivedSessionId = this._receiver.source &&
                        this._receiver.source.filter &&
                        this._receiver.source.filter[amqpCommon.Constants.sessionFilterName];
                    let errorMessage = "";
                    // SB allows a sessionId with empty string value :)
                    if (receivedSessionId == null) {
                        errorMessage =
                            `Received an incorrect sessionId '${receivedSessionId}' while creating ` +
                                `the receiver '${this.name}'.`;
                    }
                    if (this.sessionId != null && receivedSessionId !== this.sessionId) {
                        errorMessage =
                            `Received sessionId '${receivedSessionId}' does not match the provided ` +
                                `sessionId '${this.sessionId}' while creating the receiver '${this.name}'.`;
                    }
                    if (errorMessage) {
                        const error$1 = amqpCommon.translate({
                            description: errorMessage,
                            condition: amqpCommon.ErrorNameConditionMapper.SessionCannotBeLockedError
                        });
                        error("[%s] %O", this._context.namespace.connectionId, error$1);
                        throw error$1;
                    }
                    if (this.sessionId == null)
                        this.sessionId = receivedSessionId;
                    this.sessionLockedUntilUtc = convertTicksToDate(this._receiver.properties["com.microsoft:locked-until-utc"]);
                    messageSession("[%s] Session with id '%s' is locked until: '%s'.", connectionId, this.sessionId, this.sessionLockedUntilUtc.toISOString());
                    error("[%s] Receiver '%s' for sessionId '%s' has established itself.", connectionId, this.name, this.sessionId);
                    messageSession("Promise to create the receiver resolved. " + "Created receiver with name: ", this.name);
                    messageSession("[%s] Receiver '%s' created with receiver options: %O", connectionId, this.name, options);
                    if (!this._context.messageSessions[this.sessionId]) {
                        this._context.messageSessions[this.sessionId] = this;
                    }
                    this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;
                    yield this._ensureTokenRenewal();
                    yield this._ensureSessionLockRenewal();
                }
                else {
                    error("[%s] The receiver '%s' for sessionId '%s' is open -> %s and is connecting " +
                        "-> %s. Hence not reconnecting.", connectionId, this.name, this.sessionId, this.isOpen(), this.isConnecting);
                }
            }
            catch (err) {
                this.isConnecting = false;
                const errObj = amqpCommon.translate(err);
                error("[%s] An error occured while creating the receiver '%s': %O", this._context.namespace.connectionId, this.name, errObj);
                throw errObj;
            }
        });
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */
    _createMessageSessionOptions() {
        const rcvrOptions = {
            name: this.name,
            autoaccept: false,
            // receiveAndDelete -> first(0), peekLock -> second (1)
            rcv_settle_mode: this.receiveMode === exports.ReceiveMode.receiveAndDelete ? 0 : 1,
            // receiveAndDelete -> settled (1), peekLock -> unsettled (0)
            snd_settle_mode: this.receiveMode === exports.ReceiveMode.receiveAndDelete ? 1 : 0,
            source: {
                address: this.address,
                filter: {}
            },
            credit_window: 0,
            onClose: (context) => this._onAmqpClose(context).catch(() => {
                /* */
            }),
            onSessionClose: (context) => this._onSessionClose(context).catch(() => {
                /* */
            }),
            onError: this._onAmqpError,
            onSessionError: this._onSessionError,
            onSettled: this._onSettled
        };
        rcvrOptions.source.filter[amqpCommon.Constants.sessionFilterName] = this.sessionId;
        return rcvrOptions;
    }
    /**
     * Closes the underlying AMQP receiver link.
     * @param isClosedDueToExpiry Flag that denotes if close is invoked due to session expiring.
     * This is so that the internal map of expired sessions doesn't get cleared when session is
     * closed due to expiry.
     */
    close(isClosedDueToExpiry) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                messageSession("[%s] Closing the MessageSession '%s' for queue '%s'.", this._context.namespace.connectionId, this.sessionId, this.name);
                this.isReceivingMessages = false;
                if (this._newMessageReceivedTimer)
                    clearTimeout(this._newMessageReceivedTimer);
                if (this._sessionLockRenewalTimer)
                    clearTimeout(this._sessionLockRenewalTimer);
                messageSession("[%s] Cleared the timers for 'no new message received' task and " +
                    "'session lock renewal' task.", this._context.namespace.connectionId);
                if (!isClosedDueToExpiry) {
                    delete this._context.expiredMessageSessions[this.sessionId];
                }
                if (this._receiver) {
                    const receiverLink = this._receiver;
                    this._deleteFromCache();
                    yield this._closeLink(receiverLink);
                }
            }
            catch (err) {
                error("[%s] An error occurred while closing the message session with id '%s': %O.", this._context.namespace.connectionId, this.sessionId, err);
            }
        });
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     */
    isOpen() {
        const result = this._receiver && this._receiver.isOpen();
        messageSession("[%s] Receiver '%s' for sessionId '%s' is open? -> %s", this._context.namespace.connectionId, this.name, this.sessionId, result);
        return result;
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver or set the property
     * `newMessageWaitTimeoutInSeconds` in the options to provide a timeout.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed. You can
     * also provide a timeout in seconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     *
     * @returns void
     */
    receive(onMessage, onError, options) {
        if (!options)
            options = {};
        this.isReceivingMessages = true;
        if (typeof options.maxConcurrentCalls === "number" && options.maxConcurrentCalls > 0) {
            this.maxConcurrentCalls = options.maxConcurrentCalls;
        }
        // If explicitly set to false then autoComplete is false else true (default).
        this.autoComplete = options.autoComplete === false ? options.autoComplete : true;
        this._onMessage = onMessage;
        this._onError = onError;
        const connectionId = this._context.namespace.connectionId;
        /**
         * Resets the timer when a new message is received for Session Manager.
         * It will close the receiver gracefully, if no
         * messages were received for the configured newMessageWaitTimeoutInSeconds
         */
        const resetTimerOnNewMessageReceived = () => {
            if (this._newMessageReceivedTimer)
                clearTimeout(this._newMessageReceivedTimer);
            if (this.newMessageWaitTimeoutInSeconds) {
                this._newMessageReceivedTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
                    const msg = `MessageSession '${this.sessionId}' with name '${this.name}' did not receive ` +
                        `any messages in the last ${this.newMessageWaitTimeoutInSeconds} seconds. Hence closing it.`;
                    error("[%s] %s", this._context.namespace.connectionId, msg);
                    if (this.callee === SessionCallee.sessionManager) {
                        // The session manager will not forward this error to user.
                        // Instead, this is taken as a indicator to create a new session client for the next session.
                        const error = amqpCommon.translate({
                            condition: "com.microsoft:message-wait-timeout",
                            description: msg
                        });
                        this._notifyError(amqpCommon.translate(error));
                    }
                    yield this.close();
                }), this.newMessageWaitTimeoutInSeconds * 1000);
            }
        };
        if (this._receiver && this._receiver.isOpen()) {
            const onSessionMessage = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                // If the receiver got closed in PeekLock mode, avoid processing the message as we
                // cannot settle the message.
                if (this.receiveMode === exports.ReceiveMode.peekLock &&
                    (!this._receiver || !this._receiver.isOpen())) {
                    error("[%s] Not calling the user's message handler for the current message " +
                        "as the receiver '%s' is closed", connectionId, this.name);
                    return;
                }
                resetTimerOnNewMessageReceived();
                const bMessage = new ServiceBusMessage(this._context, context.message, context.delivery, true);
                try {
                    yield this._onMessage(bMessage);
                }
                catch (err) {
                    // This ensures we call users' error handler when users' message handler throws.
                    if (!rheaPromise.isAmqpError(err)) {
                        error("[%s] An error occurred while running user's message handler for the message " +
                            "with id '%s' on the receiver '%s': %O", connectionId, bMessage.messageId, this.name, err);
                        this._onError(err);
                    }
                    const error$1 = amqpCommon.translate(err);
                    // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                    if (!bMessage.delivery.remote_settled &&
                        this.receiveMode === exports.ReceiveMode.peekLock &&
                        this.isOpen() // only try to abandon the messages if the connection is still open
                    ) {
                        try {
                            error("[%s] Abandoning the message with id '%s' on the receiver '%s' since " +
                                "an error occured: %O.", connectionId, bMessage.messageId, this.name, error$1);
                            yield bMessage.abandon();
                        }
                        catch (abandonError) {
                            const translatedError = amqpCommon.translate(abandonError);
                            error("[%s] An error occurred while abandoning the message with id '%s' on the " +
                                "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                            this._notifyError(translatedError);
                        }
                    }
                    return;
                }
                finally {
                    if (this._receiver) {
                        this._receiver.addCredit(1);
                    }
                }
                // If we've made it this far, then user's message handler completed fine. Let us try
                // completing the message.
                if (this.autoComplete &&
                    this.receiveMode === exports.ReceiveMode.peekLock &&
                    !bMessage.delivery.remote_settled) {
                    try {
                        messageSession("[%s] Auto completing the message with id '%s' on " + "the receiver '%s'.", connectionId, bMessage.messageId, this.name);
                        yield bMessage.complete();
                    }
                    catch (completeError) {
                        const translatedError = amqpCommon.translate(completeError);
                        error("[%s] An error occurred while completing the message with id '%s' on the " +
                            "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                        this._notifyError(translatedError);
                    }
                }
            });
            // setting the "message" event listener.
            this._receiver.on(rheaPromise.ReceiverEvents.message, onSessionMessage);
            // adding credit
            this._receiver.addCredit(this.maxConcurrentCalls);
        }
        else {
            this.isReceivingMessages = false;
            const msg = `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` +
                `has either not been created or is not open.`;
            error("[%s] %s", this._context.namespace.connectionId, msg);
            this._notifyError(new Error(msg));
        }
    }
    /**
     * Returns a batch of messages based on given count and timeout over an AMQP receiver link
     * from a Queue/Subscription.
     *
     * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
     * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * - **Default**: `60` seconds.
     * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
     */
    receiveMessages(maxMessageCount, maxWaitTimeInSeconds) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (maxWaitTimeInSeconds == null) {
                maxWaitTimeInSeconds = amqpCommon.Constants.defaultOperationTimeoutInSeconds;
            }
            const brokeredMessages = [];
            this.isReceivingMessages = true;
            return new Promise((resolve, reject) => {
                let totalWaitTimer;
                const setnewMessageWaitTimeoutInSeconds = (value) => {
                    this.newMessageWaitTimeoutInSeconds = value;
                };
                setnewMessageWaitTimeoutInSeconds(1);
                // Action to be performed on the "receiver_drained" event.
                const onReceiveDrain = () => {
                    this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    this._receiver.drain = false;
                    this.isReceivingMessages = false;
                    messageSession("[%s] Receiver '%s' drained. Resolving receiveMessages() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                    resolve(brokeredMessages);
                };
                // Action to be performed after the max wait time is over.
                const actionAfterWaitTimeout = () => {
                    batching("[%s] Batching Receiver '%s'  max wait time in seconds %d over.", this._context.namespace.connectionId, this.name, maxWaitTimeInSeconds);
                    return finalAction();
                };
                // Action to be performed on the "message" event.
                const onReceiveMessage = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                    resetTimerOnNewMessageReceived();
                    try {
                        const data = new ServiceBusMessage(this._context, context.message, context.delivery, true);
                        if (brokeredMessages.length < maxMessageCount) {
                            brokeredMessages.push(data);
                        }
                    }
                    catch (err) {
                        // Removing listeners, so that the next receiveMessages() call can set them again.
                        if (this._receiver) {
                            this._receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                            this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                        }
                        error("[%s] Receiver '%s' received an error while converting AmqpMessage to ServiceBusMessage:\n%O", this._context.namespace.connectionId, this.name, err);
                        reject(err instanceof Error ? err : new Error(JSON.stringify(err)));
                    }
                    if (brokeredMessages.length === maxMessageCount) {
                        finalAction();
                    }
                });
                this._onError = (error) => {
                    this.isReceivingMessages = false;
                    // Resetting the newMessageWaitTimeoutInSeconds to undefined since we are done receiving
                    // a batch of messages.
                    setnewMessageWaitTimeoutInSeconds();
                    if (totalWaitTimer) {
                        clearTimeout(totalWaitTimer);
                    }
                    // Removing listeners, so that the next receiveMessages() call can set them again.
                    if (this._receiver) {
                        this._receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                        this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    }
                    reject(error);
                };
                // Final action to be performed after maxMessageCount is reached or the maxWaitTime is over.
                const finalAction = () => {
                    if (this._newMessageReceivedTimer) {
                        clearTimeout(this._newMessageReceivedTimer);
                    }
                    if (totalWaitTimer) {
                        clearTimeout(totalWaitTimer);
                    }
                    // Unsetting the newMessageWaitTimeoutInSeconds to undefined since we are done receiving
                    // a batch of messages.
                    setnewMessageWaitTimeoutInSeconds();
                    // Removing listeners, so that the next receiveMessages() call can set them again.
                    if (this._receiver) {
                        this._receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                    }
                    if (this._receiver && this._receiver.credit > 0) {
                        messageSession("[%s] Receiver '%s': Draining leftover credits(%d).", this._context.namespace.connectionId, this.name, this._receiver.credit);
                        // Setting drain must be accompanied by a flow call (aliased to addCredit in this case).
                        this._receiver.drain = true;
                        this._receiver.addCredit(1);
                    }
                    else {
                        if (this._receiver) {
                            this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                        }
                        this.isReceivingMessages = false;
                        messageSession("[%s] Receiver '%s': Resolving receiveMessages() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                        resolve(brokeredMessages);
                    }
                };
                /**
                 * Resets the timer when a new message is received. If no messages were received for
                 * `newMessageWaitTimeoutInSeconds`, the messages received till now are returned. The
                 * receiver link stays open for the next receive call, but doesnt receive messages until then.
                 * The new message wait timer mechanism is used only in `peekLock` mode.
                 */
                const resetTimerOnNewMessageReceived = this.receiveMode === exports.ReceiveMode.peekLock
                    ? () => {
                        if (this._newMessageReceivedTimer)
                            clearTimeout(this._newMessageReceivedTimer);
                        if (this.newMessageWaitTimeoutInSeconds) {
                            this._newMessageReceivedTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
                                const msg = `MessageSession '${this.sessionId}' with name '${this.name}' did not receive ` +
                                    `any messages in the last ${this.newMessageWaitTimeoutInSeconds} seconds. Hence closing it.`;
                                error("[%s] %s", this._context.namespace.connectionId, msg);
                                finalAction();
                                if (this.callee === SessionCallee.sessionManager) {
                                    yield this.close();
                                }
                            }), this.newMessageWaitTimeoutInSeconds * 1000);
                        }
                    }
                    : () => { };
                const addCreditAndSetTimer = (reuse) => {
                    batching("[%s] Receiver '%s', adding credit for receiving %d messages.", this._context.namespace.connectionId, this.name, maxMessageCount);
                    // By adding credit here, we let the service know that at max we can handle `maxMessageCount`
                    // number of messages concurrently. We will return the user an array of messages that can
                    // be of size upto maxMessageCount. Then the user needs to accordingly dispose
                    // (complete,/abandon/defer/deadletter) the messages from the array.
                    this._receiver.addCredit(maxMessageCount);
                    let msg = "[%s] Setting the wait timer for %d seconds for receiver '%s'.";
                    if (reuse)
                        msg += " Receiver link already present, hence reusing it.";
                    batching(msg, this._context.namespace.connectionId, maxWaitTimeInSeconds, this.name);
                    totalWaitTimer = setTimeout(actionAfterWaitTimeout, maxWaitTimeInSeconds * 1000);
                };
                if (this.isOpen()) {
                    this._receiver.on(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                    this._receiver.on(rheaPromise.ReceiverEvents.receiverDrained, onReceiveDrain);
                    addCreditAndSetTimer(true);
                }
                else {
                    const msg = `MessageSession "${this.name}" with sessionId "${this.sessionId}", ` +
                        `is already closed. Hence cannot receive messages in a batch.`;
                    error("[%s] %s", this._context.namespace.connectionId, msg);
                    reject(new Error(msg));
                }
            });
        });
    }
    /**
     * Settles the message with the specified disposition.
     * @param message The ServiceBus Message that needs to be settled.
     * @param operation The disposition type.
     * @param options Optional parameters that can be provided while disposing the message.
     */
    settleMessage(message, operation, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (!options)
                    options = {};
                if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {
                    return reject(new Error(`operation: '${operation}' is not a valid operation.`));
                }
                const delivery = message.delivery;
                const timer = setTimeout(() => {
                    this._deliveryDispositionMap.delete(delivery.id);
                    receiver("[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. " +
                        "Hence rejecting the promise with timeout error", this._context.namespace.connectionId, delivery.id, amqpCommon.Constants.defaultOperationTimeoutInSeconds * 1000);
                    const e = {
                        condition: amqpCommon.ErrorNameConditionMapper.ServiceUnavailableError,
                        description: "Operation to settle the message has timed out. The disposition of the " +
                            "message may or may not be successful"
                    };
                    return reject(amqpCommon.translate(e));
                }, amqpCommon.Constants.defaultOperationTimeoutInSeconds * 1000);
                this._deliveryDispositionMap.set(delivery.id, {
                    resolve: resolve,
                    reject: reject,
                    timer: timer
                });
                if (operation === DispositionType.complete) {
                    delivery.accept();
                }
                else if (operation === DispositionType.abandon) {
                    const params = {
                        undeliverable_here: false
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.defer) {
                    const params = {
                        undeliverable_here: true
                    };
                    if (options.propertiesToModify)
                        params.message_annotations = options.propertiesToModify;
                    delivery.modified(params);
                }
                else if (operation === DispositionType.deadletter) {
                    delivery.reject(options.error || {});
                }
            });
        });
    }
    /**
     * Creates a new instance of the MessageSession based on the provided parameters.
     * @param context The client entity context
     * @param options Options that can be provided while creating the MessageSession.
     */
    static create(context, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(context.namespace);
            const messageSession = new MessageSession(context, options);
            yield messageSession._init();
            return messageSession;
        });
    }
}

/**
 * The Receiver class can be used to receive messages in a batch or by registering handlers.
 * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate a Receiver.
 * The Receiver class is an abstraction over the underlying AMQP receiver link.
 * @class Receiver
 */
class Receiver {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     */
    constructor(context, receiveMode) {
        /**
         * @property {boolean} [_isClosed] Denotes if close() was called on this receiver
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(context.namespace);
        this._context = context;
        this._receiveMode =
            receiveMode === exports.ReceiveMode.receiveAndDelete ? receiveMode : exports.ReceiveMode.peekLock;
    }
    _throwIfAlreadyReceiving() {
        if (this.isReceivingMessages()) {
            const errorMessage = getAlreadyReceivingErrorMsg(this._context.entityPath);
            const error$1 = new Error(errorMessage);
            error(`[${this._context.namespace.connectionId}] %O`, error$1);
            throw error$1;
        }
    }
    _throwIfReceiverOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (this.isClosed) {
            const errorMessage = getReceiverClosedErrorMsg(this._context.entityPath, this._context.clientType, this._context.isClosed);
            const error$1 = new Error(errorMessage);
            error(`[${this._context.namespace.connectionId}] %O`, error$1);
            throw error$1;
        }
    }
    /**
     * @property Denotes receiveMode of this receiver.
     * @readonly
     */
    get receiveMode() {
        return this._receiveMode;
    }
    /**
     * @property Returns `true` if the receiver is closed. This can happen either because the receiver
     * itself has been closed or the client that created it has been closed.
     * @readonly
     */
    get isClosed() {
        return this._isClosed || this._context.isClosed;
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the Receiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control if messages should be automatically completed, and/or have
     * their locks automatically renewed. You can control the maximum number of messages that should
     * be concurrently processed. You can also provide a timeout in seconds to denote the
     * amount of time to wait for a new message before closing the receiver.
     *
     * @returns void
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if current receiver is already in state of receiving messages.
     * @throws MessagingError if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
     */
    registerMessageHandler(onMessage, onError, options) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        const connId = this._context.namespace.connectionId;
        throwTypeErrorIfParameterMissing(connId, "onMessage", onMessage);
        throwTypeErrorIfParameterMissing(connId, "onError", onError);
        if (typeof onMessage !== "function") {
            throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
        }
        if (typeof onError !== "function") {
            throw new TypeError("The parameter 'onError' must be of type 'function'.");
        }
        StreamingReceiver.create(this._context, Object.assign(Object.assign({}, options), { receiveMode: this._receiveMode }))
            .then((sReceiver) => tslib.__awaiter(this, void 0, void 0, function* () {
            if (!sReceiver) {
                return;
            }
            if (!this.isClosed) {
                sReceiver.receive(onMessage, onError);
            }
            else {
                yield sReceiver.close();
            }
            return;
        }))
            .catch((err) => {
            onError(err);
        });
    }
    /**
     * Returns a promise that resolves to an array of messages based on given count and timeout over
     * an AMQP receiver link from a Queue/Subscription.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
     * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * - **Default**: `60` seconds.
     * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws Error if current receiver is already in state of receiving messages.
     * @throws MessagingError if the service returns an error while receiving messages.
     */
    receiveMessages(maxMessageCount, maxWaitTimeInSeconds) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            this._throwIfAlreadyReceiving();
            if (!this._context.batchingReceiver || !this._context.batchingReceiver.isOpen()) {
                const options = {
                    maxConcurrentCalls: 0,
                    receiveMode: this._receiveMode
                };
                this._context.batchingReceiver = BatchingReceiver.create(this._context, options);
            }
            return this._context.batchingReceiver.receive(maxMessageCount, maxWaitTimeInSeconds);
        });
    }
    /**
     * Gets an async iterator over messages from the receiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * If the iterator is not able to fetch a new message in over a minute, `undefined` will be returned.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws Error if current receiver is already in state of receiving messages.
     * @throws MessagingError if the service returns an error while receiving messages.
     */
    getMessageIterator() {
        return tslib.__asyncGenerator(this, arguments, function* getMessageIterator_1() {
            while (true) {
                const currentBatch = yield tslib.__await(this.receiveMessages(1));
                yield yield tslib.__await(currentBatch[0]);
            }
        });
    }
    /**
     * Renews the lock on the message for the duration as specified during the Queue/Subscription
     * creation.
     * - Check the `lockedUntilUtc` property on the message for the time when the lock expires.
     * - If a message is not settled (using either `complete()`, `defer()` or `deadletter()`,
     * before its lock expires, then the message lands back in the Queue/Subscription for the next
     * receive operation.
     *
     * @param lockTokenOrMessage - The `lockToken` property of the message or the message itself.
     * @returns Promise<Date> - New lock token expiry date and time in UTC format.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws MessagingError if the service returns an error while renewing message lock.
     */
    renewMessageLock(lockTokenOrMessage) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            if (this._receiveMode !== exports.ReceiveMode.peekLock) {
                throw new Error(getErrorMessageNotSupportedInReceiveAndDeleteMode("renew the message lock"));
            }
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "lockTokenOrMessage", lockTokenOrMessage);
            const lockToken = lockTokenOrMessage instanceof ServiceBusMessage
                ? String(lockTokenOrMessage.lockToken)
                : String(lockTokenOrMessage);
            const lockedUntilUtc = yield this._context.managementClient.renewLock(lockToken);
            return lockedUntilUtc;
        });
    }
    /**
     * Returns a promise that resolves to a deferred message identified by the given `sequenceNumber`.
     * @param sequenceNumber The sequence number of the message that needs to be received.
     * @returns Promise<ServiceBusMessage | undefined>
     * - Returns `Message` identified by sequence number.
     * - Returns `undefined` if no such message is found.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws MessagingError if the service returns an error while receiving deferred message.
     */
    receiveDeferredMessage(sequenceNumber) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
            throwTypeErrorIfParameterNotLong(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
            const messages = yield this._context.managementClient.receiveDeferredMessages([sequenceNumber], this._receiveMode);
            return messages[0];
        });
    }
    /**
     * Returns a promise that resolves to an array of deferred messages identified by given `sequenceNumbers`.
     * @param sequenceNumbers An array of sequence numbers for the messages that need to be received.
     * @returns Promise<ServiceBusMessage[]>
     * - Returns a list of messages identified by the given sequenceNumbers.
     * - Returns an empty list if no messages are found.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws MessagingError if the service returns an error while receiving deferred messages.
     */
    receiveDeferredMessages(sequenceNumbers) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
            if (!Array.isArray(sequenceNumbers)) {
                sequenceNumbers = [sequenceNumbers];
            }
            throwTypeErrorIfParameterNotLongArray(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
            return this._context.managementClient.receiveDeferredMessages(sequenceNumbers, this._receiveMode);
        });
    }
    /**
     * Closes the underlying AMQP receiver link.
     * Once closed, the receiver cannot be used for any further operations.
     * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate
     * a new Receiver
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                this._isClosed = true;
                if (this._context.namespace.connection && this._context.namespace.connection.isOpen()) {
                    // Close the streaming receiver.
                    if (this._context.streamingReceiver) {
                        yield this._context.streamingReceiver.close();
                    }
                    // Close the batching receiver.
                    if (this._context.batchingReceiver) {
                        yield this._context.batchingReceiver.close();
                    }
                    // Make sure that we clear the map of deferred messages
                    this._context.requestResponseLockedMessages.clear();
                }
            }
            catch (err) {
                error("[%s] An error occurred while closing the Receiver for %s: %O", this._context.namespace.connectionId, this._context.entityPath, err);
                throw err;
            }
        });
    }
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
     */
    isReceivingMessages() {
        if (this._context.streamingReceiver && this._context.streamingReceiver.isOpen()) {
            return true;
        }
        if (this._context.batchingReceiver &&
            this._context.batchingReceiver.isOpen() &&
            this._context.batchingReceiver.isReceivingMessages) {
            return true;
        }
        return false;
    }
}
/**
 * The SessionReceiver class can be used to receive messages from a session enabled Queue or
 * Subscription in a batch or by registering handlers.
 * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate a
 * SessionReceiver.
 * The SessionReceiver class is an abstraction over the underlying AMQP receiver link.
 * @class SessionReceiver
 */
class SessionReceiver {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     * @throws Error if an open receiver is already existing for given sessionId.
     */
    constructor(context, receiveMode, sessionOptions) {
        /**
         * @property {boolean} [_isClosed] Denotes if close() was called on this receiver
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(context.namespace);
        this._context = context;
        this._receiveMode =
            receiveMode === exports.ReceiveMode.receiveAndDelete ? receiveMode : exports.ReceiveMode.peekLock;
        this._sessionOptions = sessionOptions;
        if (sessionOptions.sessionId) {
            sessionOptions.sessionId = String(sessionOptions.sessionId);
            // Check if receiver for given session already exists
            if (this._context.messageSessions[sessionOptions.sessionId] &&
                this._context.messageSessions[sessionOptions.sessionId].isOpen()) {
                const errorMessage = getOpenReceiverErrorMsg(this._context.clientType, this._context.entityPath, sessionOptions.sessionId);
                const error$1 = new Error(errorMessage);
                error(`[${this._context.namespace.connectionId}] %O`, error$1);
                throw error$1;
            }
        }
    }
    _throwIfReceiverOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context.namespace);
        if (this.isClosed) {
            const errorMessage = getReceiverClosedErrorMsg(this._context.entityPath, this._context.clientType, this._context.isClosed, this.sessionId);
            const error$1 = new Error(errorMessage);
            error(`[${this._context.namespace.connectionId}] %O`, error$1);
            throw error$1;
        }
    }
    _createMessageSessionIfDoesntExist() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._messageSession) {
                return;
            }
            this._context.isSessionEnabled = true;
            this._messageSession = yield MessageSession.create(this._context, {
                sessionId: this._sessionOptions.sessionId,
                maxSessionAutoRenewLockDurationInSeconds: this._sessionOptions
                    .maxSessionAutoRenewLockDurationInSeconds,
                receiveMode: this._receiveMode
            });
            // By this point, we should have a valid sessionId on the messageSession
            // If not, the receiver cannot be used, so throw error.
            if (this._messageSession.sessionId == null) {
                const error$1 = new Error("Something went wrong. Cannot lock a session.");
                error(`[${this._context.namespace.connectionId}] %O`, error$1);
                throw error$1;
            }
            this._sessionId = this._messageSession.sessionId;
            delete this._context.expiredMessageSessions[this._messageSession.sessionId];
        });
    }
    _throwIfAlreadyReceiving() {
        if (this.isReceivingMessages()) {
            const errorMessage = getAlreadyReceivingErrorMsg(this._context.entityPath, this.sessionId);
            const error$1 = new Error(errorMessage);
            error(`[${this._context.namespace.connectionId}] %O`, error$1);
            throw error$1;
        }
    }
    /**
     * @property Denotes receiveMode of this receiver.
     * @readonly
     */
    get receiveMode() {
        return this._receiveMode;
    }
    /**
     * @property Returns `true` if the receiver is closed. This can happen either because the receiver
     * itself has been closed or the client that created it has been closed.
     * @readonly
     */
    get isClosed() {
        return (this._isClosed || (this.sessionId ? !this._context.messageSessions[this.sessionId] : false));
    }
    /**
     * @property The id of the session from which this receiver will receive messages.
     * Will return undefined until a AMQP receiver link has been successfully set up for the session.
     * @readonly
     */
    get sessionId() {
        return this._sessionId;
    }
    /**
     * @property The time in UTC until which the session is locked.
     * Everytime `renewSessionLock()` is called, this time gets updated to current time plus the lock
     * duration as specified during the Queue/Subscription creation.
     *
     * Will return undefined until a AMQP receiver link has been successfully set up for the session.
     *
     * @readonly
     */
    get sessionLockedUntilUtc() {
        return this._messageSession ? this._messageSession.sessionLockedUntilUtc : undefined;
    }
    /**
     * Renews the lock on the session for the duration as specified during the Queue/Subscription
     * creation.
     * - Check the `sessionLockedUntilUtc` property on the SessionReceiver for the time when the lock expires.
     * - When the lock on the session expires
     *     - No more messages can be received using this receiver
     *     - If a message is not settled (using either `complete()`, `defer()` or `deadletter()`,
     *   before the session lock expires, then the message lands back in the Queue/Subscription for the next
     *   receive operation.
     *
     * @returns Promise<Date> - New lock token expiry date and time in UTC format.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while renewing session lock.
     */
    renewSessionLock() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            yield this._createMessageSessionIfDoesntExist();
            this._messageSession.sessionLockedUntilUtc = yield this._context.managementClient.renewSessionLock(this.sessionId);
            return this._messageSession.sessionLockedUntilUtc;
        });
    }
    /**
     * Sets the state on the Session. For more on session states, see
     * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions#message-session-state Session State}
     * @param state The state that needs to be set.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while setting the session state.
     */
    setState(state) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            yield this._createMessageSessionIfDoesntExist();
            return this._context.managementClient.setSessionState(this.sessionId, state);
        });
    }
    /**
     * Gets the state of the Session. For more on session states, see
     * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions#message-session-state Session State}
     * @returns Promise<any> The state of that session
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while retrieving session state.
     */
    getState() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            yield this._createMessageSessionIfDoesntExist();
            return this._context.managementClient.getSessionState(this.sessionId);
        });
    }
    /**
     * Fetches the next batch of active messages (including deferred but not deadlettered messages) in
     * the current session.
     * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the
     * subsequent message.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param maxMessageCount The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedMessageInfo[]>
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peek(maxMessageCount) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            yield this._createMessageSessionIfDoesntExist();
            return this._context.managementClient.peekMessagesBySession(this.sessionId, maxMessageCount);
        });
    }
    /**
     * Peeks the desired number of active messages (including deferred but not deadlettered messages)
     * from the specified sequence number in the current session.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peekBySequenceNumber(fromSequenceNumber, maxMessageCount) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            yield this._createMessageSessionIfDoesntExist();
            return this._context.managementClient.peekBySequenceNumber(fromSequenceNumber, maxMessageCount, this.sessionId);
        });
    }
    /**
     * Returns a promise that resolves to a deferred message identified by the given `sequenceNumber`.
     * @param sequenceNumber The sequence number of the message that needs to be received.
     * @returns Promise<ServiceBusMessage | undefined>
     * - Returns `Message` identified by sequence number.
     * - Returns `undefined` if no such message is found.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while receiving deferred message.
     */
    receiveDeferredMessage(sequenceNumber) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
            throwTypeErrorIfParameterNotLong(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
            yield this._createMessageSessionIfDoesntExist();
            const messages = yield this._context.managementClient.receiveDeferredMessages([sequenceNumber], this._receiveMode, this.sessionId);
            return messages[0];
        });
    }
    /**
     * Returns a promise that resolves to an array of deferred messages identified by given `sequenceNumbers`.
     * @param sequenceNumbers An array of sequence numbers for the messages that need to be received.
     * @returns Promise<ServiceBusMessage[]>
     * - Returns a list of messages identified by the given sequenceNumbers.
     * - Returns an empty list if no messages are found.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while receiving deferred messages.
     */
    receiveDeferredMessages(sequenceNumbers) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
            if (!Array.isArray(sequenceNumbers)) {
                sequenceNumbers = [sequenceNumbers];
            }
            throwTypeErrorIfParameterNotLongArray(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
            yield this._createMessageSessionIfDoesntExist();
            return this._context.managementClient.receiveDeferredMessages(sequenceNumbers, this._receiveMode, this.sessionId);
        });
    }
    /**
     * Returns a promise that resolves to an array of messages based on given count and timeout over
     * an AMQP receiver link from a Queue/Subscription.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
     * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * - **Default**: `60` seconds.
     * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if the receiver is already in state of receiving messages.
     * @throws MessagingError if the service returns an error while receiving messages.
     */
    receiveMessages(maxMessageCount, maxWaitTimeInSeconds) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            this._throwIfAlreadyReceiving();
            yield this._createMessageSessionIfDoesntExist();
            return this._messageSession.receiveMessages(maxMessageCount, maxWaitTimeInSeconds);
        });
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed
     * or if the lock on the session should be automatically renewed. You can control the
     * maximum number of messages that should be concurrently processed. You can
     * also provide a timeout in seconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     *
     * @returns void
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if the receiver is already in state of receiving messages.
     * @throws MessagingErrormif the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
     */
    registerMessageHandler(onMessage, onError, options) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        const connId = this._context.namespace.connectionId;
        throwTypeErrorIfParameterMissing(connId, "onMessage", onMessage);
        throwTypeErrorIfParameterMissing(connId, "onError", onError);
        if (typeof onMessage !== "function") {
            throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
        }
        if (typeof onError !== "function") {
            throw new TypeError("The parameter 'onError' must be of type 'function'.");
        }
        this._createMessageSessionIfDoesntExist()
            .then(() => tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this._messageSession) {
                return;
            }
            if (!this._isClosed) {
                this._messageSession.receive(onMessage, onError, options);
            }
            else {
                yield this._messageSession.close();
            }
            return;
        }))
            .catch((err) => {
            onError(err);
        });
    }
    /**
     * Gets an async iterator over messages from the receiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * If the iterator is not able to fetch a new message in over a minute, `undefined` will be returned
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if the receiver is already in state of receiving messages.
     * @throws MessagingError if the service returns an error while receiving messages.
     */
    getMessageIterator() {
        return tslib.__asyncGenerator(this, arguments, function* getMessageIterator_2() {
            while (true) {
                const currentBatch = yield tslib.__await(this.receiveMessages(1));
                yield yield tslib.__await(currentBatch[0]);
            }
        });
    }
    /**
     * Closes the underlying AMQP receiver link.
     * Once closed, the receiver cannot be used for any further operations.
     * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate
     * a new Receiver
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._messageSession) {
                    yield this._messageSession.close();
                    this._messageSession = undefined;
                }
            }
            catch (err) {
                error("[%s] An error occurred while closing the SessionReceiver for session %s in %s: %O", this._context.namespace.connectionId, this.sessionId, this._context.entityPath, err);
                throw err;
            }
            finally {
                this._isClosed = true;
            }
        });
    }
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
     */
    isReceivingMessages() {
        return this._messageSession ? this._messageSession.isReceivingMessages : false;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
const correlationProperties = [
    "correlationId",
    "messageId",
    "to",
    "replyTo",
    "label",
    "sessionId",
    "replyToSessionId",
    "contentType",
    "userProperties"
];
/**
 * @internal
 * @class ManagementClient
 * Descibes the ServiceBus Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
class ManagementClient extends LinkEntity {
    /**
     * @constructor
     * Instantiates the management client.
     * @param {ClientEntityContext} context The client entity context.
     * @param {ManagementClientOptions} [options] Options to be provided for creating the
     * "$management" client.
     */
    constructor(context, options) {
        super(`${context.entityPath}/$management`, context, {
            address: options && options.address ? options.address : amqpCommon.Constants.management,
            audience: options && options.audience
                ? options.audience
                : `${context.namespace.config.endpoint}${context.entityPath}/$management`
        });
        this.managementLock = `${amqpCommon.Constants.managementRequestKey}-${rheaPromise.generate_uuid()}`;
        /**
         * @property {string} replyTo The reply to Guid for the management client.
         */
        this.replyTo = rheaPromise.generate_uuid();
        /**
         * @property _lastPeekedSequenceNumber Provides the sequence number of the last peeked message.
         * @private
         */
        this._lastPeekedSequenceNumber = Long.ZERO;
        this._context = context;
        this.entityPath = context.namespace.config.entityPath;
    }
    _init() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            try {
                if (!this._isMgmtRequestResponseLinkOpen()) {
                    yield this._negotiateClaim();
                    const rxopt = {
                        source: { address: this.address },
                        name: this.replyTo,
                        target: { address: this.replyTo },
                        onSessionError: (context) => {
                            const id = context.connection.options.id;
                            const ehError = amqpCommon.translate(context.session.error);
                            error("[%s] An error occurred on the session for request/response links for " +
                                "$management: %O", id, ehError);
                        }
                    };
                    const sropt = { target: { address: this.address } };
                    mgmt("[%s] Creating sender/receiver links on a session for $management endpoint with " +
                        "srOpts: %o, receiverOpts: %O.", this._context.namespace.connectionId, sropt, rxopt);
                    this._mgmtReqResLink = yield amqpCommon.RequestResponseLink.create(this._context.namespace.connection, sropt, rxopt);
                    this._mgmtReqResLink.sender.on(rheaPromise.SenderEvents.senderError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = amqpCommon.translate(context.sender.error);
                        error("[%s] An error occurred on the $management sender link.. %O", id, ehError);
                    });
                    this._mgmtReqResLink.receiver.on(rheaPromise.ReceiverEvents.receiverError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = amqpCommon.translate(context.receiver.error);
                        error("[%s] An error occurred on the $management receiver link.. %O", id, ehError);
                    });
                    mgmt("[%s] Created sender '%s' and receiver '%s' links for $management endpoint.", this._context.namespace.connectionId, this._mgmtReqResLink.sender.name, this._mgmtReqResLink.receiver.name);
                    yield this._ensureTokenRenewal();
                }
            }
            catch (err) {
                err = amqpCommon.translate(err);
                error("[%s] An error occured while establishing the $management links: %O", this._context.namespace.connectionId, err);
                throw err;
            }
        });
    }
    _isMgmtRequestResponseLinkOpen() {
        return this._mgmtReqResLink && this._mgmtReqResLink.isOpen();
    }
    /**
     * Given array of typed values, returns the element in given index
     */
    _safelyGetTypedValueFromArray(data, index) {
        return Array.isArray(data) && data.length > index && data[index]
            ? data[index].value
            : undefined;
    }
    /**
     * Helper function to retrieve active receiver name, if it exists.
     * @param clientEntityContext The `ClientEntityContext` associated with given Service Bus entity client
     * @param sessionId `sessionId` if applicable
     */
    _getAssociatedReceiverName(clientEntityContext, sessionId) {
        if (sessionId != undefined) {
            if (clientEntityContext.messageSessions[sessionId]) {
                return clientEntityContext.messageSessions[sessionId].name;
            }
        }
        if (clientEntityContext.batchingReceiver) {
            return clientEntityContext.batchingReceiver.name;
        }
        if (clientEntityContext.streamingReceiver) {
            return clientEntityContext.streamingReceiver.name;
        }
        return;
    }
    /**
     * Closes the AMQP management session to the ServiceBus namespace for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @return Promise<void>
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._isMgmtRequestResponseLinkOpen()) {
                    const mgmtLink = this._mgmtReqResLink;
                    this._mgmtReqResLink = undefined;
                    clearTimeout(this._tokenRenewalTimer);
                    yield mgmtLink.close();
                    mgmt("Successfully closed the management session.");
                }
            }
            catch (err) {
                error("[%s] An error occurred while closing the management session: %O.", this._context.namespace.connectionId, err);
                throw err;
            }
        });
    }
    /**
     * Fetches the next batch of active messages. The first call to `peek()` fetches the first
     * active message for this client. Each subsequent call fetches the subsequent message in the
     * entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. This method will
     * also fetch even Deferred messages (but not Deadlettered message).
     * @param {number} [messageCount] The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     */
    peek(messageCount) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount);
        });
    }
    /**
     * Fetches the next batch of active messages in the current MessageSession. The first call to
     * `peek()` fetches the first active message for this client. Each subsequent call fetches the
     * subsequent message in the entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`.  This method will
     * also fetch even Deferred messages (but not Deadlettered message).
     * @param {string} sessionId The sessionId from which messages need to be peeked.
     * @param {number} [messageCount] The number of messages to retrieve. Default value `1`.
     * @returns Promise<ReceivedMessageInfo[]>
     */
    peekMessagesBySession(sessionId, messageCount) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, sessionId);
        });
    }
    /**
     * Peeks the desired number of messages from the specified sequence number.
     * @param {Long} fromSequenceNumber The sequence number from where to read the message.
     * @param {number} messageCount The number of messages to retrieve. Default value `1`.
     * @param {string} sessionId The sessionId from which messages need to be peeked.
     * @returns Promise<ReceivedMessageInfo[]>
     */
    peekBySequenceNumber(fromSequenceNumber, maxMessageCount, sessionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            const connId = this._context.namespace.connectionId;
            // Checks for fromSequenceNumber
            throwTypeErrorIfParameterMissing(connId, "fromSequenceNumber", fromSequenceNumber);
            throwTypeErrorIfParameterNotLong(connId, "fromSequenceNumber", fromSequenceNumber);
            // Checks for maxMessageCount
            if (maxMessageCount !== undefined) {
                throwTypeErrorIfParameterTypeMismatch(connId, "maxMessageCount", maxMessageCount, "number");
                if (maxMessageCount <= 0) {
                    return [];
                }
            }
            else {
                maxMessageCount = 1;
            }
            const messageList = [];
            try {
                const messageBody = {};
                messageBody[amqpCommon.Constants.fromSequenceNumber] = rheaPromise.types.wrap_long(buffer.Buffer.from(fromSequenceNumber.toBytesBE()));
                messageBody[amqpCommon.Constants.messageCount] = rheaPromise.types.wrap_int(maxMessageCount);
                if (sessionId != undefined) {
                    messageBody[amqpCommon.Constants.sessionIdMapKey] = sessionId;
                }
                const request = {
                    body: messageBody,
                    message_id: rheaPromise.generate_uuid(),
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.peekMessage
                    }
                };
                const associatedLinkName = this._getAssociatedReceiverName(this._context, sessionId);
                if (associatedLinkName) {
                    request.application_properties[amqpCommon.Constants.associatedLinkName] = associatedLinkName;
                }
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Peek by sequence number request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request);
                if (result.application_properties.statusCode !== 204) {
                    const messages = result.body.messages;
                    for (const msg of messages) {
                        const decodedMessage = rheaPromise.message.decode(msg.message);
                        const message = fromAmqpMessage(decodedMessage);
                        message.body = this._context.namespace.dataTransformer.decode(message.body);
                        messageList.push(message);
                        this._lastPeekedSequenceNumber = message.sequenceNumber;
                    }
                }
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the request to peek messages to " +
                    "$management endpoint: %O", error$1);
                // statusCode == 404 then do not throw
                if (error$1.name !== amqpCommon.ConditionErrorNameMapper["com.microsoft:message-not-found"]) {
                    throw error$1;
                }
            }
            return messageList;
        });
    }
    /**
     * Renews the lock on the message. The lock will be renewed based on the setting specified on
     * the queue.
     *
     * When a message is received in `PeekLock` mode, the message is locked on the server for this
     * receiver instance for a duration as specified during the Queue/Subscription creation
     * (LockDuration). If processing of the message requires longer than this duration, the
     * lock needs to be renewed. For each renewal, it resets the time the message is locked by the
     * LockDuration set on the Entity.
     *
     * @param {string} lockToken Lock token of the message
     * @param {SendRequestOptions} [options] Options that can be set while sending the request.
     * @returns {Promise<Date>} Promise<Date> New lock token expiry date and time in UTC format.
     */
    renewLock(lockToken, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!options)
                options = {};
            if (options.delayInSeconds == null)
                options.delayInSeconds = 1;
            if (options.timeoutInSeconds == null)
                options.timeoutInSeconds = 5;
            if (options.times == null)
                options.times = 5;
            try {
                const messageBody = {};
                messageBody[amqpCommon.Constants.lockTokens] = rheaPromise.types.wrap_array([rheaPromise.string_to_uuid(lockToken)], 0x98, undefined);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.renewLock
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                const associatedLinkName = this._getAssociatedReceiverName(this._context);
                if (associatedLinkName) {
                    request.application_properties[amqpCommon.Constants.associatedLinkName] = associatedLinkName;
                }
                mgmt("[%s] Renew message Lock request: %O.", this._context.namespace.connectionId, request);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request, options);
                const lockedUntilUtc = new Date(result.body.expirations[0]);
                return lockedUntilUtc;
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
    /**
     * Schedules an array of messages to appear on Service Bus at a later time.
     *
     * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
     * @param messages - An array of messages that needs to be scheduled.
     * @returns Promise<number> The sequence numbers of messages that were scheduled.
     */
    scheduleMessages(scheduledEnqueueTimeUtc, messages) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            const messageBody = [];
            for (let i = 0; i < messages.length; i++) {
                const item = messages[i];
                if (!item.messageId)
                    item.messageId = rheaPromise.generate_uuid();
                item.scheduledEnqueueTimeUtc = scheduledEnqueueTimeUtc;
                const amqpMessage = toAmqpMessage(item);
                try {
                    const entry = {
                        message: rheaPromise.message.encode(amqpMessage),
                        "message-id": item.messageId
                    };
                    if (item.sessionId) {
                        entry[amqpCommon.Constants.sessionIdMapKey] = item.sessionId;
                    }
                    if (item.partitionKey) {
                        entry["partition-key"] = item.partitionKey;
                    }
                    if (item.viaPartitionKey) {
                        entry["via-partition-key"] = item.viaPartitionKey;
                    }
                    const wrappedEntry = rheaPromise.types.wrap_map(entry);
                    messageBody.push(wrappedEntry);
                }
                catch (err) {
                    let error$1;
                    if (err instanceof TypeError || err.name === "TypeError") {
                        // `RheaMessageUtil.encode` can fail if message properties are of invalid type
                        // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too
                        // Errors in such cases do not have user friendy message or call stack
                        // So use `getMessagePropertyTypeMismatchError` to get a better error message
                        error$1 = amqpCommon.translate(getMessagePropertyTypeMismatchError(item) || err);
                    }
                    else {
                        error$1 = amqpCommon.translate(err);
                    }
                    error("An error occurred while encoding the item at position %d in the messages array" + ": %O", i, error$1);
                    throw error$1;
                }
            }
            try {
                const request = {
                    body: { messages: messageBody },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.scheduleMessage
                    }
                };
                if (this._context.sender) {
                    request.application_properties[amqpCommon.Constants.associatedLinkName] = this._context.sender.name;
                }
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Schedule messages request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request);
                const sequenceNumbers = result.body[amqpCommon.Constants.sequenceNumbers];
                const sequenceNumbersAsLong = [];
                for (let i = 0; i < sequenceNumbers.length; i++) {
                    if (typeof sequenceNumbers[i] === "number") {
                        sequenceNumbersAsLong.push(Long.fromNumber(sequenceNumbers[i]));
                    }
                    else {
                        sequenceNumbersAsLong.push(Long.fromBytesBE(sequenceNumbers[i]));
                    }
                }
                return sequenceNumbersAsLong;
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the request to schedule messages to " +
                    "$management endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
    /**
     * Cancels an array of messages that were scheduled.
     * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.
     * @returns Promise<void>
     */
    cancelScheduledMessages(sequenceNumbers) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            const messageBody = {};
            messageBody[amqpCommon.Constants.sequenceNumbers] = [];
            for (let i = 0; i < sequenceNumbers.length; i++) {
                const sequenceNumber = sequenceNumbers[i];
                try {
                    messageBody[amqpCommon.Constants.sequenceNumbers].push(buffer.Buffer.from(sequenceNumber.toBytesBE()));
                }
                catch (err) {
                    const error$1 = amqpCommon.translate(err);
                    error("An error occurred while encoding the item at position %d in the " +
                        "sequenceNumbers array: %O", i, error$1);
                    throw error$1;
                }
            }
            try {
                messageBody[amqpCommon.Constants.sequenceNumbers] = rheaPromise.types.wrap_array(messageBody[amqpCommon.Constants.sequenceNumbers], 0x81, undefined);
                const request = {
                    body: messageBody,
                    message_id: rheaPromise.generate_uuid(),
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.cancelScheduledMessage
                    }
                };
                if (this._context.sender) {
                    request.application_properties[amqpCommon.Constants.associatedLinkName] = this._context.sender.name;
                }
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Cancel scheduled messages request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                yield this._mgmtReqResLink.sendRequest(request);
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the request to cancel the scheduled message to " +
                    "$management endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
    /**
     * Receives a list of deferred messages identified by `sequenceNumbers`.
     * @param sequenceNumbers A list containing the sequence numbers to receive.
     * @param receiveMode The mode in which the receiver was created.
     * @returns Promise<ServiceBusMessage[]>
     * - Returns a list of messages identified by the given sequenceNumbers.
     * - Returns an empty list if no messages are found.
     * - Throws an error if the messages have not been deferred.
     */
    receiveDeferredMessages(sequenceNumbers, receiveMode, sessionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            const messageList = [];
            const messageBody = {};
            messageBody[amqpCommon.Constants.sequenceNumbers] = [];
            for (let i = 0; i < sequenceNumbers.length; i++) {
                const sequenceNumber = sequenceNumbers[i];
                try {
                    messageBody[amqpCommon.Constants.sequenceNumbers].push(buffer.Buffer.from(sequenceNumber.toBytesBE()));
                }
                catch (err) {
                    const error$1 = amqpCommon.translate(err);
                    error("An error occurred while encoding the item at position %d in the " +
                        "sequenceNumbers array: %O", i, error$1);
                    throw error$1;
                }
            }
            try {
                messageBody[amqpCommon.Constants.sequenceNumbers] = rheaPromise.types.wrap_array(messageBody[amqpCommon.Constants.sequenceNumbers], 0x81, undefined);
                const receiverSettleMode = receiveMode === exports.ReceiveMode.receiveAndDelete ? 0 : 1;
                messageBody[amqpCommon.Constants.receiverSettleMode] = rheaPromise.types.wrap_uint(receiverSettleMode);
                if (sessionId != null) {
                    messageBody[amqpCommon.Constants.sessionIdMapKey] = sessionId;
                }
                const request = {
                    body: messageBody,
                    message_id: rheaPromise.generate_uuid(),
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.receiveBySequenceNumber
                    }
                };
                const associatedLinkName = this._getAssociatedReceiverName(this._context, sessionId);
                if (associatedLinkName) {
                    request.application_properties[amqpCommon.Constants.associatedLinkName] = associatedLinkName;
                }
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Receive deferred messages request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request);
                const messages = result.body.messages;
                for (const msg of messages) {
                    const decodedMessage = rheaPromise.message.decode(msg.message);
                    const message = new ServiceBusMessage(this._context, decodedMessage, { tag: msg["lock-token"] }, false);
                    if (message.lockToken && message.lockedUntilUtc) {
                        this._context.requestResponseLockedMessages.set(message.lockToken, message.lockedUntilUtc);
                    }
                    messageList.push(message);
                }
                return messageList;
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the request to receive deferred messages to " +
                    "$management endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
    /**
     * Updates the disposition status of deferred messages.
     *
     * @param lockTokens Message lock tokens to update disposition status.
     * @param dispositionStatus The disposition status to be set
     * @param options Optional parameters that can be provided while updating the disposition status.
     *
     * @returns Promise<void>
     */
    updateDispositionStatus(lockToken, dispositionStatus, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!options)
                options = {};
            try {
                const messageBody = {};
                const lockTokenBuffer = [];
                lockTokenBuffer.push(rheaPromise.string_to_uuid(lockToken));
                messageBody[amqpCommon.Constants.lockTokens] = rheaPromise.types.wrap_array(lockTokenBuffer, 0x98, undefined);
                messageBody[amqpCommon.Constants.dispositionStatus] = dispositionStatus;
                if (options.deadLetterDescription != null) {
                    messageBody[amqpCommon.Constants.deadLetterDescription] = options.deadLetterDescription;
                }
                if (options.deadLetterReason != null) {
                    messageBody[amqpCommon.Constants.deadLetterReason] = options.deadLetterReason;
                }
                if (options.propertiesToModify != null) {
                    messageBody[amqpCommon.Constants.propertiesToModify] = options.propertiesToModify;
                }
                if (options.sessionId != null) {
                    messageBody[amqpCommon.Constants.sessionIdMapKey] = options.sessionId;
                }
                const request = {
                    body: messageBody,
                    message_id: rheaPromise.generate_uuid(),
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.updateDisposition
                    }
                };
                const associatedLinkName = this._getAssociatedReceiverName(this._context, options.sessionId);
                if (associatedLinkName) {
                    request.application_properties[amqpCommon.Constants.associatedLinkName] = associatedLinkName;
                }
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Update disposition status request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                yield this._mgmtReqResLink.sendRequest(request);
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the request to update disposition status to " +
                    "$management endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
    /**
     * Renews the lock for the specified session.
     * @param sessionId Id of the session for which the lock needs to be renewed
     * @param options Options that can be set while sending the request.
     * @returns Promise<Date> New lock token expiry date and time in UTC format.
     */
    renewSessionLock(sessionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (!options)
                options = {};
            if (options.delayInSeconds == null)
                options.delayInSeconds = 1;
            if (options.timeoutInSeconds == null)
                options.timeoutInSeconds = 5;
            if (options.times == null)
                options.times = 5;
            try {
                const messageBody = {};
                messageBody[amqpCommon.Constants.sessionIdMapKey] = sessionId;
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.renewSessionLock
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                const associatedLinkName = this._getAssociatedReceiverName(this._context, sessionId);
                if (associatedLinkName) {
                    request.application_properties[amqpCommon.Constants.associatedLinkName] = associatedLinkName;
                }
                mgmt("[%s] Renew Session Lock request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request, options);
                const lockedUntilUtc = new Date(result.body.expiration);
                mgmt("[%s] Lock for session '%s' will expire at %s.", this._context.namespace.connectionId, sessionId, lockedUntilUtc.toString());
                return lockedUntilUtc;
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
    /**
     * Sets the state of the specified session.
     * @param sessionId The session for which the state needs to be set
     * @param state The state that needs to be set.
     * @returns Promise<void>
     */
    setSessionState(sessionId, state) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            try {
                const messageBody = {};
                messageBody[amqpCommon.Constants.sessionIdMapKey] = sessionId;
                messageBody["session-state"] = toBuffer(state);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.setSessionState
                    }
                };
                const associatedLinkName = this._getAssociatedReceiverName(this._context, sessionId);
                if (associatedLinkName) {
                    request.application_properties[amqpCommon.Constants.associatedLinkName] = associatedLinkName;
                }
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Set Session state request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                yield this._mgmtReqResLink.sendRequest(request);
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
    /**
     * Gets the state of the specified session.
     * @param sessionId The session for which the state needs to be retrieved.
     * @returns Promise<any> The state of that session
     */
    getSessionState(sessionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            try {
                const messageBody = {};
                messageBody[amqpCommon.Constants.sessionIdMapKey] = sessionId;
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.getSessionState
                    }
                };
                const associatedLinkName = this._getAssociatedReceiverName(this._context, sessionId);
                if (associatedLinkName) {
                    request.application_properties[amqpCommon.Constants.associatedLinkName] = associatedLinkName;
                }
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Get session state request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const result = yield this._mgmtReqResLink.sendRequest(request);
                return result.body["session-state"]
                    ? this._context.namespace.dataTransformer.decode(result.body["session-state"])
                    : result.body["session-state"];
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
    /**
     * Lists the sessions on the ServiceBus Queue/Topic.
     * @param lastUpdateTime Filter to include only sessions updated after a given time.
     * @param skip The number of sessions to skip
     * @param top Maximum numer of sessions.
     * @returns Promise<string[]> A list of session ids.
     */
    listMessageSessions(skip, top, lastUpdatedTime) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            const defaultLastUpdatedTimeForListingSessions = 259200000; // 3 * 24 * 3600 * 1000
            if (typeof skip !== "number") {
                throw new Error("'skip' is a required parameter and must be of type 'number'.");
            }
            if (typeof top !== "number") {
                throw new Error("'top' is a required parameter and must be of type 'number'.");
            }
            if (lastUpdatedTime && !(lastUpdatedTime instanceof Date)) {
                throw new Error("'lastUpdatedTime' must be of type 'Date'.");
            }
            if (!lastUpdatedTime) {
                lastUpdatedTime = new Date(Date.now() - defaultLastUpdatedTimeForListingSessions);
            }
            try {
                const messageBody = {};
                messageBody["last-updated-time"] = lastUpdatedTime;
                messageBody["skip"] = rheaPromise.types.wrap_int(skip);
                messageBody["top"] = rheaPromise.types.wrap_int(top);
                const request = {
                    body: messageBody,
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.enumerateSessions
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] List sessions request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const response = yield this._mgmtReqResLink.sendRequest(request);
                return (response && response.body && response.body["sessions-ids"]) || [];
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
    /**
     * Get all the rules on the Subscription.
     * @returns Promise<RuleDescription[]> A list of rules.
     */
    getRules() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            try {
                const request = {
                    body: {
                        top: rheaPromise.types.wrap_int(max32BitNumber),
                        skip: rheaPromise.types.wrap_int(0)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.enumerateRules
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Get rules request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                const response = yield this._mgmtReqResLink.sendRequest(request);
                if (response.application_properties.statusCode === 204 ||
                    !response.body ||
                    !Array.isArray(response.body.rules)) {
                    return [];
                }
                // Reference: https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-amqp-request-response#response-11
                const result = response.body.rules || [];
                const rules = [];
                result.forEach((x) => {
                    const ruleDescriptor = x["rule-description"];
                    // We use the first three elements of the `ruleDescriptor.value` to get filter, action, name
                    if (!ruleDescriptor ||
                        !ruleDescriptor.descriptor ||
                        ruleDescriptor.descriptor.value !== amqpCommon.Constants.descriptorCodes.ruleDescriptionList ||
                        !Array.isArray(ruleDescriptor.value) ||
                        ruleDescriptor.value.length < 3) {
                        return;
                    }
                    const filtersRawData = ruleDescriptor.value[0];
                    const actionsRawData = ruleDescriptor.value[1];
                    const rule = {
                        name: ruleDescriptor.value[2].value
                    };
                    switch (filtersRawData.descriptor.value) {
                        case amqpCommon.Constants.descriptorCodes.trueFilterList:
                            rule.filter = "1=1";
                            break;
                        case amqpCommon.Constants.descriptorCodes.falseFilterList:
                            rule.filter = "1=0";
                            break;
                        case amqpCommon.Constants.descriptorCodes.sqlFilterList:
                            rule.filter = this._safelyGetTypedValueFromArray(filtersRawData.value, 0);
                            break;
                        case amqpCommon.Constants.descriptorCodes.correlationFilterList:
                            rule.filter = {
                                correlationId: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),
                                messageId: this._safelyGetTypedValueFromArray(filtersRawData.value, 1),
                                to: this._safelyGetTypedValueFromArray(filtersRawData.value, 2),
                                replyTo: this._safelyGetTypedValueFromArray(filtersRawData.value, 3),
                                label: this._safelyGetTypedValueFromArray(filtersRawData.value, 4),
                                sessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 5),
                                replyToSessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 6),
                                contentType: this._safelyGetTypedValueFromArray(filtersRawData.value, 7),
                                userProperties: this._safelyGetTypedValueFromArray(filtersRawData.value, 8)
                            };
                            break;
                        default:
                            mgmt(`Found unexpected descriptor code for the filter: ${filtersRawData.descriptor.value}`);
                            break;
                    }
                    if (actionsRawData.descriptor.value === amqpCommon.Constants.descriptorCodes.sqlRuleActionList &&
                        Array.isArray(actionsRawData.value) &&
                        actionsRawData.value.length) {
                        rule.action = this._safelyGetTypedValueFromArray(actionsRawData.value, 0);
                    }
                    rules.push(rule);
                });
                return rules;
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the get rules request to $management " + "endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
    /**
     * Removes the rule on the Subscription identified by the given rule name.
     * @param ruleName
     */
    removeRule(ruleName) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "ruleName", ruleName);
            ruleName = String(ruleName);
            throwTypeErrorIfParameterIsEmptyString(this._context.namespace.connectionId, "ruleName", ruleName);
            try {
                const request = {
                    body: {
                        "rule-name": rheaPromise.types.wrap_string(ruleName)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.removeRule
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Remove Rule request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                yield this._mgmtReqResLink.sendRequest(request);
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the remove rule request to $management " + "endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
    /**
     * Adds a rule on the subscription as defined by the given rule name, filter and action
     * @param ruleName Name of the rule
     * @param filter A Boolean, SQL expression or a Correlation filter
     * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression
     */
    addRule(ruleName, filter, sqlRuleActionExpression) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context.namespace);
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "ruleName", ruleName);
            ruleName = String(ruleName);
            throwTypeErrorIfParameterIsEmptyString(this._context.namespace.connectionId, "ruleName", ruleName);
            throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "filter", filter);
            if (typeof filter !== "boolean" &&
                typeof filter !== "string" &&
                !correlationProperties.some((validProperty) => filter.hasOwnProperty(validProperty))) {
                throw new TypeError(`The parameter "filter" should be either a boolean, string or implement the CorrelationFilter interface.`);
            }
            try {
                const ruleDescription = {};
                switch (typeof filter) {
                    case "boolean":
                        ruleDescription["sql-filter"] = {
                            expression: filter ? "1=1" : "1=0"
                        };
                        break;
                    case "string":
                        ruleDescription["sql-filter"] = {
                            expression: filter
                        };
                        break;
                    default:
                        ruleDescription["correlation-filter"] = {
                            "correlation-id": filter.correlationId,
                            "message-id": filter.messageId,
                            to: filter.to,
                            "reply-to": filter.replyTo,
                            label: filter.label,
                            "session-id": filter.sessionId,
                            "reply-to-session-id": filter.replyToSessionId,
                            "content-type": filter.contentType,
                            properties: filter.userProperties
                        };
                        break;
                }
                if (sqlRuleActionExpression !== undefined) {
                    ruleDescription["sql-rule-action"] = {
                        expression: String(sqlRuleActionExpression)
                    };
                }
                const request = {
                    body: {
                        "rule-name": rheaPromise.types.wrap_string(ruleName),
                        "rule-description": rheaPromise.types.wrap_map(ruleDescription)
                    },
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.operations.addRule
                    }
                };
                request.application_properties[amqpCommon.Constants.trackingId] = rheaPromise.generate_uuid();
                mgmt("[%s] Add Rule request body: %O.", this._context.namespace.connectionId, request.body);
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                yield this._mgmtReqResLink.sendRequest(request);
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("An error occurred while sending the Add rule request to $management " + "endpoint: %O", error$1);
                throw error$1;
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes a map that ensures, deleting a an entry from the map is concurrency safe.
 * @internal
 * @class ConcurrentExpiringMap<TKey>
 */
class ConcurrentExpiringMap {
    constructor(options) {
        this._map = new Map();
        this._cleanupScheduled = false;
        this._lockId = rheaPromise.generate_uuid();
        this._lockStore = new amqpCommon.AsyncLock({ maxPending: 1000000 });
        if (!options)
            options = {};
        this._delayBetweenCleanupInSeconds = options.delayBetweenCleanupInSeconds || 30;
    }
    _scheduleCleanup() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._cleanupScheduled || this._map.size === 0) {
                return;
            }
            yield this._lockStore.acquire(this._lockId, () => {
                this._cleanupScheduled = true;
                this._collectExpiredEntries().catch((err) => {
                    error("An error occurred while collecting expired entries: %O", err);
                });
            });
        });
    }
    _collectExpiredEntries() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._map.size === 0) {
                return;
            }
            yield amqpCommon.delay(this._delayBetweenCleanupInSeconds);
            this._cleanupScheduled = false;
            for (const key of this._map.keys()) {
                if (Date.now() > this._map.get(key).getTime()) {
                    this._map.delete(key);
                    map("Deleted the key '%s' from the map.", key);
                }
            }
            this._scheduleCleanup().catch((err) => {
                error("An error occurred while scheduling the cleanup, after " + "collecting expired entries: %O", err);
            });
        });
    }
    /**
     * Sets the key and it's expiration time as the value in the map.
     * @param key The key to be set.
     * @param expiration Expiration time for the key.
     * @returns void
     */
    set(key, expiration) {
        this._map.set(key, expiration);
        this._scheduleCleanup().catch((err) => {
            error("An error occurred while scheduling the cleanup, after " + "setting the key: '%s': %O", key, err);
        });
    }
    /**
     * Determines whether the key is present in the map.
     * @param key The key whose presence in the map needs to be checked.
     * @returns boolean
     */
    has(key) {
        const value = this._map.get(key);
        const result = value && value.getTime() > Date.now();
        map("Key '%s' is present in the map? -> %s", key, result);
        return result;
    }
    /**
     * Removes an entry from the the map if present
     * @param key The key which needs to be removed from the map.
     * @returns True if the key was found and removed from the map, False otherwise
     */
    delete(key) {
        map("Deleting key '%s' from the map", key);
        return this._map.delete(key);
    }
    /**
     * Clears all the entries from the underlying map.
     */
    clear() {
        map("Clearing the map of all the entries");
        this._map.clear();
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * @internal
 * A simple Semaphore
 * @class Semaphore
 */
class Semaphore {
    constructor(limit) {
        this._queue = [];
        this._used = 0;
        if (typeof limit !== "number") {
            throw new TypeError(`Expected limit to be a number, got ${typeof limit}`);
        }
        if (limit < 1) {
            throw new Error("limit cannot be less than 1");
        }
        this.limit = limit;
    }
    /**
     * Acquires a lock from the semaphore, returns a Promise that resolves when the caller holds
     * a lock.
     */
    acquire() {
        if (this._used < this.limit) {
            this._used += 1;
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            this._queue.push(resolve);
        });
    }
    /**
     * Releases a lock back to the semaphore.
     */
    release() {
        if (this._queue.length) {
            const item = this._queue.shift();
            if (item) {
                item();
            }
        }
        else {
            this._used -= 1;
        }
    }
    /**
     * Aquires a lock from the semaphore and then execute the fn. If the fn returns a Promise,
     * wait for that promise to settle and then release the lock back to the semaphore.
     * @param fn The function that needs to be executed in the ciritical region.
     * @returns A Promise that will settle with the return value of fn.
     */
    use(fn) {
        return this.acquire()
            .then(fn)
            .then((val) => {
            this.release();
            return val;
        })
            .catch((err) => {
            this.release();
            throw err;
        });
    }
    /**
     * Provides the number of locks currently held.
     */
    currentLockCount() {
        return this._used;
    }
    /**
     * Provides the number of tasks waiting to acquire a lock.
     */
    awaitedTaskCount() {
        return this._queue.length;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * Enum to denote the entity type calling the session manager
 */
var SessionEntityType;
(function (SessionEntityType) {
    SessionEntityType["queue"] = "Queue";
    SessionEntityType["subscription"] = "Subscription";
})(SessionEntityType || (SessionEntityType = {}));
/**
 * @internal
 */
class SessionManager {
    constructor(context) {
        this._isManagingSessions = false;
        this._isCancelRequested = false;
        this._context = context;
        this.maxConcurrentSessions = 2000;
    }
    /**
     * @property {number} maxConcurrentSessions The maximum number of sessions that the user wants to
     * handle concurrently.
     * - **Default**: `2000`.
     */
    set maxConcurrentSessions(value) {
        if (value <= 0) {
            throw new Error("'maxConcurrentSessions must be greater than 0.");
        }
        this._maxConcurrentSessions = value;
        this.maxConcurrentAcceptSessionRequests = value;
    }
    get maxConcurrenSessions() {
        return this._maxConcurrentSessions;
    }
    /**
     * @property {number} _maxConcurrentAcceptSessionRequests The maximum number of acceptSession
     * requests that can be made concurrently at any given time.
     */
    set maxConcurrentAcceptSessionRequests(value) {
        this._maxConcurrentAcceptSessionRequests = Math.min(value, getProcessorCount());
    }
    get maxConcurrentAcceptSessionRequests() {
        return this._maxConcurrentAcceptSessionRequests;
    }
    /**
     * Accept a new session and start receiving messages.
     * @param onMessage Handler for receiving messages from a session enabled entity.
     * @param onError Handler for receiving errors.
     * @param options Optional parameters for handling sessions.
     */
    _acceptSessionAndReceiveMessages(onMessage, onError, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!options) {
                options = {};
            }
            const connectionId = this._context.namespace.connectionId;
            const noActiveSessionBackOffInSeconds = 10;
            while (!this._isCancelRequested) {
                try {
                    yield this._maxConcurrentSessionsSemaphore.acquire();
                    sessionManager("[%s] Acquired the semaphore for max concurrent sessions: %d, %d.", connectionId, this._maxConcurrentSessionsSemaphore.currentLockCount(), this._maxConcurrentSessionsSemaphore.awaitedTaskCount());
                    yield this._maxPendingAcceptSessionsSemaphore.acquire();
                    sessionManager("[%s] Acquired the semaphore for max pending accept sessions: %d, %d.", connectionId, this._maxPendingAcceptSessionsSemaphore.currentLockCount(), this._maxPendingAcceptSessionsSemaphore.awaitedTaskCount());
                    const closeMessageSession = (messageSession) => tslib.__awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this._maxConcurrentSessionsSemaphore.release();
                            sessionManager("[%s] Releasing the semaphore for max concurrent sessions: %d, %d.", connectionId, this._maxConcurrentSessionsSemaphore.currentLockCount(), this._maxConcurrentSessionsSemaphore.awaitedTaskCount());
                            if (messageSession.isOpen()) {
                                yield messageSession.close();
                            }
                        }
                        catch (err) {
                            error("[%s] An error occurred while releasing the max concurrent session semaphore " +
                                "or while closing MessageSession with id '%s': %O.", connectionId, messageSession.sessionId, err);
                        }
                    });
                    // Create the MessageSession.
                    const messageSession = yield MessageSession.create(this._context, Object.assign({ sessionId: undefined, callee: SessionCallee.sessionManager }, options));
                    messageSession.newMessageWaitTimeoutInSeconds = options.newMessageWaitTimeoutInSeconds;
                    if (this._isCancelRequested) {
                        sessionManager("[%s] Since cancellation was requested, we will close the messageSession with id '%s'.", connectionId, messageSession.sessionId);
                        yield closeMessageSession(messageSession);
                    }
                    const sessionId = messageSession.sessionId;
                    this._context.messageSessions[sessionId] = messageSession;
                    sessionManager("[%s] Created MessageSession with id '%s'.", connectionId, sessionId);
                    const onSessionError = (error) => tslib.__awaiter(this, void 0, void 0, function* () {
                        sessionManager("An error ocurred in MessageSession with id '%s': %O. Hence closing it.", connectionId, sessionId, error);
                        yield closeMessageSession(messageSession);
                        if (error.name !== amqpCommon.ConditionErrorNameMapper["com.microsoft:message-wait-timeout"]) {
                            // notify the user about the error.
                            onError(error);
                        }
                    });
                    messageSession.receive(onMessage, onSessionError, options);
                }
                catch (err) {
                    error("[%s] An error occurred while accepting a MessageSession: %O", connectionId, err);
                    this._maxConcurrentSessionsSemaphore.release();
                    sessionManager("[%s] Releasing the semaphore for max concurrent sessions " +
                        "because an error ocurred: %d, %d.", connectionId, this._maxConcurrentSessionsSemaphore.currentLockCount(), this._maxConcurrentSessionsSemaphore.awaitedTaskCount());
                    // When we ask servicebus to give us a random session and if there are no active sessions,
                    // ServiceBus initially sends the attach frame which causes rhea to emit "receiver_open"
                    // event and thus rhea-promise resolves the promise. Moments later ServiceBus sends a
                    // detach frame with an error that the link creation timed out. Therefore inside
                    // MessageSession._init() after the promise to create a session enabled receiver link
                    // resolves we check for sessionId. If it is undefined then we reject the Promise with an
                    // error "session-cannot-be-locked". The "operation-timeout" error happens when
                    // rhea-promise does not receive a response from ServiceBus in a predefined time frame and
                    // the Promise is rejected. The "microsoft.timeout" error occurs when timeout happens on
                    // the server side and ServiceBus sends a detach frame due to which the Promise is rejected.
                    if (err.name === amqpCommon.ConditionErrorNameMapper["amqp:operation-timeout"] ||
                        err.name === amqpCommon.ConditionErrorNameMapper["com.microsoft:timeout"] ||
                        err.name === amqpCommon.ConditionErrorNameMapper["com.microsoft:session-cannot-be-locked"]) {
                        // No point in delaying if cancel has been requested.
                        if (!this._isCancelRequested) {
                            sessionManager("[%s] Sleeping for %d seconds, since there are no more active MessageSessions on " +
                                "the ServiceBus entity.", connectionId, noActiveSessionBackOffInSeconds);
                            yield amqpCommon.delay(noActiveSessionBackOffInSeconds * 1000);
                        }
                    }
                    else {
                        // notify the user about the error only when it is not one of the above mentioned errors.
                        onError(err);
                    }
                }
                finally {
                    this._maxPendingAcceptSessionsSemaphore.release();
                    sessionManager("[%s] Releasing the semaphore for max pending accept sessions from " +
                        "the finally block: %d, %d.", connectionId, this._maxPendingAcceptSessionsSemaphore.currentLockCount(), this._maxPendingAcceptSessionsSemaphore.awaitedTaskCount());
                }
            }
        });
    }
    /**
     * Manages MessageSessions based on the provided parameters.
     * @param onMessage The message handler to receive service bus messages from a session
     * enabled entity.
     * @param onError The error handler to receive an error that occurs while receiving messages
     * from a session enabled entity.
     * @throws Error if the underlying connection is closed.
     * @throws Error if the session enabled client is already receiving messages.
     * @throws MessagingError if any error occurs while receiving messages from the service.
     */
    manageMessageSessions(entityType, onMessage, onError, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._isManagingSessions) {
                throw new Error(`${entityType}Client for "${this._context.namespace.config.entityPath}" ` +
                    `is already receiving messages from sessions. Please close this ${entityType}Client or ` +
                    `create a new one and receiveMessages from Sessions.`);
            }
            this._isManagingSessions = true;
            this._isCancelRequested = false;
            if (!options)
                options = {};
            if (options.maxConcurrentSessions)
                this.maxConcurrentSessions = options.maxConcurrentSessions;
            // We are explicitly configuring the messageSession to timeout in 60 seconds (if not provided
            // by the user) when no new messages are received.
            if (!options.newMessageWaitTimeoutInSeconds) {
                options.newMessageWaitTimeoutInSeconds = amqpCommon.Constants.defaultOperationTimeoutInSeconds;
            }
            this._maxConcurrentSessionsSemaphore = new Semaphore(this.maxConcurrenSessions);
            this._maxPendingAcceptSessionsSemaphore = new Semaphore(this.maxConcurrentAcceptSessionRequests);
            for (let i = 0; i < this._maxConcurrentAcceptSessionRequests; i++) {
                this._acceptSessionAndReceiveMessages(onMessage, onError, options).catch((err) => {
                    error(err);
                });
            }
        });
    }
    /**
     * Close the session manager.
     */
    close() {
        sessionManager("[%s] Closing the SessionMaanger for entity '%s'.", this._context.namespace.connectionId, this._context.entityPath);
        this._isCancelRequested = true;
        this._isManagingSessions = false;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 */
var ClientEntityContext;
(function (ClientEntityContext) {
    /**
     * @internal
     */
    function create(entityPath, clientType, context, clientId, options) {
        entityCtxt("[%s] Creating client entity context for %s: %O", context.connectionId, clientId);
        if (!options)
            options = {};
        const entityContext = {
            namespace: context,
            entityPath: entityPath,
            clientType: clientType,
            clientId: clientId,
            isClosed: false,
            requestResponseLockedMessages: new ConcurrentExpiringMap(),
            isSessionEnabled: !!options.isSessionEnabled,
            messageSessions: {},
            expiredMessageSessions: {}
        };
        entityContext.sessionManager = new SessionManager(entityContext);
        entityContext.getReceiver = (name, sessionId) => {
            if (sessionId != undefined && entityContext.expiredMessageSessions[sessionId]) {
                const error$1 = new Error(`The session lock has expired on the session with id ${sessionId}.`);
                error$1.name = "SessionLockLostError";
                error("[%s] Failed to find receiver '%s' as the session with id '%s' is expired", entityContext.namespace.connectionId, name, sessionId);
                throw error$1;
            }
            if (sessionId != null &&
                entityContext.messageSessions[sessionId] &&
                entityContext.messageSessions[sessionId].name === name) {
                return entityContext.messageSessions[sessionId];
            }
            if (entityContext.streamingReceiver && entityContext.streamingReceiver.name === name) {
                return entityContext.streamingReceiver;
            }
            if (entityContext.batchingReceiver && entityContext.batchingReceiver.name === name) {
                return entityContext.batchingReceiver;
            }
            let existingReceivers = "";
            if (sessionId != null && entityContext.messageSessions[sessionId]) {
                existingReceivers = entityContext.messageSessions[sessionId].name;
            }
            else {
                if (entityContext.streamingReceiver) {
                    existingReceivers = entityContext.streamingReceiver.name;
                }
                if (entityContext.batchingReceiver) {
                    existingReceivers +=
                        (existingReceivers ? ", " : "") + entityContext.batchingReceiver.name;
                }
            }
            error("[%s] Failed to find receiver '%s' among existing receivers: %s", entityContext.namespace.connectionId, name, existingReceivers);
            return;
        };
        entityContext.onDetached = (error$1) => tslib.__awaiter(this, void 0, void 0, function* () {
            const connectionId = entityContext.namespace.connectionId;
            // Call onDetached() on sender so that it can decide whether to reconnect or not
            const sender = entityContext.sender;
            if (sender && !sender.isConnecting) {
                try {
                    error("[%s] calling detached on sender '%s'.", connectionId, sender.name);
                    yield sender.onDetached();
                }
                catch (err) {
                    error("[%s] An error occurred while calling onDetached() the sender '%s': %O.", connectionId, sender.name, err);
                }
            }
            // Call onDetached() on batchingReceiver so that it can gracefully close any ongoing batch operation.
            const batchingReceiver = entityContext.batchingReceiver;
            if (batchingReceiver && !batchingReceiver.isConnecting) {
                try {
                    error("[%s] calling detached on batching receiver '%s'.", connectionId, batchingReceiver.name);
                    yield batchingReceiver.onDetached(error$1);
                }
                catch (err) {
                    error("[%s] An error occurred while calling onDetached() on the batching receiver '%s': %O.", connectionId, batchingReceiver.name, err);
                }
            }
            // Call onDetached() on streamingReceiver so that it can decide whether to reconnect or not
            const streamingReceiver = entityContext.streamingReceiver;
            if (streamingReceiver && !streamingReceiver.isConnecting) {
                try {
                    error("[%s] calling detached on streaming receiver '%s'.", connectionId, streamingReceiver.name);
                    yield streamingReceiver.onDetached(error$1);
                }
                catch (err) {
                    error("[%s] An error occurred while calling onDetached() on the streaming receiver '%s': %O.", connectionId, streamingReceiver.name, err);
                }
            }
        });
        const isManagementClientSharedWithOtherClients = () => {
            for (const id of Object.keys(context.clientContexts)) {
                if (context.clientContexts[id].entityPath === entityContext.entityPath &&
                    context.clientContexts[id].clientId !== entityContext.clientId) {
                    return true;
                }
            }
            return false;
        };
        entityContext.close = () => tslib.__awaiter(this, void 0, void 0, function* () {
            if (!context.connection || !context.connection.isOpen()) {
                return;
            }
            entityCtxt("[%s] Closing client entity context for %s: %O", context.connectionId, clientId);
            // Close sender
            if (entityContext.sender) {
                yield entityContext.sender.close();
            }
            // Close batching receiver
            if (entityContext.batchingReceiver) {
                yield entityContext.batchingReceiver.close();
            }
            // Close streaming receiver
            if (entityContext.streamingReceiver) {
                yield entityContext.streamingReceiver.close();
            }
            // Close all the MessageSessions.
            for (const messageSessionId of Object.keys(entityContext.messageSessions)) {
                yield entityContext.messageSessions[messageSessionId].close();
            }
            // Close the sessionManager.
            if (entityContext.sessionManager) {
                entityContext.sessionManager.close();
            }
            // Make sure that we clear the map of deferred messages
            entityContext.requestResponseLockedMessages.clear();
            // Delete the reference in ConnectionContext
            delete context.clientContexts[clientId];
            // Close the managementClient unless it is shared with other clients
            if (entityContext.managementClient && !isManagementClientSharedWithOtherClients()) {
                yield entityContext.managementClient.close();
                entityContext.managementClient = undefined;
            }
            entityContext.isClosed = true;
            entityCtxt("[%s] Closed client entity context for %s: %O", context.connectionId, clientId);
        });
        let managementClient = getManagementClient(context.clientContexts, entityPath);
        if (!managementClient) {
            const mOptions = {
                address: options.managementClientAddress || `${entityPath}/$management`,
                audience: options.managementClientAudience
            };
            managementClient = new ManagementClient(entityContext, mOptions);
        }
        entityContext.managementClient = managementClient;
        const clientEntityContext = entityContext;
        context.clientContexts[entityContext.clientId] = clientEntityContext;
        entityCtxt("[%s] Created client entity context for %s: %O", context.connectionId, clientId);
        return clientEntityContext;
    }
    ClientEntityContext.create = create;
})(ClientEntityContext || (ClientEntityContext = {}));
// Multiple clients for the same Service Bus entity should be using the same management client.
function getManagementClient(clients, entityPath) {
    let result;
    for (const id of Object.keys(clients)) {
        if (clients[id].entityPath === entityPath) {
            result = clients[id].managementClient;
            break;
        }
    }
    return result;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the client that allows interacting with a Service Bus Queue.
 * Use the `createQueueClient` function on the ServiceBusClient object to instantiate a QueueClient
 * @class QueueClient
 */
class QueueClient {
    /**
     * Constructor for QueueClient.
     * This is not meant for the user to call directly.
     * The user should use the `createQueueClient` on the ServiceBusClient instead.
     *
     * @constructor
     * @internal
     * @param queueName The Queue name.
     * @param context The connection context to create the QueueClient.
     * @throws Error if the underlying connection is closed.
     */
    constructor(queueName, context) {
        throwErrorIfConnectionClosed(context);
        this.entityPath = String(queueName);
        this.id = `${this.entityPath}/${rheaPromise.generate_uuid()}`;
        this._context = ClientEntityContext.create(this.entityPath, ClientType.QueueClient, context, this.id);
    }
    /**
     * Closes all the AMQP links for sender/receivers created by this client.
     * Once closed, neither the QueueClient nor its sender/receivers can be used for any
     * further operations.
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                // Close the corresponding client context which will take care of closing all AMQP links
                // associated with this client
                yield this._context.close();
            }
            catch (err) {
                error("[%s] An error occurred while closing the QueueClient for %s: %O", this._context.namespace.connectionId, this.id, err);
                throw err;
            }
        });
    }
    /**
     * Creates a Sender to be used for sending messages, scheduling messages to be sent at a later time
     * and cancelling such scheduled messages.
     * @throws Error if the QueueClient or the underlying connection is closed.
     * @throws Error if an open sender already exists on the QueueClient.
     */
    createSender() {
        throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
        if (!this._currentSender || this._currentSender.isClosed) {
            this._currentSender = new Sender(this._context);
            return this._currentSender;
        }
        const errorMessage = getOpenSenderErrorMsg("QueueClient", this.entityPath);
        const error$1 = new Error(errorMessage);
        error(`[${this._context.namespace.connectionId}] %O`, error$1);
        throw error$1;
    }
    createReceiver(receiveMode, sessionOptions) {
        throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
        // Receiver for Queue where sessions are not enabled
        if (!sessionOptions) {
            if (!this._currentReceiver || this._currentReceiver.isClosed) {
                this._currentReceiver = new Receiver(this._context, receiveMode);
                return this._currentReceiver;
            }
            const errorMessage = getOpenReceiverErrorMsg(ClientType.QueueClient, this.entityPath);
            const error$1 = new Error(errorMessage);
            error(`[${this._context.namespace.connectionId}] %O`, error$1);
            throw error$1;
        }
        return new SessionReceiver(this._context, receiveMode, sessionOptions);
    }
    /**
     * Fetches the next batch of active messages (including deferred but not deadlettered messages).
     * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the
     * subsequent message.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedMessageInfo[]>
     * @throws Error if the QueueClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peek(maxMessageCount) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.peek(maxMessageCount);
        });
    }
    /**
     * Peeks the desired number of active messages (including deferred but not deadlettered messages)
     * from the specified sequence number.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedMessageInfo[]>
     * @throws Error if the QueueClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peekBySequenceNumber(fromSequenceNumber, maxMessageCount) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.peekBySequenceNumber(fromSequenceNumber, maxMessageCount);
        });
    }
    // /**
    //  * Lists the ids of the sessions on the ServiceBus Queue.
    //  * @param maxNumberOfSessions Maximum number of sessions.
    //  * @param lastUpdateTime Filter to include only sessions updated after a given time. Default
    //  * value is 3 days before the current time.
    //  */
    // async listMessageSessions(
    //   maxNumberOfSessions: number,
    //   lastUpdatedTime?: Date
    // ): Promise<string[]> {
    // TODO: Parameter validation if required
    // this.throwErrorIfClientOrConnectionClosed();
    //   return this._context.managementClient!.listMessageSessions(
    //     0,
    //     maxNumberOfSessions,
    //     lastUpdatedTime
    //   );
    // }
    /**
     * Returns the corresponding dead letter queue name for the queue represented by the given name.
     * Use this in the `createQueueClient` function on the `ServiceBusClient` instance to receive
     * messages from a dead letter queue.
     * @param queueName Name of the queue whose dead letter counterpart's name is being fetched
     */
    static getDeadLetterQueuePath(queueName) {
        return `${queueName}/$DeadLetterQueue`;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the client that allows interacting with a Service Bus Topic.
 * Use the `createTopicClient` function on the ServiceBusClient object to instantiate a TopicClient
 * @class TopicClient
 */
class TopicClient {
    /**
     * Constructor for TopicClient.
     * This is not meant for the user to call directly.
     * The user should use the `createTopicClient` on the Namespace instead.
     *
     * @constructor
     * @internal
     * @param topicName - The topic name.
     * @param context - The connection context to create the TopicClient.
     * @throws Error if the TopicClient or the underlying connection is closed.
     */
    constructor(topicName, context) {
        throwErrorIfConnectionClosed(context);
        this.entityPath = String(topicName);
        this.id = `${this.entityPath}/${rheaPromise.generate_uuid()}`;
        this._context = ClientEntityContext.create(this.entityPath, ClientType.TopicClient, context, this.id);
    }
    /**
     * Closes the AMQP link for the sender created by this client.
     * Once closed, neither the TopicClient nor its senders can be used for any
     * further operations.
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                // Close the corresponding client context which will take care of closing all AMQP links
                // associated with this client
                yield this._context.close();
            }
            catch (err) {
                error("[%s] An error occurred while closing the TopicClient for %s: %O", this._context.namespace.connectionId, this.id, err);
                throw err;
            }
        });
    }
    /**
     * Creates a Sender to be used for sending messages, scheduling messages to be sent at a later time
     * and cancelling such scheduled messages.
     *
     * If the Topic has session enabled Subscriptions, then messages sent without the `sessionId`
     * property will go to the dead letter queue of such subscriptions.
     * @throws Error if the TopicClient or the underlying connection is closed.
     * @throws Error if an open sender already exists on the TopicClient.
     */
    createSender() {
        throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
        if (!this._currentSender || this._currentSender.isClosed) {
            this._currentSender = new Sender(this._context);
            return this._currentSender;
        }
        const errorMessage = getOpenSenderErrorMsg("TopicClient", this.entityPath);
        const error$1 = new Error(errorMessage);
        error(`[${this._context.namespace.connectionId}] %O`, error$1);
        throw error$1;
    }
    /**
     * Returns the corresponding dead letter topic name for the given topic and subscription names.
     * Use this in the `createSubscriptionClient` function of the `ServiceBusClient` instance to
     * receive messages from dead letter queue for given subscription.
     * @param topicName Name of the topic whose dead letter counterpart's name is being fetched
     * @param subscriptionName Name of the subscription whose dead letter counterpart's name is being fetched
     */
    static getDeadLetterTopicPath(topicName, subscriptionName) {
        return `${topicName}/Subscriptions/${subscriptionName}/$DeadLetterQueue`;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the client that allows interacting with a Service Bus Subscription.
 * Use the `createSubscriptionClient` function on the ServiceBusClient object to instantiate a
 * SubscriptionClient
 * @class SubscriptionClient
 */
class SubscriptionClient {
    /**
     * Constructor for SubscriptionClient.
     * This is not meant for the user to call directly.
     * The user should use the `createSubscriptionClient` on the Namespace instead.
     *
     * @constructor
     * @internal
     * @param topicName - The Topic name.
     * @param subscriptionName - The Subscription name.
     * @param context - The connection context to create the SubscriptionClient.
     * @throws Error if the underlying connection is closed.
     */
    constructor(topicName, subscriptionName, context) {
        /**
         * @readonly
         * @property The name of the default rule on the subscription.
         */
        this.defaultRuleName = "$Default";
        throwErrorIfConnectionClosed(context);
        this.topicName = String(topicName);
        this.subscriptionName = String(subscriptionName);
        this.entityPath = `${topicName}/Subscriptions/${subscriptionName}`;
        this.id = `${this.entityPath}/${rheaPromise.generate_uuid()}`;
        this._context = ClientEntityContext.create(this.entityPath, ClientType.SubscriptionClient, context, this.id);
    }
    /**
     * Closes the AMQP link for the receivers created by this client.
     * Once closed, neither the SubscriptionClient nor its receivers can be used for any
     * further operations.
     *
     * @returns {Promise<void>}
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                // Close the corresponding client context which will take care of closing all AMQP links
                // associated with this client
                yield this._context.close();
            }
            catch (err) {
                error("[%s] An error occurred while closing the SubscriptionClient for %s: %O", this._context.namespace.connectionId, this.id, err);
                throw err;
            }
        });
    }
    createReceiver(receiveMode, sessionOptions) {
        throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
        // Receiver for Subscription where sessions are not enabled
        if (!sessionOptions) {
            if (!this._currentReceiver || this._currentReceiver.isClosed) {
                this._currentReceiver = new Receiver(this._context, receiveMode);
                return this._currentReceiver;
            }
            const errorMessage = getOpenReceiverErrorMsg(ClientType.SubscriptionClient, this.entityPath);
            const error$1 = new Error(errorMessage);
            error(`[${this._context.namespace.connectionId}] %O`, error$1);
            throw error$1;
        }
        return new SessionReceiver(this._context, receiveMode, sessionOptions);
    }
    /**
     * Fetches the next batch of active messages (including deferred but not deadlettered messages).
     * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the
     * subsequent message.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peek(maxMessageCount) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.peek(maxMessageCount);
        });
    }
    /**
     * Peeks the desired number of active messages (including deferred but not deadlettered messages)
     * from the specified sequence number.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peekBySequenceNumber(fromSequenceNumber, maxMessageCount) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.peekBySequenceNumber(fromSequenceNumber, maxMessageCount);
        });
    }
    // #region topic-filters
    /**
     * Gets all rules associated with the subscription
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while retrieving rules.
     */
    getRules() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.getRules();
        });
    }
    /**
     * Removes the rule on the subscription identified by the given rule name.
     *
     * **Caution**: If all rules on a subscription are removed, then the subscription will not receive
     * any more messages.
     * @param ruleName
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while removing rules.
     */
    removeRule(ruleName) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.removeRule(ruleName);
        });
    }
    /**
     * Adds a rule on the subscription as defined by the given rule name, filter and action.
     *
     * **Note**: Remove the default true filter on the subscription before adding a rule.
     * Otherwise, the added rule will have no affect as the true filter will always result in
     * the subscription receiving all messages.
     * @param ruleName Name of the rule
     * @param filter A Boolean, SQL expression or a Correlation filter. For SQL Filter syntax, see
     * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-filter SQLFilter syntax}.
     * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression. For SQL Rule Action syntax,
     * see {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-rule-action SQLRuleAction syntax}.
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while adding rules.
     */
    addRule(ruleName, filter, sqlRuleActionExpression) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            return this._context.managementClient.addRule(ruleName, filter, sqlRuleActionExpression);
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the client that allows interacting with a Service Bus instance.
 * Holds the AMQP connection to the Service Bus Namespace and is the entry point for using Queues,
 * Topics and Subscriptions.
 */
class ServiceBusClient {
    /**
     * Instantiates a ServiceBusClient to interact with a Service Bus Namespace.
     *
     * @constructor
     * @param {ConnectionConfig} config - The connection configuration needed to connect to the
     * Service Bus Namespace.
     * @param {TokenProvider} [tokenProvider] - The token provider that provides the token for
     * authentication.
     * @param {ServiceBusClientOptions} - Options to control ways to interact with the Service Bus
     * Namespace.
     */
    constructor(config, tokenProvider, options) {
        if (!options)
            options = {};
        this.name = config.endpoint;
        this._context = ConnectionContext.create(config, tokenProvider, options);
    }
    /**
     * Creates a QueueClient for an existing Service Bus Queue.
     * @param {string} queueName The queue name.
     * @returns QueueClient.
     * @throws Error if the underlying connection is closed.
     */
    createQueueClient(queueName) {
        const client = new QueueClient(queueName, this._context);
        ns("Created the QueueClient for Queue: %s", queueName);
        return client;
    }
    /**
     * Creates a TopicClient for an existing Service Bus Topic.
     * @param {string} topicName The topic name.
     * @returns TopicClient.
     * @throws
     * @throws Error if the underlying connection is closed.
     */
    createTopicClient(topicName) {
        const client = new TopicClient(topicName, this._context);
        ns("Created the TopicClient for Topic: %s", topicName);
        return client;
    }
    /**
     * Creates a SubscriptionClient for an existing Service Bus Subscription.
     * @param {string} topicName The topic name.
     * @param {string} subscriptionName The subscription name.
     * @returns SubscriptionClient.
     * @throws Error if the underlying connection is closed.
     */
    createSubscriptionClient(topicName, subscriptionName) {
        const client = new SubscriptionClient(topicName, subscriptionName, this._context);
        ns("Created the SubscriptionClient for Topic: %s and Subscription: %s", topicName, subscriptionName);
        return client;
    }
    /**
     * Closes the AMQP connection created by this ServiceBusClient along with AMQP links for
     * sender/receivers created by the queue/topic/subscription clients created by this
     * ServiceBusClient.
     * Once closed,
     * - the clients created by this ServiceBusClient cannot be used to send/receive messages anymore.
     * - this ServiceBusClient cannot be used to create any new queues/topics/subscriptions clients.
     * @returns {Promise<any>}
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.connection.isOpen()) {
                    ns("Closing the amqp connection '%s' on the client.", this._context.connectionId);
                    // Close all the clients.
                    for (const id of Object.keys(this._context.clientContexts)) {
                        const clientContext = this._context.clientContexts[id];
                        yield clientContext.close();
                    }
                    yield this._context.cbsSession.close();
                    yield this._context.connection.close();
                    this._context.wasConnectionCloseCalled = true;
                    ns("Closed the amqp connection '%s' on the client.", this._context.connectionId);
                }
            }
            catch (err) {
                const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));
                error(`An error occurred while closing the connection "${this._context.connectionId}":\n${errObj}`);
                throw errObj;
            }
        });
    }
    /**
     * Creates a ServiceBusClient for the Service Bus Namespace represented in the given connection
     * string.
     * @param {string} connectionString - Connection string of the form
     * 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {ServiceBusClientOptions} [options] Options to control ways to interact with the
     * Service Bus Namespace.
     * @returns {ServiceBusClient}
     */
    static createFromConnectionString(connectionString, options) {
        const config = amqpCommon.ConnectionConfig.create(connectionString);
        config.webSocket = options && options.webSocket;
        config.webSocketEndpointPath = "$servicebus/websocket";
        config.webSocketConstructorOptions = options && options.webSocketConstructorOptions;
        amqpCommon.ConnectionConfig.validate(config);
        const tokenProvider = new amqpCommon.SasTokenProvider(config.endpoint, config.sharedAccessKeyName, config.sharedAccessKey);
        return new ServiceBusClient(config, tokenProvider, options);
    }
    /**
     * Creates a ServiceBusClient for the Service Bus Namespace represented by the given host using
     * the given TokenProvider.
     * @param {string} host - Fully qualified domain name for Servicebus. Most likely,
     * `<yournamespace>.servicebus.windows.net`.
     * @param {TokenProvider} tokenProvider - Your custom implementation of the {@link https://github.com/Azure/amqp-common-js/blob/master/lib/auth/token.ts Token Provider}
     * interface.
     * @param {ServiceBusClientOptions} options - Options to control ways to interact with the
     * Service Bus Namespace.
     * @returns {ServiceBusClient}
     */
    static createFromTokenProvider(host, tokenProvider, options) {
        host = String(host);
        if (!tokenProvider) {
            throw new TypeError('Missing parameter "tokenProvider"');
        }
        if (!host.endsWith("/"))
            host += "/";
        const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;` +
            `SharedAccessKey=defaultKeyValue`;
        const config = amqpCommon.ConnectionConfig.create(connectionString);
        config.webSocket = options && options.webSocket;
        config.webSocketEndpointPath = "$servicebus/websocket";
        config.webSocketConstructorOptions = options && options.webSocketConstructorOptions;
        amqpCommon.ConnectionConfig.validate(config);
        return new ServiceBusClient(config, tokenProvider, options);
    }
    /**
     * Creates a ServiceBusClient for the Service Bus Namespace represented by the given host using
     * the TokenCredentials generated using the `@azure/ms-rest-nodeauth` library.
     * @param {string} host - Fully qualified domain name for ServiceBus.
     * Most likely, {yournamespace}.servicebus.windows.net
     * @param {ServiceClientCredentials} credentials - The Token credentials generated by using the
     * `@azure/ms-rest-nodeauth` library. It can be one of the following:
     *  - ApplicationTokenCredentials
     *  - UserTokenCredentials
     *  - DeviceTokenCredentials
     *  - MSITokenCredentials
     * Token audience (or resource in case of MSI based credentials) to use when creating the credentials is https://servicebus.azure.net/
     * @param {ServiceBusClientOptions} options - Options to control ways to interact with the
     * Service Bus Namespace.
     * @returns {ServiceBusClient}
     * @throws Error if `createFromAadTokenCredentials` is accessed in browser context, as AAD support is not present in browser.
     */
    static createFromAadTokenCredentials(host, credentials, options) {
        host = String(host);
        const tokenProvider = new amqpCommon.AadTokenProvider(credentials);
        return ServiceBusClient.createFromTokenProvider(host, tokenProvider, options);
    }
}

Object.defineProperty(exports, 'DefaultDataTransformer', {
    enumerable: true,
    get: function () {
        return amqpCommon.DefaultDataTransformer;
    }
});
Object.defineProperty(exports, 'MessagingError', {
    enumerable: true,
    get: function () {
        return amqpCommon.MessagingError;
    }
});
Object.defineProperty(exports, 'TokenType', {
    enumerable: true,
    get: function () {
        return amqpCommon.TokenType;
    }
});
Object.defineProperty(exports, 'delay', {
    enumerable: true,
    get: function () {
        return amqpCommon.delay;
    }
});
exports.QueueClient = QueueClient;
exports.Receiver = Receiver;
exports.Sender = Sender;
exports.ServiceBusClient = ServiceBusClient;
exports.ServiceBusMessage = ServiceBusMessage;
exports.SessionReceiver = SessionReceiver;
exports.SubscriptionClient = SubscriptionClient;
exports.TopicClient = TopicClient;
//# sourceMappingURL=index.js.map
