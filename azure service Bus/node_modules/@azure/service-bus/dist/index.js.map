{"version":3,"file":"index.js","sources":["../src/log.ts","../src/util/constants.ts","../src/connectionContext.ts","../src/client.ts","../src/util/utils.ts","../src/util/errors.ts","../src/serviceBusMessage.ts","../src/core/linkEntity.ts","../src/core/messageSender.ts","../src/sender.ts","../src/core/messageReceiver.ts","../src/core/streamingReceiver.ts","../src/core/batchingReceiver.ts","../src/session/messageSession.ts","../src/receiver.ts","../src/core/managementClient.ts","../src/util/concurrentExpiringMap.ts","../src/util/semaphore.ts","../src/session/sessionManager.ts","../src/clientEntityContext.ts","../src/queueClient.ts","../src/topicClient.ts","../src/subscriptionClient.ts","../src/serviceBusClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport debugModule from \"debug\";\n/**\n * @internal\n * log statements for linkEntity\n */\nexport const link = debugModule(\"azure:service-bus:linkEntity\");\n/**\n * @internal\n * log statements for error\n */\nexport const error = debugModule(\"azure:service-bus:error\");\n/**\n * @internal\n * log statements for warning\n */\nexport const warning = debugModule(\"azure:service-bus:warning\");\n/**\n * @internal\n * log statements for management\n */\nexport const mgmt = debugModule(\"azure:service-bus:management\");\n/**\n * @internal\n * log statements for sender\n */\nexport const sender = debugModule(\"azure:service-bus:sender\");\n/**\n * @internal\n * log statements for receiver\n */\nexport const receiver = debugModule(\"azure:service-bus:receiver\");\n/**\n * @internal\n * log statements for receiverbatching\n */\nexport const batching = debugModule(\"azure:service-bus:receiverbatching\");\n/**\n * @internal\n * log statements for receiverstreaming\n */\nexport const streaming = debugModule(\"azure:service-bus:receiverstreaming\");\n/**\n * @internal\n * log statements for connectionContext\n */\nexport const connectionCtxt = debugModule(\"azure:service-bus:connectionContext\");\n/**\n * @internal\n * log statements for clientEntityContext\n */\nexport const entityCtxt = debugModule(\"azure:service-bus:clientEntityContext\");\n/**\n * @internal\n * log statements for namespace\n */\nexport const ns = debugModule(\"azure:service-bus:namespace\");\n/**\n * @internal\n * log statements for servicebusMessage\n */\nexport const message = debugModule(\"azure:service-bus:servicebusMessage\");\n/**\n * @internal\n * log statements for map\n */\nexport const map = debugModule(\"azure:service-bus:concurrentMap\");\n/**\n * @internal\n * log statements for utils\n */\nexport const utils = debugModule(\"azure:service-bus:utils\");\n/**\n * @internal\n * log statements for messageSession\n */\nexport const messageSession = debugModule(\"azure:service-bus:messageSession\");\n/**\n * @internal\n * log statements for semaphore\n */\nexport const semaphore = debugModule(\"azure:service-bus:semaphore\");\n/**\n * @internal\n * log statements for sessionManager\n */\nexport const sessionManager = debugModule(\"azure:service-bus:sessionManager\");\n/**\n * @internal\n * log statements for Atom XML management API over HTTP\n */\nexport const httpAtomXml = debugModule(\"azure:service-bus:atom-xml\");\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nexport const packageJsonInfo = {\n  name: \"@azure/service-bus\",\n  version: \"1.1.4\"\n};\n\nexport const messageDispositionTimeout = 20000;\n\nexport const max32BitNumber = Math.pow(2, 31) - 1;\n\n/**\n * Queue name identifier\n */\nexport const QUEUE_NAME = \"QueueName\";\n\n/**\n * Topic name identifier\n */\nexport const TOPIC_NAME = \"TopicName\";\n\n/**\n * Subscription name identifier\n */\nexport const SUBSCRIPTION_NAME = \"SubscriptionName\";\n\n/**\n * Rule name identifier\n */\nexport const RULE_NAME = \"RuleName\";\n\n/**\n * Accessed at field\n */\nexport const ACCESSED_AT = \"AccessedAt\";\n\n/**\n * Updated at field\n */\nexport const UPDATED_AT = \"UpdatedAt\";\n\n/**\n * Created at field\n */\nexport const CREATED_AT = \"CreatedAt\";\n\n/**\n * Authorization rules on the entity\n */\nexport const AUTHORIZATION_RULES = \"AuthorizationRules\";\n\n/**\n * Is Anonymous Accessible field\n */\nexport const IS_ANONYMOUS_ACCESSIBLE = \"IsAnonymousAccessible\";\n\n/**\n * Entity Availability Status field\n */\nexport const ENTITY_AVAILABILITY_STATUS = \"EntityAvailabilityStatus\";\n\n/**\n * Enable express option\n */\nexport const ENABLE_EXPRESS = \"EnableExpress\";\n\n/**\n * Is express option\n */\nexport const IS_EXPRESS = \"IsExpress\";\n\n/**\n * Enable Subscription Partitioning option\n */\nexport const ENABLE_SUBSCRIPTION_PARTITIONING = \"EnableSubscriptionPartitioning\";\n\n/**\n * Filtering Messages Before Publishing option\n */\nexport const FILTER_MESSAGES_BEFORE_PUBLISHING = \"FilteringMessagesBeforePublishing\";\n\n/**\n * Indicates the default rule description.\n *\n */\nexport const DEFAULT_RULE_DESCRIPTION = \"DefaultRuleDescription\";\n\n/**\n * The entity's size in bytes.\n *\n */\nexport const SIZE_IN_BYTES = \"SizeInBytes\";\n\n/**\n * The entity's message count.\n *\n */\nexport const MESSAGE_COUNT = \"MessageCount\";\n\n/**\n * The topic's subscription count.\n *\n */\nexport const SUBSCRIPTION_COUNT = \"SubscriptionCount\";\n\n/**\n * The topic / subscription's count details.\n *\n */\nexport const COUNT_DETAILS = \"CountDetails\";\n\n/**\n * The default rule name.\n *\n */\nexport const DEFAULT_RULE_NAME = \"$Default\";\n\n/**\n * Max idle time before entity is deleted.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n */\nexport const AUTO_DELETE_ON_IDLE = \"AutoDeleteOnIdle\";\n\n/**\n * The status information on response\n *\n */\nexport const STATUS = \"Status\";\n\n/**\n * The URL of Service Bus entity to forward messages to.\n *\n */\nexport const FORWARD_TO = \"ForwardTo\";\n\n/**\n * The user meta data information\n *\n */\nexport const USER_METADATA = \"UserMetadata\";\n\n/**\n * The maximum size in megabytes.\n *\n */\nexport const MAX_SIZE_IN_MEGABYTES = \"MaxSizeInMegabytes\";\n\n/**\n * The default message time to live.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n */\nexport const DEFAULT_MESSAGE_TIME_TO_LIVE = \"DefaultMessageTimeToLive\";\n\n/**\n * The lock duration.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n */\nexport const LOCK_DURATION = \"LockDuration\";\n\n/**\n * The indication if session is required or not.\n *\n */\nexport const REQUIRES_SESSION = \"RequiresSession\";\n\n/**\n * The indication if duplicate detection is required or not.\n *\n */\nexport const REQUIRES_DUPLICATE_DETECTION = \"RequiresDuplicateDetection\";\n\n/**\n * The indication if dead lettering on message expiration. If it is enabled and a message expires,\n * the Service Bus moves the message from the queue into the entity dead-letter sub-queue.\n * If disabled, message will be permanently deleted from the main entity.\n * Settable only at entity creation time.\n *\n */\nexport const DEAD_LETTERING_ON_MESSAGE_EXPIRATION = \"DeadLetteringOnMessageExpiration\";\n\n/**\n * The indication if dead lettering on filter evaluation exceptions.\n *\n */\nexport const DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS =\n  \"DeadLetteringOnFilterEvaluationExceptions\";\n\n/**\n * The history time window for duplicate detection.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n */\nexport const DUPLICATE_DETECTION_HISTORY_TIME_WINDOW = \"DuplicateDetectionHistoryTimeWindow\";\n\n/**\n * The maximum delivery count of messages after which if it is still not settled, gets moved to the dead-letter sub-queue.\n *\n */\nexport const MAX_DELIVERY_COUNT = \"MaxDeliveryCount\";\n\n/**\n * Indicates if the queue has enabled batch operations.\n *\n */\nexport const ENABLE_BATCHED_OPERATIONS = \"EnableBatchedOperations\";\n\n/**\n * Indicates whether the topic can be ordered\n *\n */\nexport const SUPPORT_ORDERING = \"SupportOrdering\";\n\n/**\n * Indicates whether the topic/queue should be split across multiple partitions\n *\n */\nexport const ENABLE_PARTITIONING = \"EnablePartitioning\";\n\n/**\n * The URL of Service Bus entity to forward deadlettered messages to.\n *\n */\nexport const FORWARD_DEADLETTERED_MESSAGES_TO = \"ForwardDeadLetteredMessagesTo\";\n\n/**\n * Query string parameter to set Service Bus API version\n *\n */\nexport const API_VERSION_QUERY_KEY = \"api-version\";\n\n/**\n * Current API version being sent to service bus\n *\n */\nexport const CURRENT_API_VERSION = \"2017-04\";\n\n/**\n * Constant representing the Odata Error 'message' property\n *\n * @const\n * @type {string}\n */\nexport const ODATA_ERROR_MESSAGE = \"message\";\n/**\n * Constant representing the 'value' property of Odata Error 'message' property\n *\n * @const\n * @type {string}\n */\nexport const ODATA_ERROR_MESSAGE_VALUE = \"value\";\n\n/**\n * Marker for atom metadata.\n *\n * @const\n * @type {string}\n */\nexport const XML_METADATA_MARKER = \"$\";\n\n/**\n * Marker for atom value.\n *\n * @const\n * @type {string}\n */\nexport const XML_VALUE_MARKER = \"_\";\n\n/**\n * Constant representing the property where the atom default elements are stored.\n *\n * @const\n * @type {string}\n */\nexport const ATOM_METADATA_MARKER = \"_\";\n\n/**\n * Known HTTP status codes as documented and referenced in ATOM based management API feature\n * https://docs.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode?view=netframework-4.8\n */\nexport const HttpResponseCodes = {\n  100: \"Continue\",\n  101: \"SwitchingProtocols\",\n  200: \"Ok\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"NonAuthoritativeInformation\",\n  204: \"NoContent\",\n  205: \"ResetContent\",\n  206: \"PartialContent\",\n  300: \"MultipleChoices\",\n  301: \"Moved\",\n  302: \"Redirect\",\n  303: \"RedirectMethod\",\n  304: \"NotModified\",\n  305: \"UseProxy\",\n  306: \"Unused\",\n  400: \"BadRequest\",\n  401: \"Unauthorized\",\n  402: \"PaymentRequired\",\n  403: \"Forbidden\",\n  404: \"NotFound\",\n  405: \"MethodNotAllowed\",\n  406: \"NotAcceptable\",\n  407: \"ProxyAuthenticationRequired\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"LengthRequired\",\n  412: \"PreconditionFailed\",\n  413: \"RequestEntityTooLarge\",\n  414: \"RequestUriTooLong\",\n  415: \"UnsupportedMediaType\",\n  416: \"RequestRangeNotSatisfiable\",\n  417: \"ExpectationFailed\",\n  426: \"UpgradeRequired\",\n  500: \"InternalServerError\",\n  501: \"NotImplemented\",\n  502: \"BadGateway\",\n  503: \"ServiceUnavailable\",\n  504: \"GatewayTimeout\",\n  505: \"HttpVersionNotSupported\"\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport * as os from \"os\";\nimport { packageJsonInfo } from \"./util/constants\";\nimport {\n  ConnectionConfig,\n  Constants,\n  ConnectionContextBase,\n  CreateConnectionContextBaseParameters,\n  Dictionary,\n  delay,\n  TokenProvider\n} from \"@azure/amqp-common\";\nimport { ServiceBusClientOptions } from \"./serviceBusClient\";\nimport { ClientEntityContext } from \"./clientEntityContext\";\nimport { OnAmqpEvent, EventContext, ConnectionEvents } from \"rhea-promise\";\n\n/**\n * @internal\n * @interface ConnectionContext\n * Provides contextual information like the underlying amqp connection, cbs session, management session,\n * tokenProvider, senders, receivers, etc. about the ServiceBus client.\n */\nexport interface ConnectionContext extends ConnectionContextBase {\n  /**\n   * @property A dictionary of ClientEntityContext\n   * objects for each of the client in the `clients` dictionary\n   */\n  clientContexts: Dictionary<ClientEntityContext>;\n}\n\n/**\n * @internal\n */\nexport namespace ConnectionContext {\n  /**\n   * @property {string} userAgent The user agent string for the ServiceBus client.\n   * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk\n   */\n  export const userAgent: string = `azsdk-js-azureservicebus/${\n    packageJsonInfo.version\n  } (NODE-VERSION ${process.version}; ${os.type()} ${os.release()})`;\n\n  export function create(\n    config: ConnectionConfig,\n    tokenProvider: TokenProvider,\n    options?: ServiceBusClientOptions\n  ): ConnectionContext {\n    if (!options) options = {};\n    const parameters: CreateConnectionContextBaseParameters = {\n      config: config,\n      tokenProvider: tokenProvider,\n      dataTransformer: options.dataTransformer,\n      isEntityPathRequired: false,\n      connectionProperties: {\n        product: \"MSJSClient\",\n        userAgent: userAgent,\n        version: packageJsonInfo.version\n      }\n    };\n    // Let us create the base context and then add ServiceBus specific ConnectionContext properties.\n    const connectionContext = ConnectionContextBase.create(parameters) as ConnectionContext;\n    connectionContext.clientContexts = {};\n\n    // Define listeners to be added to the connection object for\n    // \"connection_open\" and \"connection_error\" events.\n    const onConnectionOpen: OnAmqpEvent = (context: EventContext) => {\n      connectionContext.wasConnectionCloseCalled = false;\n      log.connectionCtxt(\n        \"[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.\",\n        connectionContext.connection.id,\n        connectionContext.wasConnectionCloseCalled\n      );\n    };\n\n    const disconnected: OnAmqpEvent = async (context: EventContext) => {\n      const connectionError =\n        context.connection && context.connection.error ? context.connection.error : undefined;\n      if (connectionError) {\n        log.error(\n          \"[%s] Error (context.connection.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          connectionError\n        );\n      }\n      const contextError = context.error;\n      if (contextError) {\n        log.error(\n          \"[%s] Error (context.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          contextError\n        );\n      }\n      const state: Readonly<{\n        wasConnectionCloseCalled: boolean;\n        numClients: number;\n      }> = {\n        wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,\n        numClients: Object.keys(connectionContext.clientContexts).length\n      };\n\n      // Clear internal map maintained by rhea to avoid reconnecting of old links once the\n      // connection is back up.\n      connectionContext.connection.removeAllSessions();\n\n      // Close the cbs session to ensure all the event handlers are released.\n      await connectionContext.cbsSession.close();\n\n      // Close the management sessions to ensure all the event handlers are released.\n      for (const id of Object.keys(connectionContext.clientContexts)) {\n        const clientContext = connectionContext.clientContexts[id];\n        if (clientContext.managementClient) {\n          await clientContext.managementClient.close();\n        }\n      }\n\n      // The connection should always be brought back up if the sdk did not call connection.close()\n      // and there was atleast one sender/receiver link on the connection before it went down.\n      log.error(\"[%s] state: %O\", connectionContext.connectionId, state);\n      if (!state.wasConnectionCloseCalled && state.numClients) {\n        log.error(\n          \"[%s] connection.close() was not called from the sdk and there were some \" +\n            \"clients. We should reconnect.\",\n          connectionContext.connection.id\n        );\n        await delay(Constants.connectionReconnectDelay);\n        // reconnect clients if any\n        for (const id of Object.keys(connectionContext.clientContexts)) {\n          const clientContext = connectionContext.clientContexts[id];\n          log.error(\n            \"[%s] calling detached on client '%s'.\",\n            connectionContext.connection.id,\n            clientContext.clientId\n          );\n          clientContext.onDetached(connectionError || contextError).catch((err) => {\n            log.error(\n              \"[%s] An error occurred while reconnecting the sender '%s': %O.\",\n              connectionContext.connection.id,\n              clientContext.clientId,\n              err\n            );\n          });\n        }\n      }\n    };\n\n    const protocolError: OnAmqpEvent = async (context: EventContext) => {\n      if (context.connection && context.connection.error) {\n        log.error(\n          \"[%s] Error (context.connection.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        log.error(\n          \"[%s] Error (context.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    const error: OnAmqpEvent = async (context: EventContext) => {\n      if (context.connection && context.connection.error) {\n        log.error(\n          \"[%s] Error (context.connection.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        log.error(\n          \"[%s] Error (context.error) occurred on the amqp connection: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    // Add listeners on the connection object.\n    connectionContext.connection.on(ConnectionEvents.connectionOpen, onConnectionOpen);\n    connectionContext.connection.on(ConnectionEvents.disconnected, disconnected);\n    connectionContext.connection.on(ConnectionEvents.protocolError, protocolError);\n    connectionContext.connection.on(ConnectionEvents.error, error);\n\n    log.connectionCtxt(\n      \"[%s] Created connection context successfully.\",\n      connectionContext.connectionId\n    );\n\n    return connectionContext;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * Interface for Queue/Topic/Subscription clients\n */\nexport interface Client {\n  /**\n   * @readonly\n   * @property The path for the Service Bus entity for which this client is created.\n   */\n  readonly entityPath: string;\n  /**\n   * @readonly\n   * @property A unique identifier for this client.\n   */\n  readonly id: string;\n  /**\n   * Closes the client along with all senders and receivers created using the client.\n   */\n  close(): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport enum ClientType {\n  QueueClient = \"QueueClient\",\n  TopicClient = \"TopicClient\",\n  SubscriptionClient = \"SubscriptionClient\"\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport Long from \"long\";\nimport * as log from \"../log\";\nimport { generate_uuid } from \"rhea-promise\";\nimport isBuffer from \"is-buffer\";\nimport { Buffer } from \"buffer\";\nimport * as Constants from \"../util/constants\";\n\n// This is the only dependency we have on DOM types, so rather than require\n// the DOM lib we can just shim this in.\ninterface Navigator {\n  hardwareConcurrency: number;\n}\ndeclare const navigator: Navigator;\n\n/**\n * A constant that indicates whether the environment is node.js or browser based.\n */\nexport const isNode = typeof navigator === \"undefined\" && typeof process !== \"undefined\";\n\n/**\n * @internal\n * Provides a uniue name by appending a string guid to the given string in the following format:\n * `{name}-{uuid}`.\n * @param name The nme of the entity\n */\nexport function getUniqueName(name: string): string {\n  return `${name}-${generate_uuid()}`;\n}\n\n/**\n * @internal\n * If you try to turn a Guid into a Buffer in .NET, the bytes of the first three groups get\n * flipped within the group, but the last two groups don't get flipped, so we end up with a\n * different byte order. This is the order of bytes needed to make Service Bus recognize the token.\n *\n * @param lockToken The lock token whose bytes need to be reorded.\n * @returns Buffer - Buffer representing reordered bytes.\n */\nexport function reorderLockToken(lockTokenBytes: Buffer): Buffer {\n  if (!lockTokenBytes || !Buffer.isBuffer(lockTokenBytes)) {\n    return lockTokenBytes;\n  }\n\n  return Buffer.from([\n    lockTokenBytes[3],\n    lockTokenBytes[2],\n    lockTokenBytes[1],\n    lockTokenBytes[0],\n\n    lockTokenBytes[5],\n    lockTokenBytes[4],\n\n    lockTokenBytes[7],\n    lockTokenBytes[6],\n\n    lockTokenBytes[8],\n    lockTokenBytes[9],\n\n    lockTokenBytes[10],\n    lockTokenBytes[11],\n    lockTokenBytes[12],\n    lockTokenBytes[13],\n    lockTokenBytes[14],\n    lockTokenBytes[15]\n  ]);\n}\n\n/**\n * @internal\n * Provides the time in milliseconds after which the lock renewal should occur.\n * @param lockedUntilUtc - The time until which the message is locked.\n */\nexport function calculateRenewAfterDuration(lockedUntilUtc: Date): number {\n  const now = Date.now();\n  const lockedUntil = lockedUntilUtc.getTime();\n  const remainingTime = lockedUntil - now;\n  log.utils(\"Locked until utc  : %d\", lockedUntil);\n  log.utils(\"Current time is   : %d\", now);\n  log.utils(\"Remaining time is : %d\", remainingTime);\n  if (remainingTime < 1000) {\n    return 0;\n  }\n  const buffer = Math.min(remainingTime / 2, 10000); // 10 seconds\n  const renewAfter = remainingTime - buffer;\n  log.utils(\"Renew after       : %d\", renewAfter);\n  return renewAfter;\n}\n\n/**\n * @internal\n * Converts the .net ticks to a JS Date object.\n *\n * - The epoch for the DateTimeOffset type is `0000-01-01`, while the epoch for JS Dates is\n * `1970-01-01`.\n * - The DateTimeOffset ticks value for the date `1970-01-01` is `621355968000000000`.\n *   - Hence, to convert it to the JS epoch; we `subtract` the delta from the given value.\n * - Ticks in DateTimeOffset is `1/10000000` second, while ticks in JS Date is `1/1000` second.\n *   - Thus, we `divide` the value by `10000` to convert it to JS Date ticks.\n *\n * @param buf Input as a Buffer\n * @returns Date The JS Date object.\n */\nexport function convertTicksToDate(buf: number[]): Date {\n  const epochMicroDiff: number = 621355968000000000;\n  const longValue: Long = Long.fromBytesBE(buf);\n  const timeInMS = longValue\n    .sub(epochMicroDiff)\n    .div(10000)\n    .toNumber();\n  const result = new Date(timeInMS);\n  log.utils(\"The converted date is: %s\", result.toString());\n  return result;\n}\n\n/**\n * @internal\n * Returns the number of logical processors in the system.\n */\nexport function getProcessorCount(): number {\n  if (isNode) {\n    const os = require(\"os\");\n    return os.cpus().length;\n  } else {\n    return navigator.hardwareConcurrency || 1;\n  }\n}\n\n/**\n * @internal\n * Converts any given input to a Buffer.\n * @param input The input that needs to be converted to a Buffer.\n */\nexport function toBuffer(input: any): Buffer {\n  let result: any;\n  log.utils(\n    \"[utils.toBuffer] The given message body that needs to be converted to buffer is: \",\n    input\n  );\n  if (isBuffer(input)) {\n    result = input;\n  } else {\n    // string, undefined, null, boolean, array, object, number should end up here\n    // coercing undefined to null as that will ensure that null value will be given to the\n    // customer on receive.\n    if (input === undefined) input = null;\n    try {\n      const inputStr = JSON.stringify(input);\n      result = Buffer.from(inputStr, \"utf8\");\n    } catch (err) {\n      const msg =\n        `An error occurred while executing JSON.stringify() on the given input ` +\n        input +\n        `${err instanceof Error ? err.stack : JSON.stringify(err)}`;\n      log.error(\"[utils.toBuffer] \" + msg);\n      throw err instanceof Error ? err : new Error(msg);\n    }\n  }\n  log.utils(\"[utils.toBuffer] The converted buffer is: %O.\", result);\n  return result;\n}\n\n/**\n * @ignore\n * Helper utility to retrieve `string` value from given string,\n * or throws error if undefined.\n * @param value\n */\nexport function getString(value: any, nameOfProperty: string): string {\n  const result = getStringOrUndefined(value);\n  if (result == undefined) {\n    throw new Error(\n      `\"${nameOfProperty}\" received from service expected to be a string value and not undefined.`\n    );\n  }\n  return result;\n}\n\n/**\n * @ignore\n * Helper utility to retrieve `string` value from given input,\n * or undefined if not passed in.\n * @param value\n */\nexport function getStringOrUndefined(value: any): string | undefined {\n  if (value == undefined) {\n    return undefined;\n  }\n  return value.toString();\n}\n\n/**\n * @ignore\n * Helper utility to retrieve `integer` value from given string,\n * or throws error if undefined.\n * @param value\n */\nexport function getInteger(value: any, nameOfProperty: string): number {\n  const result = getIntegerOrUndefined(value);\n  if (result == undefined) {\n    throw new Error(\n      `\"${nameOfProperty}\" received from service expected to be a number value and not undefined.`\n    );\n  }\n  return result;\n}\n\n/**\n * @ignore\n * Helper utility to retrieve `integer` value from given string,\n * or undefined if not passed in.\n * @param value\n */\nexport function getIntegerOrUndefined(value: any): number | undefined {\n  if (value == undefined) {\n    return undefined;\n  }\n  const result = parseInt(value.toString());\n  return result == NaN ? undefined : result;\n}\n\n/**\n * @ignore\n * Helper utility to retrieve `boolean` value from given string,\n * or throws error if undefined.\n * @param value\n */\nexport function getBoolean(value: any, nameOfProperty: string): boolean {\n  const result = getBooleanOrUndefined(value);\n  if (result == undefined) {\n    throw new Error(\n      `\"${nameOfProperty}\" received from service expected to be a boolean value and not undefined.`\n    );\n  }\n  return result;\n}\n\n/**\n * @ignore\n * Helper utility to retrieve `boolean` value from given string,\n * or undefined if not passed in.\n * @param value\n */\nexport function getBooleanOrUndefined(value: any): boolean | undefined {\n  if (value == undefined) {\n    return undefined;\n  }\n  return (\n    value\n      .toString()\n      .trim()\n      .toLowerCase() === \"true\"\n  );\n}\n\n/**\n * @ignore\n * Returns `true` if given input is a JSON like object.\n * @param value\n */\nexport function isJSONLikeObject(value: any): boolean {\n  return typeof value === \"object\" && !(value instanceof Number) && !(value instanceof String);\n}\n\n/**\n * @ignore\n * Helper utility to retrieve message count details from given input,\n * or undefined if not passed in.\n * @param value\n */\nexport function getCountDetailsOrUndefined(value: any): MessageCountDetails | undefined {\n  if (value == undefined) {\n    return undefined;\n  }\n  return {\n    activeMessageCount: parseInt(value[\"d2p1:ActiveMessageCount\"]) || 0,\n    deadLetterMessageCount: parseInt(value[\"d2p1:DeadLetterMessageCount\"]) || 0,\n    scheduledMessageCount: parseInt(value[\"d2p1:ScheduledMessageCount\"]) || 0,\n    transferMessageCount: parseInt(value[\"d2p1:TransferMessageCount\"]) || 0,\n    transferDeadLetterMessageCount: parseInt(value[\"d2p1:TransferDeadLetterMessageCount\"]) || 0\n  };\n}\n\n/**\n * Represents type of message count details in ATOM based management operations.\n */\nexport type MessageCountDetails = {\n  activeMessageCount: number;\n  deadLetterMessageCount: number;\n  scheduledMessageCount: number;\n  transferMessageCount: number;\n  transferDeadLetterMessageCount: number;\n};\n\n/**\n * Represents type of `AuthorizationRule` in ATOM based management operations.\n */\nexport type AuthorizationRule = {\n  claimType: string;\n  claimValue: string;\n  rights: { accessRights?: string[] };\n  keyName: string;\n  primaryKey?: string;\n  secondaryKey?: string;\n};\n\n/**\n * @ignore\n * Helper utility to retrieve array of `AuthorizationRule` from given input,\n * or undefined if not passed in.\n * @param value\n */\nexport function getAuthorizationRulesOrUndefined(value: any): AuthorizationRule[] | undefined {\n  const authorizationRules: AuthorizationRule[] = [];\n\n  // Ignore special case as Service Bus treats \"\" as a valid value for authorization rules\n  if (typeof value === \"string\" && value.trim() === \"\") {\n    return undefined;\n  }\n\n  if (value == undefined) {\n    return undefined;\n  }\n\n  const rawAuthorizationRules = value.AuthorizationRule;\n  if (Array.isArray(rawAuthorizationRules)) {\n    for (let i = 0; i < rawAuthorizationRules.length; i++) {\n      authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules[i]));\n    }\n  } else {\n    authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules));\n  }\n  return authorizationRules;\n}\n\n/**\n * Helper utility to build an instance of parsed authorization rule as `AuthorizationRule` from given input.\n * @param value\n */\nfunction buildAuthorizationRule(value: any): AuthorizationRule {\n  let accessRights;\n  if (value[\"Rights\"] != undefined) {\n    accessRights = value[\"Rights\"][\"AccessRights\"];\n  }\n\n  const authorizationRule: AuthorizationRule = {\n    claimType: value[\"ClaimType\"],\n    claimValue: value[\"ClaimValue\"],\n    rights: {\n      accessRights: accessRights\n    },\n    keyName: value[\"KeyName\"],\n    primaryKey: value[\"PrimaryKey\"],\n    secondaryKey: value[\"SecondaryKey\"]\n  };\n\n  if (\n    authorizationRule.rights.accessRights &&\n    !Array.isArray(authorizationRule.rights.accessRights)\n  ) {\n    authorizationRule.rights.accessRights = [authorizationRule.rights.accessRights];\n  }\n  return authorizationRule;\n}\n\n/**\n * @ignore\n * Helper utility to extract output containing array of `RawAuthorizationRule` instances from given input,\n * or undefined if not passed in.\n * @param value\n */\nexport function getRawAuthorizationRules(authorizationRules: AuthorizationRule[] | undefined): any {\n  if (authorizationRules == undefined) {\n    return undefined;\n  }\n\n  if (!Array.isArray(authorizationRules)) {\n    throw new TypeError(\n      `authorizationRules must be an array of AuthorizationRule objects or undefined, but received ${JSON.stringify(\n        authorizationRules,\n        undefined,\n        2\n      )}`\n    );\n  }\n\n  const rawAuthorizationRules: any[] = [];\n  for (let i = 0; i < authorizationRules.length; i++) {\n    rawAuthorizationRules.push(buildRawAuthorizationRule(authorizationRules[i]));\n  }\n  return { AuthorizationRule: rawAuthorizationRules };\n}\n\n/**\n * Helper utility to build an instance of raw authorization rule as RawAuthorizationRule from given `AuthorizationRule` input.\n * @param authorizationRule parsed Authorization Rule instance\n */\nfunction buildRawAuthorizationRule(authorizationRule: AuthorizationRule): any {\n  if (!isJSONLikeObject(authorizationRule) || authorizationRule === null) {\n    throw new TypeError(\n      `Expected authorizationRule input to be a JS object value, but received ${JSON.stringify(\n        authorizationRule,\n        undefined,\n        2\n      )}`\n    );\n  }\n\n  const rawAuthorizationRule: any = {\n    ClaimType: authorizationRule.claimType,\n    ClaimValue: authorizationRule.claimValue,\n    Rights: {\n      AccessRights: authorizationRule.rights.accessRights\n    },\n    KeyName: authorizationRule.keyName,\n    PrimaryKey: authorizationRule.primaryKey,\n    SecondaryKey: authorizationRule.secondaryKey\n  };\n  rawAuthorizationRule[Constants.XML_METADATA_MARKER] = {\n    \"p5:type\": \"SharedAccessAuthorizationRule\",\n    \"xmlns:p5\": \"http://www.w3.org/2001/XMLSchema-instance\"\n  };\n  return rawAuthorizationRule;\n}\n\n/**\n * @ignore\n * Helper utility to check if given string is an absolute URL\n * @param url\n */\nexport function isAbsoluteUrl(url: string) {\n  const _url = url.toLowerCase();\n  return _url.startsWith(\"sb://\") || _url.startsWith(\"http://\") || _url.startsWith(\"https://\");\n}\n\n/**\n * Possible values for `status` of the Service Bus messaging entities.\n */\nexport type EntityStatus =\n  | \"Active\"\n  | \"Creating\"\n  | \"Deleting\"\n  | \"ReceiveDisabled\"\n  | \"SendDisabled\"\n  | \"Disabled\"\n  | \"Renaming\"\n  | \"Restoring\"\n  | \"Unknown\";\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"../log\";\nimport Long from \"long\";\nimport { ClientType } from \"../client\";\nimport { ConnectionContext } from \"../connectionContext\";\n\n/**\n * @internal\n * Logs and throws Error if the current AMQP connection is closed.\n * @param context The ConnectionContext associated with the current AMQP connection.\n */\nexport function throwErrorIfConnectionClosed(context: ConnectionContext): void {\n  if (context && context.wasConnectionCloseCalled) {\n    const errorMessage = \"The underlying AMQP connection is closed.\";\n    const error = new Error(errorMessage);\n    log.error(`[${context.connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and throws error if the underlying AMQP connection or if the client is closed\n * @param context The ConnectionContext associated with the current AMQP connection.\n * @param entityPath Entity Path of the client which denotes the name of the Queue/Topic/Subscription\n * @param isClientClosed Boolean denoting if the client is closed or not\n */\nexport function throwErrorIfClientOrConnectionClosed(\n  context: ConnectionContext,\n  entityPath: string,\n  isClientClosed: boolean\n): void {\n  throwErrorIfConnectionClosed(context);\n  if (context && isClientClosed) {\n    const errorMessage = getClientClosedErrorMsg(entityPath);\n    const error = new Error(errorMessage);\n    log.error(`[${context.connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Gets the error message when an open sender exists, but a new one is asked for on the same client\n * @param clientType 'QueueClient' or 'TopicClient'\n * @param entityPath  Value of the `entityPath` property on the client which denotes its name\n */\nexport function getOpenSenderErrorMsg(clientType: string, entityPath: string): string {\n  return (\n    `An open sender already exists on the ${clientType} for \"${entityPath}\". ` +\n    `Please close it and try again or use a new ${clientType} instance.`\n  );\n}\n\n/**\n * @internal\n * Gets the error message when an open receiver exists, but a new one is asked for on the same client\n * @param clientType 'QueueClient' or 'SubscriptionClient'\n * @param entityPath  Value of the `entityPath` property on the client which denotes its name\n * @param sessionId If using session receiver, then the id of the session\n */\nexport function getOpenReceiverErrorMsg(\n  clientType: ClientType,\n  entityPath: string,\n  sessionId?: string\n): string {\n  if (!sessionId) {\n    return (\n      `An open receiver already exists on the ${clientType} for \"${entityPath}\". ` +\n      `Please close it and try again or use a new ${clientType} instance.`\n    );\n  }\n  return (\n    `An open receiver already exists for the session \"${sessionId}\" on the ${clientType} for ` +\n    `\"${entityPath}\". Please close it and try again or use a new ${clientType} instance.`\n  );\n}\n\n/**\n * @internal\n * Gets the error message when a client is used when its already closed\n * @param entityPath Value of the `entityPath` property on the client which denotes its name\n */\nexport function getClientClosedErrorMsg(entityPath: string): string {\n  return (\n    `The client for \"${entityPath}\" has been closed and can no longer be used. ` +\n    `Please create a new client using an instance of ServiceBusClient.`\n  );\n}\n\n/**\n * @internal\n * Gets the error message when a sender is used when its already closed\n * @param entityPath Value of the `entityPath` property on the client which denotes its name\n * @param clientType One of \"QueueClient\", \"TopicClient\" or \"SubscriptionClient\", used for logging\n * @param isClientClosed Denotes if the close() was called on the client that created the sender\n */\nexport function getSenderClosedErrorMsg(\n  entityPath: string,\n  clientType: ClientType,\n  isClientClosed: boolean\n): string {\n  if (isClientClosed) {\n    return (\n      `The client for \"${entityPath}\" has been closed. The sender created by it can no longer be used. ` +\n      `Please create a new client using an instance of ServiceBusClient.`\n    );\n  }\n  return (\n    `The sender for \"${entityPath}\" has been closed and can no longer be used. ` +\n    `Please create a new sender using the \"createSender\" function on the ${clientType}.`\n  );\n}\n\n/**\n * @internal\n * Gets the error message when a receiver is used when its already closed\n * @param entityPath Value of the `entityPath` property on the client which denotes its name\n * @param clientType One of \"QueueClient\", \"TopicClient\" or \"SubscriptionClient\", used for logging\n * @param isClientClosed Denotes if the close() was called on the client that created the sender\n * @param sessionId If using session receiver, then the id of the session\n */\nexport function getReceiverClosedErrorMsg(\n  entityPath: string,\n  clientType: ClientType,\n  isClientClosed: boolean,\n  sessionId?: string\n): string {\n  if (isClientClosed) {\n    return (\n      `The client for \"${entityPath}\" has been closed. The receiver created by it can no longer be used. ` +\n      `Please create a new client using an instance of ServiceBusClient.`\n    );\n  }\n  if (sessionId == undefined) {\n    return (\n      `The receiver for \"${entityPath}\" has been closed and can no longer be used. ` +\n      `Please create a new receiver using the \"createReceiver\" function on the ${clientType}.`\n    );\n  }\n  return (\n    `The receiver for session \"${sessionId}\" in \"${entityPath}\" has been closed and can no ` +\n    `longer be used. Please create a new receiver using the \"createReceiver\" function.`\n  );\n}\n\n/**\n * @internal\n * @param entityPath Value of the `entityPath` property on the client which denotes its name\n * @param sessionId If using session receiver, then the id of the session\n */\nexport function getAlreadyReceivingErrorMsg(entityPath: string, sessionId?: string): string {\n  if (sessionId == undefined) {\n    return `The receiver for \"${entityPath}\" is already receiving messages.`;\n  }\n  return `The receiver for session \"${sessionId}\" for \"${entityPath}\" is already receiving messages.`;\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is undefined or null\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to check\n * @param parameterValue Value of the parameter to check\n */\nexport function throwTypeErrorIfParameterMissing(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any\n): void {\n  if (parameterValue === undefined || parameterValue === null) {\n    const error = new TypeError(`Missing parameter \"${parameterName}\"`);\n    log.error(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is not of expected type\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n * @param expectedType Expected type of the parameter\n */\nexport function throwTypeErrorIfParameterTypeMismatch(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any,\n  expectedType: string\n): void {\n  if (typeof parameterValue !== expectedType) {\n    const error = new TypeError(\n      `The parameter \"${parameterName}\" should be of type \"${expectedType}\"`\n    );\n    log.error(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is not of type `Long`\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterNotLong(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any\n): TypeError | undefined {\n  if (Long.isLong(parameterValue)) {\n    return;\n  }\n  const error = new TypeError(`The parameter \"${parameterName}\" should be of type \"Long\"`);\n  log.error(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is not an array of type `Long`\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterNotLongArray(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any[]\n): TypeError | undefined {\n  if (parameterValue.every((item) => Long.isLong(item))) {\n    return;\n  }\n  const error = new TypeError(`The parameter \"${parameterName}\" should be an array of type \"Long\"`);\n  log.error(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is an empty string\n * @param connectionId Id of the underlying AMQP connection used for logging\n * @param parameterName Name of the parameter to type check\n * @param parameterValue Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterIsEmptyString(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: string\n): TypeError | undefined {\n  if (parameterValue !== \"\") {\n    return;\n  }\n  const error = new TypeError(`Empty string not allowed in parameter \"${parameterName}\"`);\n  log.error(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * Gets error message for when an operation is not supported in ReceiveAndDelete mode\n * @param failedToDo A string to add to the placeholder in the error message. Denotes the action\n * that is not supported in ReceiveAndDelete mode\n */\nexport function getErrorMessageNotSupportedInReceiveAndDeleteMode(failedToDo: string): string {\n  return `Failed to ${failedToDo} as the operation is only supported in 'PeekLock' recieve mode.`;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport Long from \"long\";\nimport {\n  Delivery,\n  uuid_to_string,\n  AmqpError,\n  MessageAnnotations,\n  DeliveryAnnotations\n} from \"rhea-promise\";\nimport { Constants, AmqpMessage, translate, ErrorNameConditionMapper } from \"@azure/amqp-common\";\nimport * as log from \"./log\";\nimport { ClientEntityContext } from \"./clientEntityContext\";\nimport { reorderLockToken } from \"../src/util/utils\";\nimport { MessageReceiver } from \"../src/core/messageReceiver\";\nimport { MessageSession } from \"../src/session/messageSession\";\nimport { getErrorMessageNotSupportedInReceiveAndDeleteMode } from \"./util/errors\";\nimport { Buffer } from \"buffer\";\n\n/**\n * The mode in which messages should be received. The 2 modes are `peekLock` and `receiveAndDelete`.\n */\nexport enum ReceiveMode {\n  /**\n   * Once a message is received in this mode, the receiver has a lock on the message for a\n   * particular duration. If the message is not settled by this time, it lands back on Service Bus\n   * to be fetched by the next receive operation.\n   * @type {Number}\n   */\n  peekLock = 1,\n\n  /**\n   * Messages received in this mode get automatically removed from Service Bus.\n   * @type {Number}\n   */\n  receiveAndDelete = 2\n}\n\n/**\n * @internal\n */\nexport enum DispositionType {\n  complete = \"complete\",\n  deadletter = \"deadletter\",\n  abandon = \"abandon\",\n  defer = \"defer\"\n}\n\n/**\n * @internal\n */\nexport enum DispositionStatus {\n  completed = \"completed\",\n  defered = \"defered\",\n  suspended = \"suspended\",\n  abandoned = \"abandoned\",\n  renewed = \"renewed\"\n}\n\n/**\n * @internal\n * Describes the delivery annotations for Service Bus.\n * @interface\n */\nexport interface ServiceBusDeliveryAnnotations extends DeliveryAnnotations {\n  /**\n   * @property {string} [last_enqueued_offset] The offset of the last event.\n   */\n  last_enqueued_offset?: string;\n  /**\n   * @property {number} [last_enqueued_sequence_number] The sequence number of the last event.\n   */\n  last_enqueued_sequence_number?: number;\n  /**\n   * @property {number} [last_enqueued_time_utc] The enqueued time of the last event.\n   */\n  last_enqueued_time_utc?: number;\n  /**\n   * @property {number} [runtime_info_retrieval_time_utc] The retrieval time of the last event.\n   */\n  runtime_info_retrieval_time_utc?: number;\n  /**\n   * @property {string} Any unknown delivery annotations.\n   */\n  [x: string]: any;\n}\n\n/**\n * @internal\n * Describes the message annotations for Service Bus.\n * @interface ServiceBusMessageAnnotations\n */\nexport interface ServiceBusMessageAnnotations extends MessageAnnotations {\n  /**\n   * @property {string | null} [x-opt-partition-key] Annotation for the partition key set for the event.\n   */\n  \"x-opt-partition-key\"?: string | null;\n  /**\n   * @property {number} [x-opt-sequence-number] Annontation for the sequence number of the event.\n   */\n  \"x-opt-sequence-number\"?: number;\n  /**\n   * @property {number} [x-opt-enqueued-time] Annotation for the enqueued time of the event.\n   */\n  \"x-opt-enqueued-time\"?: number;\n  /**\n   * @property {string} [x-opt-offset] Annotation for the offset of the event.\n   */\n  \"x-opt-offset\"?: string;\n  /**\n   * @property {string} [x-opt-locked-until] Annotation for the message being locked until.\n   */\n  \"x-opt-locked-until\"?: Date | number;\n}\n\n/**\n * Describes the reason and error description for dead lettering a message using the `deadLetter()`\n * method on the message received from Service Bus.\n * @interface DeadLetterOptions\n */\nexport interface DeadLetterOptions {\n  /**\n   * @property The reason for deadlettering the message.\n   */\n  deadletterReason: string;\n  /**\n   * @property The error description for deadlettering the message.\n   */\n  deadLetterErrorDescription: string;\n}\n\n/**\n * Describes the message to be sent to Service Bus.\n * @interface SendableMessageInfo.\n */\nexport interface SendableMessageInfo {\n  /**\n   * @property The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * @property The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * @property The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n  /**\n   * @property The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  correlationId?: string | number | Buffer;\n  /**\n   * @property The partition key for sending a message to a partitioned entity.\n   * Maximum length is 128 characters. For {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning partitioned entities},\n   * setting this value enables assigning related messages to the same internal partition,\n   * so that submission sequence order is correctly recorded. The partition is chosen by a hash\n   * function over this value and cannot be chosen directly.\n   * - For session-aware entities, the `sessionId` property overrides this value.\n   * - For non partitioned entities, partition key will be ignored\n   *\n   */\n  partitionKey?: string;\n  /**\n   * @property The partition key for sending a message into an entity\n   * via a partitioned transfer queue. Maximum length is 128 characters. If a message is sent via a\n   * transfer queue in the scope of a transaction, this value selects the transfer queue partition:\n   * This is functionally equivalent to `partitionKey` property and ensures that messages are kept\n   * together and in order as they are transferred.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via Transfers and Send Via}.\n   */\n  viaPartitionKey?: string;\n  /**\n   * @property The session identifier for a session-aware entity. Maximum\n   * length is 128 characters. For session-aware entities, this application-defined value specifies\n   * the session affiliation of the message. Messages with the same session identifier are subject\n   * to summary locking and enable exact in-order processing and demultiplexing. For\n   * session-unaware entities, this value is ignored.\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions Message Sessions}.\n   */\n  sessionId?: string;\n  /**\n   * @property The session identifier augmenting the `replyTo` address.\n   * Maximum length is 128 characters. This value augments the ReplyTo information and specifies\n   * which SessionId should be set for the reply when sent to the reply entity.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  replyToSessionId?: string;\n  /**\n   * @property The message’s time to live value. This value is the relative\n   * duration after which the message expires, starting from the instant the message has been\n   * accepted and stored by the broker, as captured in `enqueuedTimeUtc`. When not set explicitly,\n   * the assumed value is the DefaultTimeToLive for the respective queue or topic. A message-level\n   * `timeToLive` value cannot be longer than the entity's DefaultTimeToLive setting and it is\n   * silently adjusted if it does. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-expiration Expiration}.\n   */\n  timeToLive?: number;\n  /**\n   * @property The application specific label. This property enables the\n   * application to indicate the purpose of the message to the receiver in a standardized. fashion,\n   * similar to an email subject line. The mapped AMQP property is \"subject\".\n   */\n  label?: string;\n  /**\n   * @property The \"to\" address. This property is reserved for future use in routing\n   * scenarios and presently ignored by the broker itself. Applications can use this value in\n   * rule-driven {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-auto-forwarding auto-forward chaining}\n   * scenarios to indicate the intended logical destination of the message.\n   */\n  to?: string;\n  /**\n   * @property The address of an entity to send replies to. This optional and\n   * application-defined value is a standard way to express a reply path to the receiver of the\n   * message. When a sender expects a reply, it sets the value to the absolute or relative path of\n   * the queue or topic it expects the reply to be sent to. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  replyTo?: string;\n  /**\n   * @property The date and time in UTC at which the message will\n   * be enqueued. This property returns the time in UTC; when setting the property, the\n   * supplied DateTime value must also be in UTC. This value is for delayed message sending.\n   * It is utilized to delay messages sending to a specific time in the future. Message enqueuing\n   * time does not mean that the message will be sent at the same time. It will get enqueued,\n   * but the actual sending time depends on the queue's workload and its state.\n   */\n  scheduledEnqueueTimeUtc?: Date;\n  /**\n   * @property The application specific properties which can be\n   * used for custom message metadata.\n   */\n  userProperties?: { [key: string]: any };\n}\n\n/**\n * @internal\n * Gets the error message for when a property on given message is not of expected type\n */\nexport function getMessagePropertyTypeMismatchError(msg: SendableMessageInfo): Error | undefined {\n  if (msg.contentType != null && typeof msg.contentType !== \"string\") {\n    return new TypeError(\"The property 'contentType' on the message must be of type 'string'\");\n  }\n\n  if (msg.label != null && typeof msg.label !== \"string\") {\n    return new TypeError(\"The property 'label' on the message must be of type 'string'\");\n  }\n\n  if (msg.to != null && typeof msg.to !== \"string\") {\n    return new TypeError(\"The property 'to' on the message must be of type 'string'\");\n  }\n\n  if (msg.replyTo != null && typeof msg.replyTo !== \"string\") {\n    return new TypeError(\"The property 'replyTo' on the message must be of type 'string'\");\n  }\n\n  if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== \"string\") {\n    return new TypeError(\"The property 'replyToSessionId' on the message must be of type 'string'\");\n  }\n\n  if (msg.timeToLive != null && typeof msg.timeToLive !== \"number\") {\n    return new TypeError(\"The property 'timeToLive' on the message must be of type 'number'\");\n  }\n\n  if (msg.sessionId != null && typeof msg.sessionId !== \"string\") {\n    return new TypeError(\"The property 'sessionId' on the message must be of type 'string'\");\n  }\n\n  if (\n    msg.messageId != null &&\n    typeof msg.messageId !== \"string\" &&\n    typeof msg.messageId !== \"number\" &&\n    !Buffer.isBuffer(msg.messageId)\n  ) {\n    return new TypeError(\n      \"The property 'messageId' on the message must be of type string, number or Buffer\"\n    );\n  }\n\n  if (\n    msg.correlationId != null &&\n    typeof msg.correlationId !== \"string\" &&\n    typeof msg.correlationId !== \"number\" &&\n    !Buffer.isBuffer(msg.correlationId)\n  ) {\n    return new TypeError(\n      \"The property 'correlationId' on the message must be of type string, number or Buffer\"\n    );\n  }\n  return;\n}\n\n/**\n * @internal\n * Converts given SendableMessageInfo to AmqpMessage\n */\nexport function toAmqpMessage(msg: SendableMessageInfo): AmqpMessage {\n  const amqpMsg: AmqpMessage = {\n    body: msg.body,\n    message_annotations: {}\n  };\n  if (msg.userProperties != null) {\n    amqpMsg.application_properties = msg.userProperties;\n  }\n  if (msg.contentType != null) {\n    amqpMsg.content_type = msg.contentType;\n  }\n  if (msg.sessionId != null) {\n    if (msg.sessionId.length > Constants.maxSessionIdLength) {\n      throw new Error(\n        \"Length of 'sessionId' property on the message cannot be greater than 128 characters.\"\n      );\n    }\n    amqpMsg.group_id = msg.sessionId;\n  }\n  if (msg.replyTo != null) {\n    amqpMsg.reply_to = msg.replyTo;\n  }\n  if (msg.to != null) {\n    amqpMsg.to = msg.to;\n  }\n  if (msg.label != null) {\n    amqpMsg.subject = msg.label;\n  }\n  if (msg.messageId != null) {\n    if (typeof msg.messageId === \"string\" && msg.messageId.length > Constants.maxMessageIdLength) {\n      throw new Error(\n        \"Length of 'messageId' property on the message cannot be greater than 128 characters.\"\n      );\n    }\n    amqpMsg.message_id = msg.messageId;\n  }\n  if (msg.correlationId != null) {\n    amqpMsg.correlation_id = msg.correlationId;\n  }\n  if (msg.replyToSessionId != null) {\n    amqpMsg.reply_to_group_id = msg.replyToSessionId;\n  }\n  if (msg.timeToLive != null && msg.timeToLive !== Constants.maxDurationValue) {\n    amqpMsg.ttl = msg.timeToLive;\n    amqpMsg.creation_time = Date.now();\n    if (Constants.maxAbsoluteExpiryTime - amqpMsg.creation_time > amqpMsg.ttl) {\n      amqpMsg.absolute_expiry_time = amqpMsg.creation_time + amqpMsg.ttl;\n    } else {\n      amqpMsg.absolute_expiry_time = Constants.maxAbsoluteExpiryTime;\n    }\n  }\n  if (msg.partitionKey != null) {\n    if (msg.partitionKey.length > Constants.maxPartitionKeyLength) {\n      throw new Error(\n        \"Length of 'partitionKey' property on the message cannot be greater than 128 characters.\"\n      );\n    }\n    amqpMsg.message_annotations![Constants.partitionKey] = msg.partitionKey;\n  }\n  if (msg.viaPartitionKey != null) {\n    if (msg.viaPartitionKey.length > Constants.maxPartitionKeyLength) {\n      throw new Error(\n        \"Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters.\"\n      );\n    }\n    amqpMsg.message_annotations![Constants.viaPartitionKey] = msg.viaPartitionKey;\n  }\n  if (msg.scheduledEnqueueTimeUtc != null) {\n    amqpMsg.message_annotations![Constants.scheduledEnqueueTime] = msg.scheduledEnqueueTimeUtc;\n  }\n  log.message(\"SBMessage to AmqpMessage: %O\", amqpMsg);\n  return amqpMsg;\n}\n\n/**\n * Describes the message received from Service Bus during peek operations and so cannot be settled.\n * @class ReceivedSBMessage\n */\nexport interface ReceivedMessageInfo extends SendableMessageInfo {\n  /**\n   * @property The lock token is a reference to the lock that is being held by the broker in\n   * `ReceiveMode.PeekLock` mode. Locks are used internally settle messages as explained in the\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement product documentation in more detail}\n   * - Not applicable when the message is received in `ReceiveMode.receiveAndDelete`\n   * mode.\n   * @readonly\n   */\n  readonly lockToken?: string;\n  /**\n   * @property Number of deliveries that have been attempted for this message. The count is\n   * incremented when a message lock expires, or the message is explicitly abandoned using the\n   * `abandon()` method on the message.\n   * @readonly\n   */\n  readonly deliveryCount?: number;\n  /**\n   * @property The UTC instant at which the message has been accepted and stored in Service Bus.\n   * @readonly\n   */\n  readonly enqueuedTimeUtc?: Date;\n  /**\n   * @property The UTC instant at which the message is marked for removal and no longer available for\n   * retrieval from the entity due to expiration. This property is computed from 2 other properties\n   * on the message: `enqueuedTimeUtc` + `timeToLive`.\n   */\n  readonly expiresAtUtc?: Date;\n  /**\n   * @property The UTC instant until which the message is held locked in the queue/subscription.\n   * When the lock expires, the `deliveryCount` is incremented and the message is again available\n   * for retrieval.\n   * - Not applicable when the message is received in `ReceiveMode.receiveAndDelete`\n   * mode.\n   */\n  lockedUntilUtc?: Date;\n  /**\n   * @property The original sequence number of the message. For\n   * messages that have been auto-forwarded, this property reflects the sequence number that had\n   * first been assigned to the message at its original point of submission.\n   * @readonly\n   */\n  readonly enqueuedSequenceNumber?: number;\n  /**\n   * @property The unique number assigned to a message by Service Bus.\n   * The sequence number is a unique 64-bit integer assigned to a message as it is accepted\n   * and stored by the broker and functions as its true identifier. For partitioned entities,\n   * the topmost 16 bits reflect the partition identifier. Sequence numbers monotonically increase.\n   * They roll over to 0 when the 48-64 bit range is exhausted.\n   *\n   * **Max safe integer** that Javascript currently supports is `2^53 - 1`. The sequence number\n   * is an AMQP `Long` type which can be upto 64 bits long. To represent that we are using a\n   * library named {@link https://github.com/dcodeIO/long.js long.js}. We expect customers\n   * to use the **`Long`** type exported by this library.\n   * @readonly\n   */\n  readonly sequenceNumber?: Long;\n  /**\n   * @property {string} [deadLetterSource] The name of the queue or subscription that this message\n   * was enqueued on, before it was deadlettered. Only set in messages that have been dead-lettered\n   * and subsequently auto-forwarded from the dead-letter sub-queue to another entity. Indicates the\n   * entity in which the message was dead-lettered.\n   * @readonly\n   */\n  readonly deadLetterSource?: string;\n  /**\n   * @property {AmqpMessage} _amqpMessage The underlying raw amqp message.\n   * @readonly\n   */\n  readonly _amqpMessage: AmqpMessage;\n}\n\n/**\n * @ignore\n * Converts given AmqpMessage to ReceivedMessageInfo\n */\nexport function fromAmqpMessage(\n  msg: AmqpMessage,\n  delivery?: Delivery,\n  shouldReorderLockToken?: boolean\n): ReceivedMessageInfo {\n  if (!msg) {\n    msg = {\n      body: undefined\n    };\n  }\n  const sbmsg: SendableMessageInfo = {\n    body: msg.body\n  };\n\n  if (msg.application_properties != null) {\n    sbmsg.userProperties = msg.application_properties;\n  }\n  if (msg.content_type != null) {\n    sbmsg.contentType = msg.content_type;\n  }\n  if (msg.group_id != null) {\n    sbmsg.sessionId = msg.group_id;\n  }\n  if (msg.reply_to != null) {\n    sbmsg.replyTo = msg.reply_to;\n  }\n  if (msg.to != null) {\n    sbmsg.to = msg.to;\n  }\n  if (msg.ttl != null) {\n    sbmsg.timeToLive = msg.ttl;\n  }\n  if (msg.subject != null) {\n    sbmsg.label = msg.subject;\n  }\n  if (msg.message_id != null) {\n    sbmsg.messageId = msg.message_id;\n  }\n  if (msg.correlation_id != null) {\n    sbmsg.correlationId = msg.correlation_id;\n  }\n  if (msg.reply_to_group_id != null) {\n    sbmsg.replyToSessionId = msg.reply_to_group_id;\n  }\n\n  if (msg.message_annotations != null) {\n    if (msg.message_annotations[Constants.partitionKey] != null) {\n      sbmsg.partitionKey = msg.message_annotations[Constants.partitionKey];\n    }\n    if (msg.message_annotations[Constants.viaPartitionKey] != null) {\n      sbmsg.viaPartitionKey = msg.message_annotations[Constants.viaPartitionKey];\n    }\n    if (msg.message_annotations[Constants.scheduledEnqueueTime] != null) {\n      sbmsg.scheduledEnqueueTimeUtc = msg.message_annotations[Constants.scheduledEnqueueTime];\n    }\n  }\n\n  const props: any = {};\n  if (msg.message_annotations != null) {\n    if (msg.message_annotations[Constants.deadLetterSource] != null) {\n      props.deadLetterSource = msg.message_annotations[Constants.deadLetterSource];\n    }\n    if (msg.message_annotations[Constants.enqueueSequenceNumber] != null) {\n      props.enqueuedSequenceNumber = msg.message_annotations[Constants.enqueueSequenceNumber];\n    }\n    if (msg.message_annotations[Constants.sequenceNumber] != null) {\n      if (Buffer.isBuffer(msg.message_annotations[Constants.sequenceNumber])) {\n        props.sequenceNumber = Long.fromBytesBE(msg.message_annotations[Constants.sequenceNumber]);\n      } else {\n        props.sequenceNumber = Long.fromNumber(msg.message_annotations[Constants.sequenceNumber]);\n      }\n    }\n    if (msg.message_annotations[Constants.enqueuedTime] != null) {\n      props.enqueuedTimeUtc = new Date(msg.message_annotations[Constants.enqueuedTime] as number);\n    }\n    if (msg.message_annotations[Constants.lockedUntil] != null) {\n      props.lockedUntilUtc = new Date(msg.message_annotations[Constants.lockedUntil] as number);\n    }\n  }\n  if (msg.ttl != null && msg.ttl >= Constants.maxDurationValue - props.enqueuedTimeUtc.getTime()) {\n    props.expiresAtUtc = new Date(Constants.maxDurationValue);\n  } else {\n    props.expiresAtUtc = new Date(props.enqueuedTimeUtc.getTime() + msg.ttl!);\n  }\n\n  const rcvdsbmsg: ReceivedMessageInfo = {\n    _amqpMessage: msg,\n    _delivery: delivery,\n    deliveryCount: msg.delivery_count,\n    lockToken:\n      delivery && delivery.tag && delivery.tag.length !== 0\n        ? uuid_to_string(\n            shouldReorderLockToken === true\n              ? reorderLockToken(\n                  typeof delivery.tag === \"string\" ? Buffer.from(delivery.tag) : delivery.tag\n                )\n              : typeof delivery.tag === \"string\"\n              ? Buffer.from(delivery.tag)\n              : delivery.tag\n          )\n        : undefined,\n    ...sbmsg,\n    ...props\n  };\n\n  log.message(\"AmqpMessage to ReceivedSBMessage: %O\", rcvdsbmsg);\n  return rcvdsbmsg;\n}\n\n/**\n * Describes the message received from Service Bus.\n * @interface ReceivedMessage\n */\ninterface ReceivedMessage extends ReceivedMessageInfo {\n  /**\n   * Removes the message from Service Bus.\n   * @returns Promise<void>.\n   */\n  complete(): Promise<void>;\n\n  /**\n   * The lock held on the message by the receiver is let go, making the message available again in\n   * Service Bus for another receive operation.\n   * @param propertiesToModify The properties of the message to modify while abandoning the message.\n   *\n   * @return Promise<void>.\n   */\n  abandon(propertiesToModify?: { [key: string]: any }): Promise<void>;\n\n  /**\n   * Defers the processing of the message. Save the `sequenceNumber` of the message, in order to\n   * receive it message again in the future using the `receiveDeferredMessage` method.\n   * @param propertiesToModify The properties of the message to modify while deferring the message\n   *\n   * @returns Promise<void>\n   */\n  defer(propertiesToModify?: { [key: string]: any }): Promise<void>;\n\n  /**\n   * Moves the message to the deadletter sub-queue. To receive a deadletted message, create a new\n   * QueueClient/SubscriptionClient using the path for the deadletter sub-queue.\n   * @param options The DeadLetter options that can be provided while\n   * rejecting the message.\n   *\n   * @returns Promise<void>\n   */\n  deadLetter(options?: DeadLetterOptions): Promise<void>;\n}\n\n/**\n * Describes the message received from Service Bus.\n * @class ServiceBusMessage\n */\nexport class ServiceBusMessage implements ReceivedMessage {\n  /**\n   * @property The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * @property The application specific properties.\n   */\n  userProperties?: { [key: string]: any };\n  /**\n   * @property The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload. The identifier\n   * is a free-form string and can reflect a GUID or an identifier derived from the application\n   * context. If enabled, the\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection duplicate detection}\n   * identifies and removes second and further submissions of messages with the same MessageId.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * @property The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n  /**\n   * @property The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  correlationId?: string | number | Buffer;\n  /**\n   * @property The partition key for sending a message to a\n   * partitioned entity. Maximum length is 128 characters. For {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning partitioned entities},\n   * setting this value enables assigning related messages to the same internal partition,\n   * so that submission sequence order is correctly recorded. The partition is chosen by a hash\n   * function over this value and cannot be chosen directly. For session-aware entities,\n   * the `sessionId` property overrides this value.\n   */\n  partitionKey?: string;\n  /**\n   * @property The partition key for sending a message into an entity\n   * via a partitioned transfer queue. Maximum length is 128 characters. If a message is sent via a\n   * transfer queue in the scope of a transaction, this value selects the transfer queue partition:\n   * This is functionally equivalent to `partitionKey` property and ensures that messages are kept\n   * together and in order as they are transferred.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via Transfers and Send Via}.\n   */\n  viaPartitionKey?: string;\n  /**\n   * @property The session identifier for a session-aware entity. Maximum\n   * length is 128 characters. For session-aware entities, this application-defined value specifies\n   * the session affiliation of the message. Messages with the same session identifier are subject\n   * to summary locking and enable exact in-order processing and demultiplexing. For\n   * session-unaware entities, this value is ignored.\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions Message Sessions}.\n   */\n  sessionId?: string;\n  /**\n   * @property The session identifier augmenting the `replyTo` address.\n   * Maximum length is 128 characters. This value augments the ReplyTo information and specifies\n   * which SessionId should be set for the reply when sent to the reply entity.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  replyToSessionId?: string;\n  /**\n   * @property The message’s time to live value. This value is the relative\n   * duration after which the message expires, starting from the instant the message has been\n   * accepted and stored by the broker, as captured in `enqueuedTimeUtc`. When not set explicitly,\n   * the assumed value is the DefaultTimeToLive for the respective queue or topic. A message-level\n   * `timeToLive` value cannot be longer than the entity's DefaultTimeToLive setting and it is\n   * silently adjusted if it does. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-expiration Expiration}.\n   */\n  timeToLive?: number;\n  /**\n   * @property The application specific label. This property enables the\n   * application to indicate the purpose of the message to the receiver in a standardized. fashion,\n   * similar to an email subject line. The mapped AMQP property is \"subject\".\n   */\n  label?: string;\n  /**\n   * @property The \"to\" address. This property is reserved for future use in routing\n   * scenarios and presently ignored by the broker itself. Applications can use this value in\n   * rule-driven {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-auto-forwarding auto-forward chaining}\n   * scenarios to indicate the intended logical destination of the message.\n   */\n  to?: string;\n  /**\n   * @property The address of an entity to send replies to. This optional and\n   * application-defined value is a standard way to express a reply path to the receiver of the\n   * message. When a sender expects a reply, it sets the value to the absolute or relative path of\n   * the queue or topic it expects the reply to be sent to. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.\n   */\n  replyTo?: string;\n  /**\n   * @property The date and time in UTC at which the message will\n   * be enqueued. This property returns the time in UTC; when setting the property, the\n   * supplied DateTime value must also be in UTC. This value is for delayed message sending.\n   * It is utilized to delay messages sending to a specific time in the future. Message enqueuing\n   * time does not mean that the message will be sent at the same time. It will get enqueued,\n   * but the actual sending time depends on the queue's workload and its state.\n   */\n  scheduledEnqueueTimeUtc?: Date;\n  /**\n   * @property The lock token is a reference to the lock that is being held by the broker in\n   * `ReceiveMode.PeekLock` mode. Locks are used internally settle messages as explained in the\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement product documentation in more detail}\n   * - Not applicable when the message is received in `ReceiveMode.receiveAndDelete`\n   * mode.\n   * @readonly\n   */\n  readonly lockToken?: string;\n  /**\n   * @property Number of deliveries that have been attempted for this message. The count is\n   * incremented when a message lock expires, or the message is explicitly abandoned using the\n   * `abandon()` method on the message.\n   * @readonly\n   */\n  readonly deliveryCount?: number;\n  /**\n   * @property The UTC instant at which the message has been accepted and stored in Service Bus.\n   * @readonly\n   */\n  readonly enqueuedTimeUtc?: Date;\n  /**\n   * @property The UTC instant at which the message is marked for removal and no longer available for\n   * retrieval from the entity due to expiration. This property is computed from 2 other properties\n   * on the message: `enqueuedTimeUtc` + `timeToLive`.\n   */\n  readonly expiresAtUtc?: Date;\n  /**\n   * @property The UTC instant until which the message is held locked in the queue/subscription.\n   * When the lock expires, the `deliveryCount` is incremented and the message is again available\n   * for retrieval.\n   * - Not applicable when the message is received in `ReceiveMode.receiveAndDelete`\n   * mode.\n   */\n  lockedUntilUtc?: Date;\n  /**\n   * @property The original sequence number of the message. For\n   * messages that have been auto-forwarded, this property reflects the sequence number that had\n   * first been assigned to the message at its original point of submission.\n   * @readonly\n   */\n  readonly enqueuedSequenceNumber?: number;\n  /**\n   * @property The unique number assigned to a message by Service Bus.\n   * The sequence number is a unique 64-bit integer assigned to a message as it is accepted\n   * and stored by the broker and functions as its true identifier. For partitioned entities,\n   * the topmost 16 bits reflect the partition identifier. Sequence numbers monotonically increase.\n   * They roll over to 0 when the 48-64 bit range is exhausted.\n   * @readonly\n   */\n  readonly sequenceNumber?: Long;\n  /**\n   * @property The name of the queue or subscription that this message\n   * was enqueued on, before it was deadlettered. Only set in messages that have been dead-lettered\n   * and subsequently auto-forwarded from the dead-letter sub-queue to another entity. Indicates the\n   * entity in which the message was dead-lettered.\n   * @readonly\n   */\n  readonly deadLetterSource?: string;\n  /**\n   * The associated delivery of the received message.\n   */\n  readonly delivery: Delivery;\n  /**\n   * @property {AmqpMessage} _amqpMessage The underlying raw amqp message.\n   * @readonly\n   */\n  readonly _amqpMessage: AmqpMessage;\n  /**\n   * @property Boolean denoting if the message has already been settled.\n   * @readonly\n   */\n  public get isSettled(): boolean {\n    return this.delivery.remote_settled;\n  }\n  /**\n   * @property {ClientEntityContext} _context The client entity context.\n   * @readonly\n   */\n  private readonly _context: ClientEntityContext;\n\n  /**\n   * @internal\n   */\n  constructor(\n    context: ClientEntityContext,\n    msg: AmqpMessage,\n    delivery: Delivery,\n    shouldReorderLockToken: boolean\n  ) {\n    Object.assign(this, fromAmqpMessage(msg, delivery, shouldReorderLockToken));\n    this._context = context;\n    if (msg.body) {\n      this.body = this._context.namespace.dataTransformer.decode(msg.body);\n    }\n    this._amqpMessage = msg;\n    this.delivery = delivery;\n  }\n\n  /**\n   * Removes the message from Service Bus.\n   *\n   * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link got closed by the library due to network loss or service error.\n   * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled. To avoid this error check the `isSettled`\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   *\n   * @returns Promise<void>.\n   */\n  async complete(): Promise<void> {\n    log.message(\n      \"[%s] Completing the message with id '%s'.\",\n      this._context.namespace.connectionId,\n      this.messageId\n    );\n    if (this._context.requestResponseLockedMessages.has(this.lockToken!)) {\n      await this._context.managementClient!.updateDispositionStatus(\n        this.lockToken!,\n        DispositionStatus.completed,\n        {\n          sessionId: this.sessionId\n        }\n      );\n\n      // Remove the message from the internal map of deferred messages\n      this._context.requestResponseLockedMessages.delete(this.lockToken!);\n      return;\n    }\n    const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);\n    this.throwIfMessageCannotBeSettled(receiver, DispositionType.complete);\n\n    return receiver!.settleMessage(this, DispositionType.complete);\n  }\n  /**\n   * The lock held on the message by the receiver is let go, making the message available again in\n   * Service Bus for another receive operation.\n   *\n   * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link got closed by the library due to network loss or service error.\n   * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled. To avoid this error check the `isSettled`\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   *\n   * @param propertiesToModify The properties of the message to modify while abandoning the message.\n   *\n   * @return Promise<void>.\n   */\n  async abandon(propertiesToModify?: { [key: string]: any }): Promise<void> {\n    // TODO: Figure out a mechanism to convert specified properties to message_annotations.\n    log.message(\n      \"[%s] Abandoning the message with id '%s'.\",\n      this._context.namespace.connectionId,\n      this.messageId\n    );\n    if (this._context.requestResponseLockedMessages.has(this.lockToken!)) {\n      await this._context.managementClient!.updateDispositionStatus(\n        this.lockToken!,\n        DispositionStatus.abandoned,\n        { propertiesToModify: propertiesToModify, sessionId: this.sessionId }\n      );\n\n      // Remove the message from the internal map of deferred messages\n      this._context.requestResponseLockedMessages.delete(this.lockToken!);\n      return;\n    }\n    const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);\n    this.throwIfMessageCannotBeSettled(receiver, DispositionType.abandon);\n\n    return receiver!.settleMessage(this, DispositionType.abandon, {\n      propertiesToModify: propertiesToModify\n    });\n  }\n\n  /**\n   * Defers the processing of the message. Save the `sequenceNumber` of the message, in order to\n   * receive it message again in the future using the `receiveDeferredMessage` method.\n   *\n   * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link got closed by the library due to network loss or service error.\n   * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled. To avoid this error check the `isSettled`\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   *\n   * @param propertiesToModify The properties of the message to modify while deferring the message\n   *\n   * @returns Promise<void>\n   */\n  async defer(propertiesToModify?: { [key: string]: any }): Promise<void> {\n    log.message(\n      \"[%s] Deferring the message with id '%s'.\",\n      this._context.namespace.connectionId,\n      this.messageId\n    );\n    if (this._context.requestResponseLockedMessages.has(this.lockToken!)) {\n      await this._context.managementClient!.updateDispositionStatus(\n        this.lockToken!,\n        DispositionStatus.defered,\n        { propertiesToModify: propertiesToModify, sessionId: this.sessionId }\n      );\n\n      // Remove the message from the internal map of deferred messages\n      this._context.requestResponseLockedMessages.delete(this.lockToken!);\n      return;\n    }\n    const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);\n    this.throwIfMessageCannotBeSettled(receiver, DispositionType.defer);\n\n    return receiver!.settleMessage(this, DispositionType.defer, {\n      propertiesToModify: propertiesToModify\n    });\n  }\n\n  /**\n   * Moves the message to the deadletter sub-queue. To receive a deadletted message, create a new\n   * QueueClient/SubscriptionClient using the path for the deadletter sub-queue.\n   *\n   * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link got closed by the library due to network loss or service error.\n   * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled. To avoid this error check the `isSettled`\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   *\n   * @param options The DeadLetter options that can be provided while\n   * rejecting the message.\n   *\n   * @returns Promise<void>\n   */\n  async deadLetter(options?: DeadLetterOptions): Promise<void> {\n    const error: AmqpError = {\n      condition: Constants.deadLetterName\n    };\n    if (options) {\n      error.info = {\n        DeadLetterReason: options.deadletterReason,\n        DeadLetterErrorDescription: options.deadLetterErrorDescription\n      };\n    }\n    log.message(\n      \"[%s] Deadlettering the message with id '%s'.\",\n      this._context.namespace.connectionId,\n      this.messageId\n    );\n    if (this._context.requestResponseLockedMessages.has(this.lockToken!)) {\n      await this._context.managementClient!.updateDispositionStatus(\n        this.lockToken!,\n        DispositionStatus.suspended,\n        {\n          deadLetterReason: error.condition,\n          deadLetterDescription: error.description,\n          sessionId: this.sessionId\n        }\n      );\n\n      // Remove the message from the internal map of deferred messages\n      this._context.requestResponseLockedMessages.delete(this.lockToken!);\n      return;\n    }\n    const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);\n    this.throwIfMessageCannotBeSettled(receiver, DispositionType.deadletter);\n\n    return receiver!.settleMessage(this, DispositionType.deadletter, {\n      error: error\n    });\n  }\n\n  /**\n   * Creates a clone of the current message to allow it to be re-sent to the queue\n   * @returns ServiceBusMessage\n   */\n  clone(): SendableMessageInfo {\n    // We are returning a SendableMessageInfo object because that object can then be sent to Service Bus\n    const clone: SendableMessageInfo = {\n      body: this.body,\n      contentType: this.contentType,\n      correlationId: this.correlationId,\n      label: this.label,\n      messageId: this.messageId,\n      partitionKey: this.partitionKey,\n      replyTo: this.replyTo,\n      replyToSessionId: this.replyToSessionId,\n      scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,\n      sessionId: this.sessionId,\n      timeToLive: this.timeToLive,\n      to: this.to,\n      userProperties: this.userProperties,\n      viaPartitionKey: this.viaPartitionKey\n    };\n\n    return clone;\n  }\n\n  /**\n   * @private\n   * Logs and Throws an error if the given message cannot be settled.\n   * @param receiver Receiver to be used to settle this message\n   * @param operation Settle operation: complete, abandon, defer or deadLetter\n   */\n  private throwIfMessageCannotBeSettled(\n    receiver: MessageReceiver | MessageSession | undefined,\n    operation: DispositionType\n  ): void {\n    let error: Error | undefined;\n\n    if (receiver && receiver.receiveMode !== ReceiveMode.peekLock) {\n      error = new Error(\n        getErrorMessageNotSupportedInReceiveAndDeleteMode(`${operation} the message`)\n      );\n    } else if (this.delivery.remote_settled) {\n      error = new Error(`Failed to ${operation} the message as this message is already settled.`);\n    } else if (!receiver || !receiver.isOpen()) {\n      const errorMessage =\n        `Failed to ${operation} the message as the AMQP link with which the message was ` +\n        `received is no longer alive.`;\n      if (this.sessionId != undefined) {\n        error = translate({\n          description: errorMessage,\n          condition: ErrorNameConditionMapper.SessionLockLostError\n        });\n      } else {\n        error = translate({\n          description: errorMessage,\n          condition: ErrorNameConditionMapper.MessageLockLostError\n        });\n      }\n    }\n    if (!error) {\n      return;\n    }\n    log.error(\n      \"[%s] An error occured when settling a message with id '%s'. \" +\n        \"This message was received using the receiver %s which %s currently open: %O\",\n      this._context.namespace.connectionId,\n      this.messageId,\n      this.delivery.link.name,\n      this.delivery.link.is_open() ? \"is\" : \"is not\",\n      error\n    );\n\n    throw error;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { defaultLock } from \"@azure/amqp-common\";\nimport { ClientEntityContext } from \"../clientEntityContext\";\nimport * as log from \"../log\";\nimport { Sender, Receiver } from \"rhea-promise\";\nimport { getUniqueName } from \"../util/utils\";\n\n/**\n * @internal\n * Options passed to the constructor of LinkEntity\n */\nexport interface LinkEntityOptions {\n  /**\n   * @property {string} address The client entity address in one of the following forms:\n   */\n  address?: string;\n  /**\n   * @property {string} audience The client entity token audience in one of the following forms:\n   */\n  audience?: string;\n}\n\n/**\n * @internal\n * Describes the base class for entities like MessageSender, MessageReceiver and Management client.\n * @class ClientEntity\n */\nexport class LinkEntity {\n  /**\n   * @property {string} id The unique name for the entity in the format:\n   * `${name of the entity}-${guid}`.\n   */\n  name: string;\n  /**\n   * @property {string} address The client entity address in one of the following forms:\n   *\n   * **Sender**\n   * - `\"<queue-name>\"`.\n   * - `\"<topic-name>\"`.\n   *\n   * **Receiver**\n   * - `\"<queue-name>\"`.\n   * - `\"<topic-name>\"`.\n   *\n   * **ManagementClient**\n   * -`\"$management\"`.\n   */\n  address: string;\n  /**\n   * @property {string} audience The client entity token audience in one of the following forms:\n   *\n   * **Sender**\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<queue-name>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<topic-name>\"`\n   *\n   * **Receiver**\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<queue-name>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<topic-name>\"`\n   *\n   * **ManagementClient**\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<queue-name>/$management\"`.\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<topic-name>/$management\"`.\n   */\n  audience: string;\n  /**\n   * @property {boolean} isConnecting Indicates whether the link is in the process of connecting\n   * (establishing) itself. Default value: `false`.\n   */\n  isConnecting: boolean = false;\n  /**\n   * @property {ClientEntityContext} _context Provides relevant information about the amqp connection,\n   * cbs and $management sessions, token provider, sender and receivers.\n   * @protected\n   */\n  protected _context: ClientEntityContext;\n  /**\n   * @property {NodeJS.Timer} _tokenRenewalTimer The token renewal timer that keeps track of when\n   * the Client Entity is due for token renewal.\n   * @protected\n   */\n  protected _tokenRenewalTimer?: NodeJS.Timer;\n  /**\n   * Creates a new ClientEntity instance.\n   * @constructor\n   * @param {ClientEntityContext} context The connection context.\n   * @param {LinkEntityOptions} [options] Options that can be provided while creating the LinkEntity.\n   */\n  constructor(name: string, context: ClientEntityContext, options?: LinkEntityOptions) {\n    if (!options) options = {};\n    this._context = context;\n    this.address = options.address || \"\";\n    this.audience = options.audience || \"\";\n    this.name = getUniqueName(name);\n  }\n\n  /**\n   * Negotiates the cbs claim for the ClientEntity.\n   * @protected\n   * @param {boolean} [setTokenRenewal] Set the token renewal timer. Default false.\n   * @return {Promise<void>} Promise<void>\n   */\n  protected async _negotiateClaim(setTokenRenewal?: boolean): Promise<void> {\n    // Acquire the lock and establish a cbs session if it does not exist on the connection.\n    // Although node.js is single threaded, we need a locking mechanism to ensure that a\n    // race condition does not happen while creating a shared resource (in this case the\n    // cbs session, since we want to have exactly 1 cbs session per connection).\n    log.link(\n      \"[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: \" +\n        \"'%s' with address: '%s'.\",\n      this._context.namespace.connectionId,\n      this._context.namespace.cbsSession.cbsLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    await defaultLock.acquire(this._context.namespace.cbsSession.cbsLock, () => {\n      return this._context.namespace.cbsSession.init();\n    });\n    const tokenObject = await this._context.namespace.tokenProvider.getToken(this.audience);\n    log.link(\n      \"[%s] %s: calling negotiateClaim for audience '%s'.\",\n      this._context.namespace.connectionId,\n      this._type,\n      this.audience\n    );\n    // Acquire the lock to negotiate the CBS claim.\n    log.link(\n      \"[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.\",\n      this._context.namespace.connectionId,\n      this._context.namespace.negotiateClaimLock,\n      this._type,\n      this.name,\n      this.address\n    );\n    await defaultLock.acquire(this._context.namespace.negotiateClaimLock, () => {\n      return this._context.namespace.cbsSession.negotiateClaim(this.audience, tokenObject);\n    });\n    log.link(\n      \"[%s] Negotiated claim for %s '%s' with with address: %s\",\n      this._context.namespace.connectionId,\n      this._type,\n      this.name,\n      this.address\n    );\n    if (setTokenRenewal) {\n      await this._ensureTokenRenewal();\n    }\n  }\n\n  /**\n   * Ensures that the token is renewed within the predefined renewal margin.\n   * @protected\n   * @returns {void}\n   */\n  protected async _ensureTokenRenewal(): Promise<void> {\n    const tokenValidTimeInSeconds = this._context.namespace.tokenProvider.tokenValidTimeInSeconds;\n    const tokenRenewalMarginInSeconds = this._context.namespace.tokenProvider\n      .tokenRenewalMarginInSeconds;\n    const nextRenewalTimeout = (tokenValidTimeInSeconds - tokenRenewalMarginInSeconds) * 1000;\n    this._tokenRenewalTimer = setTimeout(async () => {\n      try {\n        await this._negotiateClaim(true);\n      } catch (err) {\n        // TODO: May be add some retries over here before emitting the error.\n        log.error(\n          \"[%s] %s '%s' with address %s, an error occurred while renewing the token: %O\",\n          this._context.namespace.connectionId,\n          this._type,\n          this.name,\n          this.address,\n          err\n        );\n      }\n    }, nextRenewalTimeout);\n    log.link(\n      \"[%s] %s '%s' with address %s, has next token renewal in %d seconds @(%s).\",\n      this._context.namespace.connectionId,\n      this._type,\n      this.name,\n      this.address,\n      nextRenewalTimeout / 1000,\n      new Date(Date.now() + nextRenewalTimeout).toString()\n    );\n  }\n\n  /**\n   * Closes the Sender|Receiver link and it's underlying session and also removes it from the\n   * internal map.\n   *\n   * @param {Sender | Receiver} [link] The Sender or Receiver link that needs to be closed and\n   * removed.\n   */\n  protected async _closeLink(link?: Sender | Receiver): Promise<void> {\n    clearTimeout(this._tokenRenewalTimer as NodeJS.Timer);\n    if (link) {\n      try {\n        // This should take care of closing the link and it's underlying session. This should also\n        // remove them from the internal map.\n        await link.close();\n        log.link(\n          \"[%s] %s '%s' with address '%s' closed.\",\n          this._context.namespace.connectionId,\n          this._type,\n          this.name,\n          this.address\n        );\n      } catch (err) {\n        log.error(\n          \"[%s] An error occurred while closing the %s '%s': %O\",\n          this._context.namespace.connectionId,\n          this._type,\n          this.name,\n          this.address,\n          err\n        );\n      }\n    }\n  }\n\n  /**\n   * Provides the current type of the ClientEntity.\n   * @return {string} The entity type.\n   */\n  private get _type(): string {\n    let result = \"LinkEntity\";\n    if ((this as any).constructor && (this as any).constructor.name) {\n      result = (this as any).constructor.name;\n    }\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"../log\";\nimport {\n  messageProperties,\n  Sender,\n  EventContext,\n  OnAmqpEvent,\n  SenderOptions,\n  SenderEvents,\n  message as RheaMessageUtil,\n  AmqpError,\n  generate_uuid\n} from \"rhea-promise\";\nimport {\n  defaultLock,\n  Func,\n  retry,\n  translate,\n  AmqpMessage,\n  ErrorNameConditionMapper,\n  RetryConfig,\n  RetryOperationType,\n  Constants,\n  randomNumberFromInterval,\n  delay\n} from \"@azure/amqp-common\";\nimport {\n  SendableMessageInfo,\n  toAmqpMessage,\n  getMessagePropertyTypeMismatchError\n} from \"../serviceBusMessage\";\nimport { ClientEntityContext } from \"../clientEntityContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { getUniqueName } from \"../util/utils\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\n\n/**\n * @internal\n */\ninterface CreateSenderOptions {\n  newName?: boolean;\n}\n\n/**\n * @internal\n * Describes the MessageSender that will send messages to ServiceBus.\n * @class MessageSender\n */\nexport class MessageSender extends LinkEntity {\n  /**\n   * @property {string} senderLock The unqiue lock name per connection that is used to acquire the\n   * lock for establishing a sender link by an entity on that connection.\n   * @readonly\n   */\n  readonly senderLock: string = `sender-${generate_uuid()}`;\n  /**\n   * @property {OnAmqpEvent} _onAmqpError The handler function to handle errors that happen on the\n   * underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onAmqpClose The handler function to handle \"sender_close\" event\n   * that happens on the underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpClose: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onSessionError The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_error\" event.\n   * @private\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onSessionClose The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_close\" event.\n   * @private\n   */\n  private _onSessionClose: OnAmqpEvent;\n  /**\n   * @property {Sender} [_sender] The AMQP sender link.\n   * @private\n   */\n  private _sender?: Sender;\n\n  /**\n   * Creates a new MessageSender instance.\n   * @constructor\n   * @param {ClientEntityContext} context The client entity context.\n   */\n  constructor(context: ClientEntityContext) {\n    super(context.entityPath, context, {\n      address: context.entityPath,\n      audience: `${context.namespace.config.endpoint}${context.entityPath}`\n    });\n    this._onAmqpError = (context: EventContext) => {\n      const senderError = context.sender && context.sender.error;\n      if (senderError) {\n        const err = translate(senderError);\n        log.error(\n          \"[%s] An error occurred for sender '%s': %O.\",\n          this._context.namespace.connectionId,\n          this.name,\n          err\n        );\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const err = translate(sessionError);\n        log.error(\n          \"[%s] An error occurred on the session of sender '%s': %O.\",\n          this._context.namespace.connectionId,\n          this.name,\n          err\n        );\n      }\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const sender = this._sender || context.sender!;\n      const senderError = context.sender && context.sender.error;\n      if (senderError) {\n        log.error(\n          \"[%s] 'sender_close' event occurred for sender '%s' with address '%s'. \" +\n            \"The associated error is: %O\",\n          this._context.namespace.connectionId,\n          this.name,\n          this.address,\n          senderError\n        );\n      }\n      if (sender && !sender.isItselfClosed()) {\n        if (!this.isConnecting) {\n          log.error(\n            \"[%s] 'sender_close' event occurred on the sender '%s' with address '%s' \" +\n              \"and the sdk did not initiate this. The sender is not reconnecting. Hence, calling \" +\n              \"detached from the _onAmqpClose() handler.\",\n            this._context.namespace.connectionId,\n            this.name,\n            this.address\n          );\n          await this.onDetached(senderError);\n        } else {\n          log.error(\n            \"[%s] 'sender_close' event occurred on the sender '%s' with address '%s' \" +\n              \"and the sdk did not initate this. Moreover the sender is already re-connecting. \" +\n              \"Hence not calling detached from the _onAmqpClose() handler.\",\n            this._context.namespace.connectionId,\n            this.name,\n            this.address\n          );\n        }\n      } else {\n        log.error(\n          \"[%s] 'sender_close' event occurred on the sender '%s' with address '%s' \" +\n            \"because the sdk initiated it. Hence not calling detached from the _onAmqpClose\" +\n            \"() handler.\",\n          this._context.namespace.connectionId,\n          this.name,\n          this.address\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const sender = this._sender || context.sender!;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        log.error(\n          \"[%s] 'session_close' event occurred for sender '%s' with address '%s'. \" +\n            \"The associated error is: %O\",\n          this._context.namespace.connectionId,\n          this.name,\n          this.address,\n          sessionError\n        );\n      }\n      if (sender && !sender.isSessionItselfClosed()) {\n        if (!this.isConnecting) {\n          log.error(\n            \"[%s] 'session_close' event occurred on the session of sender '%s' with \" +\n              \"address '%s' and the sdk did not initiate this. Hence calling detached from the \" +\n              \"_onSessionClose() handler.\",\n            this._context.namespace.connectionId,\n            this.name,\n            this.address\n          );\n          await this.onDetached(sessionError);\n        } else {\n          log.error(\n            \"[%s] 'session_close' event occurred on the session of sender '%s' with \" +\n              \"address '%s' and the sdk did not initiate this. Moreover the sender is already \" +\n              \"re-connecting. Hence not calling detached from the _onSessionClose() handler.\",\n            this._context.namespace.connectionId,\n            this.name,\n            this.address\n          );\n        }\n      } else {\n        log.error(\n          \"[%s] 'session_close' event occurred on the session of sender '%s' with address \" +\n            \"'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose\" +\n            \"() handler.\",\n          this._context.namespace.connectionId,\n          this.name,\n          this.address\n        );\n      }\n    };\n  }\n\n  private _deleteFromCache(): void {\n    this._sender = undefined;\n    delete this._context.sender;\n    log.error(\n      \"[%s] Deleted the sender '%s' with address '%s' from the client cache.\",\n      this._context.namespace.connectionId,\n      this.name,\n      this.address\n    );\n  }\n\n  private _createSenderOptions(options: CreateSenderOptions): SenderOptions {\n    if (options.newName) this.name = getUniqueName(this._context.entityPath);\n    const srOptions: SenderOptions = {\n      name: this.name,\n      target: {\n        address: this.address\n      },\n      onError: this._onAmqpError,\n      onClose: this._onAmqpClose,\n      onSessionError: this._onSessionError,\n      onSessionClose: this._onSessionClose\n    };\n    log.sender(\"Creating sender with options: %O\", srOptions);\n    return srOptions;\n  }\n\n  /**\n   * Tries to send the message to ServiceBus if there is enough credit to send them\n   * and the circular buffer has available space to settle the message after sending them.\n   *\n   * We have implemented a synchronous send over here in the sense that we shall be waiting\n   * for the message to be accepted or rejected and accordingly resolve or reject the promise.\n   *\n   * @param encodedMessage The encoded message to be sent to ServiceBus.\n   * @param sendBatch Boolean indicating whether the encoded message represents a batch of messages or not\n   * @return {Promise<Delivery>} Promise<Delivery>\n   */\n  private _trySend(encodedMessage: Buffer, sendBatch?: boolean): Promise<void> {\n    const sendEventPromise = () =>\n      new Promise<void>(async (resolve, reject) => {\n        let waitTimer: any;\n        log.sender(\n          \"[%s] Sender '%s', credit: %d available: %d\",\n          this._context.namespace.connectionId,\n          this.name,\n          this._sender!.credit,\n          this._sender!.session.outgoing.available()\n        );\n        if (!this._sender!.sendable()) {\n          log.sender(\n            \"[%s] Sender '%s', waiting for 1 second for sender to become sendable\",\n            this._context.namespace.connectionId,\n            this.name\n          );\n\n          await delay(1000);\n\n          log.sender(\n            \"[%s] Sender '%s' after waiting for a second, credit: %d available: %d\",\n            this._context.namespace.connectionId,\n            this.name,\n            this._sender!.credit,\n            this._sender!.session.outgoing.available()\n          );\n        }\n        if (this._sender!.sendable()) {\n          let onRejected: Func<EventContext, void>;\n          let onReleased: Func<EventContext, void>;\n          let onModified: Func<EventContext, void>;\n          let onAccepted: Func<EventContext, void>;\n          const removeListeners = (): void => {\n            clearTimeout(waitTimer);\n            // When `removeListeners` is called on timeout, the sender might be closed and cleared\n            // So, check if it exists, before removing listeners from it.\n            if (this._sender) {\n              this._sender.removeListener(SenderEvents.rejected, onRejected);\n              this._sender.removeListener(SenderEvents.accepted, onAccepted);\n              this._sender.removeListener(SenderEvents.released, onReleased);\n              this._sender.removeListener(SenderEvents.modified, onModified);\n            }\n          };\n\n          onAccepted = (context: EventContext) => {\n            // Since we will be adding listener for accepted and rejected event every time\n            // we send a message, we need to remove listener for both the events.\n            // This will ensure duplicate listeners are not added for the same event.\n            removeListeners();\n            log.sender(\n              \"[%s] Sender '%s', got event accepted.\",\n              this._context.namespace.connectionId,\n              this.name\n            );\n            resolve();\n          };\n          onRejected = (context: EventContext) => {\n            removeListeners();\n            log.error(\n              \"[%s] Sender '%s', got event rejected.\",\n              this._context.namespace.connectionId,\n              this.name\n            );\n            const err = translate(context!.delivery!.remote_state!.error);\n            reject(err);\n          };\n          onReleased = (context: EventContext) => {\n            removeListeners();\n            log.error(\n              \"[%s] Sender '%s', got event released.\",\n              this._context.namespace.connectionId,\n              this.name\n            );\n            let err: Error;\n            if (context!.delivery!.remote_state!.error) {\n              err = translate(context!.delivery!.remote_state!.error);\n            } else {\n              err = new Error(\n                `[${this._context.namespace.connectionId}]Sender '${this.name}', ` +\n                  `received a release disposition.Hence we are rejecting the promise.`\n              );\n            }\n            reject(err);\n          };\n          onModified = (context: EventContext) => {\n            removeListeners();\n            log.error(\n              \"[%s] Sender '%s', got event modified.\",\n              this._context.namespace.connectionId,\n              this.name\n            );\n            let err: Error;\n            if (context!.delivery!.remote_state!.error) {\n              err = translate(context!.delivery!.remote_state!.error);\n            } else {\n              err = new Error(\n                `[${this._context.namespace.connectionId}]Sender \"${this.name}\", ` +\n                  `received a modified disposition.Hence we are rejecting the promise.`\n              );\n            }\n            reject(err);\n          };\n\n          const actionAfterTimeout = () => {\n            removeListeners();\n            const desc: string =\n              `[${this._context.namespace.connectionId}] Sender \"${this.name}\" ` +\n              `with address \"${this.address}\", was not able to send the message right now, due ` +\n              `to operation timeout.`;\n            log.error(desc);\n            const e: AmqpError = {\n              condition: ErrorNameConditionMapper.ServiceUnavailableError,\n              description: desc\n            };\n            return reject(translate(e));\n          };\n\n          this._sender!.on(SenderEvents.accepted, onAccepted);\n          this._sender!.on(SenderEvents.rejected, onRejected);\n          this._sender!.on(SenderEvents.modified, onModified);\n          this._sender!.on(SenderEvents.released, onReleased);\n          waitTimer = setTimeout(\n            actionAfterTimeout,\n            Constants.defaultOperationTimeoutInSeconds * 1000\n          );\n          try {\n            const delivery = this._sender!.send(\n              encodedMessage,\n              undefined,\n              sendBatch ? 0x80013700 : 0\n            );\n            log.sender(\n              \"[%s] Sender '%s', sent message with delivery id: %d\",\n              this._context.namespace.connectionId,\n              this.name,\n              delivery.id\n            );\n          } catch (error) {\n            removeListeners();\n            return reject(error);\n          }\n        } else {\n          // let us retry to send the message after some time.\n          const msg =\n            `[${this._context.namespace.connectionId}] Sender \"${this.name}\", ` +\n            `cannot send the message right now. Please try later.`;\n          log.error(msg);\n          const amqpError: AmqpError = {\n            condition: ErrorNameConditionMapper.SenderBusyError,\n            description: msg\n          };\n          reject(translate(amqpError));\n        }\n      });\n\n    const jitterInSeconds = randomNumberFromInterval(1, 4);\n    const config: RetryConfig<void> = {\n      operation: sendEventPromise,\n      connectionId: this._context.namespace.connectionId!,\n      operationType: RetryOperationType.sendMessage,\n      times: Constants.defaultRetryAttempts,\n      delayInSeconds: Constants.defaultDelayBetweenOperationRetriesInSeconds + jitterInSeconds\n    };\n\n    return retry<void>(config);\n  }\n\n  /**\n   * Initializes the sender session on the connection.\n   */\n  private async _init(options?: SenderOptions): Promise<void> {\n    try {\n      // isOpen isConnecting  Should establish\n      // true     false          No\n      // true     true           No\n      // false    true           No\n      // false    false          Yes\n      if (!this.isOpen()) {\n        log.error(\n          \"[%s] The sender '%s' with address '%s' is not open and is not currently \" +\n            \"establishing itself. Hence let's try to connect.\",\n          this._context.namespace.connectionId,\n          this.name,\n          this.address\n        );\n        this.isConnecting = true;\n        await this._negotiateClaim();\n        log.error(\n          \"[%s] Trying to create sender '%s'...\",\n          this._context.namespace.connectionId,\n          this.name\n        );\n        if (!options) {\n          options = this._createSenderOptions({});\n        }\n        this._sender = await this._context.namespace.connection.createSender(options);\n        this.isConnecting = false;\n        log.error(\n          \"[%s] Sender '%s' with address '%s' has established itself.\",\n          this._context.namespace.connectionId,\n          this.name,\n          this.address\n        );\n        this._sender.setMaxListeners(1000);\n        log.error(\n          \"[%s] Promise to create the sender resolved. Created sender with name: %s\",\n          this._context.namespace.connectionId,\n          this.name\n        );\n        log.error(\n          \"[%s] Sender '%s' created with sender options: %O\",\n          this._context.namespace.connectionId,\n          this.name,\n          options\n        );\n        // It is possible for someone to close the sender and then start it again.\n        // Thus make sure that the sender is present in the client cache.\n        if (!this._sender) this._context.sender = this;\n        await this._ensureTokenRenewal();\n      }\n    } catch (err) {\n      err = translate(err);\n      log.error(\n        \"[%s] An error occurred while creating the sender %s\",\n        this._context.namespace.connectionId,\n        this.name,\n        err\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Will reconnect the sender link if necessary.\n   * @param {AmqpError | Error} [senderError] The sender error if any.\n   * @returns {Promise<void>} Promise<void>.\n   */\n  async onDetached(senderError?: AmqpError | Error): Promise<void> {\n    try {\n      const wasCloseInitiated = this._sender && this._sender.isItselfClosed();\n      // Clears the token renewal timer. Closes the link and its session if they are open.\n      // Removes the link and its session if they are present in rhea's cache.\n      await this._closeLink(this._sender);\n      // We should attempt to reopen only when the sender(sdk) did not initiate the close\n      let shouldReopen = false;\n      if (senderError && !wasCloseInitiated) {\n        const translatedError = translate(senderError);\n        if (translatedError.retryable) {\n          shouldReopen = true;\n          log.error(\n            \"[%s] close() method of Sender '%s' with address '%s' was not called. There \" +\n              \"was an accompanying error an it is retryable. This is a candidate for re-establishing \" +\n              \"the sender link.\",\n            this._context.namespace.connectionId,\n            this.name,\n            this.address\n          );\n        } else {\n          log.error(\n            \"[%s] close() method of Sender '%s' with address '%s' was not called. There \" +\n              \"was an accompanying error and it is NOT retryable. Hence NOT re-establishing \" +\n              \"the sender link.\",\n            this._context.namespace.connectionId,\n            this.name,\n            this.address\n          );\n        }\n      } else if (!wasCloseInitiated) {\n        shouldReopen = true;\n        log.error(\n          \"[%s] close() method of Sender '%s' with address '%s' was not called. There \" +\n            \"was no accompanying error as well. This is a candidate for re-establishing \" +\n            \"the sender link.\",\n          this._context.namespace.connectionId,\n          this.name,\n          this.address\n        );\n      } else {\n        const state: any = {\n          wasCloseInitiated: wasCloseInitiated,\n          senderError: senderError,\n          _sender: this._sender\n        };\n        log.error(\n          \"[%s] Something went wrong. State of sender '%s' with address '%s' is: %O\",\n          this._context.namespace.connectionId,\n          this.name,\n          this.address,\n          state\n        );\n      }\n      if (shouldReopen) {\n        await defaultLock.acquire(this.senderLock, () => {\n          const options: SenderOptions = this._createSenderOptions({\n            newName: true\n          });\n          // shall retry forever at an interval of 15 seconds if the error is a retryable error\n          // else bail out when the error is not retryable or the oepration succeeds.\n          const config: RetryConfig<void> = {\n            operation: () => this._init(options),\n            connectionId: this._context.namespace.connectionId!,\n            operationType: RetryOperationType.senderLink,\n            times: Constants.defaultConnectionRetryAttempts,\n            connectionHost: this._context.namespace.config.host,\n            delayInSeconds: 15\n          };\n          return retry<void>(config);\n        });\n      }\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while processing detached() of Sender '%s' with address \" +\n          \"'%s': %O\",\n        this._context.namespace.connectionId,\n        this.name,\n        this.address,\n        err\n      );\n    }\n  }\n\n  /**\n   * Deletes the sender fromt the context. Clears the token renewal timer. Closes the sender link.\n   * @return {Promise<void>} Promise<void>\n   */\n  async close(): Promise<void> {\n    if (this._sender) {\n      log.sender(\n        \"[%s] Closing the Sender for the entity '%s'.\",\n        this._context.namespace.connectionId,\n        this._context.entityPath\n      );\n      const senderLink = this._sender;\n      this._deleteFromCache();\n      await this._closeLink(senderLink);\n    }\n  }\n\n  /**\n   * Determines whether the AMQP sender link is open. If open then returns true else returns false.\n   * @return {boolean} boolean\n   */\n  isOpen(): boolean {\n    const result: boolean = this._sender! && this._sender!.isOpen();\n    log.error(\n      \"[%s] Sender '%s' with address '%s' is open? -> %s\",\n      this._context.namespace.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Sends the given message, with the given options on this link\n   *\n   * @param {SendableMessageInfo} data Message to send.  Will be sent as UTF8-encoded JSON string.\n   * @returns {Promise<void>}\n   */\n  async send(data: SendableMessageInfo): Promise<void> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    try {\n      if (!this.isOpen()) {\n        log.sender(\n          \"Acquiring lock %s for initializing the session, sender and \" +\n            \"possibly the connection.\",\n          this.senderLock\n        );\n        await defaultLock.acquire(this.senderLock, () => {\n          return this._init();\n        });\n      }\n      const amqpMessage = toAmqpMessage(data);\n      amqpMessage.body = this._context.namespace.dataTransformer.encode(data.body);\n\n      let encodedMessage;\n      try {\n        encodedMessage = RheaMessageUtil.encode(amqpMessage);\n      } catch (error) {\n        if (error instanceof TypeError || error.name === \"TypeError\") {\n          // `RheaMessageUtil.encode` can fail if message properties are of invalid type\n          // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too\n          // Errors in such cases do not have user friendy message or call stack\n          // So use `getMessagePropertyTypeMismatchError` to get a better error message\n          throw getMessagePropertyTypeMismatchError(data) || error;\n        }\n        throw error;\n      }\n      log.sender(\n        \"[%s] Sender '%s', trying to send message: %O\",\n        this._context.namespace.connectionId,\n        this.name,\n        data\n      );\n      return await this._trySend(encodedMessage);\n    } catch (err) {\n      log.error(\n        \"[%s] Sender '%s': An error occurred while sending the message: %O\\nError: %O\",\n        this._context.namespace.connectionId,\n        this.name,\n        data,\n        err\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Send a batch of Message to the ServiceBus in a single AMQP message. The \"message_annotations\",\n   * \"application_properties\" and \"properties\" of the first message will be set as that\n   * of the envelope (batch message).\n   * @param {Array<Message>} inputMessages  An array of Message objects to be sent in a\n   * Batch message.\n   * @return {Promise<void>}\n   */\n  async sendBatch(inputMessages: SendableMessageInfo[]): Promise<void> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    try {\n      if (!Array.isArray(inputMessages)) {\n        inputMessages = [inputMessages];\n      }\n\n      if (!this.isOpen()) {\n        log.sender(\n          \"Acquiring lock %s for initializing the session, sender and \" +\n            \"possibly the connection.\",\n          this.senderLock\n        );\n        await defaultLock.acquire(this.senderLock, () => {\n          return this._init();\n        });\n      }\n      log.sender(\n        \"[%s] Sender '%s', trying to send Message[]: %O\",\n        this._context.namespace.connectionId,\n        this.name,\n        inputMessages\n      );\n      const amqpMessages: AmqpMessage[] = [];\n      const encodedMessages = [];\n      // Convert Message to AmqpMessage.\n      for (let i = 0; i < inputMessages.length; i++) {\n        const amqpMessage = toAmqpMessage(inputMessages[i]);\n        amqpMessage.body = this._context.namespace.dataTransformer.encode(inputMessages[i].body);\n        amqpMessages[i] = amqpMessage;\n        try {\n          encodedMessages[i] = RheaMessageUtil.encode(amqpMessage);\n        } catch (error) {\n          if (error instanceof TypeError || error.name === \"TypeError\") {\n            throw getMessagePropertyTypeMismatchError(inputMessages[i]) || error;\n          }\n          throw error;\n        }\n      }\n\n      // Convert every encoded message to amqp data section\n      const batchMessage: AmqpMessage = {\n        body: RheaMessageUtil.data_sections(encodedMessages)\n      };\n      // Set message_annotations, application_properties and properties of the first message as\n      // that of the envelope (batch message).\n      if (amqpMessages[0].message_annotations) {\n        batchMessage.message_annotations = amqpMessages[0].message_annotations;\n      }\n      if (amqpMessages[0].application_properties) {\n        batchMessage.application_properties = amqpMessages[0].application_properties;\n      }\n      for (const prop of messageProperties) {\n        if ((amqpMessages[0] as any)[prop]) {\n          (batchMessage as any)[prop] = (amqpMessages[0] as any)[prop];\n        }\n      }\n\n      // Finally encode the envelope (batch message).\n      const encodedBatchMessage = RheaMessageUtil.encode(batchMessage);\n      log.sender(\n        \"[%s]Sender '%s', sending encoded batch message.\",\n        this._context.namespace.connectionId,\n        this.name,\n        encodedBatchMessage\n      );\n      return await this._trySend(encodedBatchMessage, true);\n    } catch (err) {\n      log.error(\n        \"[%s] Sender '%s': An error occurred while sending the messages: %O\\nError: %O\",\n        this._context.namespace.connectionId,\n        this.name,\n        inputMessages,\n        err\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Creates a new sender to the specifiec ServiceBus entity, and optionally to a given\n   * partition if it is not present in the context or returns the one present in the context.\n   * @static\n   * @returns {Promise<MessageSender>}\n   */\n  static create(context: ClientEntityContext): MessageSender {\n    throwErrorIfConnectionClosed(context.namespace);\n    if (!context.sender) {\n      context.sender = new MessageSender(context);\n    }\n    return context.sender;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport Long from \"long\";\nimport * as log from \"./log\";\nimport { MessageSender } from \"./core/messageSender\";\nimport { SendableMessageInfo } from \"./serviceBusMessage\";\nimport { ClientEntityContext } from \"./clientEntityContext\";\nimport {\n  getSenderClosedErrorMsg,\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n  throwTypeErrorIfParameterNotLongArray\n} from \"./util/errors\";\n\n/**\n * The Sender class can be used to send messages, schedule messages to be sent at a later time\n * and cancel such scheduled messages.\n * Use the `createSender` function on the QueueClient or TopicClient to instantiate a Sender.\n * The Sender class is an abstraction over the underlying AMQP sender link.\n * @class Sender\n */\nexport class Sender {\n  /**\n   * @property Describes the amqp connection context for the Client.\n   */\n  private _context: ClientEntityContext;\n  /**\n   * @property Denotes if close() was called on this sender\n   */\n  private _isClosed: boolean = false;\n\n  /**\n   * @internal\n   * @throws Error if the underlying connection is closed.\n   */\n  constructor(context: ClientEntityContext) {\n    throwErrorIfConnectionClosed(context.namespace);\n    this._context = context;\n  }\n\n  private _throwIfSenderOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    if (this.isClosed) {\n      const errorMessage = getSenderClosedErrorMsg(\n        this._context.entityPath,\n        this._context.clientType,\n        this._context.isClosed\n      );\n      const error = new Error(errorMessage);\n      log.error(`[${this._context.namespace.connectionId}] %O`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * @property Returns `true` if either the sender or the client that created it has been closed\n   * @readonly\n   */\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.isClosed;\n  }\n\n  /**\n   * Sends the given message after creating an AMQP Sender link if it doesnt already exists.\n   *\n   * To send a message to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`\n   * and/or `partitionKey` properties respectively on the message.\n   *\n   * @param message - Message to send.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws MessagingError if the service returns an error while sending messages to the service.\n   */\n  async send(message: SendableMessageInfo): Promise<void> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, \"message\", message);\n    const sender = MessageSender.create(this._context);\n    return sender.send(message);\n  }\n\n  /**\n   * Sends the given messages in a single batch i.e. in a single AMQP message after creating an AMQP\n   * Sender link if it doesnt already exists.\n   *\n   * - To send messages to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`\n   * and/or `partitionKey` properties respectively on the messages.\n   * - When doing so, all\n   * messages in the batch should have the same `sessionId` (if using sessions) and the same\n   * `parititionKey` (if using paritions).\n   *\n   * @param messages - An array of SendableMessageInfo objects to be sent in a Batch message.\n   * @return Promise<void>\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws MessagingError if the service returns an error while sending messages to the service.\n   */\n  async sendBatch(messages: SendableMessageInfo[]): Promise<void> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, \"messages\", messages);\n    if (!Array.isArray(messages)) {\n      messages = [messages];\n    }\n    const sender = MessageSender.create(this._context);\n    return sender.sendBatch(messages);\n  }\n\n  /**\n   * Schedules given message to appear on Service Bus Queue/Subscription at a later time.\n   *\n   * Please note that you need to explicitly encode the message body if you intend to receive the message using a tool or library other than this library.\n   * For example:\n   *  1. Import DefaultDataTransformer and instantiate.\n   *      ```js\n   *        const dt = new DefaultDataTransformer();\n   *      ```\n   *  2. Use the `encode` method on the transformer to encode the message body before calling the scheduleMessage() method\n   *      ```js\n   *        message.body = dt.encode(message.body);\n   *      ```\n   *\n   * @param scheduledEnqueueTimeUtc - The UTC time at which the message should be enqueued.\n   * @param message - The message that needs to be scheduled.\n   * @returns Promise<Long> - The sequence number of the message that was scheduled.\n   * You will need the sequence number if you intend to cancel the scheduling of the message.\n   * Save the `Long` type as-is in your application without converting to number. Since JavaScript\n   * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws MessagingError if the service returns an error while scheduling a message.\n   */\n  async scheduleMessage(\n    scheduledEnqueueTimeUtc: Date,\n    message: SendableMessageInfo\n  ): Promise<Long> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.namespace.connectionId,\n      \"scheduledEnqueueTimeUtc\",\n      scheduledEnqueueTimeUtc\n    );\n    throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, \"message\", message);\n\n    const messages = [message];\n    const result = await this._context.managementClient!.scheduleMessages(\n      scheduledEnqueueTimeUtc,\n      messages\n    );\n    return result[0];\n  }\n\n  /**\n   * Schedules given messages to appear on Service Bus Queue/Subscription at a later time.\n   *\n   * Please note that you need to explicitly encode the message body if you intend to receive the message using a tool or library other than this library.\n   * For example:\n   *  1. Import DefaultDataTransformer and instantiate.\n   *      ```js\n   *        const dt = new DefaultDataTransformer();\n   *      ```\n   *  2. Use the `encode` method on the transformer to encode the message body before calling the scheduleMessage() method\n   *      ```js\n   *        message.body = dt.encode(message.body);\n   *      ```\n   *\n   * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.\n   * @param messages - Array of Messages that need to be scheduled.\n   * @returns Promise<Long[]> - The sequence numbers of messages that were scheduled.\n   * You will need the sequence number if you intend to cancel the scheduling of the messages.\n   * Save the `Long` type as-is in your application without converting to number. Since JavaScript\n   * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws MessagingError if the service returns an error while scheduling messages.\n   */\n  async scheduleMessages(\n    scheduledEnqueueTimeUtc: Date,\n    messages: SendableMessageInfo[]\n  ): Promise<Long[]> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.namespace.connectionId,\n      \"scheduledEnqueueTimeUtc\",\n      scheduledEnqueueTimeUtc\n    );\n    throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, \"messages\", messages);\n    if (!Array.isArray(messages)) {\n      messages = [messages];\n    }\n\n    return this._context.managementClient!.scheduleMessages(scheduledEnqueueTimeUtc, messages);\n  }\n\n  /**\n   * Cancels a message that was scheduled to appear on a ServiceBus Queue/Subscription.\n   * @param sequenceNumber - The sequence number of the message to be cancelled.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws MessagingError if the service returns an error while canceling a scheduled message.\n   */\n  async cancelScheduledMessage(sequenceNumber: Long): Promise<void> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.namespace.connectionId,\n      \"sequenceNumber\",\n      sequenceNumber\n    );\n    throwTypeErrorIfParameterNotLong(\n      this._context.namespace.connectionId,\n      \"sequenceNumber\",\n      sequenceNumber\n    );\n\n    return this._context.managementClient!.cancelScheduledMessages([sequenceNumber]);\n  }\n\n  /**\n   * Cancels multiple messages that were scheduled to appear on a ServiceBus Queue/Subscription.\n   * @param sequenceNumbers - An Array of sequence numbers of the messages to be cancelled.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws MessagingError if the service returns an error while canceling scheduled messages.\n   */\n  async cancelScheduledMessages(sequenceNumbers: Long[]): Promise<void> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.namespace.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n    if (!Array.isArray(sequenceNumbers)) {\n      sequenceNumbers = [sequenceNumbers];\n    }\n    throwTypeErrorIfParameterNotLongArray(\n      this._context.namespace.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n\n    return this._context.managementClient!.cancelScheduledMessages(sequenceNumbers);\n  }\n\n  /**\n   * Closes the underlying AMQP sender link.\n   * Once closed, the sender cannot be used for any further operations.\n   * Use the `createSender` function on the QueueClient or TopicClient to instantiate a new Sender\n   *\n   * @returns {Promise<void>}\n   */\n  async close(): Promise<void> {\n    try {\n      this._isClosed = true;\n      if (\n        this._context.namespace.connection &&\n        this._context.namespace.connection.isOpen() &&\n        this._context.sender\n      ) {\n        await this._context.sender.close();\n      }\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while closing the Sender for %s: %O\",\n        this._context.namespace.connectionId,\n        this._context.entityPath,\n        err\n      );\n      throw err;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {\n  translate,\n  Constants,\n  MessagingError,\n  retry,\n  RetryOperationType,\n  RetryConfig,\n  ConditionErrorNameMapper,\n  ErrorNameConditionMapper\n} from \"@azure/amqp-common\";\nimport {\n  Receiver,\n  OnAmqpEvent,\n  EventContext,\n  ReceiverOptions,\n  AmqpError,\n  isAmqpError\n} from \"rhea-promise\";\nimport * as log from \"../log\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { ClientEntityContext } from \"../clientEntityContext\";\nimport { ServiceBusMessage, DispositionType, ReceiveMode } from \"../serviceBusMessage\";\nimport { getUniqueName, calculateRenewAfterDuration } from \"../util/utils\";\nimport { MessageHandlerOptions } from \"./streamingReceiver\";\n\n/**\n * @internal\n */\ninterface CreateReceiverOptions {\n  onMessage: OnAmqpEventAsPromise;\n  onClose: OnAmqpEventAsPromise;\n  onSessionClose: OnAmqpEventAsPromise;\n  onError: OnAmqpEvent;\n  onSettled: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n}\n\n/**\n * @internal\n */\nexport interface OnAmqpEventAsPromise extends OnAmqpEvent {\n  (context: EventContext): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport interface PromiseLike {\n  resolve: (value?: any) => void;\n  reject: (reason?: any) => void;\n  timer: NodeJS.Timer;\n}\n\n/**\n * @internal\n */\nexport interface DispositionOptions {\n  propertiesToModify?: { [key: string]: any };\n  error?: AmqpError;\n}\n\n/**\n * @internal\n */\nexport enum ReceiverType {\n  batching = \"batching\",\n  streaming = \"streaming\"\n}\n\n/**\n * @internal\n */\nexport interface ReceiveOptions extends MessageHandlerOptions {\n  /**\n   * @property {number} [receiveMode] The mode in which messages should be received.\n   * Default: ReceiveMode.peekLock\n   */\n  receiveMode?: ReceiveMode;\n}\n\n/**\n * Describes the signature of the message handler passed to `registerMessageHandler` method.\n */\nexport interface OnMessage {\n  /**\n   * Handler for processing each incoming message.\n   */\n  (message: ServiceBusMessage): Promise<void>;\n}\n\n/**\n * Describes the signature of the error handler passed to `registerMessageHandler` method.\n */\nexport interface OnError {\n  /**\n   * Handler for any error that occurs while receiving or processing messages.\n   */\n  (error: MessagingError | Error): void;\n}\n\n/**\n * @internal\n * Describes the MessageReceiver that will receive messages from ServiceBus.\n * @class MessageReceiver\n */\nexport class MessageReceiver extends LinkEntity {\n  /**\n   * @property {string} receiverType The type of receiver: \"batching\" or \"streaming\".\n   */\n  receiverType: ReceiverType;\n  /**\n   * @property {number} [maxConcurrentCalls] The maximum number of messages that should be\n   * processed concurrently while in streaming mode. Once this limit has been reached, more\n   * messages will not be received until the user's message handler has completed processing current message.\n   * Default: 1\n   */\n  maxConcurrentCalls: number = 1;\n  /**\n   * @property {number} [receiveMode] The mode in which messages should be received.\n   * Default: ReceiveMode.peekLock\n   */\n  receiveMode: ReceiveMode;\n  /**\n   * @property {boolean} autoComplete Indicates whether `Message.complete()` should be called\n   * automatically after the message processing is complete while receiving messages with handlers.\n   * Default: false.\n   */\n  autoComplete: boolean;\n  /**\n   * @property {number} maxAutoRenewDurationInSeconds The maximum duration within which the\n   * lock will be renewed automatically. This value should be greater than the longest message\n   * lock duration; for example, the `lockDuration` property on the received message.\n   *\n   * Default: `300` (5 minutes);\n   */\n  maxAutoRenewDurationInSeconds: number;\n  /**\n   * @property {number} [newMessageWaitTimeoutInSeconds] The maximum amount of idle time the\n   * receiver will wait after a message has been received. If no messages are received by this\n   * time then the receive operation will end.\n   */\n  newMessageWaitTimeoutInSeconds?: number;\n  /**\n   * @property {boolean} autoRenewLock Should lock renewal happen automatically.\n   */\n  autoRenewLock: boolean;\n  /**\n   * @property {Receiver} [_receiver] The AMQP receiver link.\n   * @protected\n   */\n  protected _receiver?: Receiver;\n  /**\n   * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that\n   * are being actively disposed. It acts as a store for correlating the responses received for\n   * active dispositions.\n   */\n  protected _deliveryDispositionMap: Map<number, PromiseLike> = new Map<number, PromiseLike>();\n  /**\n   * @property {OnMessage} _onMessage The message handler provided by the user that will be wrapped\n   * inside _onAmqpMessage.\n   * @protected\n   */\n  protected _onMessage!: OnMessage;\n  /**\n   * @property {OnMessage} _onError The error handler provided by the user that will be wrapped\n   * inside _onAmqpError.\n   * @protected\n   */\n  protected _onError?: OnError;\n  /**\n   * @property {OnAmqpEventAsPromise} _onAmqpMessage The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"message\" event.\n   * @protected\n   */\n  protected _onAmqpMessage: OnAmqpEventAsPromise;\n  /**\n   * @property {OnAmqpEventAsPromise} _onAmqpClose The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_close\" event.\n   * @protected\n   */\n  protected _onAmqpClose: OnAmqpEventAsPromise;\n  /**\n   * @property {OnAmqpEvent} _onSessionError The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_error\" event.\n   * @protected\n   */\n  protected _onSessionError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEventAsPromise} _onSessionClose The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_close\" event.\n   * @protected\n   */\n  protected _onSessionClose: OnAmqpEventAsPromise;\n  /**\n   * @property {OnAmqpEvent} _onAmqpError The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_error\" event.\n   * @protected\n   */\n  protected _onAmqpError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onSettled The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"settled\" event.\n   * @protected\n   */\n  protected _onSettled: OnAmqpEvent;\n  /**\n   * @property {boolean} wasCloseInitiated Denotes if receiver was explicitly closed by user.\n   * @protected\n   */\n  protected wasCloseInitiated?: boolean;\n  /**\n   * @property {Map<string, Function>} _messageRenewLockTimers Maintains a map of messages for which\n   * the lock is automatically renewed.\n   * @protected\n   */\n  protected _messageRenewLockTimers: Map<string, NodeJS.Timer | undefined> = new Map<\n    string,\n    NodeJS.Timer | undefined\n  >();\n  /**\n   * @property {NodeJS.Timer} _newMessageReceivedTimer The timer that keeps track of time since the\n   * last message was received.\n   */\n  protected _newMessageReceivedTimer?: NodeJS.Timer;\n  /**\n   * Resets the `_newMessageReceivedTimer` timer when a new message is received.\n   */\n  protected resetTimerOnNewMessageReceived: () => void;\n  /**\n   * @property {Function} _clearMessageLockRenewTimer Clears the message lock renew timer for a\n   * specific messageId.\n   * @protected\n   */\n  protected _clearMessageLockRenewTimer: (messageId: string) => void;\n  /**\n   * @property {Function} _clearMessageLockRenewTimer Clears the message lock renew timer for all\n   * the active messages.\n   * @protected\n   */\n  protected _clearAllMessageLockRenewTimers: () => void;\n  constructor(context: ClientEntityContext, receiverType: ReceiverType, options?: ReceiveOptions) {\n    super(context.entityPath, context, {\n      address: context.entityPath,\n      audience: `${context.namespace.config.endpoint}${context.entityPath}`\n    });\n    if (!options) options = {};\n    this.wasCloseInitiated = false;\n    this.receiverType = receiverType;\n    this.receiveMode = options.receiveMode || ReceiveMode.peekLock;\n    if (typeof options.maxConcurrentCalls === \"number\" && options.maxConcurrentCalls > 0) {\n      this.maxConcurrentCalls = options.maxConcurrentCalls;\n    }\n    this.resetTimerOnNewMessageReceived = () => {\n      /** */\n    };\n    // If explicitly set to false then autoComplete is false else true (default).\n    this.autoComplete = options.autoComplete === false ? options.autoComplete : true;\n    this.maxAutoRenewDurationInSeconds =\n      options.maxMessageAutoRenewLockDurationInSeconds != null\n        ? options.maxMessageAutoRenewLockDurationInSeconds\n        : 300;\n    this.autoRenewLock =\n      this.maxAutoRenewDurationInSeconds > 0 && this.receiveMode === ReceiveMode.peekLock;\n    this._clearMessageLockRenewTimer = (messageId: string) => {\n      if (this._messageRenewLockTimers.has(messageId)) {\n        clearTimeout(this._messageRenewLockTimers.get(messageId) as NodeJS.Timer);\n        log.receiver(\n          \"[%s] Cleared the message renew lock timer for message with id '%s'.\",\n          this._context.namespace.connectionId,\n          messageId\n        );\n        this._messageRenewLockTimers.delete(messageId);\n      }\n    };\n    this._clearAllMessageLockRenewTimers = () => {\n      log.receiver(\n        \"[%s] Clearing message renew lock timers for all the active messages.\",\n        this._context.namespace.connectionId\n      );\n      for (const messageId of this._messageRenewLockTimers.keys()) {\n        this._clearMessageLockRenewTimer(messageId);\n      }\n    };\n    // setting all the handlers\n    this._onSettled = (context: EventContext) => {\n      const connectionId = this._context.namespace.connectionId;\n      const delivery = context.delivery;\n      if (delivery) {\n        const id = delivery.id;\n        const state = delivery.remote_state;\n        const settled = delivery.remote_settled;\n        log.receiver(\n          \"[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been \" + \"received.\",\n          connectionId,\n          id,\n          settled,\n          state && state.error ? state.error : state\n        );\n        if (settled && this._deliveryDispositionMap.has(id)) {\n          const promise = this._deliveryDispositionMap.get(id) as PromiseLike;\n          clearTimeout(promise.timer);\n          log.receiver(\n            \"[%s] Found the delivery with id %d in the map and cleared the timer.\",\n            connectionId,\n            id\n          );\n          const deleteResult = this._deliveryDispositionMap.delete(id);\n          log.receiver(\n            \"[%s] Successfully deleted the delivery with id %d from the map.\",\n            connectionId,\n            id,\n            deleteResult\n          );\n          if (state && state.error && (state.error.condition || state.error.description)) {\n            const error = translate(state.error);\n            return promise.reject(error);\n          }\n\n          return promise.resolve();\n        }\n      }\n    };\n\n    this._onAmqpMessage = async (context: EventContext) => {\n      // If the receiver got closed in PeekLock mode, avoid processing the message as we\n      // cannot settle the message.\n      if (\n        this.receiveMode === ReceiveMode.peekLock &&\n        (!this._receiver || !this._receiver.isOpen())\n      ) {\n        log.error(\n          \"[%s] Not calling the user's message handler for the current message \" +\n            \"as the receiver '%s' is closed\",\n          this._context.namespace.connectionId,\n          this.name\n        );\n        return;\n      }\n\n      this.resetTimerOnNewMessageReceived();\n      const connectionId = this._context.namespace.connectionId;\n      const bMessage: ServiceBusMessage = new ServiceBusMessage(\n        this._context,\n        context.message!,\n        context.delivery!,\n        true\n      );\n\n      if (this.autoRenewLock && bMessage.lockToken) {\n        const lockToken = bMessage.lockToken;\n        // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.\n        // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInSeconds\n        // - We should be able to clear the renewal timer when the user's message handler\n        // is done (whether it succeeds or fails).\n        // Setting the messageId with undefined value in the _messageRenewockTimers Map because we\n        // track state by checking the presence of messageId in the map. It is removed from the map\n        // when an attempt is made to settle the message (either by the user or by the sdk) OR\n        // when the execution of user's message handler completes.\n        this._messageRenewLockTimers.set(bMessage.messageId as string, undefined);\n        log.receiver(\n          \"[%s] message with id '%s' is locked until %s.\",\n          connectionId,\n          bMessage.messageId,\n          bMessage.lockedUntilUtc!.toString()\n        );\n        const totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;\n        log.receiver(\n          \"[%s] Total autolockrenew duration for message with id '%s' is: \",\n          connectionId,\n          bMessage.messageId,\n          new Date(totalAutoLockRenewDuration).toString()\n        );\n        const autoRenewLockTask = (): void => {\n          if (\n            new Date(totalAutoLockRenewDuration) > bMessage.lockedUntilUtc! &&\n            Date.now() < totalAutoLockRenewDuration\n          ) {\n            if (this._messageRenewLockTimers.has(bMessage.messageId as string)) {\n              // TODO: We can run into problems with clock skew between the client and the server.\n              // It would be better to calculate the duration based on the \"lockDuration\" property\n              // of the queue. However, we do not have the management plane of the client ready for\n              // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.\n              const amount = calculateRenewAfterDuration(bMessage.lockedUntilUtc!);\n              log.receiver(\n                \"[%s] Sleeping for %d milliseconds while renewing the lock for \" +\n                  \"message with id '%s' is: \",\n                connectionId,\n                amount,\n                bMessage.messageId\n              );\n              // Setting the value of the messageId to the actual timer. This will be cleared when\n              // an attempt is made to settle the message (either by the user or by the sdk) OR\n              // when the execution of user's message handler completes.\n              this._messageRenewLockTimers.set(\n                bMessage.messageId as string,\n                setTimeout(async () => {\n                  try {\n                    log.receiver(\n                      \"[%s] Attempting to renew the lock for message with id '%s'.\",\n                      connectionId,\n                      bMessage.messageId\n                    );\n                    bMessage.lockedUntilUtc = await this._context.managementClient!.renewLock(\n                      lockToken\n                    );\n                    log.receiver(\n                      \"[%s] Successfully renewed the lock for message with id '%s'.\",\n                      connectionId,\n                      bMessage.messageId\n                    );\n                    log.receiver(\n                      \"[%s] Calling the autorenewlock task again for message with \" + \"id '%s'.\",\n                      connectionId,\n                      bMessage.messageId\n                    );\n                    autoRenewLockTask();\n                  } catch (err) {\n                    log.error(\n                      \"[%s] An error occured while auto renewing the message lock '%s' \" +\n                        \"for message with id '%s': %O.\",\n                      connectionId,\n                      bMessage.lockToken,\n                      bMessage.messageId,\n                      err\n                    );\n                    // Let the user know that there was an error renewing the message lock.\n                    this._onError!(err);\n                  }\n                }, amount)\n              );\n            } else {\n              log.receiver(\n                \"[%s] Looks like the message lock renew timer has already been \" +\n                  \"cleared for message with id '%s'.\",\n                connectionId,\n                bMessage.messageId\n              );\n            }\n          } else {\n            log.receiver(\n              \"[%s] Current time %s exceeds the total autolockrenew duration %s for \" +\n                \"message with messageId '%s'. Hence we will stop the autoLockRenewTask.\",\n              connectionId,\n              new Date(Date.now()).toString(),\n              new Date(totalAutoLockRenewDuration).toString(),\n              bMessage.messageId\n            );\n            this._clearMessageLockRenewTimer(bMessage.messageId as string);\n          }\n        };\n        // start\n        autoRenewLockTask();\n      }\n      try {\n        await this._onMessage(bMessage);\n        this._clearMessageLockRenewTimer(bMessage.messageId as string);\n      } catch (err) {\n        // This ensures we call users' error handler when users' message handler throws.\n        if (!isAmqpError(err)) {\n          log.error(\n            \"[%s] An error occurred while running user's message handler for the message \" +\n              \"with id '%s' on the receiver '%s': %O\",\n            connectionId,\n            bMessage.messageId,\n            this.name,\n            err\n          );\n          this._onError!(err);\n        }\n\n        // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,\n        // doing this here. Otherwise, this should be done in finally.\n        this._clearMessageLockRenewTimer(bMessage.messageId as string);\n        const error = translate(err);\n        // Nothing much to do if user's message handler throws. Let us try abandoning the message.\n        if (\n          !bMessage.delivery.remote_settled &&\n          error.name !== ConditionErrorNameMapper[\"com.microsoft:message-lock-lost\"] &&\n          this.receiveMode === ReceiveMode.peekLock &&\n          this.isOpen() // only try to abandon the messages if the connection is still open\n        ) {\n          try {\n            log.error(\n              \"[%s] Abandoning the message with id '%s' on the receiver '%s' since \" +\n                \"an error occured: %O.\",\n              connectionId,\n              bMessage.messageId,\n              this.name,\n              error\n            );\n            await bMessage.abandon();\n          } catch (abandonError) {\n            const translatedError = translate(abandonError);\n            log.error(\n              \"[%s] An error occurred while abandoning the message with id '%s' on the \" +\n                \"receiver '%s': %O.\",\n              connectionId,\n              bMessage.messageId,\n              this.name,\n              translatedError\n            );\n            this._onError!(translatedError);\n          }\n        }\n        return;\n      } finally {\n        if (this._receiver) {\n          this._receiver.addCredit(1);\n        }\n      }\n\n      // If we've made it this far, then user's message handler completed fine. Let us try\n      // completing the message.\n      if (\n        this.autoComplete &&\n        this.receiveMode === ReceiveMode.peekLock &&\n        !bMessage.delivery.remote_settled\n      ) {\n        try {\n          log[this.receiverType](\n            \"[%s] Auto completing the message with id '%s' on \" + \"the receiver '%s'.\",\n            connectionId,\n            bMessage.messageId,\n            this.name\n          );\n          await bMessage.complete();\n        } catch (completeError) {\n          const translatedError = translate(completeError);\n          log.error(\n            \"[%s] An error occurred while completing the message with id '%s' on the \" +\n              \"receiver '%s': %O.\",\n            connectionId,\n            bMessage.messageId,\n            this.name,\n            translatedError\n          );\n          this._onError!(translatedError);\n        }\n      }\n    };\n\n    this._onAmqpError = (context: EventContext) => {\n      const connectionId = this._context.namespace.connectionId;\n      const receiver = this._receiver || context.receiver!;\n      const receiverError = context.receiver && context.receiver.error;\n      if (receiverError) {\n        const sbError = translate(receiverError);\n        log.error(\n          \"[%s] An error occurred for Receiver '%s': %O.\",\n          connectionId,\n          this.name,\n          sbError\n        );\n        if (!sbError.retryable) {\n          if (receiver && !receiver.isItselfClosed()) {\n            log.error(\n              \"[%s] Since the user did not close the receiver and the error is not \" +\n                \"retryable, we let the user know about it by calling the user's error handler.\",\n              connectionId\n            );\n            this._onError!(sbError);\n          } else {\n            log.error(\n              \"[%s] The received error is not retryable. However, the receiver was \" +\n                \"closed by the user. Hence not notifying the user's error handler.\",\n              connectionId\n            );\n          }\n        } else {\n          log.error(\n            \"[%s] Since received error is retryable, we will NOT notify the user's \" +\n              \"error handler.\",\n            connectionId\n          );\n        }\n      }\n      if (this._newMessageReceivedTimer) {\n        clearTimeout(this._newMessageReceivedTimer);\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const connectionId = this._context.namespace.connectionId;\n      const receiver = this._receiver || context.receiver!;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translate(sessionError);\n        log.error(\n          \"[%s] An error occurred on the session for Receiver '%s': %O.\",\n          connectionId,\n          this.name,\n          sbError\n        );\n        if (receiver && !receiver.isSessionItselfClosed() && !sbError.retryable) {\n          log.error(\n            \"[%s] Since the user did not close the receiver and the session error is not \" +\n              \"retryable, we let the user know about it by calling the user's error handler.\",\n            connectionId\n          );\n          this._onError!(sbError);\n        }\n      }\n      if (this._newMessageReceivedTimer) {\n        clearTimeout(this._newMessageReceivedTimer);\n      }\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const connectionId = this._context.namespace.connectionId;\n      const receiverError = context.receiver && context.receiver.error;\n      const receiver = this._receiver || context.receiver!;\n      if (receiverError) {\n        log.error(\n          \"[%s] 'receiver_close' event occurred for receiver '%s' with address '%s'. \" +\n            \"The associated error is: %O\",\n          connectionId,\n          this.name,\n          this.address,\n          receiverError\n        );\n      }\n      this._clearAllMessageLockRenewTimers();\n      if (receiver && !receiver.isItselfClosed()) {\n        if (!this.isConnecting) {\n          log.error(\n            \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' \" +\n              \"and the sdk did not initiate this. The receiver is not reconnecting. Hence, calling \" +\n              \"detached from the _onAmqpClose() handler.\",\n            connectionId,\n            this.name,\n            this.address\n          );\n          await this.onDetached(receiverError);\n        } else {\n          log.error(\n            \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' \" +\n              \"and the sdk did not initate this. Moreover the receiver is already re-connecting. \" +\n              \"Hence not calling detached from the _onAmqpClose() handler.\",\n            connectionId,\n            this.name,\n            this.address\n          );\n        }\n      } else {\n        log.error(\n          \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' \" +\n            \"because the sdk initiated it. Hence not calling detached from the _onAmqpClose\" +\n            \"() handler.\",\n          connectionId,\n          this.name,\n          this.address\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const connectionId = this._context.namespace.connectionId;\n      const receiver = this._receiver || context.receiver!;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        log.error(\n          \"[%s] 'session_close' event occurred for receiver '%s' with address '%s'. \" +\n            \"The associated error is: %O\",\n          connectionId,\n          this.name,\n          this.address,\n          sessionError\n        );\n      }\n      this._clearAllMessageLockRenewTimers();\n      if (receiver && !receiver.isSessionItselfClosed()) {\n        if (!this.isConnecting) {\n          log.error(\n            \"[%s] 'session_close' event occurred on the session of receiver '%s' with \" +\n              \"address '%s' and the sdk did not initiate this. Hence calling detached from the \" +\n              \"_onSessionClose() handler.\",\n            connectionId,\n            this.name,\n            this.address\n          );\n          await this.onDetached(sessionError);\n        } else {\n          log.error(\n            \"[%s] 'session_close' event occurred on the session of receiver '%s' with \" +\n              \"address '%s' and the sdk did not initiate this. Moreover the receiver is already \" +\n              \"re-connecting. Hence not calling detached from the _onSessionClose() handler.\",\n            connectionId,\n            this.name,\n            this.address\n          );\n        }\n      } else {\n        log.error(\n          \"[%s] 'session_close' event occurred on the session of receiver '%s' with address \" +\n            \"'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose\" +\n            \"() handler.\",\n          connectionId,\n          this.name,\n          this.address\n        );\n      }\n    };\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   */\n  protected _createReceiverOptions(\n    useNewName?: boolean,\n    options?: CreateReceiverOptions\n  ): ReceiverOptions {\n    if (!options) {\n      options = {\n        onMessage: (context: EventContext) =>\n          this._onAmqpMessage(context).catch(() => {\n            /* */\n          }),\n        onClose: (context: EventContext) =>\n          this._onAmqpClose(context).catch(() => {\n            /* */\n          }),\n        onSessionClose: (context: EventContext) =>\n          this._onSessionClose(context).catch(() => {\n            /* */\n          }),\n        onError: this._onAmqpError,\n        onSessionError: this._onSessionError,\n        onSettled: this._onSettled\n      };\n    }\n    const rcvrOptions: ReceiverOptions = {\n      name: useNewName ? getUniqueName(this._context.entityPath) : this.name,\n      autoaccept: this.receiveMode === ReceiveMode.receiveAndDelete ? true : false,\n      // receiveAndDelete -> first(0), peekLock -> second (1)\n      rcv_settle_mode: this.receiveMode === ReceiveMode.receiveAndDelete ? 0 : 1,\n      // receiveAndDelete -> settled (1), peekLock -> unsettled (0)\n      snd_settle_mode: this.receiveMode === ReceiveMode.receiveAndDelete ? 1 : 0,\n      source: {\n        address: this.address\n      },\n      credit_window: 0,\n      ...options\n    };\n\n    return rcvrOptions;\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   * @protected\n   *\n   * @returns {Promise<void>} Promise<void>.\n   */\n  protected async _init(options?: ReceiverOptions): Promise<void> {\n    const connectionId = this._context.namespace.connectionId;\n    try {\n      if (!this.isOpen() && !this.isConnecting) {\n        log.error(\n          \"[%s] The receiver '%s' with address '%s' is not open and is not currently \" +\n            \"establishing itself. Hence let's try to connect.\",\n          connectionId,\n          this.name,\n          this.address\n        );\n\n        if (options && options.name) {\n          this.name = options.name;\n        }\n\n        this.isConnecting = true;\n        await this._negotiateClaim();\n        if (!options) {\n          options = this._createReceiverOptions();\n        }\n        log.error(\n          \"[%s] Trying to create receiver '%s' with options %O\",\n          connectionId,\n          this.name,\n          options\n        );\n\n        this._receiver = await this._context.namespace.connection.createReceiver(options);\n        this.isConnecting = false;\n        log.error(\n          \"[%s] Receiver '%s' with address '%s' has established itself.\",\n          connectionId,\n          this.name,\n          this.address\n        );\n        log[this.receiverType](\n          \"Promise to create the receiver resolved. \" + \"Created receiver with name: \",\n          this.name\n        );\n        log[this.receiverType](\n          \"[%s] Receiver '%s' created with receiver options: %O\",\n          connectionId,\n          this.name,\n          options\n        );\n        // It is possible for someone to close the receiver and then start it again.\n        // Thus make sure that the receiver is present in the client cache.\n        if (this.receiverType === ReceiverType.streaming && !this._context.streamingReceiver) {\n          this._context.streamingReceiver = this as any;\n        } else if (this.receiverType === ReceiverType.batching && !this._context.batchingReceiver) {\n          this._context.batchingReceiver = this as any;\n        }\n        await this._ensureTokenRenewal();\n      } else {\n        log.error(\n          \"[%s] The receiver '%s' with address '%s' is open -> %s and is connecting \" +\n            \"-> %s. Hence not reconnecting.\",\n          connectionId,\n          this.name,\n          this.address,\n          this.isOpen(),\n          this.isConnecting\n        );\n      }\n    } catch (err) {\n      this.isConnecting = false;\n      err = translate(err);\n      log.error(\n        \"[%s] An error occured while creating the receiver '%s': %O\",\n        this._context.namespace.connectionId,\n        this.name,\n        err\n      );\n      throw err;\n    }\n  }\n\n  protected _deleteFromCache(): void {\n    this._receiver = undefined;\n    if (this.receiverType === ReceiverType.streaming) {\n      this._context.streamingReceiver = undefined;\n    } else if (this.receiverType === ReceiverType.batching) {\n      this._context.batchingReceiver = undefined;\n    }\n    log.error(\n      \"[%s] Deleted the receiver '%s' from the client cache.\",\n      this._context.namespace.connectionId,\n      this.name\n    );\n  }\n\n  /**\n   * Will reconnect the receiver link if necessary.\n   * @param {AmqpError | Error} [receiverError] The receiver error if any.\n   * @returns {Promise<void>} Promise<void>.\n   */\n  async onDetached(receiverError?: AmqpError | Error): Promise<void> {\n    const connectionId = this._context.namespace.connectionId;\n    try {\n      // Local 'wasCloseInitiated' serves same purpose as {this.wasCloseInitiated}\n      // but the condition is inferred based on state of receiver in context of network disconnect scenario\n      const wasCloseInitiated = this._receiver && this._receiver.isItselfClosed();\n      // Clears the token renewal timer. Closes the link and its session if they are open.\n      // Removes the link and its session if they are present in rhea's cache.\n      await this._closeLink(this._receiver);\n\n      if (this.receiverType === ReceiverType.batching) {\n        log.error(\n          \"[%s] Receiver '%s' with address '%s' is a Batching Receiver, so we will not be \" +\n            \"re-establishing the receiver link.\",\n          connectionId,\n          this.name,\n          this.address\n        );\n        return;\n      }\n\n      // We should attempt to reopen only when the receiver(sdk) did not initiate the close\n      let shouldReopen = false;\n      if (receiverError && !wasCloseInitiated) {\n        const translatedError = translate(receiverError);\n        if (translatedError.retryable) {\n          shouldReopen = true;\n          log.error(\n            \"[%s] close() method of Receiver '%s' with address '%s' was not called. There \" +\n              \"was an accompanying error and it is retryable. This is a candidate for re-establishing \" +\n              \"the receiver link.\",\n            connectionId,\n            this.name,\n            this.address\n          );\n        } else {\n          log.error(\n            \"[%s] close() method of Receiver '%s' with address '%s' was not called. There \" +\n              \"was an accompanying error and it is NOT retryable. Hence NOT re-establishing \" +\n              \"the receiver link.\",\n            connectionId,\n            this.name,\n            this.address\n          );\n        }\n      } else if (!wasCloseInitiated) {\n        shouldReopen = true;\n        log.error(\n          \"[%s] close() method of Receiver '%s' with address '%s' was not called. \" +\n            \"There was no accompanying error as well. This is a candidate for re-establishing \" +\n            \"the receiver link.\",\n          connectionId,\n          this.name,\n          this.address\n        );\n      } else {\n        const state: any = {\n          wasCloseInitiated: wasCloseInitiated,\n          receiverError: receiverError,\n          _receiver: this._receiver\n        };\n        log.error(\n          \"[%s] Something went wrong. State of Receiver '%s' with address '%s' is: %O\",\n          connectionId,\n          this.name,\n          this.address,\n          state\n        );\n      }\n      if (shouldReopen) {\n        // provide a new name to the link while re-connecting it. This ensures that\n        // the service does not send an error stating that the link is still open.\n        const options: ReceiverOptions = this._createReceiverOptions(true);\n\n        // shall retry forever at an interval of 15 seconds if the error is a retryable error\n        // else bail out when the error is not retryable or the oepration succeeds.\n        const config: RetryConfig<void> = {\n          operation: () =>\n            this._init(options).then(async () => {\n              if (this.wasCloseInitiated) {\n                log.error(\n                  \"[%s] close() method of Receiver '%s' with address '%s' was called. \" +\n                    \"by the time the receiver finished getting created. Hence, disallowing messages from being received. \",\n                  connectionId,\n                  this.name,\n                  this.address\n                );\n                await this.close();\n              } else {\n                if (this._receiver && this.receiverType === ReceiverType.streaming) {\n                  this._receiver.addCredit(this.maxConcurrentCalls);\n                }\n              }\n              return;\n            }),\n          connectionId: connectionId,\n          operationType: RetryOperationType.receiverLink,\n          times: Constants.defaultConnectionRetryAttempts,\n          connectionHost: this._context.namespace.config.host,\n          delayInSeconds: 15\n        };\n        if (!this.wasCloseInitiated) {\n          await retry<void>(config);\n        }\n      }\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while processing detached() of Receiver '%s': %O \",\n        connectionId,\n        this.name,\n        this.address,\n        err\n      );\n      if (typeof this._onError === \"function\") {\n        log.error(\n          \"[%s] Unable to automatically reconnect Receiver '%s' with address '%s'.\",\n          connectionId,\n          this.name,\n          this.address\n        );\n        try {\n          this._onError(err);\n        } catch (err) {\n          log.error(\n            \"[%s] User-code error in error handler called after disconnect: %O\",\n            connectionId,\n            err\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Closes the underlying AMQP receiver.\n   * @return {Promise<void>} Promise<void>.\n   */\n  async close(): Promise<void> {\n    this.wasCloseInitiated = true;\n    log.receiver(\n      \"[%s] Closing the [%s]Receiver for entity '%s'.\",\n      this._context.namespace.connectionId,\n      this.receiverType,\n      this._context.entityPath\n    );\n    if (this._newMessageReceivedTimer) clearTimeout(this._newMessageReceivedTimer);\n    this._clearAllMessageLockRenewTimers();\n    if (this._receiver) {\n      const receiverLink = this._receiver;\n      this._deleteFromCache();\n      await this._closeLink(receiverLink);\n    }\n  }\n\n  /**\n   * Settles the message with the specified disposition.\n   * @param message The ServiceBus Message that needs to be settled.\n   * @param operation The disposition type.\n   * @param options Optional parameters that can be provided while disposing the message.\n   */\n  async settleMessage(\n    message: ServiceBusMessage,\n    operation: DispositionType,\n    options?: DispositionOptions\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      if (!options) options = {};\n      if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {\n        return reject(new Error(`operation: '${operation}' is not a valid operation.`));\n      }\n      this._clearMessageLockRenewTimer(message.messageId as string);\n      const delivery = message.delivery;\n      const timer = setTimeout(() => {\n        this._deliveryDispositionMap.delete(delivery.id);\n\n        log.receiver(\n          \"[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. \" +\n            \"Hence rejecting the promise with timeout error.\",\n          this._context.namespace.connectionId,\n          delivery.id,\n          Constants.defaultOperationTimeoutInSeconds * 1000\n        );\n\n        const e: AmqpError = {\n          condition: ErrorNameConditionMapper.ServiceUnavailableError,\n          description:\n            \"Operation to settle the message has timed out. The disposition of the \" +\n            \"message may or may not be successful\"\n        };\n        return reject(translate(e));\n      }, Constants.defaultOperationTimeoutInSeconds * 1000);\n      this._deliveryDispositionMap.set(delivery.id, {\n        resolve: resolve,\n        reject: reject,\n        timer: timer\n      });\n      if (operation === DispositionType.complete) {\n        delivery.accept();\n      } else if (operation === DispositionType.abandon) {\n        const params: any = {\n          undeliverable_here: false\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.defer) {\n        const params: any = {\n          undeliverable_here: true\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.deadletter) {\n        delivery.reject(options.error || {});\n      }\n    });\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   * @return {boolean} boolean\n   */\n  isOpen(): boolean {\n    const result: boolean = this._receiver! && this._receiver!.isOpen();\n    log.error(\n      \"[%s] Receiver '%s' with address '%s' is open? -> %s\",\n      this._context.namespace.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {\n  MessageReceiver,\n  ReceiveOptions,\n  OnMessage,\n  OnError,\n  ReceiverType\n} from \"./messageReceiver\";\n\nimport { ClientEntityContext } from \"../clientEntityContext\";\n\nimport * as log from \"../log\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\n\n/**\n * Describes the options passed to `registerMessageHandler` method when receiving messages from a\n * Queue/Subscription which does not have sessions enabled.\n */\nexport interface MessageHandlerOptions {\n  /**\n   * @property Indicates whether the `complete()` method on the message should automatically be\n   * called by the sdk after the user provided onMessage handler has been executed.\n   * Calling `complete()` on a message removes it from the Queue/Subscription.\n   * - **Default**: `true`.\n   */\n  autoComplete?: boolean;\n  /**\n   * @property The maximum duration in seconds until which the lock on the message will be renewed\n   * by the sdk automatically. This auto renewal stops once the message is settled or once the user\n   * provided onMessage handler completes ite execution.\n   *\n   * - **Default**: `300` seconds (5 minutes).\n   * - **To disable autolock renewal**, set this to `0`.\n   */\n  maxMessageAutoRenewLockDurationInSeconds?: number;\n  /**\n   * @property The maximum number of concurrent calls that the sdk can make to the user's message\n   * handler. Once this limit has been reached, further messages will not be received until atleast\n   * one of the calls to the user's message handler has completed.\n   * - **Default**: `1`.\n   */\n  maxConcurrentCalls?: number;\n}\n\n/**\n * @internal\n * Describes the streaming receiver where the user can receive the message\n * by providing handler functions.\n * @class StreamingReceiver\n * @extends MessageReceiver\n */\nexport class StreamingReceiver extends MessageReceiver {\n  /**\n   * Instantiate a new Streaming receiver for receiving messages with handlers.\n   *\n   * @constructor\n   * @param {ClientEntityContext} context                      The client entity context.\n   * @param {ReceiveOptions} [options]                         Options for how you'd like to connect.\n   */\n  constructor(context: ClientEntityContext, options?: ReceiveOptions) {\n    super(context, ReceiverType.streaming, options);\n\n    this.resetTimerOnNewMessageReceived = () => {\n      if (this._newMessageReceivedTimer) clearTimeout(this._newMessageReceivedTimer);\n      if (this.newMessageWaitTimeoutInSeconds) {\n        this._newMessageReceivedTimer = setTimeout(async () => {\n          const msg =\n            `StreamingReceiver '${this.name}' did not receive any messages in ` +\n            `the last ${this.newMessageWaitTimeoutInSeconds} seconds. ` +\n            `Hence ending this receive operation.`;\n          log.error(\"[%s] %s\", this._context.namespace.connectionId, msg);\n\n          await this.close();\n        }, this.newMessageWaitTimeoutInSeconds * 1000);\n      }\n    };\n  }\n\n  /**\n   * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.\n   *\n   * @param {OnMessage} onMessage The message handler to receive servicebus messages.\n   * @param {OnError} onError The error handler to receive an error that occurs while receivin messages.\n   */\n  receive(onMessage: OnMessage, onError: OnError): void {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    this._onMessage = onMessage;\n    this._onError = onError;\n\n    if (this._receiver) {\n      this._receiver.addCredit(this.maxConcurrentCalls);\n    }\n  }\n\n  /**\n   * Creates a streaming receiver.\n   * @static\n   *\n   * @param {ClientEntityContext} context    The connection context.\n   * @param {ReceiveOptions} [options]     Receive options.\n   * @return {Promise<StreamingReceiver>} A promise that resolves with an instance of StreamingReceiver.\n   */\n  static async create(\n    context: ClientEntityContext,\n    options?: ReceiveOptions\n  ): Promise<StreamingReceiver> {\n    throwErrorIfConnectionClosed(context.namespace);\n    if (!options) options = {};\n    if (options.autoComplete == null) options.autoComplete = true;\n    const sReceiver = new StreamingReceiver(context, options);\n    await sReceiver._init();\n    context.streamingReceiver = sReceiver;\n    return sReceiver;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"../log\";\nimport { Constants, translate, MessagingError } from \"@azure/amqp-common\";\nimport { ReceiverEvents, EventContext, OnAmqpEvent, SessionEvents, AmqpError } from \"rhea-promise\";\nimport { ServiceBusMessage, ReceiveMode } from \"../serviceBusMessage\";\nimport {\n  MessageReceiver,\n  ReceiveOptions,\n  ReceiverType,\n  PromiseLike,\n  OnAmqpEventAsPromise\n} from \"./messageReceiver\";\nimport { ClientEntityContext } from \"../clientEntityContext\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\n\n/**\n * Describes the batching receiver where the user can receive a specified number of messages for\n * a predefined time.\n * @internal\n * @class BatchingReceiver\n * @extends MessageReceiver\n */\nexport class BatchingReceiver extends MessageReceiver {\n  /**\n   * @property {boolean} isReceivingMessages Indicates whether the link is actively receiving\n   * messages. Default: false.\n   */\n  isReceivingMessages: boolean = false;\n\n  /**\n   * @property {AmqpError | Error | undefined} detachedError Error that occured when receiver\n   * got detached. Not applicable when onReceiveError is called.\n   *  Default: undefined.\n   */\n  private detachedError: AmqpError | Error | undefined = undefined;\n\n  private _finalActionHandler: (() => void) | undefined = undefined;\n\n  /**\n   * Instantiate a new BatchingReceiver.\n   *\n   * @constructor\n   * @param {ClientEntityContext} context The client entity context.\n   * @param {ReceiveOptions} [options]  Options for how you'd like to connect.\n   */\n  constructor(context: ClientEntityContext, options?: ReceiveOptions) {\n    super(context, ReceiverType.batching, options);\n    this.newMessageWaitTimeoutInSeconds = 1;\n  }\n\n  /**\n   * Clear the token renewal timer and set the `detachedError` property.\n   * @param {AmqpError | Error} [receiverError] The receiver error if any.\n   * @returns {Promise<void>} Promise<void>.\n   */\n  async onDetached(receiverError?: AmqpError | Error): Promise<void> {\n    // Clears the token renewal timer. Closes the link and its session if they are open.\n    await this._closeLink(this._receiver);\n    this.detachedError = receiverError;\n    if (this.isReceivingMessages && typeof this._finalActionHandler === \"function\") {\n      this._finalActionHandler();\n    }\n  }\n\n  /**\n   * Receives a batch of messages from a ServiceBus Queue/Topic.\n   * @param maxMessageCount The maximum number of messages to receive.\n   * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.\n   * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * - **Default**: `60` seconds.\n   * @returns {Promise<ServiceBusMessage[]>} A promise that resolves with an array of Message objects.\n   */\n  receive(maxMessageCount: number, maxWaitTimeInSeconds?: number): Promise<ServiceBusMessage[]> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n\n    if (maxWaitTimeInSeconds == null) {\n      maxWaitTimeInSeconds = Constants.defaultOperationTimeoutInSeconds;\n    }\n\n    const brokeredMessages: ServiceBusMessage[] = [];\n\n    this.isReceivingMessages = true;\n    return new Promise<ServiceBusMessage[]>((resolve, reject) => {\n      let totalWaitTimer: NodeJS.Timer | undefined;\n\n      const onSessionError: OnAmqpEvent = (context: EventContext) => {\n        this.isReceivingMessages = false;\n        const receiver = this._receiver || context.receiver!;\n        receiver.removeListener(ReceiverEvents.receiverError, onReceiveError);\n        receiver.removeListener(ReceiverEvents.message, onReceiveMessage);\n        receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n        receiver.session.removeListener(SessionEvents.sessionError, onSessionError);\n\n        const sessionError = context.session && context.session.error;\n        let error = new MessagingError(\"An error occurred while receiving messages.\");\n        if (sessionError) {\n          error = translate(sessionError);\n          log.error(\n            \"[%s] 'session_close' event occurred for Receiver '%s' received an error:\\n%O\",\n            this._context.namespace.connectionId,\n            this.name,\n            error\n          );\n        }\n        if (totalWaitTimer) {\n          clearTimeout(totalWaitTimer);\n        }\n        if (this._newMessageReceivedTimer) {\n          clearTimeout(this._newMessageReceivedTimer);\n        }\n        reject(error);\n      };\n\n      // Final action to be performed after maxMessageCount is reached or the maxWaitTime is over.\n      const finalAction = (this._finalActionHandler = (): void => {\n        // clear finalActionHandler so that it can't be called multiple times.\n        this._finalActionHandler = undefined;\n        if (this._newMessageReceivedTimer) {\n          clearTimeout(this._newMessageReceivedTimer);\n        }\n        if (totalWaitTimer) {\n          clearTimeout(totalWaitTimer);\n        }\n\n        // Removing listeners, so that the next receiveMessages() call can set them again.\n        if (this._receiver) {\n          this._receiver.removeListener(ReceiverEvents.receiverError, onReceiveError);\n          this._receiver.removeListener(ReceiverEvents.message, onReceiveMessage);\n          this._receiver.session.removeListener(SessionEvents.sessionError, onSessionError);\n        }\n\n        // When receiveMode is in receiveAndDelete mode, we should return those messages to the user\n        // because they have already been removed from service bus and are safe to handle.\n        // If there haven't been any received messages, then it's safe to reject the promise\n        // so that the user knows there was an underlying issue that prevented receiving messages.\n        if (\n          this.detachedError &&\n          (this.receiveMode !== ReceiveMode.receiveAndDelete || brokeredMessages.length === 0)\n        ) {\n          if (this._receiver) {\n            this._receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n          }\n          this.isReceivingMessages = false;\n          const err = translate(this.detachedError);\n          return reject(err);\n        }\n\n        // If the receiver has been detached, there is no need to drain.\n        if (this._receiver && this._receiver.credit > 0 && !this.detachedError) {\n          log.batching(\n            \"[%s] Receiver '%s': Draining leftover credits(%d).\",\n            this._context.namespace.connectionId,\n            this.name,\n            this._receiver.credit\n          );\n\n          // Setting drain must be accompanied by a flow call (aliased to addCredit in this case).\n          this._receiver.drain = true;\n          this._receiver.addCredit(1);\n        } else {\n          if (this._receiver) {\n            this._receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n          }\n\n          this.isReceivingMessages = false;\n          log.batching(\n            \"[%s] Receiver '%s': Resolving receiveMessages() with %d messages.\",\n            this._context.namespace.connectionId,\n            this.name,\n            brokeredMessages.length\n          );\n          resolve(brokeredMessages);\n        }\n      });\n\n      // Action to be performed on the \"message\" event.\n      const onReceiveMessage: OnAmqpEventAsPromise = async (context: EventContext) => {\n        this.resetTimerOnNewMessageReceived();\n        try {\n          const data: ServiceBusMessage = new ServiceBusMessage(\n            this._context,\n            context.message!,\n            context.delivery!,\n            true\n          );\n          if (brokeredMessages.length < maxMessageCount) {\n            brokeredMessages.push(data);\n          }\n        } catch (err) {\n          const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));\n          log.error(\n            \"[%s] Receiver '%s' received an error while converting AmqpMessage to ServiceBusMessage:\\n%O\",\n            this._context.namespace.connectionId,\n            this.name,\n            errObj\n          );\n          reject(errObj);\n        }\n        if (brokeredMessages.length === maxMessageCount) {\n          finalAction();\n        }\n      };\n\n      const onSessionClose: OnAmqpEventAsPromise = async (context: EventContext) => {\n        try {\n          this.isReceivingMessages = false;\n          const sessionError = context.session && context.session.error;\n          if (sessionError) {\n            log.error(\n              \"[%s] 'session_close' event occurred for receiver '%s'. The associated error is: %O\",\n              this._context.namespace.connectionId,\n              this.name,\n              sessionError\n            );\n          }\n        } catch (err) {\n          log.error(\n            \"[%s] Receiver '%s' error in onSessionClose handler:\\n%O\",\n            this._context.namespace.connectionId,\n            this.name,\n            translate(err)\n          );\n        }\n      };\n\n      // Action to be performed on the \"receiver_drained\" event.\n      const onReceiveDrain: OnAmqpEvent = () => {\n        if (this._receiver) {\n          this._receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n          this._receiver.drain = false;\n        }\n\n        this.isReceivingMessages = false;\n\n        log.batching(\n          \"[%s] Receiver '%s' drained. Resolving receiveMessages() with %d messages.\",\n          this._context.namespace.connectionId,\n          this.name,\n          brokeredMessages.length\n        );\n\n        resolve(brokeredMessages);\n      };\n\n      const onReceiveClose: OnAmqpEventAsPromise = async (context: EventContext) => {\n        try {\n          this.isReceivingMessages = false;\n          const receiverError = context.receiver && context.receiver.error;\n          if (receiverError) {\n            log.error(\n              \"[%s] 'receiver_close' event occurred. The associated error is: %O\",\n              this._context.namespace.connectionId,\n              receiverError\n            );\n          }\n        } catch (err) {\n          log.error(\n            \"[%s] Receiver '%s' error in onClose handler:\\n%O\",\n            this._context.namespace.connectionId,\n            this.name,\n            translate(err)\n          );\n        }\n      };\n\n      // Action to be taken when an error is received.\n      const onReceiveError: OnAmqpEvent = (context: EventContext) => {\n        this.isReceivingMessages = false;\n        const receiver = this._receiver || context.receiver!;\n        receiver.removeListener(ReceiverEvents.receiverError, onReceiveError);\n        receiver.removeListener(ReceiverEvents.message, onReceiveMessage);\n        receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n        receiver.session.removeListener(SessionEvents.sessionError, onSessionError);\n\n        const receiverError = context.receiver && context.receiver.error;\n        let error = new MessagingError(\"An error occurred while receiving messages.\");\n        if (receiverError) {\n          error = translate(receiverError);\n          log.error(\n            \"[%s] Receiver '%s' received an error:\\n%O\",\n            this._context.namespace.connectionId,\n            this.name,\n            error\n          );\n        }\n        if (totalWaitTimer) {\n          clearTimeout(totalWaitTimer);\n        }\n        if (this._newMessageReceivedTimer) {\n          clearTimeout(this._newMessageReceivedTimer);\n        }\n        reject(error);\n      };\n\n      // Use new message wait timer only in peekLock mode\n      if (this.receiveMode === ReceiveMode.peekLock) {\n        /**\n         * Resets the timer when a new message is received. If no messages were received for\n         * `newMessageWaitTimeoutInSeconds`, the messages received till now are returned. The\n         * receiver link stays open for the next receive call, but doesnt receive messages until then.\n         */\n        this.resetTimerOnNewMessageReceived = () => {\n          if (this._newMessageReceivedTimer) clearTimeout(this._newMessageReceivedTimer);\n          if (this.newMessageWaitTimeoutInSeconds) {\n            this._newMessageReceivedTimer = setTimeout(async () => {\n              const msg =\n                `BatchingReceiver '${this.name}' did not receive any messages in the last ` +\n                `${this.newMessageWaitTimeoutInSeconds} seconds. ` +\n                `Hence ending this batch receive operation.`;\n              log.error(\"[%s] %s\", this._context.namespace.connectionId, msg);\n              finalAction();\n            }, this.newMessageWaitTimeoutInSeconds * 1000);\n          }\n        };\n      }\n\n      // Action to be performed after the max wait time is over.\n      const actionAfterWaitTimeout = (): void => {\n        log.batching(\n          \"[%s] Batching Receiver '%s'  max wait time in seconds %d over.\",\n          this._context.namespace.connectionId,\n          this.name,\n          maxWaitTimeInSeconds\n        );\n        return finalAction();\n      };\n\n      const onSettled: OnAmqpEvent = (context: EventContext) => {\n        const connectionId = this._context.namespace.connectionId;\n        const delivery = context.delivery;\n        if (delivery) {\n          const id = delivery.id;\n          const state = delivery.remote_state;\n          const settled = delivery.remote_settled;\n          log.receiver(\n            \"[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been \" +\n              \"received.\",\n            connectionId,\n            id,\n            settled,\n            state && state.error ? state.error : state\n          );\n          if (settled && this._deliveryDispositionMap.has(id)) {\n            const promise = this._deliveryDispositionMap.get(id) as PromiseLike;\n            clearTimeout(promise.timer);\n            log.receiver(\n              \"[%s] Found the delivery with id %d in the map and cleared the timer.\",\n              connectionId,\n              id\n            );\n            const deleteResult = this._deliveryDispositionMap.delete(id);\n            log.receiver(\n              \"[%s] Successfully deleted the delivery with id %d from the map.\",\n              connectionId,\n              id,\n              deleteResult\n            );\n            if (state && state.error && (state.error.condition || state.error.description)) {\n              const error = translate(state.error);\n              return promise.reject(error);\n            }\n\n            return promise.resolve();\n          }\n        }\n      };\n\n      const addCreditAndSetTimer = (reuse?: boolean): void => {\n        log.batching(\n          \"[%s] Receiver '%s', adding credit for receiving %d messages.\",\n          this._context.namespace.connectionId,\n          this.name,\n          maxMessageCount\n        );\n        // By adding credit here, we let the service know that at max we can handle `maxMessageCount`\n        // number of messages concurrently. We will return the user an array of messages that can\n        // be of size upto maxMessageCount. Then the user needs to accordingly dispose\n        // (complete/abandon/defer/deadletter) the messages from the array.\n        this._receiver!.addCredit(maxMessageCount);\n        let msg: string = \"[%s] Setting the wait timer for %d seconds for receiver '%s'.\";\n        if (reuse) msg += \" Receiver link already present, hence reusing it.\";\n        log.batching(msg, this._context.namespace.connectionId, maxWaitTimeInSeconds, this.name);\n        totalWaitTimer = setTimeout(\n          actionAfterWaitTimeout,\n          (maxWaitTimeInSeconds as number) * 1000\n        );\n        // TODO: Disabling this for now. We would want to give the user a decent chance to receive\n        // the first message and only timeout faster if successive messages from there onwards are\n        // not received quickly. However, it may be possible that there are no pending messages\n        // currently on the queue. In that case waiting for idleTimeoutInSeconds would be\n        // unnecessary.\n        // There is a management plane API to get runtimeInfo of the Queue which provides\n        // information about active messages on the Queue and it's sub Queues. However, this adds\n        // a little complexity. If the first message was delayed due to network latency then there\n        // are bright chances that the management plane api would receive the same fate.\n        // It would be better to weigh all the options before making a decision.\n        // resetTimerOnNewMessageReceived();\n      };\n\n      if (!this.isOpen()) {\n        // clear detachedError since we are reconnecting.\n        this.detachedError = undefined;\n        log.batching(\n          \"[%s] Receiver '%s', setting max concurrent calls to 0.\",\n          this._context.namespace.connectionId,\n          this.name\n        );\n        // while creating the receiver link for batching receiver the max concurrent calls\n        // i.e. the credit_window on the link is set to zero. After the link is created\n        // successfully, we add credit which is the maxMessageCount specified by the user.\n        this.maxConcurrentCalls = 0;\n        const rcvrOptions = this._createReceiverOptions(false, {\n          onMessage: onReceiveMessage,\n          onError: onReceiveError,\n          onSessionError: onSessionError,\n          onSettled: onSettled,\n          onClose: onReceiveClose,\n          onSessionClose: onSessionClose\n        });\n        this._init(rcvrOptions)\n          .then(() => {\n            this._receiver!.on(ReceiverEvents.receiverDrained, onReceiveDrain);\n            addCreditAndSetTimer();\n            return;\n          })\n          .catch(reject);\n      } else {\n        addCreditAndSetTimer(true);\n        this._receiver!.on(ReceiverEvents.message, onReceiveMessage);\n        this._receiver!.on(ReceiverEvents.receiverError, onReceiveError);\n        this._receiver!.on(ReceiverEvents.receiverDrained, onReceiveDrain);\n        this._receiver!.session.on(SessionEvents.sessionError, onSessionError);\n      }\n    });\n  }\n\n  /**\n   * Creates a batching receiver.\n   * @static\n   *\n   * @param {ClientEntityContext} context    The connection context.\n   * @param {ReceiveOptions} [options]     Receive options.\n   */\n  static create(context: ClientEntityContext, options?: ReceiveOptions): BatchingReceiver {\n    throwErrorIfConnectionClosed(context.namespace);\n    const bReceiver = new BatchingReceiver(context, options);\n    context.batchingReceiver = bReceiver;\n    return bReceiver;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {\n  translate,\n  Constants,\n  ErrorNameConditionMapper,\n  MessagingError,\n  Func\n} from \"@azure/amqp-common\";\nimport {\n  Receiver,\n  OnAmqpEvent,\n  EventContext,\n  ReceiverOptions,\n  ReceiverEvents,\n  AmqpError,\n  isAmqpError\n} from \"rhea-promise\";\nimport * as log from \"../log\";\nimport {\n  OnError,\n  OnAmqpEventAsPromise,\n  PromiseLike,\n  DispositionOptions,\n  OnMessage\n} from \"../core/messageReceiver\";\nimport { LinkEntity } from \"../core/linkEntity\";\nimport { ClientEntityContext } from \"../clientEntityContext\";\nimport { convertTicksToDate, calculateRenewAfterDuration } from \"../util/utils\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport { ServiceBusMessage, DispositionType, ReceiveMode } from \"../serviceBusMessage\";\n\n/**\n * Enum to denote who is calling the session receiver\n * @internal\n */\nexport enum SessionCallee {\n  standalone = \"standalone\",\n  sessionManager = \"sessionManager\"\n}\n\n/**\n * Describes the options that need to be provided while creating a message session receiver link.\n * @internal\n */\nexport interface CreateMessageSessionReceiverLinkOptions {\n  onClose: OnAmqpEventAsPromise;\n  onSessionClose: OnAmqpEventAsPromise;\n  onError: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSettled: OnAmqpEvent;\n  sessionId?: string;\n}\n\n/**\n * Describes the options passed to the `createReceiver` method when using a Queue/Subscription that\n * has sessions enabled.\n */\nexport interface SessionReceiverOptions {\n  /**\n   * @property The id of the session from which messages need to be received. If null or undefined is\n   * provided, Service Bus chooses a random session from available sessions.\n   */\n  sessionId: string | undefined;\n  /**\n   * @property The maximum duration in seconds\n   * until which, the lock on the session will be renewed automatically by the sdk.\n   * - **Default**: `300` seconds (5 minutes).\n   * - **To disable autolock renewal**, set this to `0`.\n   */\n  maxSessionAutoRenewLockDurationInSeconds?: number;\n}\n\n/**\n * Describes the options passed to `registerMessageHandler` method when receiving messages from a\n * Queue/Subscription which has sessions enabled.\n */\nexport interface SessionMessageHandlerOptions {\n  /**\n   * @property Indicates whether the `complete()` method on the message should automatically be\n   * called by the sdk after the user provided onMessage handler has been executed.\n   * Calling `complete()` on a message removes it from the Queue/Subscription.\n   * - **Default**: `true`.\n   */\n  autoComplete?: boolean;\n  /**\n   * @property The maximum number of concurrent calls that the library\n   * can make to the user's message handler. Once this limit has been reached, more messages will\n   * not be received until atleast one of the calls to the user's message handler has completed.\n   * - **Default**: `1`.\n   */\n  maxConcurrentCalls?: number;\n}\n/**\n * @internal\n * Describes the options for creating a Session Manager.\n */\nexport interface SessionManagerOptions extends SessionMessageHandlerOptions {\n  /**\n   * @property {number} [maxConcurrentSessions] The maximum number of sessions that the user wants to\n   * handle concurrently.\n   * - **Default**: `2000`.\n   */\n  maxConcurrentSessions?: number;\n  /**\n   * @property The maximum amount of time the receiver will wait to receive a new message. If no new\n   * message is received in this time, then the receiver will be closed.\n   *\n   * If this option is not provided, then receiver link will stay open until manually closed.\n   *\n   * **Caution**: When setting this value, take into account the time taken to process messages. Once\n   * the receiver is closed, operations like complete()/abandon()/defer()/deadletter() cannot be\n   * invoked on messages.\n   */\n  newMessageWaitTimeoutInSeconds?: number;\n}\n\n/**\n * @internal\n * Describes all the options that can be set while instantiating a MessageSession object.\n */\nexport type MessageSessionOptions = SessionManagerOptions &\n  SessionReceiverOptions & {\n    callee?: SessionCallee;\n    receiveMode?: ReceiveMode;\n  };\n\n/**\n * @internal\n * Describes the receiver for a Message Session.\n */\nexport class MessageSession extends LinkEntity {\n  /**\n   * @property {Date} [sessionLockedUntilUtc] Provides the duration until which the session is locked.\n   */\n  sessionLockedUntilUtc?: Date;\n  /**\n   * @property {string} [sessionId] The sessionId for the message session. Empty string is valid sessionId\n   */\n  sessionId?: string;\n  /**\n   * @property {number} [maxConcurrentSessions] The maximum number of concurrent sessions that the\n   * client should initate.\n   * - **Default**: `1`.\n   */\n  maxConcurrentSessions?: number;\n  /**\n   * @property {number} [maxConcurrentCalls] The maximum number of messages that should be\n   * processed concurrently in a session while in streaming mode. Once this limit has been reached,\n   * more messages will not be received until the user's message handler has completed processing current message.\n   * - **Default**: `1` (message in a session at a time).\n   */\n  maxConcurrentCalls: number = 1;\n  /**\n   * @property {number} [receiveMode] The mode in which messages should be received.\n   * Default: ReceiveMode.peekLock\n   */\n  receiveMode: ReceiveMode;\n  /**\n   * @property {boolean} autoComplete Indicates whether `Message.complete()` should be called\n   * automatically after the message processing is complete while receiving messages with handlers.\n   * Default: false.\n   */\n  autoComplete: boolean;\n  /**\n   * @property {number} maxAutoRenewDurationInSeconds The maximum duration within which the\n   * lock will be renewed automatically. This value should be greater than the longest message\n   * lock duration; for example, the `lockDuration` property on the received message.\n   *\n   * Default: `300` (5 minutes);\n   */\n  maxAutoRenewDurationInSeconds: number;\n  /**\n   * @property {number} [newMessageWaitTimeoutInSeconds] The maximum amount of idle time the session\n   * reaceiver will wait ater a message has been received. If no messages are received in that\n   * time frame then the session will be closed.\n   */\n  newMessageWaitTimeoutInSeconds?: number;\n  /**\n   * @property {boolean} autoRenewLock Should lock renewal happen automatically.\n   */\n  autoRenewLock: boolean;\n  /**\n   * @property {SessionCallee} callee Describes who instantied the MessageSession. Whether it was\n   * called by the SessionManager or it was called standalone.\n   * - Default: \"standalone\"\n   */\n  callee: SessionCallee;\n  /**\n   * Denotes if we are currently receiving messages\n   */\n  isReceivingMessages: boolean;\n  /**\n   * @property {Receiver} [_receiver] The AMQP receiver link.\n   */\n  private _receiver?: Receiver;\n  /**\n   * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that\n   * are being actively disposed. It acts as a store for correlating the responses received for\n   * active dispositions.\n   */\n  private _deliveryDispositionMap: Map<number, PromiseLike> = new Map<number, PromiseLike>();\n  /**\n   * @property {OnMessage} _onMessage The message handler provided by the user that will\n   * be wrapped inside _onAmqpMessage.\n   */\n  private _onMessage!: OnMessage;\n  /**\n   * @property {OnError} _onError The error handler provided by the user that will be wrapped\n   * inside _onAmqpError.\n   */\n  private _onError?: OnError;\n  /**\n   * @property {OnError} _notifyError If the user provided error handler is present then it will\n   * notify the user's error handler about the error.\n   */\n  private _notifyError: OnError;\n  /**\n   * @property {OnAmqpEventAsPromise} _onAmqpClose The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_close\" event.\n   */\n  private _onAmqpClose: OnAmqpEventAsPromise;\n  /**\n   * @property {OnAmqpEvent} _onSessionError The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEventAsPromise} _onSessionClose The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEventAsPromise;\n  /**\n   * @property {OnAmqpEvent} _onAmqpError The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_error\" event.\n   */\n  private _onAmqpError: OnAmqpEvent;\n  /**\n   * @property {OnAmqpEvent} _onSettled The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"settled\" event.\n   */\n  private _onSettled: OnAmqpEvent;\n  /**\n   * @property {NodeJS.Timer} _sessionLockRenewalTimer The session lock renewal timer that keeps\n   * track of when the MessageSession is due for session lock renewal.\n   */\n  private _sessionLockRenewalTimer?: NodeJS.Timer;\n  /**\n   * @property {NodeJS.Timer} _newMessageReceivedTimer The new message received timer that keeps\n   * track of closing the MessageSession if no message was received in the configured\n   * `newMessageWaitTimeoutInSeconds` seconds.\n   */\n  private _newMessageReceivedTimer?: NodeJS.Timer;\n\n  private _totalAutoLockRenewDuration: number;\n\n  /**\n   * Ensures that the session lock is renewed before it expires. The lock will not be renewed for\n   * more than the configured totalAutoLockRenewDuration.\n   */\n  private _ensureSessionLockRenewal(): void {\n    if (\n      this.autoRenewLock &&\n      new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc! &&\n      Date.now() < this._totalAutoLockRenewDuration &&\n      this.isOpen()\n    ) {\n      const connectionId = this._context.namespace.connectionId;\n      const nextRenewalTimeout = calculateRenewAfterDuration(this.sessionLockedUntilUtc!);\n      this._sessionLockRenewalTimer = setTimeout(async () => {\n        try {\n          log.messageSession(\n            \"[%s] Attempting to renew the session lock for MessageSession '%s' \" +\n              \"with name '%s'.\",\n            connectionId,\n            this.sessionId,\n            this.name\n          );\n          this.sessionLockedUntilUtc = await this._context.managementClient!.renewSessionLock(\n            this.sessionId!,\n            {\n              delayInSeconds: 0,\n              timeoutInSeconds: 10,\n              times: 4\n            }\n          );\n          log.receiver(\n            \"[%s] Successfully renewed the session lock for MessageSession '%s' \" +\n              \"with name '%s'.\",\n            connectionId,\n            this.sessionId,\n            this.name\n          );\n          log.receiver(\n            \"[%s] Calling _ensureSessionLockRenewal() again for MessageSession '%s'.\",\n            connectionId,\n            this.sessionId\n          );\n          this._ensureSessionLockRenewal();\n        } catch (err) {\n          log.error(\n            \"[%s] An error occurred while renewing the session lock for MessageSession \" +\n              \"'%s' with name '%s': %O\",\n            this._context.namespace.connectionId,\n            this.sessionId,\n            this.name,\n            err\n          );\n        }\n      }, nextRenewalTimeout);\n      log.messageSession(\n        \"[%s] MessageSession '%s' with name '%s', has next session lock renewal \" +\n          \"in %d seconds @(%s).\",\n        this._context.namespace.connectionId,\n        this.sessionId,\n        this.name,\n        nextRenewalTimeout / 1000,\n        new Date(Date.now() + nextRenewalTimeout).toString()\n      );\n    }\n  }\n\n  /**\n   * Deletes the MessageSession from the internal cache.\n   */\n  private _deleteFromCache(): void {\n    this._receiver = undefined;\n    delete this._context.messageSessions[this.sessionId!];\n    log.error(\n      \"[%s] Deleted the receiver '%s' with sessionId '%s' from the client cache.\",\n      this._context.namespace.connectionId,\n      this.name,\n      this.sessionId\n    );\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   */\n  private async _init(): Promise<void> {\n    const connectionId = this._context.namespace.connectionId;\n    try {\n      if (!this.isOpen() && !this.isConnecting) {\n        log.error(\n          \"[%s] The receiver '%s' with address '%s' is not open and is not currently \" +\n            \"establishing itself. Hence let's try to connect.\",\n          connectionId,\n          this.name,\n          this.address\n        );\n        this.isConnecting = true;\n        await this._negotiateClaim();\n\n        const options = this._createMessageSessionOptions();\n\n        log.error(\n          \"[%s] Trying to create receiver '%s' with options %O\",\n          connectionId,\n          this.name,\n          options\n        );\n\n        this._receiver = await this._context.namespace.connection.createReceiver(options);\n        this.isConnecting = false;\n        const receivedSessionId =\n          this._receiver.source &&\n          this._receiver.source.filter &&\n          this._receiver.source.filter[Constants.sessionFilterName];\n        let errorMessage: string = \"\";\n        // SB allows a sessionId with empty string value :)\n        if (receivedSessionId == null) {\n          errorMessage =\n            `Received an incorrect sessionId '${receivedSessionId}' while creating ` +\n            `the receiver '${this.name}'.`;\n        }\n        if (this.sessionId != null && receivedSessionId !== this.sessionId) {\n          errorMessage =\n            `Received sessionId '${receivedSessionId}' does not match the provided ` +\n            `sessionId '${this.sessionId}' while creating the receiver '${this.name}'.`;\n        }\n        if (errorMessage) {\n          const error = translate({\n            description: errorMessage,\n            condition: ErrorNameConditionMapper.SessionCannotBeLockedError\n          });\n          log.error(\"[%s] %O\", this._context.namespace.connectionId, error);\n          throw error;\n        }\n        if (this.sessionId == null) this.sessionId = receivedSessionId;\n        this.sessionLockedUntilUtc = convertTicksToDate(\n          this._receiver.properties[\"com.microsoft:locked-until-utc\"]\n        );\n        log.messageSession(\n          \"[%s] Session with id '%s' is locked until: '%s'.\",\n          connectionId,\n          this.sessionId,\n          this.sessionLockedUntilUtc.toISOString()\n        );\n        log.error(\n          \"[%s] Receiver '%s' for sessionId '%s' has established itself.\",\n          connectionId,\n          this.name,\n          this.sessionId\n        );\n        log.messageSession(\n          \"Promise to create the receiver resolved. \" + \"Created receiver with name: \",\n          this.name\n        );\n        log.messageSession(\n          \"[%s] Receiver '%s' created with receiver options: %O\",\n          connectionId,\n          this.name,\n          options\n        );\n        if (!this._context.messageSessions[this.sessionId!]) {\n          this._context.messageSessions[this.sessionId!] = this;\n        }\n        this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;\n        await this._ensureTokenRenewal();\n        await this._ensureSessionLockRenewal();\n      } else {\n        log.error(\n          \"[%s] The receiver '%s' for sessionId '%s' is open -> %s and is connecting \" +\n            \"-> %s. Hence not reconnecting.\",\n          connectionId,\n          this.name,\n          this.sessionId,\n          this.isOpen(),\n          this.isConnecting\n        );\n      }\n    } catch (err) {\n      this.isConnecting = false;\n      const errObj = translate(err);\n      log.error(\n        \"[%s] An error occured while creating the receiver '%s': %O\",\n        this._context.namespace.connectionId,\n        this.name,\n        errObj\n      );\n      throw errObj;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   */\n  private _createMessageSessionOptions(): ReceiverOptions {\n    const rcvrOptions: ReceiverOptions = {\n      name: this.name,\n      autoaccept: false,\n      // receiveAndDelete -> first(0), peekLock -> second (1)\n      rcv_settle_mode: this.receiveMode === ReceiveMode.receiveAndDelete ? 0 : 1,\n      // receiveAndDelete -> settled (1), peekLock -> unsettled (0)\n      snd_settle_mode: this.receiveMode === ReceiveMode.receiveAndDelete ? 1 : 0,\n      source: {\n        address: this.address,\n        filter: {}\n      },\n      credit_window: 0,\n      onClose: (context) =>\n        this._onAmqpClose(context).catch(() => {\n          /* */\n        }),\n      onSessionClose: (context) =>\n        this._onSessionClose(context).catch(() => {\n          /* */\n        }),\n      onError: this._onAmqpError,\n      onSessionError: this._onSessionError,\n      onSettled: this._onSettled\n    };\n    (rcvrOptions.source as any).filter[Constants.sessionFilterName] = this.sessionId;\n    return rcvrOptions;\n  }\n\n  constructor(context: ClientEntityContext, options?: MessageSessionOptions) {\n    super(context.entityPath, context, {\n      address: context.entityPath,\n      audience: `${context.namespace.config.endpoint}${context.entityPath}`\n    });\n    this._context.isSessionEnabled = true;\n    this.isReceivingMessages = false;\n    if (!options) options = { sessionId: undefined };\n    this.autoComplete = false;\n    this.sessionId = options.sessionId;\n    this.receiveMode = options.receiveMode || ReceiveMode.peekLock;\n    this.callee = options.callee || SessionCallee.standalone;\n    this.maxAutoRenewDurationInSeconds =\n      options.maxSessionAutoRenewLockDurationInSeconds != null\n        ? options.maxSessionAutoRenewLockDurationInSeconds\n        : 300;\n    this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;\n    this.autoRenewLock =\n      this.maxAutoRenewDurationInSeconds > 0 && this.receiveMode === ReceiveMode.peekLock;\n\n    // setting all the handlers\n    this._onSettled = (context: EventContext) => {\n      const connectionId = this._context.namespace.connectionId;\n      const delivery = context.delivery;\n      if (delivery) {\n        const id = delivery.id;\n        const state = delivery.remote_state;\n        const settled = delivery.remote_settled;\n        log.receiver(\n          \"[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been \" + \"received.\",\n          connectionId,\n          id,\n          settled,\n          state && state.error ? state.error : state\n        );\n        if (settled && this._deliveryDispositionMap.has(id)) {\n          const promise = this._deliveryDispositionMap.get(id) as PromiseLike;\n          clearTimeout(promise.timer);\n          log.receiver(\n            \"[%s] Found the delivery with id %d in the map and cleared the timer.\",\n            connectionId,\n            id\n          );\n          const deleteResult = this._deliveryDispositionMap.delete(id);\n          log.receiver(\n            \"[%s] Successfully deleted the delivery with id %d from the map.\",\n            connectionId,\n            id,\n            deleteResult\n          );\n          if (state && state.error && (state.error.condition || state.error.description)) {\n            const error = translate(state.error);\n            return promise.reject(error);\n          }\n\n          return promise.resolve();\n        }\n      }\n    };\n\n    this._notifyError = (error: MessagingError | Error) => {\n      if (this._onError) {\n        this._onError(error);\n        log.error(\n          \"[%s] Notified the user's error handler about the error received by the \" +\n            \"Receiver '%s'.\",\n          this._context.namespace.connectionId,\n          this.name\n        );\n      }\n    };\n\n    this._onAmqpError = (context: EventContext) => {\n      const connectionId = this._context.namespace.connectionId;\n      const receiverError = context.receiver && context.receiver.error;\n      if (receiverError) {\n        const sbError = translate(receiverError);\n        if (sbError.name === \"SessionLockLostError\") {\n          this._context.expiredMessageSessions[this.sessionId!] = true;\n          sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;\n        }\n        log.error(\n          \"[%s] An error occurred for Receiver '%s': %O.\",\n          connectionId,\n          this.name,\n          sbError\n        );\n        this._notifyError(sbError);\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const connectionId = this._context.namespace.connectionId;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translate(sessionError);\n        log.error(\n          \"[%s] An error occurred on the session for Receiver '%s': %O.\",\n          connectionId,\n          this.name,\n          sbError\n        );\n        this._notifyError(sbError);\n      }\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const connectionId = this._context.namespace.connectionId;\n      const receiverError = context.receiver && context.receiver.error;\n      const receiver = this._receiver || context.receiver!;\n      let isClosedDueToExpiry = false;\n      if (receiverError) {\n        const sbError = translate(receiverError);\n        if (sbError.name === \"SessionLockLostError\") {\n          isClosedDueToExpiry = true;\n        }\n        log.error(\n          \"[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. \" +\n            \"The associated error is: %O\",\n          connectionId,\n          this.name,\n          this.sessionId,\n          sbError\n        );\n        // no need to notify the user's error handler since rhea guarantees that receiver_error\n        // will always be emitted before receiver_close.\n      }\n      if (receiver && !receiver.isItselfClosed()) {\n        log.error(\n          \"[%s] 'receiver_close' event occurred on the receiver '%s' for sessionId '%s' \" +\n            \"and the sdk did not initiate this. Hence, let's gracefully close the receiver.\",\n          connectionId,\n          this.name,\n          this.sessionId\n        );\n        try {\n          await this.close(isClosedDueToExpiry);\n        } catch (err) {\n          log.error(\n            \"[%s] An error occurred while closing the receiver '%s' for sessionId '%s': %O.\",\n            connectionId,\n            this.name,\n            this.sessionId,\n            err\n          );\n        }\n      } else {\n        log.error(\n          \"[%s] 'receiver_close' event occurred on the receiver '%s' for sessionId '%s' \" +\n            \"because the sdk initiated it. Hence no need to gracefully close the receiver\",\n          connectionId,\n          this.name,\n          this.sessionId\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const connectionId = this._context.namespace.connectionId;\n      const receiver = this._receiver || context.receiver!;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translate(sessionError);\n        log.error(\n          \"[%s] 'session_close' event occurred for receiver '%s' for sessionId '%s'. \" +\n            \"The associated error is: %O\",\n          connectionId,\n          this.name,\n          this.sessionId,\n          sbError\n        );\n        // no need to notify the user's error handler since rhea guarantees that session_error\n        // will always be emitted before session_close.\n      }\n\n      if (receiver && !receiver.isSessionItselfClosed()) {\n        log.error(\n          \"[%s] 'session_close' event occurred on the receiver '%s' for sessionId '%s' \" +\n            \"and the sdk did not initiate this. Hence, let's gracefully close the receiver.\",\n          connectionId,\n          this.name,\n          this.sessionId\n        );\n        try {\n          await this.close();\n        } catch (err) {\n          log.error(\n            \"[%s] An error occurred while closing the receiver '%s' for sessionId '%s': %O.\",\n            connectionId,\n            this.name,\n            this.sessionId,\n            err\n          );\n        }\n      } else {\n        log.error(\n          \"[%s] 'session_close' event occurred on the receiver '%s' for sessionId '%s' \" +\n            \"because the sdk initiated it. Hence no need to gracefully close the receiver\",\n          connectionId,\n          this.name,\n          this.sessionId\n        );\n      }\n    };\n  }\n\n  /**\n   * Closes the underlying AMQP receiver link.\n   * @param isClosedDueToExpiry Flag that denotes if close is invoked due to session expiring.\n   * This is so that the internal map of expired sessions doesn't get cleared when session is\n   * closed due to expiry.\n   */\n  async close(isClosedDueToExpiry?: boolean): Promise<void> {\n    try {\n      log.messageSession(\n        \"[%s] Closing the MessageSession '%s' for queue '%s'.\",\n        this._context.namespace.connectionId,\n        this.sessionId,\n        this.name\n      );\n\n      this.isReceivingMessages = false;\n      if (this._newMessageReceivedTimer) clearTimeout(this._newMessageReceivedTimer);\n      if (this._sessionLockRenewalTimer) clearTimeout(this._sessionLockRenewalTimer);\n      log.messageSession(\n        \"[%s] Cleared the timers for 'no new message received' task and \" +\n          \"'session lock renewal' task.\",\n        this._context.namespace.connectionId\n      );\n\n      if (!isClosedDueToExpiry) {\n        delete this._context.expiredMessageSessions[this.sessionId!];\n      }\n\n      if (this._receiver) {\n        const receiverLink = this._receiver;\n        this._deleteFromCache();\n        await this._closeLink(receiverLink);\n      }\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while closing the message session with id '%s': %O.\",\n        this._context.namespace.connectionId,\n        this.sessionId,\n        err\n      );\n    }\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   */\n  isOpen(): boolean {\n    const result: boolean = this._receiver! && this._receiver!.isOpen();\n    log.messageSession(\n      \"[%s] Receiver '%s' for sessionId '%s' is open? -> %s\",\n      this._context.namespace.connectionId,\n      this.name,\n      this.sessionId,\n      result\n    );\n    return result;\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the SessionReceiver or set the property\n   * `newMessageWaitTimeoutInSeconds` in the options to provide a timeout.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control whether messages should be automatically completed. You can\n   * also provide a timeout in seconds to denote the amount of time to wait for a new message\n   * before closing the receiver.\n   *\n   * @returns void\n   */\n  receive(onMessage: OnMessage, onError: OnError, options?: SessionMessageHandlerOptions): void {\n    if (!options) options = {};\n    this.isReceivingMessages = true;\n    if (typeof options.maxConcurrentCalls === \"number\" && options.maxConcurrentCalls > 0) {\n      this.maxConcurrentCalls = options.maxConcurrentCalls;\n    }\n\n    // If explicitly set to false then autoComplete is false else true (default).\n    this.autoComplete = options.autoComplete === false ? options.autoComplete : true;\n    this._onMessage = onMessage;\n    this._onError = onError;\n    const connectionId = this._context.namespace.connectionId;\n\n    /**\n     * Resets the timer when a new message is received for Session Manager.\n     * It will close the receiver gracefully, if no\n     * messages were received for the configured newMessageWaitTimeoutInSeconds\n     */\n    const resetTimerOnNewMessageReceived = (): void => {\n      if (this._newMessageReceivedTimer) clearTimeout(this._newMessageReceivedTimer);\n      if (this.newMessageWaitTimeoutInSeconds) {\n        this._newMessageReceivedTimer = setTimeout(async () => {\n          const msg =\n            `MessageSession '${this.sessionId}' with name '${this.name}' did not receive ` +\n            `any messages in the last ${this.newMessageWaitTimeoutInSeconds} seconds. Hence closing it.`;\n          log.error(\"[%s] %s\", this._context.namespace.connectionId, msg);\n\n          if (this.callee === SessionCallee.sessionManager) {\n            // The session manager will not forward this error to user.\n            // Instead, this is taken as a indicator to create a new session client for the next session.\n            const error = translate({\n              condition: \"com.microsoft:message-wait-timeout\",\n              description: msg\n            });\n            this._notifyError(translate(error));\n          }\n          await this.close();\n        }, this.newMessageWaitTimeoutInSeconds * 1000);\n      }\n    };\n\n    if (this._receiver && this._receiver.isOpen()) {\n      const onSessionMessage = async (context: EventContext): Promise<void> => {\n        // If the receiver got closed in PeekLock mode, avoid processing the message as we\n        // cannot settle the message.\n        if (\n          this.receiveMode === ReceiveMode.peekLock &&\n          (!this._receiver || !this._receiver.isOpen())\n        ) {\n          log.error(\n            \"[%s] Not calling the user's message handler for the current message \" +\n              \"as the receiver '%s' is closed\",\n            connectionId,\n            this.name\n          );\n          return;\n        }\n\n        resetTimerOnNewMessageReceived();\n        const bMessage: ServiceBusMessage = new ServiceBusMessage(\n          this._context,\n          context.message!,\n          context.delivery!,\n          true\n        );\n        try {\n          await this._onMessage(bMessage);\n        } catch (err) {\n          // This ensures we call users' error handler when users' message handler throws.\n          if (!isAmqpError(err)) {\n            log.error(\n              \"[%s] An error occurred while running user's message handler for the message \" +\n                \"with id '%s' on the receiver '%s': %O\",\n              connectionId,\n              bMessage.messageId,\n              this.name,\n              err\n            );\n            this._onError!(err);\n          }\n\n          const error = translate(err);\n          // Nothing much to do if user's message handler throws. Let us try abandoning the message.\n          if (\n            !bMessage.delivery.remote_settled &&\n            this.receiveMode === ReceiveMode.peekLock &&\n            this.isOpen() // only try to abandon the messages if the connection is still open\n          ) {\n            try {\n              log.error(\n                \"[%s] Abandoning the message with id '%s' on the receiver '%s' since \" +\n                  \"an error occured: %O.\",\n                connectionId,\n                bMessage.messageId,\n                this.name,\n                error\n              );\n              await bMessage.abandon();\n            } catch (abandonError) {\n              const translatedError = translate(abandonError);\n              log.error(\n                \"[%s] An error occurred while abandoning the message with id '%s' on the \" +\n                  \"receiver '%s': %O.\",\n                connectionId,\n                bMessage.messageId,\n                this.name,\n                translatedError\n              );\n              this._notifyError(translatedError);\n            }\n          }\n          return;\n        } finally {\n          if (this._receiver) {\n            this._receiver!.addCredit(1);\n          }\n        }\n\n        // If we've made it this far, then user's message handler completed fine. Let us try\n        // completing the message.\n        if (\n          this.autoComplete &&\n          this.receiveMode === ReceiveMode.peekLock &&\n          !bMessage.delivery.remote_settled\n        ) {\n          try {\n            log.messageSession(\n              \"[%s] Auto completing the message with id '%s' on \" + \"the receiver '%s'.\",\n              connectionId,\n              bMessage.messageId,\n              this.name\n            );\n            await bMessage.complete();\n          } catch (completeError) {\n            const translatedError = translate(completeError);\n            log.error(\n              \"[%s] An error occurred while completing the message with id '%s' on the \" +\n                \"receiver '%s': %O.\",\n              connectionId,\n              bMessage.messageId,\n              this.name,\n              translatedError\n            );\n            this._notifyError(translatedError);\n          }\n        }\n      };\n      // setting the \"message\" event listener.\n      this._receiver.on(ReceiverEvents.message, onSessionMessage);\n      // adding credit\n      this._receiver!.addCredit(this.maxConcurrentCalls);\n    } else {\n      this.isReceivingMessages = false;\n      const msg =\n        `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` +\n        `has either not been created or is not open.`;\n      log.error(\"[%s] %s\", this._context.namespace.connectionId, msg);\n      this._notifyError(new Error(msg));\n    }\n  }\n\n  /**\n   * Returns a batch of messages based on given count and timeout over an AMQP receiver link\n   * from a Queue/Subscription.\n   *\n   * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.\n   * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * - **Default**: `60` seconds.\n   * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.\n   */\n  async receiveMessages(\n    maxMessageCount: number,\n    maxWaitTimeInSeconds?: number\n  ): Promise<ServiceBusMessage[]> {\n    if (maxWaitTimeInSeconds == null) {\n      maxWaitTimeInSeconds = Constants.defaultOperationTimeoutInSeconds;\n    }\n\n    const brokeredMessages: ServiceBusMessage[] = [];\n    this.isReceivingMessages = true;\n\n    return new Promise<ServiceBusMessage[]>((resolve, reject) => {\n      let totalWaitTimer: any;\n\n      const setnewMessageWaitTimeoutInSeconds = (value?: number): void => {\n        this.newMessageWaitTimeoutInSeconds = value;\n      };\n\n      setnewMessageWaitTimeoutInSeconds(1);\n\n      // Action to be performed on the \"receiver_drained\" event.\n      const onReceiveDrain: OnAmqpEvent = () => {\n        this._receiver!.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n        this._receiver!.drain = false;\n\n        this.isReceivingMessages = false;\n\n        log.messageSession(\n          \"[%s] Receiver '%s' drained. Resolving receiveMessages() with %d messages.\",\n          this._context.namespace.connectionId,\n          this.name,\n          brokeredMessages.length\n        );\n\n        resolve(brokeredMessages);\n      };\n\n      // Action to be performed after the max wait time is over.\n      const actionAfterWaitTimeout: Func<void, void> = (): void => {\n        log.batching(\n          \"[%s] Batching Receiver '%s'  max wait time in seconds %d over.\",\n          this._context.namespace.connectionId,\n          this.name,\n          maxWaitTimeInSeconds\n        );\n        return finalAction();\n      };\n\n      // Action to be performed on the \"message\" event.\n      const onReceiveMessage: OnAmqpEventAsPromise = async (context: EventContext) => {\n        resetTimerOnNewMessageReceived();\n        try {\n          const data: ServiceBusMessage = new ServiceBusMessage(\n            this._context,\n            context.message!,\n            context.delivery!,\n            true\n          );\n          if (brokeredMessages.length < maxMessageCount) {\n            brokeredMessages.push(data);\n          }\n        } catch (err) {\n          // Removing listeners, so that the next receiveMessages() call can set them again.\n          if (this._receiver) {\n            this._receiver.removeListener(ReceiverEvents.message, onReceiveMessage);\n            this._receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n          }\n\n          log.error(\n            \"[%s] Receiver '%s' received an error while converting AmqpMessage to ServiceBusMessage:\\n%O\",\n            this._context.namespace.connectionId,\n            this.name,\n            err\n          );\n          reject(err instanceof Error ? err : new Error(JSON.stringify(err)));\n        }\n        if (brokeredMessages.length === maxMessageCount) {\n          finalAction();\n        }\n      };\n\n      this._onError = (error: MessagingError | Error) => {\n        this.isReceivingMessages = false;\n        // Resetting the newMessageWaitTimeoutInSeconds to undefined since we are done receiving\n        // a batch of messages.\n        setnewMessageWaitTimeoutInSeconds();\n        if (totalWaitTimer) {\n          clearTimeout(totalWaitTimer);\n        }\n        // Removing listeners, so that the next receiveMessages() call can set them again.\n        if (this._receiver) {\n          this._receiver.removeListener(ReceiverEvents.message, onReceiveMessage);\n          this._receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n        }\n        reject(error);\n      };\n\n      // Final action to be performed after maxMessageCount is reached or the maxWaitTime is over.\n      const finalAction = (): void => {\n        if (this._newMessageReceivedTimer) {\n          clearTimeout(this._newMessageReceivedTimer);\n        }\n        if (totalWaitTimer) {\n          clearTimeout(totalWaitTimer);\n        }\n\n        // Unsetting the newMessageWaitTimeoutInSeconds to undefined since we are done receiving\n        // a batch of messages.\n        setnewMessageWaitTimeoutInSeconds();\n\n        // Removing listeners, so that the next receiveMessages() call can set them again.\n        if (this._receiver) {\n          this._receiver.removeListener(ReceiverEvents.message, onReceiveMessage);\n        }\n\n        if (this._receiver && this._receiver.credit > 0) {\n          log.messageSession(\n            \"[%s] Receiver '%s': Draining leftover credits(%d).\",\n            this._context.namespace.connectionId,\n            this.name,\n            this._receiver.credit\n          );\n\n          // Setting drain must be accompanied by a flow call (aliased to addCredit in this case).\n          this._receiver.drain = true;\n          this._receiver.addCredit(1);\n        } else {\n          if (this._receiver) {\n            this._receiver.removeListener(ReceiverEvents.receiverDrained, onReceiveDrain);\n          }\n\n          this.isReceivingMessages = false;\n          log.messageSession(\n            \"[%s] Receiver '%s': Resolving receiveMessages() with %d messages.\",\n            this._context.namespace.connectionId,\n            this.name,\n            brokeredMessages.length\n          );\n          resolve(brokeredMessages);\n        }\n      };\n\n      /**\n       * Resets the timer when a new message is received. If no messages were received for\n       * `newMessageWaitTimeoutInSeconds`, the messages received till now are returned. The\n       * receiver link stays open for the next receive call, but doesnt receive messages until then.\n       * The new message wait timer mechanism is used only in `peekLock` mode.\n       */\n      const resetTimerOnNewMessageReceived =\n        this.receiveMode === ReceiveMode.peekLock\n          ? (): void => {\n              if (this._newMessageReceivedTimer) clearTimeout(this._newMessageReceivedTimer);\n              if (this.newMessageWaitTimeoutInSeconds) {\n                this._newMessageReceivedTimer = setTimeout(async () => {\n                  const msg =\n                    `MessageSession '${this.sessionId}' with name '${this.name}' did not receive ` +\n                    `any messages in the last ${this.newMessageWaitTimeoutInSeconds} seconds. Hence closing it.`;\n                  log.error(\"[%s] %s\", this._context.namespace.connectionId, msg);\n                  finalAction();\n                  if (this.callee === SessionCallee.sessionManager) {\n                    await this.close();\n                  }\n                }, this.newMessageWaitTimeoutInSeconds * 1000);\n              }\n            }\n          : () => {};\n\n      const addCreditAndSetTimer = (reuse?: boolean): void => {\n        log.batching(\n          \"[%s] Receiver '%s', adding credit for receiving %d messages.\",\n          this._context.namespace.connectionId,\n          this.name,\n          maxMessageCount\n        );\n        // By adding credit here, we let the service know that at max we can handle `maxMessageCount`\n        // number of messages concurrently. We will return the user an array of messages that can\n        // be of size upto maxMessageCount. Then the user needs to accordingly dispose\n        // (complete,/abandon/defer/deadletter) the messages from the array.\n        this._receiver!.addCredit(maxMessageCount);\n        let msg: string = \"[%s] Setting the wait timer for %d seconds for receiver '%s'.\";\n        if (reuse) msg += \" Receiver link already present, hence reusing it.\";\n        log.batching(msg, this._context.namespace.connectionId, maxWaitTimeInSeconds, this.name);\n        totalWaitTimer = setTimeout(\n          actionAfterWaitTimeout,\n          (maxWaitTimeInSeconds as number) * 1000\n        );\n      };\n\n      if (this.isOpen()) {\n        this._receiver!.on(ReceiverEvents.message, onReceiveMessage);\n        this._receiver!.on(ReceiverEvents.receiverDrained, onReceiveDrain);\n        addCreditAndSetTimer(true);\n      } else {\n        const msg =\n          `MessageSession \"${this.name}\" with sessionId \"${this.sessionId}\", ` +\n          `is already closed. Hence cannot receive messages in a batch.`;\n        log.error(\"[%s] %s\", this._context.namespace.connectionId, msg);\n        reject(new Error(msg));\n      }\n    });\n  }\n\n  /**\n   * Settles the message with the specified disposition.\n   * @param message The ServiceBus Message that needs to be settled.\n   * @param operation The disposition type.\n   * @param options Optional parameters that can be provided while disposing the message.\n   */\n  async settleMessage(\n    message: ServiceBusMessage,\n    operation: DispositionType,\n    options?: DispositionOptions\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      if (!options) options = {};\n      if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {\n        return reject(new Error(`operation: '${operation}' is not a valid operation.`));\n      }\n      const delivery = message.delivery;\n      const timer = setTimeout(() => {\n        this._deliveryDispositionMap.delete(delivery.id);\n        log.receiver(\n          \"[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. \" +\n            \"Hence rejecting the promise with timeout error\",\n          this._context.namespace.connectionId,\n          delivery.id,\n          Constants.defaultOperationTimeoutInSeconds * 1000\n        );\n\n        const e: AmqpError = {\n          condition: ErrorNameConditionMapper.ServiceUnavailableError,\n          description:\n            \"Operation to settle the message has timed out. The disposition of the \" +\n            \"message may or may not be successful\"\n        };\n        return reject(translate(e));\n      }, Constants.defaultOperationTimeoutInSeconds * 1000);\n      this._deliveryDispositionMap.set(delivery.id, {\n        resolve: resolve,\n        reject: reject,\n        timer: timer\n      });\n      if (operation === DispositionType.complete) {\n        delivery.accept();\n      } else if (operation === DispositionType.abandon) {\n        const params: any = {\n          undeliverable_here: false\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.defer) {\n        const params: any = {\n          undeliverable_here: true\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.deadletter) {\n        delivery.reject(options.error || {});\n      }\n    });\n  }\n\n  /**\n   * Creates a new instance of the MessageSession based on the provided parameters.\n   * @param context The client entity context\n   * @param options Options that can be provided while creating the MessageSession.\n   */\n  static async create(\n    context: ClientEntityContext,\n    options?: MessageSessionOptions\n  ): Promise<MessageSession> {\n    throwErrorIfConnectionClosed(context.namespace);\n    const messageSession = new MessageSession(context, options);\n    await messageSession._init();\n    return messageSession;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport Long from \"long\";\nimport * as log from \"./log\";\nimport { StreamingReceiver, MessageHandlerOptions } from \"./core/streamingReceiver\";\nimport { BatchingReceiver } from \"./core/batchingReceiver\";\nimport { ReceiveOptions, OnError, OnMessage } from \"./core/messageReceiver\";\nimport { ClientEntityContext } from \"./clientEntityContext\";\nimport { ServiceBusMessage, ReceiveMode, ReceivedMessageInfo } from \"./serviceBusMessage\";\nimport {\n  MessageSession,\n  SessionMessageHandlerOptions,\n  SessionReceiverOptions\n} from \"./session/messageSession\";\nimport {\n  getAlreadyReceivingErrorMsg,\n  getOpenReceiverErrorMsg,\n  getReceiverClosedErrorMsg,\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n  throwTypeErrorIfParameterNotLongArray,\n  getErrorMessageNotSupportedInReceiveAndDeleteMode\n} from \"./util/errors\";\n\n/**\n * The Receiver class can be used to receive messages in a batch or by registering handlers.\n * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate a Receiver.\n * The Receiver class is an abstraction over the underlying AMQP receiver link.\n * @class Receiver\n */\nexport class Receiver {\n  /**\n   * @property Describes the amqp connection context for the QueueClient.\n   */\n  private _context: ClientEntityContext;\n  private _receiveMode: ReceiveMode;\n  /**\n   * @property {boolean} [_isClosed] Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n\n  /**\n   * @internal\n   * @throws Error if the underlying connection is closed.\n   */\n  constructor(context: ClientEntityContext, receiveMode: ReceiveMode) {\n    throwErrorIfConnectionClosed(context.namespace);\n    this._context = context;\n\n    this._receiveMode =\n      receiveMode === ReceiveMode.receiveAndDelete ? receiveMode : ReceiveMode.peekLock;\n  }\n\n  private _throwIfAlreadyReceiving(): void {\n    if (this.isReceivingMessages()) {\n      const errorMessage = getAlreadyReceivingErrorMsg(this._context.entityPath);\n      const error = new Error(errorMessage);\n      log.error(`[${this._context.namespace.connectionId}] %O`, error);\n      throw error;\n    }\n  }\n\n  private _throwIfReceiverOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    if (this.isClosed) {\n      const errorMessage = getReceiverClosedErrorMsg(\n        this._context.entityPath,\n        this._context.clientType,\n        this._context.isClosed\n      );\n      const error = new Error(errorMessage);\n      log.error(`[${this._context.namespace.connectionId}] %O`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * @property Denotes receiveMode of this receiver.\n   * @readonly\n   */\n  public get receiveMode(): ReceiveMode {\n    return this._receiveMode;\n  }\n\n  /**\n   * @property Returns `true` if the receiver is closed. This can happen either because the receiver\n   * itself has been closed or the client that created it has been closed.\n   * @readonly\n   */\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.isClosed;\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the Receiver.\n   *\n   * Throws an error if there is another receive operation in progress on the same receiver. If you\n   * are not sure whether there is another receive operation running, check the `isReceivingMessages`\n   * property on the receiver.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control if messages should be automatically completed, and/or have\n   * their locks automatically renewed. You can control the maximum number of messages that should\n   * be concurrently processed. You can also provide a timeout in seconds to denote the\n   * amount of time to wait for a new message before closing the receiver.\n   *\n   * @returns void\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws Error if current receiver is already in state of receiving messages.\n   * @throws MessagingError if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.\n   */\n  registerMessageHandler(\n    onMessage: OnMessage,\n    onError: OnError,\n    options?: MessageHandlerOptions\n  ): void {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    const connId = this._context.namespace.connectionId;\n    throwTypeErrorIfParameterMissing(connId, \"onMessage\", onMessage);\n    throwTypeErrorIfParameterMissing(connId, \"onError\", onError);\n    if (typeof onMessage !== \"function\") {\n      throw new TypeError(\"The parameter 'onMessage' must be of type 'function'.\");\n    }\n    if (typeof onError !== \"function\") {\n      throw new TypeError(\"The parameter 'onError' must be of type 'function'.\");\n    }\n\n    StreamingReceiver.create(this._context, {\n      ...options,\n      receiveMode: this._receiveMode\n    })\n      .then(async (sReceiver) => {\n        if (!sReceiver) {\n          return;\n        }\n        if (!this.isClosed) {\n          sReceiver.receive(onMessage, onError);\n        } else {\n          await sReceiver.close();\n        }\n        return;\n      })\n      .catch((err) => {\n        onError(err);\n      });\n  }\n\n  /**\n   * Returns a promise that resolves to an array of messages based on given count and timeout over\n   * an AMQP receiver link from a Queue/Subscription.\n   *\n   * Throws an error if there is another receive operation in progress on the same receiver. If you\n   * are not sure whether there is another receive operation running, check the `isReceivingMessages`\n   * property on the receiver.\n   *\n   * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.\n   * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * - **Default**: `60` seconds.\n   * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.\n   * @throws Error if the underlying connection, client or receiver is closed.\n   * @throws Error if current receiver is already in state of receiving messages.\n   * @throws MessagingError if the service returns an error while receiving messages.\n   */\n  async receiveMessages(\n    maxMessageCount: number,\n    maxWaitTimeInSeconds?: number\n  ): Promise<ServiceBusMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n\n    if (!this._context.batchingReceiver || !this._context.batchingReceiver.isOpen()) {\n      const options: ReceiveOptions = {\n        maxConcurrentCalls: 0,\n        receiveMode: this._receiveMode\n      };\n      this._context.batchingReceiver = BatchingReceiver.create(this._context, options);\n    }\n\n    return this._context.batchingReceiver.receive(maxMessageCount, maxWaitTimeInSeconds);\n  }\n\n  /**\n   * Gets an async iterator over messages from the receiver.\n   *\n   * Throws an error if there is another receive operation in progress on the same receiver. If you\n   * are not sure whether there is another receive operation running, check the `isReceivingMessages`\n   * property on the receiver.\n   *\n   * If the iterator is not able to fetch a new message in over a minute, `undefined` will be returned.\n   * @throws Error if the underlying connection, client or receiver is closed.\n   * @throws Error if current receiver is already in state of receiving messages.\n   * @throws MessagingError if the service returns an error while receiving messages.\n   */\n  async *getMessageIterator(): AsyncIterableIterator<ServiceBusMessage> {\n    while (true) {\n      const currentBatch = await this.receiveMessages(1);\n      yield currentBatch[0];\n    }\n  }\n\n  /**\n   * Renews the lock on the message for the duration as specified during the Queue/Subscription\n   * creation.\n   * - Check the `lockedUntilUtc` property on the message for the time when the lock expires.\n   * - If a message is not settled (using either `complete()`, `defer()` or `deadletter()`,\n   * before its lock expires, then the message lands back in the Queue/Subscription for the next\n   * receive operation.\n   *\n   * @param lockTokenOrMessage - The `lockToken` property of the message or the message itself.\n   * @returns Promise<Date> - New lock token expiry date and time in UTC format.\n   * @throws Error if the underlying connection, client or receiver is closed.\n   * @throws MessagingError if the service returns an error while renewing message lock.\n   */\n  async renewMessageLock(lockTokenOrMessage: string | ServiceBusMessage): Promise<Date> {\n    this._throwIfReceiverOrConnectionClosed();\n    if (this._receiveMode !== ReceiveMode.peekLock) {\n      throw new Error(getErrorMessageNotSupportedInReceiveAndDeleteMode(\"renew the message lock\"));\n    }\n    throwTypeErrorIfParameterMissing(\n      this._context.namespace.connectionId,\n      \"lockTokenOrMessage\",\n      lockTokenOrMessage\n    );\n\n    const lockToken =\n      lockTokenOrMessage instanceof ServiceBusMessage\n        ? String(lockTokenOrMessage.lockToken)\n        : String(lockTokenOrMessage);\n\n    const lockedUntilUtc = await this._context.managementClient!.renewLock(lockToken);\n\n    return lockedUntilUtc;\n  }\n\n  /**\n   * Returns a promise that resolves to a deferred message identified by the given `sequenceNumber`.\n   * @param sequenceNumber The sequence number of the message that needs to be received.\n   * @returns Promise<ServiceBusMessage | undefined>\n   * - Returns `Message` identified by sequence number.\n   * - Returns `undefined` if no such message is found.\n   * @throws Error if the underlying connection, client or receiver is closed.\n   * @throws MessagingError if the service returns an error while receiving deferred message.\n   */\n  async receiveDeferredMessage(sequenceNumber: Long): Promise<ServiceBusMessage | undefined> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.namespace.connectionId,\n      \"sequenceNumber\",\n      sequenceNumber\n    );\n    throwTypeErrorIfParameterNotLong(\n      this._context.namespace.connectionId,\n      \"sequenceNumber\",\n      sequenceNumber\n    );\n\n    const messages = await this._context.managementClient!.receiveDeferredMessages(\n      [sequenceNumber],\n      this._receiveMode\n    );\n    return messages[0];\n  }\n\n  /**\n   * Returns a promise that resolves to an array of deferred messages identified by given `sequenceNumbers`.\n   * @param sequenceNumbers An array of sequence numbers for the messages that need to be received.\n   * @returns Promise<ServiceBusMessage[]>\n   * - Returns a list of messages identified by the given sequenceNumbers.\n   * - Returns an empty list if no messages are found.\n   * @throws Error if the underlying connection, client or receiver is closed.\n   * @throws MessagingError if the service returns an error while receiving deferred messages.\n   */\n  async receiveDeferredMessages(sequenceNumbers: Long[]): Promise<ServiceBusMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.namespace.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n    if (!Array.isArray(sequenceNumbers)) {\n      sequenceNumbers = [sequenceNumbers];\n    }\n    throwTypeErrorIfParameterNotLongArray(\n      this._context.namespace.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n\n    return this._context.managementClient!.receiveDeferredMessages(\n      sequenceNumbers,\n      this._receiveMode\n    );\n  }\n\n  /**\n   * Closes the underlying AMQP receiver link.\n   * Once closed, the receiver cannot be used for any further operations.\n   * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate\n   * a new Receiver\n   *\n   * @returns {Promise<void>}\n   */\n  async close(): Promise<void> {\n    try {\n      this._isClosed = true;\n      if (this._context.namespace.connection && this._context.namespace.connection.isOpen()) {\n        // Close the streaming receiver.\n        if (this._context.streamingReceiver) {\n          await this._context.streamingReceiver.close();\n        }\n\n        // Close the batching receiver.\n        if (this._context.batchingReceiver) {\n          await this._context.batchingReceiver.close();\n        }\n\n        // Make sure that we clear the map of deferred messages\n        this._context.requestResponseLockedMessages.clear();\n      }\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while closing the Receiver for %s: %O\",\n        this._context.namespace.connectionId,\n        this._context.entityPath,\n        err\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Indicates whether the receiver is currently receiving messages or not.\n   * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.\n   */\n  isReceivingMessages(): boolean {\n    if (this._context.streamingReceiver && this._context.streamingReceiver.isOpen()) {\n      return true;\n    }\n    if (\n      this._context.batchingReceiver &&\n      this._context.batchingReceiver.isOpen() &&\n      this._context.batchingReceiver.isReceivingMessages\n    ) {\n      return true;\n    }\n    return false;\n  }\n}\n\n/**\n * The SessionReceiver class can be used to receive messages from a session enabled Queue or\n * Subscription in a batch or by registering handlers.\n * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate a\n * SessionReceiver.\n * The SessionReceiver class is an abstraction over the underlying AMQP receiver link.\n * @class SessionReceiver\n */\nexport class SessionReceiver {\n  /**\n   * @property {ClientEntityContext} _context Describes the amqp connection context for the QueueClient.\n   */\n\n  private _context: ClientEntityContext;\n  private _receiveMode: ReceiveMode;\n  private _messageSession: MessageSession | undefined;\n  private _sessionOptions: SessionReceiverOptions;\n  /**\n   * @property {boolean} [_isClosed] Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n  private _sessionId: string | undefined;\n\n  /**\n   * @internal\n   * @throws Error if the underlying connection is closed.\n   * @throws Error if an open receiver is already existing for given sessionId.\n   */\n  constructor(\n    context: ClientEntityContext,\n    receiveMode: ReceiveMode,\n    sessionOptions: SessionReceiverOptions\n  ) {\n    throwErrorIfConnectionClosed(context.namespace);\n    this._context = context;\n    this._receiveMode =\n      receiveMode === ReceiveMode.receiveAndDelete ? receiveMode : ReceiveMode.peekLock;\n    this._sessionOptions = sessionOptions;\n\n    if (sessionOptions.sessionId) {\n      sessionOptions.sessionId = String(sessionOptions.sessionId);\n\n      // Check if receiver for given session already exists\n      if (\n        this._context.messageSessions[sessionOptions.sessionId] &&\n        this._context.messageSessions[sessionOptions.sessionId].isOpen()\n      ) {\n        const errorMessage = getOpenReceiverErrorMsg(\n          this._context.clientType,\n          this._context.entityPath,\n          sessionOptions.sessionId\n        );\n        const error = new Error(errorMessage);\n        log.error(`[${this._context.namespace.connectionId}] %O`, error);\n        throw error;\n      }\n    }\n  }\n\n  private _throwIfReceiverOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    if (this.isClosed) {\n      const errorMessage = getReceiverClosedErrorMsg(\n        this._context.entityPath,\n        this._context.clientType,\n        this._context.isClosed,\n        this.sessionId!\n      );\n      const error = new Error(errorMessage);\n      log.error(`[${this._context.namespace.connectionId}] %O`, error);\n      throw error;\n    }\n  }\n\n  private async _createMessageSessionIfDoesntExist(): Promise<void> {\n    if (this._messageSession) {\n      return;\n    }\n    this._context.isSessionEnabled = true;\n    this._messageSession = await MessageSession.create(this._context, {\n      sessionId: this._sessionOptions.sessionId,\n      maxSessionAutoRenewLockDurationInSeconds: this._sessionOptions\n        .maxSessionAutoRenewLockDurationInSeconds,\n      receiveMode: this._receiveMode\n    });\n    // By this point, we should have a valid sessionId on the messageSession\n    // If not, the receiver cannot be used, so throw error.\n    if (this._messageSession.sessionId == null) {\n      const error = new Error(\"Something went wrong. Cannot lock a session.\");\n      log.error(`[${this._context.namespace.connectionId}] %O`, error);\n      throw error;\n    }\n    this._sessionId = this._messageSession.sessionId;\n    delete this._context.expiredMessageSessions[this._messageSession.sessionId];\n  }\n\n  private _throwIfAlreadyReceiving(): void {\n    if (this.isReceivingMessages()) {\n      const errorMessage = getAlreadyReceivingErrorMsg(this._context.entityPath, this.sessionId);\n      const error = new Error(errorMessage);\n      log.error(`[${this._context.namespace.connectionId}] %O`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * @property Denotes receiveMode of this receiver.\n   * @readonly\n   */\n  public get receiveMode(): ReceiveMode {\n    return this._receiveMode;\n  }\n\n  /**\n   * @property Returns `true` if the receiver is closed. This can happen either because the receiver\n   * itself has been closed or the client that created it has been closed.\n   * @readonly\n   */\n  public get isClosed(): boolean {\n    return (\n      this._isClosed || (this.sessionId ? !this._context.messageSessions[this.sessionId] : false)\n    );\n  }\n\n  /**\n   * @property The id of the session from which this receiver will receive messages.\n   * Will return undefined until a AMQP receiver link has been successfully set up for the session.\n   * @readonly\n   */\n  public get sessionId(): string | undefined {\n    return this._sessionId;\n  }\n\n  /**\n   * @property The time in UTC until which the session is locked.\n   * Everytime `renewSessionLock()` is called, this time gets updated to current time plus the lock\n   * duration as specified during the Queue/Subscription creation.\n   *\n   * Will return undefined until a AMQP receiver link has been successfully set up for the session.\n   *\n   * @readonly\n   */\n  public get sessionLockedUntilUtc(): Date | undefined {\n    return this._messageSession ? this._messageSession.sessionLockedUntilUtc : undefined;\n  }\n\n  /**\n   * Renews the lock on the session for the duration as specified during the Queue/Subscription\n   * creation.\n   * - Check the `sessionLockedUntilUtc` property on the SessionReceiver for the time when the lock expires.\n   * - When the lock on the session expires\n   *     - No more messages can be received using this receiver\n   *     - If a message is not settled (using either `complete()`, `defer()` or `deadletter()`,\n   *   before the session lock expires, then the message lands back in the Queue/Subscription for the next\n   *   receive operation.\n   *\n   * @returns Promise<Date> - New lock token expiry date and time in UTC format.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws MessagingError if the service returns an error while renewing session lock.\n   */\n  async renewSessionLock(): Promise<Date> {\n    this._throwIfReceiverOrConnectionClosed();\n    await this._createMessageSessionIfDoesntExist();\n\n    this._messageSession!.sessionLockedUntilUtc = await this._context.managementClient!.renewSessionLock(\n      this.sessionId!\n    );\n    return this._messageSession!.sessionLockedUntilUtc!;\n  }\n\n  /**\n   * Sets the state on the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions#message-session-state Session State}\n   * @param state The state that needs to be set.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws MessagingError if the service returns an error while setting the session state.\n   */\n  async setState(state: any): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    await this._createMessageSessionIfDoesntExist();\n    return this._context.managementClient!.setSessionState(this.sessionId!, state);\n  }\n\n  /**\n   * Gets the state of the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions#message-session-state Session State}\n   * @returns Promise<any> The state of that session\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws MessagingError if the service returns an error while retrieving session state.\n   */\n  async getState(): Promise<any> {\n    this._throwIfReceiverOrConnectionClosed();\n    await this._createMessageSessionIfDoesntExist();\n    return this._context.managementClient!.getSessionState(this.sessionId!);\n  }\n\n  /**\n   * Fetches the next batch of active messages (including deferred but not deadlettered messages) in\n   * the current session.\n   * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the\n   * subsequent message.\n   * - Unlike a `received` message, `peeked` message is a read-only version of the message.\n   * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.\n   *\n   * @param maxMessageCount The maximum number of messages to peek. Default value `1`.\n   * @returns Promise<ReceivedMessageInfo[]>\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws MessagingError if the service returns an error while peeking for messages.\n   */\n  async peek(maxMessageCount?: number): Promise<ReceivedMessageInfo[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    await this._createMessageSessionIfDoesntExist();\n    return this._context.managementClient!.peekMessagesBySession(this.sessionId!, maxMessageCount);\n  }\n\n  /**\n   * Peeks the desired number of active messages (including deferred but not deadlettered messages)\n   * from the specified sequence number in the current session.\n   * - Unlike a `received` message, `peeked` message is a read-only version of the message.\n   * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.\n   *\n   * @param fromSequenceNumber The sequence number from where to read the message.\n   * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.\n   * @returns Promise<ReceivedSBMessage[]>\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws MessagingError if the service returns an error while peeking for messages.\n   */\n  async peekBySequenceNumber(\n    fromSequenceNumber: Long,\n    maxMessageCount?: number\n  ): Promise<ReceivedMessageInfo[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    await this._createMessageSessionIfDoesntExist();\n    return this._context.managementClient!.peekBySequenceNumber(\n      fromSequenceNumber,\n      maxMessageCount,\n      this.sessionId\n    );\n  }\n\n  /**\n   * Returns a promise that resolves to a deferred message identified by the given `sequenceNumber`.\n   * @param sequenceNumber The sequence number of the message that needs to be received.\n   * @returns Promise<ServiceBusMessage | undefined>\n   * - Returns `Message` identified by sequence number.\n   * - Returns `undefined` if no such message is found.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws MessagingError if the service returns an error while receiving deferred message.\n   */\n  async receiveDeferredMessage(sequenceNumber: Long): Promise<ServiceBusMessage | undefined> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.namespace.connectionId,\n      \"sequenceNumber\",\n      sequenceNumber\n    );\n    throwTypeErrorIfParameterNotLong(\n      this._context.namespace.connectionId,\n      \"sequenceNumber\",\n      sequenceNumber\n    );\n\n    await this._createMessageSessionIfDoesntExist();\n    const messages = await this._context.managementClient!.receiveDeferredMessages(\n      [sequenceNumber],\n      this._receiveMode,\n      this.sessionId\n    );\n    return messages[0];\n  }\n\n  /**\n   * Returns a promise that resolves to an array of deferred messages identified by given `sequenceNumbers`.\n   * @param sequenceNumbers An array of sequence numbers for the messages that need to be received.\n   * @returns Promise<ServiceBusMessage[]>\n   * - Returns a list of messages identified by the given sequenceNumbers.\n   * - Returns an empty list if no messages are found.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws MessagingError if the service returns an error while receiving deferred messages.\n   */\n  async receiveDeferredMessages(sequenceNumbers: Long[]): Promise<ServiceBusMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.namespace.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n    if (!Array.isArray(sequenceNumbers)) {\n      sequenceNumbers = [sequenceNumbers];\n    }\n    throwTypeErrorIfParameterNotLongArray(\n      this._context.namespace.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers\n    );\n\n    await this._createMessageSessionIfDoesntExist();\n    return this._context.managementClient!.receiveDeferredMessages(\n      sequenceNumbers,\n      this._receiveMode,\n      this.sessionId\n    );\n  }\n\n  /**\n   * Returns a promise that resolves to an array of messages based on given count and timeout over\n   * an AMQP receiver link from a Queue/Subscription.\n   *\n   * Throws an error if there is another receive operation in progress on the same receiver. If you\n   * are not sure whether there is another receive operation running, check the `isReceivingMessages`\n   * property on the receiver.\n   *\n   * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.\n   * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * - **Default**: `60` seconds.\n   * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws Error if the receiver is already in state of receiving messages.\n   * @throws MessagingError if the service returns an error while receiving messages.\n   */\n  async receiveMessages(\n    maxMessageCount: number,\n    maxWaitTimeInSeconds?: number\n  ): Promise<ServiceBusMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    await this._createMessageSessionIfDoesntExist();\n    return this._messageSession!.receiveMessages(maxMessageCount, maxWaitTimeInSeconds);\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the SessionReceiver.\n   *\n   * Throws an error if there is another receive operation in progress on the same receiver. If you\n   * are not sure whether there is another receive operation running, check the `isReceivingMessages`\n   * property on the receiver.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control whether messages should be automatically completed\n   * or if the lock on the session should be automatically renewed. You can control the\n   * maximum number of messages that should be concurrently processed. You can\n   * also provide a timeout in seconds to denote the amount of time to wait for a new message\n   * before closing the receiver.\n   *\n   * @returns void\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws Error if the receiver is already in state of receiving messages.\n   * @throws MessagingErrormif the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.\n   */\n  registerMessageHandler(\n    onMessage: OnMessage,\n    onError: OnError,\n    options?: SessionMessageHandlerOptions\n  ): void {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    const connId = this._context.namespace.connectionId;\n    throwTypeErrorIfParameterMissing(connId, \"onMessage\", onMessage);\n    throwTypeErrorIfParameterMissing(connId, \"onError\", onError);\n    if (typeof onMessage !== \"function\") {\n      throw new TypeError(\"The parameter 'onMessage' must be of type 'function'.\");\n    }\n    if (typeof onError !== \"function\") {\n      throw new TypeError(\"The parameter 'onError' must be of type 'function'.\");\n    }\n\n    this._createMessageSessionIfDoesntExist()\n      .then(async () => {\n        if (!this._messageSession) {\n          return;\n        }\n        if (!this._isClosed) {\n          this._messageSession.receive(onMessage, onError, options);\n        } else {\n          await this._messageSession.close();\n        }\n        return;\n      })\n      .catch((err) => {\n        onError(err);\n      });\n  }\n\n  /**\n   * Gets an async iterator over messages from the receiver.\n   *\n   * Throws an error if there is another receive operation in progress on the same receiver. If you\n   * are not sure whether there is another receive operation running, check the `isReceivingMessages`\n   * property on the receiver.\n   *\n   * If the iterator is not able to fetch a new message in over a minute, `undefined` will be returned\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws Error if the receiver is already in state of receiving messages.\n   * @throws MessagingError if the service returns an error while receiving messages.\n   */\n  async *getMessageIterator(): AsyncIterableIterator<ServiceBusMessage> {\n    while (true) {\n      const currentBatch = await this.receiveMessages(1);\n      yield currentBatch[0];\n    }\n  }\n\n  /**\n   * Closes the underlying AMQP receiver link.\n   * Once closed, the receiver cannot be used for any further operations.\n   * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate\n   * a new Receiver\n   *\n   * @returns {Promise<void>}\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._messageSession) {\n        await this._messageSession.close();\n        this._messageSession = undefined;\n      }\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while closing the SessionReceiver for session %s in %s: %O\",\n        this._context.namespace.connectionId,\n        this.sessionId,\n        this._context.entityPath,\n        err\n      );\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  /**\n   * Indicates whether the receiver is currently receiving messages or not.\n   * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.\n   */\n  isReceivingMessages(): boolean {\n    return this._messageSession ? this._messageSession.isReceivingMessages : false;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport Long from \"long\";\nimport {\n  EventContext,\n  SenderEvents,\n  ReceiverEvents,\n  SenderOptions,\n  ReceiverOptions,\n  types,\n  message as RheaMessageUtil,\n  generate_uuid,\n  string_to_uuid\n} from \"rhea-promise\";\nimport {\n  defaultLock,\n  translate,\n  Constants,\n  RequestResponseLink,\n  ConditionErrorNameMapper,\n  AmqpMessage,\n  SendRequestOptions\n} from \"@azure/amqp-common\";\nimport { ClientEntityContext } from \"../clientEntityContext\";\nimport {\n  ReceivedMessageInfo,\n  ServiceBusMessage,\n  SendableMessageInfo,\n  DispositionStatus,\n  toAmqpMessage,\n  getMessagePropertyTypeMismatchError\n} from \"../serviceBusMessage\";\nimport { LinkEntity } from \"./linkEntity\";\nimport * as log from \"../log\";\nimport { ReceiveMode, fromAmqpMessage } from \"../serviceBusMessage\";\nimport { toBuffer } from \"../util/utils\";\nimport {\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n  throwTypeErrorIfParameterTypeMismatch,\n  throwTypeErrorIfParameterIsEmptyString\n} from \"../util/errors\";\nimport { Typed } from \"rhea-promise\";\nimport { max32BitNumber } from \"../util/constants\";\nimport { Buffer } from \"buffer\";\n\n/**\n * Represents a Rule on a Subscription that is used to filter the incoming message from the\n * Subscription.\n */\nexport interface RuleDescription {\n  /**\n   * Filter expression used to match messages. Supports 2 types:\n   * - `string`: SQL-like condition expression that is evaluated against the messages'\n   * user-defined properties and system properties. All system properties will be prefixed with\n   * `sys.` in the condition expression.\n   * - `CorrelationFilter`: Properties of the filter will be used to match with the message properties.\n   */\n  filter?: string | CorrelationFilter;\n  /**\n   * Action to perform if the message satisfies the filtering expression.\n   */\n  action?: string;\n  /**\n   * Represents the name of the rule.\n   */\n  name: string;\n}\n\n/**\n * Represents the correlation filter expression.\n * A CorrelationFilter holds a set of conditions that are matched against user and system properties\n * of incoming messages from a Subscription.\n */\nexport interface CorrelationFilter {\n  /**\n   * Value to be matched with the `correlationId` property of the incoming message.\n   */\n  correlationId?: string;\n  /**\n   * Value to be matched with the `messageId` property of the incoming message.\n   */\n  messageId?: string;\n  /**\n   * Value to be matched with the `to` property of the incoming message.\n   */\n  to?: string;\n  /**\n   * Value to be matched with the `replyTo` property of the incoming message.\n   */\n  replyTo?: string;\n  /**\n   * Value to be matched with the `label` property of the incoming message.\n   */\n  label?: string;\n  /**\n   * Value to be matched with the `sessionId` property of the incoming message.\n   */\n  sessionId?: string;\n  /**\n   * Value to be matched with the `replyToSessionId` property of the incoming message.\n   */\n  replyToSessionId?: string;\n  /**\n   * Value to be matched with the `contentType` property of the incoming message.\n   */\n  contentType?: string;\n  /**\n   * Value to be matched with the user properties of the incoming message.\n   */\n  userProperties?: any;\n}\n\nconst correlationProperties = [\n  \"correlationId\",\n  \"messageId\",\n  \"to\",\n  \"replyTo\",\n  \"label\",\n  \"sessionId\",\n  \"replyToSessionId\",\n  \"contentType\",\n  \"userProperties\"\n];\n\n/**\n * @internal\n * Options to set when updating the disposition status\n */\ninterface DispositionStatusOptions {\n  /**\n   * @property [propertiesToModify] A dictionary of Service Bus brokered message properties\n   * to modify.\n   */\n  propertiesToModify?: { [key: string]: any };\n  /**\n   * @property [deadLetterReason] The deadletter reason. May be set if disposition status\n   * is set to suspended.\n   */\n  deadLetterReason?: string;\n  /**\n   * @property [deadLetterDescription] The deadletter description. May be set if disposition status\n   * is set to suspended.\n   */\n  deadLetterDescription?: string;\n  /**\n   * This should only be provided if `session` is enabled for a Queue or Topic.\n   */\n  sessionId?: string;\n}\n\n/**\n * @internal\n * Options passed to the constructor of ManagementClient\n */\nexport interface ManagementClientOptions {\n  address?: string;\n  audience?: string;\n}\n\n/**\n * @internal\n * @class ManagementClient\n * Descibes the ServiceBus Management Client that talks\n * to the $management endpoint over AMQP connection.\n */\nexport class ManagementClient extends LinkEntity {\n  readonly managementLock: string = `${Constants.managementRequestKey}-${generate_uuid()}`;\n  /**\n   * @property {string} entityPath - The name/path of the entity (queue/topic/subscription name)\n   * for which the management request needs to be made.\n   */\n  entityPath: string;\n  /**\n   * @property {string} replyTo The reply to Guid for the management client.\n   */\n  replyTo: string = generate_uuid();\n  /**\n   * @property $management sender, receiver on the same session.\n   * @private\n   */\n  private _mgmtReqResLink?: RequestResponseLink;\n  /**\n   * @property _lastPeekedSequenceNumber Provides the sequence number of the last peeked message.\n   * @private\n   */\n  private _lastPeekedSequenceNumber: Long = Long.ZERO;\n\n  /**\n   * @constructor\n   * Instantiates the management client.\n   * @param {ClientEntityContext} context The client entity context.\n   * @param {ManagementClientOptions} [options] Options to be provided for creating the\n   * \"$management\" client.\n   */\n  constructor(context: ClientEntityContext, options?: ManagementClientOptions) {\n    super(`${context.entityPath}/$management`, context, {\n      address: options && options.address ? options.address : Constants.management,\n      audience:\n        options && options.audience\n          ? options.audience\n          : `${context.namespace.config.endpoint}${context.entityPath}/$management`\n    });\n    this._context = context;\n    this.entityPath = context.namespace.config.entityPath as string;\n  }\n\n  private async _init(): Promise<void> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    try {\n      if (!this._isMgmtRequestResponseLinkOpen()) {\n        await this._negotiateClaim();\n        const rxopt: ReceiverOptions = {\n          source: { address: this.address },\n          name: this.replyTo,\n          target: { address: this.replyTo },\n          onSessionError: (context: EventContext) => {\n            const id = context.connection.options.id;\n            const ehError = translate(context.session!.error!);\n            log.error(\n              \"[%s] An error occurred on the session for request/response links for \" +\n                \"$management: %O\",\n              id,\n              ehError\n            );\n          }\n        };\n        const sropt: SenderOptions = { target: { address: this.address } };\n        log.mgmt(\n          \"[%s] Creating sender/receiver links on a session for $management endpoint with \" +\n            \"srOpts: %o, receiverOpts: %O.\",\n          this._context.namespace.connectionId,\n          sropt,\n          rxopt\n        );\n        this._mgmtReqResLink = await RequestResponseLink.create(\n          this._context.namespace.connection,\n          sropt,\n          rxopt\n        );\n        this._mgmtReqResLink.sender.on(SenderEvents.senderError, (context: EventContext) => {\n          const id = context.connection.options.id;\n          const ehError = translate(context.sender!.error!);\n          log.error(\"[%s] An error occurred on the $management sender link.. %O\", id, ehError);\n        });\n        this._mgmtReqResLink.receiver.on(ReceiverEvents.receiverError, (context: EventContext) => {\n          const id = context.connection.options.id;\n          const ehError = translate(context.receiver!.error!);\n          log.error(\"[%s] An error occurred on the $management receiver link.. %O\", id, ehError);\n        });\n        log.mgmt(\n          \"[%s] Created sender '%s' and receiver '%s' links for $management endpoint.\",\n          this._context.namespace.connectionId,\n          this._mgmtReqResLink.sender.name,\n          this._mgmtReqResLink.receiver.name\n        );\n        await this._ensureTokenRenewal();\n      }\n    } catch (err) {\n      err = translate(err);\n      log.error(\n        \"[%s] An error occured while establishing the $management links: %O\",\n        this._context.namespace.connectionId,\n        err\n      );\n      throw err;\n    }\n  }\n\n  private _isMgmtRequestResponseLinkOpen(): boolean {\n    return this._mgmtReqResLink! && this._mgmtReqResLink!.isOpen();\n  }\n\n  /**\n   * Given array of typed values, returns the element in given index\n   */\n  private _safelyGetTypedValueFromArray(data: Typed[], index: number): any {\n    return Array.isArray(data) && data.length > index && data[index]\n      ? data[index].value\n      : undefined;\n  }\n\n  /**\n   * Helper function to retrieve active receiver name, if it exists.\n   * @param clientEntityContext The `ClientEntityContext` associated with given Service Bus entity client\n   * @param sessionId `sessionId` if applicable\n   */\n  private _getAssociatedReceiverName(\n    clientEntityContext: ClientEntityContext,\n    sessionId?: string\n  ): string | undefined {\n    if (sessionId != undefined) {\n      if (clientEntityContext.messageSessions[sessionId]) {\n        return clientEntityContext.messageSessions[sessionId].name;\n      }\n    }\n    if (clientEntityContext.batchingReceiver) {\n      return clientEntityContext.batchingReceiver.name;\n    }\n    if (clientEntityContext.streamingReceiver) {\n      return clientEntityContext.streamingReceiver.name;\n    }\n    return;\n  }\n\n  /**\n   * Closes the AMQP management session to the ServiceBus namespace for this client,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @return Promise<void>\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._isMgmtRequestResponseLinkOpen()) {\n        const mgmtLink = this._mgmtReqResLink;\n        this._mgmtReqResLink = undefined;\n        clearTimeout(this._tokenRenewalTimer as NodeJS.Timer);\n        await mgmtLink!.close();\n        log.mgmt(\"Successfully closed the management session.\");\n      }\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while closing the management session: %O.\",\n        this._context.namespace.connectionId,\n        err\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Fetches the next batch of active messages. The first call to `peek()` fetches the first\n   * active message for this client. Each subsequent call fetches the subsequent message in the\n   * entity.\n   *\n   * Unlike a `received` message, `peeked` message will not have lock token associated with it,\n   * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. This method will\n   * also fetch even Deferred messages (but not Deadlettered message).\n   * @param {number} [messageCount] The number of messages to retrieve. Default value `1`.\n   * @returns Promise<ReceivedSBMessage[]>\n   */\n  async peek(messageCount?: number): Promise<ReceivedMessageInfo[]> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount);\n  }\n\n  /**\n   * Fetches the next batch of active messages in the current MessageSession. The first call to\n   * `peek()` fetches the first active message for this client. Each subsequent call fetches the\n   * subsequent message in the entity.\n   *\n   * Unlike a `received` message, `peeked` message will not have lock token associated with it,\n   * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`.  This method will\n   * also fetch even Deferred messages (but not Deadlettered message).\n   * @param {string} sessionId The sessionId from which messages need to be peeked.\n   * @param {number} [messageCount] The number of messages to retrieve. Default value `1`.\n   * @returns Promise<ReceivedMessageInfo[]>\n   */\n  async peekMessagesBySession(\n    sessionId: string,\n    messageCount?: number\n  ): Promise<ReceivedMessageInfo[]> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    return this.peekBySequenceNumber(\n      this._lastPeekedSequenceNumber.add(1),\n      messageCount,\n      sessionId\n    );\n  }\n\n  /**\n   * Peeks the desired number of messages from the specified sequence number.\n   * @param {Long} fromSequenceNumber The sequence number from where to read the message.\n   * @param {number} messageCount The number of messages to retrieve. Default value `1`.\n   * @param {string} sessionId The sessionId from which messages need to be peeked.\n   * @returns Promise<ReceivedMessageInfo[]>\n   */\n  async peekBySequenceNumber(\n    fromSequenceNumber: Long,\n    maxMessageCount?: number,\n    sessionId?: string\n  ): Promise<ReceivedMessageInfo[]> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    const connId = this._context.namespace.connectionId;\n\n    // Checks for fromSequenceNumber\n    throwTypeErrorIfParameterMissing(connId, \"fromSequenceNumber\", fromSequenceNumber);\n    throwTypeErrorIfParameterNotLong(connId, \"fromSequenceNumber\", fromSequenceNumber);\n\n    // Checks for maxMessageCount\n    if (maxMessageCount !== undefined) {\n      throwTypeErrorIfParameterTypeMismatch(connId, \"maxMessageCount\", maxMessageCount, \"number\");\n      if (maxMessageCount <= 0) {\n        return [];\n      }\n    } else {\n      maxMessageCount = 1;\n    }\n\n    const messageList: ReceivedMessageInfo[] = [];\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.fromSequenceNumber] = types.wrap_long(\n        Buffer.from(fromSequenceNumber.toBytesBE())\n      );\n      messageBody[Constants.messageCount] = types.wrap_int(maxMessageCount);\n      if (sessionId != undefined) {\n        messageBody[Constants.sessionIdMapKey] = sessionId;\n      }\n      const request: AmqpMessage = {\n        body: messageBody,\n        message_id: generate_uuid(),\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.peekMessage\n        }\n      };\n      const associatedLinkName = this._getAssociatedReceiverName(this._context, sessionId);\n      if (associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      log.mgmt(\n        \"[%s] Peek by sequence number request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n\n      const result = await this._mgmtReqResLink!.sendRequest(request);\n      if (result.application_properties!.statusCode !== 204) {\n        const messages = result.body.messages as { message: Buffer }[];\n        for (const msg of messages) {\n          const decodedMessage = RheaMessageUtil.decode(msg.message);\n          const message = fromAmqpMessage(decodedMessage as any);\n          message.body = this._context.namespace.dataTransformer.decode(message.body);\n          messageList.push(message);\n          this._lastPeekedSequenceNumber = message.sequenceNumber!;\n        }\n      }\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the request to peek messages to \" +\n          \"$management endpoint: %O\",\n        error\n      );\n      // statusCode == 404 then do not throw\n      if (error.name !== ConditionErrorNameMapper[\"com.microsoft:message-not-found\"]) {\n        throw error;\n      }\n    }\n    return messageList;\n  }\n\n  /**\n   * Renews the lock on the message. The lock will be renewed based on the setting specified on\n   * the queue.\n   *\n   * When a message is received in `PeekLock` mode, the message is locked on the server for this\n   * receiver instance for a duration as specified during the Queue/Subscription creation\n   * (LockDuration). If processing of the message requires longer than this duration, the\n   * lock needs to be renewed. For each renewal, it resets the time the message is locked by the\n   * LockDuration set on the Entity.\n   *\n   * @param {string} lockToken Lock token of the message\n   * @param {SendRequestOptions} [options] Options that can be set while sending the request.\n   * @returns {Promise<Date>} Promise<Date> New lock token expiry date and time in UTC format.\n   */\n  async renewLock(lockToken: string, options?: SendRequestOptions): Promise<Date> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    if (!options) options = {};\n    if (options.delayInSeconds == null) options.delayInSeconds = 1;\n    if (options.timeoutInSeconds == null) options.timeoutInSeconds = 5;\n    if (options.times == null) options.times = 5;\n\n    try {\n      const messageBody: any = {};\n\n      messageBody[Constants.lockTokens] = types.wrap_array(\n        [string_to_uuid(lockToken)],\n        0x98,\n        undefined\n      );\n      const request: AmqpMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.renewLock\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      const associatedLinkName = this._getAssociatedReceiverName(this._context);\n      if (associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = associatedLinkName;\n      }\n      log.mgmt(\n        \"[%s] Renew message Lock request: %O.\",\n        this._context.namespace.connectionId,\n        request\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n      const result = await this._mgmtReqResLink!.sendRequest(request, options);\n      const lockedUntilUtc = new Date(result.body.expirations[0]);\n      return lockedUntilUtc;\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the renew lock request to $management \" + \"endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Schedules an array of messages to appear on Service Bus at a later time.\n   *\n   * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.\n   * @param messages - An array of messages that needs to be scheduled.\n   * @returns Promise<number> The sequence numbers of messages that were scheduled.\n   */\n  async scheduleMessages(\n    scheduledEnqueueTimeUtc: Date,\n    messages: SendableMessageInfo[]\n  ): Promise<Long[]> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    const messageBody: any[] = [];\n    for (let i = 0; i < messages.length; i++) {\n      const item = messages[i];\n      if (!item.messageId) item.messageId = generate_uuid();\n      item.scheduledEnqueueTimeUtc = scheduledEnqueueTimeUtc;\n      const amqpMessage = toAmqpMessage(item);\n\n      try {\n        const entry: any = {\n          message: RheaMessageUtil.encode(amqpMessage),\n          \"message-id\": item.messageId\n        };\n        if (item.sessionId) {\n          entry[Constants.sessionIdMapKey] = item.sessionId;\n        }\n        if (item.partitionKey) {\n          entry[\"partition-key\"] = item.partitionKey;\n        }\n        if (item.viaPartitionKey) {\n          entry[\"via-partition-key\"] = item.viaPartitionKey;\n        }\n\n        const wrappedEntry = types.wrap_map(entry);\n        messageBody.push(wrappedEntry);\n      } catch (err) {\n        let error: Error;\n        if (err instanceof TypeError || err.name === \"TypeError\") {\n          // `RheaMessageUtil.encode` can fail if message properties are of invalid type\n          // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too\n          // Errors in such cases do not have user friendy message or call stack\n          // So use `getMessagePropertyTypeMismatchError` to get a better error message\n          error = translate(getMessagePropertyTypeMismatchError(item) || err);\n        } else {\n          error = translate(err);\n        }\n        log.error(\n          \"An error occurred while encoding the item at position %d in the messages array\" + \": %O\",\n          i,\n          error\n        );\n        throw error;\n      }\n    }\n    try {\n      const request: AmqpMessage = {\n        body: { messages: messageBody },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.scheduleMessage\n        }\n      };\n      if (this._context.sender) {\n        request.application_properties![Constants.associatedLinkName] = this._context.sender!.name;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      log.mgmt(\n        \"[%s] Schedule messages request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n      const result = await this._mgmtReqResLink!.sendRequest(request);\n      const sequenceNumbers = result.body[Constants.sequenceNumbers];\n      const sequenceNumbersAsLong = [];\n      for (let i = 0; i < sequenceNumbers.length; i++) {\n        if (typeof sequenceNumbers[i] === \"number\") {\n          sequenceNumbersAsLong.push(Long.fromNumber(sequenceNumbers[i]));\n        } else {\n          sequenceNumbersAsLong.push(Long.fromBytesBE(sequenceNumbers[i]));\n        }\n      }\n      return sequenceNumbersAsLong;\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the request to schedule messages to \" +\n          \"$management endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Cancels an array of messages that were scheduled.\n   * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.\n   * @returns Promise<void>\n   */\n  async cancelScheduledMessages(sequenceNumbers: Long[]): Promise<void> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    const messageBody: any = {};\n    messageBody[Constants.sequenceNumbers] = [];\n    for (let i = 0; i < sequenceNumbers.length; i++) {\n      const sequenceNumber = sequenceNumbers[i];\n      try {\n        messageBody[Constants.sequenceNumbers].push(Buffer.from(sequenceNumber.toBytesBE()));\n      } catch (err) {\n        const error = translate(err);\n        log.error(\n          \"An error occurred while encoding the item at position %d in the \" +\n            \"sequenceNumbers array: %O\",\n          i,\n          error\n        );\n        throw error;\n      }\n    }\n\n    try {\n      messageBody[Constants.sequenceNumbers] = types.wrap_array(\n        messageBody[Constants.sequenceNumbers],\n        0x81,\n        undefined\n      );\n      const request: AmqpMessage = {\n        body: messageBody,\n        message_id: generate_uuid(),\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.cancelScheduledMessage\n        }\n      };\n\n      if (this._context.sender) {\n        request.application_properties![Constants.associatedLinkName] = this._context.sender!.name;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      log.mgmt(\n        \"[%s] Cancel scheduled messages request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n      await this._mgmtReqResLink!.sendRequest(request);\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the request to cancel the scheduled message to \" +\n          \"$management endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Receives a list of deferred messages identified by `sequenceNumbers`.\n   * @param sequenceNumbers A list containing the sequence numbers to receive.\n   * @param receiveMode The mode in which the receiver was created.\n   * @returns Promise<ServiceBusMessage[]>\n   * - Returns a list of messages identified by the given sequenceNumbers.\n   * - Returns an empty list if no messages are found.\n   * - Throws an error if the messages have not been deferred.\n   */\n  async receiveDeferredMessages(\n    sequenceNumbers: Long[],\n    receiveMode: ReceiveMode,\n    sessionId?: string\n  ): Promise<ServiceBusMessage[]> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n\n    const messageList: ServiceBusMessage[] = [];\n    const messageBody: any = {};\n    messageBody[Constants.sequenceNumbers] = [];\n    for (let i = 0; i < sequenceNumbers.length; i++) {\n      const sequenceNumber = sequenceNumbers[i];\n      try {\n        messageBody[Constants.sequenceNumbers].push(Buffer.from(sequenceNumber.toBytesBE()));\n      } catch (err) {\n        const error = translate(err);\n        log.error(\n          \"An error occurred while encoding the item at position %d in the \" +\n            \"sequenceNumbers array: %O\",\n          i,\n          error\n        );\n        throw error;\n      }\n    }\n\n    try {\n      messageBody[Constants.sequenceNumbers] = types.wrap_array(\n        messageBody[Constants.sequenceNumbers],\n        0x81,\n        undefined\n      );\n      const receiverSettleMode: number = receiveMode === ReceiveMode.receiveAndDelete ? 0 : 1;\n      messageBody[Constants.receiverSettleMode] = types.wrap_uint(receiverSettleMode);\n      if (sessionId != null) {\n        messageBody[Constants.sessionIdMapKey] = sessionId;\n      }\n      const request: AmqpMessage = {\n        body: messageBody,\n        message_id: generate_uuid(),\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.receiveBySequenceNumber\n        }\n      };\n      const associatedLinkName = this._getAssociatedReceiverName(this._context, sessionId);\n      if (associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      log.mgmt(\n        \"[%s] Receive deferred messages request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n\n      const result = await this._mgmtReqResLink!.sendRequest(request);\n      const messages = result.body.messages as {\n        message: Buffer;\n        \"lock-token\": Buffer;\n      }[];\n      for (const msg of messages) {\n        const decodedMessage = RheaMessageUtil.decode(msg.message);\n        const message = new ServiceBusMessage(\n          this._context,\n          decodedMessage as any,\n          { tag: msg[\"lock-token\"] } as any,\n          false\n        );\n        if (message.lockToken && message.lockedUntilUtc) {\n          this._context.requestResponseLockedMessages.set(\n            message.lockToken,\n            message.lockedUntilUtc\n          );\n        }\n        messageList.push(message);\n      }\n      return messageList;\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the request to receive deferred messages to \" +\n          \"$management endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Updates the disposition status of deferred messages.\n   *\n   * @param lockTokens Message lock tokens to update disposition status.\n   * @param dispositionStatus The disposition status to be set\n   * @param options Optional parameters that can be provided while updating the disposition status.\n   *\n   * @returns Promise<void>\n   */\n  async updateDispositionStatus(\n    lockToken: string,\n    dispositionStatus: DispositionStatus,\n    options?: DispositionStatusOptions\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n\n    if (!options) options = {};\n    try {\n      const messageBody: any = {};\n      const lockTokenBuffer: Buffer[] = [];\n      lockTokenBuffer.push(string_to_uuid(lockToken));\n      messageBody[Constants.lockTokens] = types.wrap_array(lockTokenBuffer, 0x98, undefined);\n      messageBody[Constants.dispositionStatus] = dispositionStatus;\n      if (options.deadLetterDescription != null) {\n        messageBody[Constants.deadLetterDescription] = options.deadLetterDescription;\n      }\n      if (options.deadLetterReason != null) {\n        messageBody[Constants.deadLetterReason] = options.deadLetterReason;\n      }\n      if (options.propertiesToModify != null) {\n        messageBody[Constants.propertiesToModify] = options.propertiesToModify;\n      }\n      if (options.sessionId != null) {\n        messageBody[Constants.sessionIdMapKey] = options.sessionId;\n      }\n      const request: AmqpMessage = {\n        body: messageBody,\n        message_id: generate_uuid(),\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.updateDisposition\n        }\n      };\n      const associatedLinkName = this._getAssociatedReceiverName(this._context, options.sessionId);\n      if (associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      log.mgmt(\n        \"[%s] Update disposition status request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n      await this._mgmtReqResLink!.sendRequest(request);\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the request to update disposition status to \" +\n          \"$management endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Renews the lock for the specified session.\n   * @param sessionId Id of the session for which the lock needs to be renewed\n   * @param options Options that can be set while sending the request.\n   * @returns Promise<Date> New lock token expiry date and time in UTC format.\n   */\n  async renewSessionLock(sessionId: string, options?: SendRequestOptions): Promise<Date> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    if (!options) options = {};\n    if (options.delayInSeconds == null) options.delayInSeconds = 1;\n    if (options.timeoutInSeconds == null) options.timeoutInSeconds = 5;\n    if (options.times == null) options.times = 5;\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.sessionIdMapKey] = sessionId;\n      const request: AmqpMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.renewSessionLock\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      const associatedLinkName = this._getAssociatedReceiverName(this._context, sessionId);\n      if (associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = associatedLinkName;\n      }\n      log.mgmt(\n        \"[%s] Renew Session Lock request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n      const result = await this._mgmtReqResLink!.sendRequest(request, options);\n      const lockedUntilUtc = new Date(result.body.expiration);\n      log.mgmt(\n        \"[%s] Lock for session '%s' will expire at %s.\",\n        this._context.namespace.connectionId,\n        sessionId,\n        lockedUntilUtc.toString()\n      );\n      return lockedUntilUtc;\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the renew lock request to $management \" + \"endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Sets the state of the specified session.\n   * @param sessionId The session for which the state needs to be set\n   * @param state The state that needs to be set.\n   * @returns Promise<void>\n   */\n  async setSessionState(sessionId: string, state: any): Promise<void> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.sessionIdMapKey] = sessionId;\n      messageBody[\"session-state\"] = toBuffer(state);\n      const request: AmqpMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.setSessionState\n        }\n      };\n      const associatedLinkName = this._getAssociatedReceiverName(this._context, sessionId);\n      if (associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      log.mgmt(\n        \"[%s] Set Session state request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n      await this._mgmtReqResLink!.sendRequest(request);\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the renew lock request to $management \" + \"endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the state of the specified session.\n   * @param sessionId The session for which the state needs to be retrieved.\n   * @returns Promise<any> The state of that session\n   */\n  async getSessionState(sessionId: string): Promise<any> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.sessionIdMapKey] = sessionId;\n      const request: AmqpMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.getSessionState\n        }\n      };\n      const associatedLinkName = this._getAssociatedReceiverName(this._context, sessionId);\n      if (associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] = associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      log.mgmt(\n        \"[%s] Get session state request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n      const result = await this._mgmtReqResLink!.sendRequest(request);\n      return result.body[\"session-state\"]\n        ? this._context.namespace.dataTransformer.decode(result.body[\"session-state\"])\n        : result.body[\"session-state\"];\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the renew lock request to $management \" + \"endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Lists the sessions on the ServiceBus Queue/Topic.\n   * @param lastUpdateTime Filter to include only sessions updated after a given time.\n   * @param skip The number of sessions to skip\n   * @param top Maximum numer of sessions.\n   * @returns Promise<string[]> A list of session ids.\n   */\n  async listMessageSessions(skip: number, top: number, lastUpdatedTime?: Date): Promise<string[]> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    const defaultLastUpdatedTimeForListingSessions: number = 259200000; // 3 * 24 * 3600 * 1000\n    if (typeof skip !== \"number\") {\n      throw new Error(\"'skip' is a required parameter and must be of type 'number'.\");\n    }\n    if (typeof top !== \"number\") {\n      throw new Error(\"'top' is a required parameter and must be of type 'number'.\");\n    }\n    if (lastUpdatedTime && !(lastUpdatedTime instanceof Date)) {\n      throw new Error(\"'lastUpdatedTime' must be of type 'Date'.\");\n    }\n    if (!lastUpdatedTime) {\n      lastUpdatedTime = new Date(Date.now() - defaultLastUpdatedTimeForListingSessions);\n    }\n    try {\n      const messageBody: any = {};\n      messageBody[\"last-updated-time\"] = lastUpdatedTime;\n      messageBody[\"skip\"] = types.wrap_int(skip);\n      messageBody[\"top\"] = types.wrap_int(top);\n      const request: AmqpMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.enumerateSessions\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      log.mgmt(\n        \"[%s] List sessions request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n      const response = await this._mgmtReqResLink!.sendRequest(request);\n\n      return (response && response.body && response.body[\"sessions-ids\"]) || [];\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the renew lock request to $management \" + \"endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get all the rules on the Subscription.\n   * @returns Promise<RuleDescription[]> A list of rules.\n   */\n  async getRules(): Promise<RuleDescription[]> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    try {\n      const request: AmqpMessage = {\n        body: {\n          top: types.wrap_int(max32BitNumber),\n          skip: types.wrap_int(0)\n        },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.enumerateRules\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n\n      log.mgmt(\n        \"[%s] Get rules request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n\n      const response = await this._mgmtReqResLink!.sendRequest(request);\n      if (\n        response.application_properties!.statusCode === 204 ||\n        !response.body ||\n        !Array.isArray(response.body.rules)\n      ) {\n        return [];\n      }\n\n      // Reference: https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-amqp-request-response#response-11\n      const result: { \"rule-description\": Typed }[] = response.body.rules || [];\n      const rules: RuleDescription[] = [];\n      result.forEach((x) => {\n        const ruleDescriptor = x[\"rule-description\"];\n\n        // We use the first three elements of the `ruleDescriptor.value` to get filter, action, name\n        if (\n          !ruleDescriptor ||\n          !ruleDescriptor.descriptor ||\n          ruleDescriptor.descriptor.value !== Constants.descriptorCodes.ruleDescriptionList ||\n          !Array.isArray(ruleDescriptor.value) ||\n          ruleDescriptor.value.length < 3\n        ) {\n          return;\n        }\n\n        const filtersRawData: Typed = ruleDescriptor.value[0];\n        const actionsRawData: Typed = ruleDescriptor.value[1];\n        const rule: RuleDescription = {\n          name: ruleDescriptor.value[2].value\n        };\n\n        switch (filtersRawData.descriptor.value) {\n          case Constants.descriptorCodes.trueFilterList:\n            rule.filter = \"1=1\";\n            break;\n          case Constants.descriptorCodes.falseFilterList:\n            rule.filter = \"1=0\";\n            break;\n          case Constants.descriptorCodes.sqlFilterList:\n            rule.filter = this._safelyGetTypedValueFromArray(filtersRawData.value, 0);\n            break;\n          case Constants.descriptorCodes.correlationFilterList:\n            rule.filter = {\n              correlationId: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),\n              messageId: this._safelyGetTypedValueFromArray(filtersRawData.value, 1),\n              to: this._safelyGetTypedValueFromArray(filtersRawData.value, 2),\n              replyTo: this._safelyGetTypedValueFromArray(filtersRawData.value, 3),\n              label: this._safelyGetTypedValueFromArray(filtersRawData.value, 4),\n              sessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 5),\n              replyToSessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 6),\n              contentType: this._safelyGetTypedValueFromArray(filtersRawData.value, 7),\n              userProperties: this._safelyGetTypedValueFromArray(filtersRawData.value, 8)\n            };\n            break;\n          default:\n            log.mgmt(\n              `Found unexpected descriptor code for the filter: ${filtersRawData.descriptor.value}`\n            );\n            break;\n        }\n\n        if (\n          actionsRawData.descriptor.value === Constants.descriptorCodes.sqlRuleActionList &&\n          Array.isArray(actionsRawData.value) &&\n          actionsRawData.value.length\n        ) {\n          rule.action = this._safelyGetTypedValueFromArray(actionsRawData.value, 0);\n        }\n\n        rules.push(rule);\n      });\n\n      return rules;\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the get rules request to $management \" + \"endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Removes the rule on the Subscription identified by the given rule name.\n   * @param ruleName\n   */\n  async removeRule(ruleName: string): Promise<void> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n    throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, \"ruleName\", ruleName);\n    ruleName = String(ruleName);\n    throwTypeErrorIfParameterIsEmptyString(\n      this._context.namespace.connectionId,\n      \"ruleName\",\n      ruleName\n    );\n\n    try {\n      const request: AmqpMessage = {\n        body: {\n          \"rule-name\": types.wrap_string(ruleName)\n        },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.removeRule\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n\n      log.mgmt(\n        \"[%s] Remove Rule request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n\n      await this._mgmtReqResLink!.sendRequest(request);\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the remove rule request to $management \" + \"endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Adds a rule on the subscription as defined by the given rule name, filter and action\n   * @param ruleName Name of the rule\n   * @param filter A Boolean, SQL expression or a Correlation filter\n   * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression\n   */\n  async addRule(\n    ruleName: string,\n    filter: boolean | string | CorrelationFilter,\n    sqlRuleActionExpression?: string\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context.namespace);\n\n    throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, \"ruleName\", ruleName);\n    ruleName = String(ruleName);\n    throwTypeErrorIfParameterIsEmptyString(\n      this._context.namespace.connectionId,\n      \"ruleName\",\n      ruleName\n    );\n\n    throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, \"filter\", filter);\n    if (\n      typeof filter !== \"boolean\" &&\n      typeof filter !== \"string\" &&\n      !correlationProperties.some((validProperty) => filter.hasOwnProperty(validProperty))\n    ) {\n      throw new TypeError(\n        `The parameter \"filter\" should be either a boolean, string or implement the CorrelationFilter interface.`\n      );\n    }\n\n    try {\n      const ruleDescription: any = {};\n      switch (typeof filter) {\n        case \"boolean\":\n          ruleDescription[\"sql-filter\"] = {\n            expression: filter ? \"1=1\" : \"1=0\"\n          };\n          break;\n        case \"string\":\n          ruleDescription[\"sql-filter\"] = {\n            expression: filter\n          };\n          break;\n        default:\n          ruleDescription[\"correlation-filter\"] = {\n            \"correlation-id\": filter.correlationId,\n            \"message-id\": filter.messageId,\n            to: filter.to,\n            \"reply-to\": filter.replyTo,\n            label: filter.label,\n            \"session-id\": filter.sessionId,\n            \"reply-to-session-id\": filter.replyToSessionId,\n            \"content-type\": filter.contentType,\n            properties: filter.userProperties\n          };\n          break;\n      }\n\n      if (sqlRuleActionExpression !== undefined) {\n        ruleDescription[\"sql-rule-action\"] = {\n          expression: String(sqlRuleActionExpression)\n        };\n      }\n      const request: AmqpMessage = {\n        body: {\n          \"rule-name\": types.wrap_string(ruleName),\n          \"rule-description\": types.wrap_map(ruleDescription)\n        },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.addRule\n        }\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n\n      log.mgmt(\n        \"[%s] Add Rule request body: %O.\",\n        this._context.namespace.connectionId,\n        request.body\n      );\n      log.mgmt(\n        \"[%s] Acquiring lock to get the management req res link.\",\n        this._context.namespace.connectionId\n      );\n      await defaultLock.acquire(this.managementLock, () => {\n        return this._init();\n      });\n\n      await this._mgmtReqResLink!.sendRequest(request);\n    } catch (err) {\n      const error = translate(err);\n      log.error(\n        \"An error occurred while sending the Add rule request to $management \" + \"endpoint: %O\",\n        error\n      );\n      throw error;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { generate_uuid } from \"rhea-promise\";\nimport { delay, AsyncLock } from \"@azure/amqp-common\";\nimport * as log from \"../log\";\n\n/**\n * Describes a map that ensures, deleting a an entry from the map is concurrency safe.\n * @internal\n * @class ConcurrentExpiringMap<TKey>\n */\nexport class ConcurrentExpiringMap<TKey> {\n  private readonly _map: Map<TKey, Date> = new Map();\n  private _cleanupScheduled: boolean = false;\n  private _delayBetweenCleanupInSeconds: number;\n  private _lockId: string = generate_uuid();\n  private _lockStore: AsyncLock = new AsyncLock({ maxPending: 1000000 });\n\n  constructor(options?: { delayBetweenCleanupInSeconds?: number }) {\n    if (!options) options = {};\n    this._delayBetweenCleanupInSeconds = options.delayBetweenCleanupInSeconds || 30;\n  }\n\n  private async _scheduleCleanup(): Promise<void> {\n    if (this._cleanupScheduled || this._map.size === 0) {\n      return;\n    }\n\n    await this._lockStore.acquire(this._lockId, () => {\n      this._cleanupScheduled = true;\n      this._collectExpiredEntries().catch((err) => {\n        log.error(\"An error occurred while collecting expired entries: %O\", err);\n      });\n    });\n  }\n\n  private async _collectExpiredEntries(): Promise<void> {\n    if (this._map.size === 0) {\n      return;\n    }\n\n    await delay(this._delayBetweenCleanupInSeconds);\n    this._cleanupScheduled = false;\n    for (const key of this._map.keys()) {\n      if (Date.now() > this._map.get(key)!.getTime()) {\n        this._map.delete(key);\n        log.map(\"Deleted the key '%s' from the map.\", key);\n      }\n    }\n    this._scheduleCleanup().catch((err) => {\n      log.error(\n        \"An error occurred while scheduling the cleanup, after \" + \"collecting expired entries: %O\",\n        err\n      );\n    });\n  }\n\n  /**\n   * Sets the key and it's expiration time as the value in the map.\n   * @param key The key to be set.\n   * @param expiration Expiration time for the key.\n   * @returns void\n   */\n  set(key: TKey, expiration: Date): void {\n    this._map.set(key, expiration);\n    this._scheduleCleanup().catch((err) => {\n      log.error(\n        \"An error occurred while scheduling the cleanup, after \" + \"setting the key: '%s': %O\",\n        key,\n        err\n      );\n    });\n  }\n\n  /**\n   * Determines whether the key is present in the map.\n   * @param key The key whose presence in the map needs to be checked.\n   * @returns boolean\n   */\n  has(key: TKey): boolean {\n    const value = this._map.get(key) as Date;\n    const result: boolean = value && value.getTime() > Date.now();\n    log.map(\"Key '%s' is present in the map? -> %s\", key, result);\n    return result;\n  }\n\n  /**\n   * Removes an entry from the the map if present\n   * @param key The key which needs to be removed from the map.\n   * @returns True if the key was found and removed from the map, False otherwise\n   */\n  delete(key: TKey): boolean {\n    log.map(\"Deleting key '%s' from the map\", key);\n    return this._map.delete(key);\n  }\n\n  /**\n   * Clears all the entries from the underlying map.\n   */\n  clear(): void {\n    log.map(\"Clearing the map of all the entries\");\n    this._map.clear();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * @internal\n * A simple Semaphore\n * @class Semaphore\n */\nexport class Semaphore {\n  /**\n   * The number of concurrent calls that can be made.\n   */\n  limit: number;\n  private _queue: ((value?: void | PromiseLike<void> | undefined) => void)[] = [];\n  private _used: number = 0;\n  constructor(limit: number) {\n    if (typeof limit !== \"number\") {\n      throw new TypeError(`Expected limit to be a number, got ${typeof limit}`);\n    }\n\n    if (limit < 1) {\n      throw new Error(\"limit cannot be less than 1\");\n    }\n    this.limit = limit;\n  }\n\n  /**\n   * Acquires a lock from the semaphore, returns a Promise that resolves when the caller holds\n   * a lock.\n   */\n  acquire(): Promise<void> {\n    if (this._used < this.limit) {\n      this._used += 1;\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => {\n      this._queue.push(resolve);\n    });\n  }\n\n  /**\n   * Releases a lock back to the semaphore.\n   */\n  release(): void {\n    if (this._queue.length) {\n      const item = this._queue.shift();\n      if (item) {\n        item();\n      }\n    } else {\n      this._used -= 1;\n    }\n  }\n\n  /**\n   * Aquires a lock from the semaphore and then execute the fn. If the fn returns a Promise,\n   * wait for that promise to settle and then release the lock back to the semaphore.\n   * @param fn The function that needs to be executed in the ciritical region.\n   * @returns A Promise that will settle with the return value of fn.\n   */\n  use<T>(fn: () => T | PromiseLike<T>): Promise<T> {\n    return this.acquire()\n      .then(fn)\n      .then((val) => {\n        this.release();\n        return val;\n      })\n      .catch((err) => {\n        this.release();\n        throw err;\n      });\n  }\n\n  /**\n   * Provides the number of locks currently held.\n   */\n  currentLockCount(): number {\n    return this._used;\n  }\n\n  /**\n   * Provides the number of tasks waiting to acquire a lock.\n   */\n  awaitedTaskCount(): number {\n    return this._queue.length;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { SessionManagerOptions, MessageSession, SessionCallee } from \"./messageSession\";\nimport { OnError, OnMessage } from \"../core/messageReceiver\";\nimport { ClientEntityContext } from \"../clientEntityContext\";\nimport { getProcessorCount } from \"../util/utils\";\nimport * as log from \"../log\";\nimport { Semaphore } from \"../util/semaphore\";\nimport { delay, ConditionErrorNameMapper, Constants } from \"@azure/amqp-common\";\n\n/**\n * @internal\n * Enum to denote the entity type calling the session manager\n */\nexport enum SessionEntityType {\n  queue = \"Queue\",\n  subscription = \"Subscription\"\n}\n\n/**\n * @internal\n */\nexport class SessionManager {\n  /**\n   * @property {number} maxConcurrentSessions The maximum number of sessions that the user wants to\n   * handle concurrently.\n   * - **Default**: `2000`.\n   */\n  set maxConcurrentSessions(value: number) {\n    if (value <= 0) {\n      throw new Error(\"'maxConcurrentSessions must be greater than 0.\");\n    }\n    this._maxConcurrentSessions = value;\n    this.maxConcurrentAcceptSessionRequests = value;\n  }\n  get maxConcurrenSessions(): number {\n    return this._maxConcurrentSessions;\n  }\n  /**\n   * @property {number} _maxConcurrentAcceptSessionRequests The maximum number of acceptSession\n   * requests that can be made concurrently at any given time.\n   */\n  set maxConcurrentAcceptSessionRequests(value: number) {\n    this._maxConcurrentAcceptSessionRequests = Math.min(value, getProcessorCount());\n  }\n  get maxConcurrentAcceptSessionRequests(): number {\n    return this._maxConcurrentAcceptSessionRequests;\n  }\n\n  private _isManagingSessions: boolean = false;\n  private _maxConcurrentSessions!: number;\n  private _maxConcurrentAcceptSessionRequests!: number;\n  private _isCancelRequested: boolean = false;\n  private _maxConcurrentSessionsSemaphore!: Semaphore;\n  private _maxPendingAcceptSessionsSemaphore!: Semaphore;\n\n  /**\n   * @property {ClientEntityContext} _context The client entity context.\n   * @readonly\n   */\n  private readonly _context: ClientEntityContext;\n\n  constructor(context: ClientEntityContext) {\n    this._context = context;\n    this.maxConcurrentSessions = 2000;\n  }\n\n  /**\n   * Accept a new session and start receiving messages.\n   * @param onMessage Handler for receiving messages from a session enabled entity.\n   * @param onError Handler for receiving errors.\n   * @param options Optional parameters for handling sessions.\n   */\n  private async _acceptSessionAndReceiveMessages(\n    onMessage: OnMessage,\n    onError: OnError,\n    options?: SessionManagerOptions\n  ): Promise<void> {\n    if (!options) {\n      options = {};\n    }\n    const connectionId = this._context.namespace.connectionId;\n    const noActiveSessionBackOffInSeconds = 10;\n    while (!this._isCancelRequested) {\n      try {\n        await this._maxConcurrentSessionsSemaphore.acquire();\n        log.sessionManager(\n          \"[%s] Acquired the semaphore for max concurrent sessions: %d, %d.\",\n          connectionId,\n          this._maxConcurrentSessionsSemaphore.currentLockCount(),\n          this._maxConcurrentSessionsSemaphore.awaitedTaskCount()\n        );\n\n        await this._maxPendingAcceptSessionsSemaphore.acquire();\n        log.sessionManager(\n          \"[%s] Acquired the semaphore for max pending accept sessions: %d, %d.\",\n          connectionId,\n          this._maxPendingAcceptSessionsSemaphore.currentLockCount(),\n          this._maxPendingAcceptSessionsSemaphore.awaitedTaskCount()\n        );\n\n        const closeMessageSession = async (messageSession: MessageSession): Promise<void> => {\n          try {\n            await this._maxConcurrentSessionsSemaphore.release();\n            log.sessionManager(\n              \"[%s] Releasing the semaphore for max concurrent sessions: %d, %d.\",\n              connectionId,\n              this._maxConcurrentSessionsSemaphore.currentLockCount(),\n              this._maxConcurrentSessionsSemaphore.awaitedTaskCount()\n            );\n            if (messageSession.isOpen()) {\n              await messageSession.close();\n            }\n          } catch (err) {\n            log.error(\n              \"[%s] An error occurred while releasing the max concurrent session semaphore \" +\n                \"or while closing MessageSession with id '%s': %O.\",\n              connectionId,\n              messageSession.sessionId,\n              err\n            );\n          }\n        };\n        // Create the MessageSession.\n        const messageSession = await MessageSession.create(this._context, {\n          sessionId: undefined,\n          callee: SessionCallee.sessionManager,\n          ...options\n        });\n\n        messageSession.newMessageWaitTimeoutInSeconds = options.newMessageWaitTimeoutInSeconds;\n\n        if (this._isCancelRequested) {\n          log.sessionManager(\n            \"[%s] Since cancellation was requested, we will close the messageSession with id '%s'.\",\n            connectionId,\n            messageSession.sessionId\n          );\n          await closeMessageSession(messageSession);\n        }\n        const sessionId = messageSession.sessionId;\n        this._context.messageSessions[sessionId as string] = messageSession;\n\n        log.sessionManager(\"[%s] Created MessageSession with id '%s'.\", connectionId, sessionId);\n        const onSessionError: OnError = async (error) => {\n          log.sessionManager(\n            \"An error ocurred in MessageSession with id '%s': %O. Hence closing it.\",\n            connectionId,\n            sessionId,\n            error\n          );\n          await closeMessageSession(messageSession);\n          if (error.name !== ConditionErrorNameMapper[\"com.microsoft:message-wait-timeout\"]) {\n            // notify the user about the error.\n            onError(error);\n          }\n        };\n        messageSession.receive(onMessage, onSessionError, options);\n      } catch (err) {\n        log.error(\"[%s] An error occurred while accepting a MessageSession: %O\", connectionId, err);\n        this._maxConcurrentSessionsSemaphore.release();\n        log.sessionManager(\n          \"[%s] Releasing the semaphore for max concurrent sessions \" +\n            \"because an error ocurred: %d, %d.\",\n          connectionId,\n          this._maxConcurrentSessionsSemaphore.currentLockCount(),\n          this._maxConcurrentSessionsSemaphore.awaitedTaskCount()\n        );\n        // When we ask servicebus to give us a random session and if there are no active sessions,\n        // ServiceBus initially sends the attach frame which causes rhea to emit \"receiver_open\"\n        // event and thus rhea-promise resolves the promise. Moments later ServiceBus sends a\n        // detach frame with an error that the link creation timed out. Therefore inside\n        // MessageSession._init() after the promise to create a session enabled receiver link\n        // resolves we check for sessionId. If it is undefined then we reject the Promise with an\n        // error \"session-cannot-be-locked\". The \"operation-timeout\" error happens when\n        // rhea-promise does not receive a response from ServiceBus in a predefined time frame and\n        // the Promise is rejected. The \"microsoft.timeout\" error occurs when timeout happens on\n        // the server side and ServiceBus sends a detach frame due to which the Promise is rejected.\n        if (\n          err.name === ConditionErrorNameMapper[\"amqp:operation-timeout\"] ||\n          err.name === ConditionErrorNameMapper[\"com.microsoft:timeout\"] ||\n          err.name === ConditionErrorNameMapper[\"com.microsoft:session-cannot-be-locked\"]\n        ) {\n          // No point in delaying if cancel has been requested.\n          if (!this._isCancelRequested) {\n            log.sessionManager(\n              \"[%s] Sleeping for %d seconds, since there are no more active MessageSessions on \" +\n                \"the ServiceBus entity.\",\n              connectionId,\n              noActiveSessionBackOffInSeconds\n            );\n            await delay(noActiveSessionBackOffInSeconds * 1000);\n          }\n        } else {\n          // notify the user about the error only when it is not one of the above mentioned errors.\n          onError(err);\n        }\n      } finally {\n        this._maxPendingAcceptSessionsSemaphore.release();\n        log.sessionManager(\n          \"[%s] Releasing the semaphore for max pending accept sessions from \" +\n            \"the finally block: %d, %d.\",\n          connectionId,\n          this._maxPendingAcceptSessionsSemaphore.currentLockCount(),\n          this._maxPendingAcceptSessionsSemaphore.awaitedTaskCount()\n        );\n      }\n    }\n  }\n\n  /**\n   * Manages MessageSessions based on the provided parameters.\n   * @param onMessage The message handler to receive service bus messages from a session\n   * enabled entity.\n   * @param onError The error handler to receive an error that occurs while receiving messages\n   * from a session enabled entity.\n   * @throws Error if the underlying connection is closed.\n   * @throws Error if the session enabled client is already receiving messages.\n   * @throws MessagingError if any error occurs while receiving messages from the service.\n   */\n  async manageMessageSessions(\n    entityType: SessionEntityType,\n    onMessage: OnMessage,\n    onError: OnError,\n    options?: SessionManagerOptions\n  ): Promise<void> {\n    if (this._isManagingSessions) {\n      throw new Error(\n        `${entityType}Client for \"${this._context.namespace.config.entityPath}\" ` +\n          `is already receiving messages from sessions. Please close this ${entityType}Client or ` +\n          `create a new one and receiveMessages from Sessions.`\n      );\n    }\n    this._isManagingSessions = true;\n    this._isCancelRequested = false;\n    if (!options) options = {};\n    if (options.maxConcurrentSessions) this.maxConcurrentSessions = options.maxConcurrentSessions;\n    // We are explicitly configuring the messageSession to timeout in 60 seconds (if not provided\n    // by the user) when no new messages are received.\n    if (!options.newMessageWaitTimeoutInSeconds) {\n      options.newMessageWaitTimeoutInSeconds = Constants.defaultOperationTimeoutInSeconds;\n    }\n    this._maxConcurrentSessionsSemaphore = new Semaphore(this.maxConcurrenSessions);\n    this._maxPendingAcceptSessionsSemaphore = new Semaphore(\n      this.maxConcurrentAcceptSessionRequests\n    );\n\n    for (let i = 0; i < this._maxConcurrentAcceptSessionRequests; i++) {\n      this._acceptSessionAndReceiveMessages(onMessage, onError, options).catch((err) => {\n        log.error(err);\n      });\n    }\n  }\n\n  /**\n   * Close the session manager.\n   */\n  close(): void {\n    log.sessionManager(\n      \"[%s] Closing the SessionMaanger for entity '%s'.\",\n      this._context.namespace.connectionId,\n      this._context.entityPath\n    );\n    this._isCancelRequested = true;\n    this._isManagingSessions = false;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport { StreamingReceiver } from \"./core/streamingReceiver\";\nimport { MessageSender } from \"./core/messageSender\";\nimport { ManagementClient, ManagementClientOptions } from \"./core/managementClient\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { Dictionary, AmqpError } from \"rhea-promise\";\nimport { ClientType } from \"./client\";\nimport { BatchingReceiver } from \"./core/batchingReceiver\";\nimport { ConcurrentExpiringMap } from \"./util/concurrentExpiringMap\";\nimport { MessageReceiver } from \"./core/messageReceiver\";\nimport { MessageSession } from \"./session/messageSession\";\nimport { SessionManager } from \"./session/sessionManager\";\n\n/**\n * @interface ClientEntityContext\n * Provides contextual information like the underlying amqp connection, cbs session,\n * management session, tokenProvider, senders, receivers, etc. about the ServiceBus client.\n * @internal\n */\nexport interface ClientEntityContextBase {\n  /**\n   * @property {ConnectionContext} namespace Describes the context with common properties at\n   * the namespace level.\n   */\n  namespace: ConnectionContext;\n  /**\n   * @property {string} entityPath - The name/path of the entity (queue/topic/subscription) to which\n   * the connection needs to happen.\n   */\n  entityPath: string;\n  /**\n   * @property {boolean} [isSessionEnabled] Indicates whether the client entity is session enabled.\n   * Default: `false`.\n   */\n  isSessionEnabled?: boolean;\n  /**\n   * @property {ManagementClient} [managementClient] A reference to the management client\n   * ($management endpoint) on the underlying amqp connection for the ServiceBus Client.\n   */\n  managementClient?: ManagementClient;\n  /**\n   * @property {StreamingReceiver} [receiver] The ServiceBus receiver associated with the\n   * client entity for streaming messages.\n   */\n  streamingReceiver?: StreamingReceiver;\n  /**\n   * @property {BatchingReceiver} [batchingReceiver] The ServiceBus receiver associated with the\n   * client entity for receiving a batch of messages.\n   */\n  batchingReceiver?: BatchingReceiver;\n  /**\n   * @property {Dictionary<MessageSession>} messageSessions A dictionary of the MessageSession\n   * objects associated with this client.\n   */\n  messageSessions: Dictionary<MessageSession>;\n  /**\n   * @property {Dictionary<MessageSession>} expiredMessageSessions A dictionary that stores expired message sessions IDs.\n   */\n  expiredMessageSessions: Dictionary<boolean>;\n  /**\n   * @property {MessageSender} [sender] The ServiceBus sender associated with the client entity.\n   */\n  sender?: MessageSender;\n  /**\n   * @property {ConcurrentExpiringMap<string>} [requestResponseLockedMessages] A map of locked\n   * messages received using the management client.\n   */\n  requestResponseLockedMessages: ConcurrentExpiringMap<string>;\n  /**\n   * @property {SessionManager} [sessionManager] SessionManager is responsible for efficiently\n   * receiving messages from multiple message sessions.\n   */\n  sessionManager?: SessionManager;\n\n  /**\n   * @property {ClientType} [clientType] Type of the client, used mostly for logging\n   */\n  clientType: ClientType;\n\n  /**\n   * @property {string} [clientId] Unique Id of the client for which this context is created\n   */\n  clientId: string;\n\n  /**\n   * @property {boolean} [isClosed] Denotes if close() was called on this client.\n   */\n  isClosed: boolean;\n}\n\n/**\n * @internal\n */\nexport interface ClientEntityContext extends ClientEntityContextBase {\n  onDetached(error?: AmqpError | Error): Promise<void>;\n  getReceiver(name: string, sessionId?: string): MessageReceiver | MessageSession | undefined;\n  close(): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport interface ClientEntityContextOptions {\n  managementClientAddress?: string;\n  managementClientAudience?: string;\n  isSessionEnabled?: boolean;\n}\n\n/**\n * @internal\n */\nexport namespace ClientEntityContext {\n  /**\n   * @internal\n   */\n  export function create(\n    entityPath: string,\n    clientType: ClientType,\n    context: ConnectionContext,\n    clientId: string,\n    options?: ClientEntityContextOptions\n  ): ClientEntityContext {\n    log.entityCtxt(\n      \"[%s] Creating client entity context for %s: %O\",\n      context.connectionId,\n      clientId\n    );\n\n    if (!options) options = {};\n    const entityContext: ClientEntityContextBase = {\n      namespace: context,\n      entityPath: entityPath,\n      clientType: clientType,\n      clientId: clientId,\n      isClosed: false,\n      requestResponseLockedMessages: new ConcurrentExpiringMap<string>(),\n      isSessionEnabled: !!options.isSessionEnabled,\n      messageSessions: {},\n      expiredMessageSessions: {}\n    };\n\n    (entityContext as ClientEntityContext).sessionManager = new SessionManager(\n      entityContext as ClientEntityContext\n    );\n\n    (entityContext as ClientEntityContext).getReceiver = (name: string, sessionId?: string) => {\n      if (sessionId != undefined && entityContext.expiredMessageSessions[sessionId]) {\n        const error = new Error(\n          `The session lock has expired on the session with id ${sessionId}.`\n        );\n        error.name = \"SessionLockLostError\";\n        log.error(\n          \"[%s] Failed to find receiver '%s' as the session with id '%s' is expired\",\n          entityContext.namespace.connectionId,\n          name,\n          sessionId\n        );\n        throw error;\n      }\n\n      if (\n        sessionId != null &&\n        entityContext.messageSessions[sessionId] &&\n        entityContext.messageSessions[sessionId].name === name\n      ) {\n        return entityContext.messageSessions[sessionId];\n      }\n\n      if (entityContext.streamingReceiver && entityContext.streamingReceiver.name === name) {\n        return entityContext.streamingReceiver;\n      }\n\n      if (entityContext.batchingReceiver && entityContext.batchingReceiver.name === name) {\n        return entityContext.batchingReceiver;\n      }\n\n      let existingReceivers = \"\";\n      if (sessionId != null && entityContext.messageSessions[sessionId]) {\n        existingReceivers = entityContext.messageSessions[sessionId].name;\n      } else {\n        if (entityContext.streamingReceiver) {\n          existingReceivers = entityContext.streamingReceiver.name;\n        }\n        if (entityContext.batchingReceiver) {\n          existingReceivers +=\n            (existingReceivers ? \", \" : \"\") + entityContext.batchingReceiver.name;\n        }\n      }\n\n      log.error(\n        \"[%s] Failed to find receiver '%s' among existing receivers: %s\",\n        entityContext.namespace.connectionId,\n        name,\n        existingReceivers\n      );\n      return;\n    };\n\n    (entityContext as ClientEntityContext).onDetached = async (error?: AmqpError | Error) => {\n      const connectionId = entityContext.namespace.connectionId;\n\n      // Call onDetached() on sender so that it can decide whether to reconnect or not\n      const sender = entityContext.sender;\n      if (sender && !sender.isConnecting) {\n        try {\n          log.error(\"[%s] calling detached on sender '%s'.\", connectionId, sender.name);\n          await sender.onDetached();\n        } catch (err) {\n          log.error(\n            \"[%s] An error occurred while calling onDetached() the sender '%s': %O.\",\n            connectionId,\n            sender.name,\n            err\n          );\n        }\n      }\n\n      // Call onDetached() on batchingReceiver so that it can gracefully close any ongoing batch operation.\n      const batchingReceiver = entityContext.batchingReceiver;\n      if (batchingReceiver && !batchingReceiver.isConnecting) {\n        try {\n          log.error(\n            \"[%s] calling detached on batching receiver '%s'.\",\n            connectionId,\n            batchingReceiver.name\n          );\n          await batchingReceiver.onDetached(error);\n        } catch (err) {\n          log.error(\n            \"[%s] An error occurred while calling onDetached() on the batching receiver '%s': %O.\",\n            connectionId,\n            batchingReceiver.name,\n            err\n          );\n        }\n      }\n\n      // Call onDetached() on streamingReceiver so that it can decide whether to reconnect or not\n      const streamingReceiver = entityContext.streamingReceiver;\n      if (streamingReceiver && !streamingReceiver.isConnecting) {\n        try {\n          log.error(\n            \"[%s] calling detached on streaming receiver '%s'.\",\n            connectionId,\n            streamingReceiver.name\n          );\n          await streamingReceiver.onDetached(error);\n        } catch (err) {\n          log.error(\n            \"[%s] An error occurred while calling onDetached() on the streaming receiver '%s': %O.\",\n            connectionId,\n            streamingReceiver.name,\n            err\n          );\n        }\n      }\n    };\n\n    const isManagementClientSharedWithOtherClients = (): boolean => {\n      for (const id of Object.keys(context.clientContexts)) {\n        if (\n          context.clientContexts[id].entityPath === entityContext.entityPath &&\n          context.clientContexts[id].clientId !== entityContext.clientId\n        ) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    (entityContext as ClientEntityContext).close = async () => {\n      if (!context.connection || !context.connection.isOpen()) {\n        return;\n      }\n\n      log.entityCtxt(\n        \"[%s] Closing client entity context for %s: %O\",\n        context.connectionId,\n        clientId\n      );\n\n      // Close sender\n      if (entityContext.sender) {\n        await entityContext.sender.close();\n      }\n\n      // Close batching receiver\n      if (entityContext.batchingReceiver) {\n        await entityContext.batchingReceiver.close();\n      }\n\n      // Close streaming receiver\n      if (entityContext.streamingReceiver) {\n        await entityContext.streamingReceiver.close();\n      }\n\n      // Close all the MessageSessions.\n      for (const messageSessionId of Object.keys(entityContext.messageSessions)) {\n        await entityContext.messageSessions[messageSessionId].close();\n      }\n\n      // Close the sessionManager.\n      if (entityContext.sessionManager) {\n        entityContext.sessionManager.close();\n      }\n\n      // Make sure that we clear the map of deferred messages\n      entityContext.requestResponseLockedMessages.clear();\n\n      // Delete the reference in ConnectionContext\n      delete context.clientContexts[clientId];\n\n      // Close the managementClient unless it is shared with other clients\n      if (entityContext.managementClient && !isManagementClientSharedWithOtherClients()) {\n        await entityContext.managementClient.close();\n        entityContext.managementClient = undefined;\n      }\n\n      entityContext.isClosed = true;\n\n      log.entityCtxt(\n        \"[%s] Closed client entity context for %s: %O\",\n        context.connectionId,\n        clientId\n      );\n    };\n\n    let managementClient = getManagementClient(context.clientContexts, entityPath);\n    if (!managementClient) {\n      const mOptions: ManagementClientOptions = {\n        address: options.managementClientAddress || `${entityPath}/$management`,\n        audience: options.managementClientAudience\n      };\n      managementClient = new ManagementClient(entityContext as ClientEntityContext, mOptions);\n    }\n    entityContext.managementClient = managementClient;\n\n    const clientEntityContext = entityContext as ClientEntityContext;\n    context.clientContexts[entityContext.clientId] = clientEntityContext;\n\n    log.entityCtxt(\"[%s] Created client entity context for %s: %O\", context.connectionId, clientId);\n\n    return clientEntityContext;\n  }\n}\n\n// Multiple clients for the same Service Bus entity should be using the same management client.\nfunction getManagementClient(\n  clients: Dictionary<ClientEntityContext>,\n  entityPath: string\n): ManagementClient | undefined {\n  let result: ManagementClient | undefined;\n  for (const id of Object.keys(clients)) {\n    if (clients[id].entityPath === entityPath) {\n      result = clients[id].managementClient;\n      break;\n    }\n  }\n  return result;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport Long from \"long\";\nimport * as log from \"./log\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { ReceivedMessageInfo, ReceiveMode } from \"./serviceBusMessage\";\nimport { Client, ClientType } from \"./client\";\nimport { SessionReceiverOptions } from \"./session/messageSession\";\nimport { Sender } from \"./sender\";\nimport { Receiver, SessionReceiver } from \"./receiver\";\nimport {\n  getOpenReceiverErrorMsg,\n  getOpenSenderErrorMsg,\n  throwErrorIfClientOrConnectionClosed,\n  throwErrorIfConnectionClosed\n} from \"./util/errors\";\nimport { generate_uuid } from \"rhea-promise\";\nimport { ClientEntityContext } from \"./clientEntityContext\";\n\n/**\n * Describes the client that allows interacting with a Service Bus Queue.\n * Use the `createQueueClient` function on the ServiceBusClient object to instantiate a QueueClient\n * @class QueueClient\n */\nexport class QueueClient implements Client {\n  /**\n   * @readonly\n   * @property The path for the Service Bus Queue for which this client is created.\n   */\n  readonly entityPath: string;\n  /**\n   * @readonly\n   * @property A unique identifier for this client.\n   */\n  readonly id: string;\n  /**\n   * @property Describes the amqp connection context for the QueueClient.\n   */\n  private _context: ClientEntityContext;\n\n  private _currentReceiver: Receiver | undefined;\n  private _currentSender: Sender | undefined;\n\n  /**\n   * Constructor for QueueClient.\n   * This is not meant for the user to call directly.\n   * The user should use the `createQueueClient` on the ServiceBusClient instead.\n   *\n   * @constructor\n   * @internal\n   * @param queueName The Queue name.\n   * @param context The connection context to create the QueueClient.\n   * @throws Error if the underlying connection is closed.\n   */\n  constructor(queueName: string, context: ConnectionContext) {\n    throwErrorIfConnectionClosed(context);\n    this.entityPath = String(queueName);\n    this.id = `${this.entityPath}/${generate_uuid()}`;\n    this._context = ClientEntityContext.create(\n      this.entityPath,\n      ClientType.QueueClient,\n      context,\n      this.id\n    );\n  }\n\n  /**\n   * Closes all the AMQP links for sender/receivers created by this client.\n   * Once closed, neither the QueueClient nor its sender/receivers can be used for any\n   * further operations.\n   *\n   * @returns {Promise<void>}\n   */\n  async close(): Promise<void> {\n    try {\n      // Close the corresponding client context which will take care of closing all AMQP links\n      // associated with this client\n      await this._context.close();\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while closing the QueueClient for %s: %O\",\n        this._context.namespace.connectionId,\n        this.id,\n        err\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Creates a Sender to be used for sending messages, scheduling messages to be sent at a later time\n   * and cancelling such scheduled messages.\n   * @throws Error if the QueueClient or the underlying connection is closed.\n   * @throws Error if an open sender already exists on the QueueClient.\n   */\n  createSender(): Sender {\n    throwErrorIfClientOrConnectionClosed(\n      this._context.namespace,\n      this.entityPath,\n      this._context.isClosed\n    );\n    if (!this._currentSender || this._currentSender.isClosed) {\n      this._currentSender = new Sender(this._context);\n      return this._currentSender;\n    }\n    const errorMessage = getOpenSenderErrorMsg(\"QueueClient\", this.entityPath);\n    const error = new Error(errorMessage);\n    log.error(`[${this._context.namespace.connectionId}] %O`, error);\n    throw error;\n  }\n\n  /**\n   * Creates a Receiver for receiving messages from a Queue which does not have sessions enabled.\n   * @param receiveMode An enum indicating the mode in which messages should be received. Possible\n   * values are:\n   * - `ReceiveMode.peekLock`: Once a message is received in this mode, the receiver has a lock on\n   * the message for a particular duration. If the message is not settled by this time, it lands back\n   * on Service Bus to be fetched by the next receive operation.\n   * - `ReceiveMode.receiveAndDelete`: Messages received in this mode get automatically removed from\n   * Service Bus.\n   *\n   * @returns Receiver A receiver to receive messages from a Queue which does not have\n   * sessions enabled.\n   * @throws Error if the QueueClient or the underlying connection is closed.\n   * @throws Error if an open receiver already exists on the QueueClient.\n   * @throws MessagingError with name `InvalidOperationError` if the Queue has sessions enabled\n   * (in which case, use the overload of this method which takes\n   * `sessionOptions` argument)\n   */\n  public createReceiver(receiveMode: ReceiveMode): Receiver;\n\n  /**\n   * Creates a Receiver for receiving messages from a session enabled Queue. When no sessionId is\n   * given, a random session among the available sessions is used.\n   *\n   * @param receiveMode An enum indicating the mode in which messages should be received. Possible\n   * values are:\n   * - `ReceiveMode.peekLock`: Once a message is received in this mode, the receiver has a lock on\n   * the message for a particular duration. If the message is not settled by this time, it lands back\n   * on Service Bus to be fetched by the next receive operation.\n   * - `ReceiveMode.receiveAndDelete`: Messages received in this mode get automatically removed from\n   * Service Bus.\n   * @param sessionOptions Options to provide sessionId and duration of automatic lock renewal for\n   * the session receiver.\n   *\n   * @returns SessionReceiver A receiver to receive from a session in the Queue.\n   * @throws Error if the QueueClient or the underlying connection is closed.\n   * @throws Error if an open receiver already exists on the QueueClient for given sessionId.\n   * @throws MessagingError with name `SessionCannotBeLockedError` if the Queue does not have sessions enabled (in which\n   * case do not pass the `sessionOptions` argument) or if Service Bus is not able to get a lock on\n   * the session (in which case try again after some time)\n   */\n  public createReceiver(\n    receiveMode: ReceiveMode,\n    sessionOptions: SessionReceiverOptions\n  ): SessionReceiver;\n\n  public createReceiver(\n    receiveMode: ReceiveMode,\n    sessionOptions?: SessionReceiverOptions\n  ): Receiver | SessionReceiver {\n    throwErrorIfClientOrConnectionClosed(\n      this._context.namespace,\n      this.entityPath,\n      this._context.isClosed\n    );\n\n    // Receiver for Queue where sessions are not enabled\n    if (!sessionOptions) {\n      if (!this._currentReceiver || this._currentReceiver.isClosed) {\n        this._currentReceiver = new Receiver(this._context, receiveMode);\n        return this._currentReceiver;\n      }\n      const errorMessage = getOpenReceiverErrorMsg(ClientType.QueueClient, this.entityPath);\n      const error = new Error(errorMessage);\n      log.error(`[${this._context.namespace.connectionId}] %O`, error);\n      throw error;\n    }\n\n    return new SessionReceiver(this._context, receiveMode, sessionOptions);\n  }\n\n  /**\n   * Fetches the next batch of active messages (including deferred but not deadlettered messages).\n   * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the\n   * subsequent message.\n   * - Unlike a `received` message, `peeked` message is a read-only version of the message.\n   * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.\n   *\n   * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.\n   * @returns Promise<ReceivedMessageInfo[]>\n   * @throws Error if the QueueClient or the underlying connection is closed.\n   * @throws MessagingError if the service returns an error while peeking for messages.\n   */\n  async peek(maxMessageCount?: number): Promise<ReceivedMessageInfo[]> {\n    throwErrorIfClientOrConnectionClosed(\n      this._context.namespace,\n      this.entityPath,\n      this._context.isClosed\n    );\n\n    return this._context.managementClient!.peek(maxMessageCount);\n  }\n\n  /**\n   * Peeks the desired number of active messages (including deferred but not deadlettered messages)\n   * from the specified sequence number.\n   * - Unlike a `received` message, `peeked` message is a read-only version of the message.\n   * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.\n   *\n   * @param fromSequenceNumber The sequence number from where to read the message.\n   * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.\n   * @returns Promise<ReceivedMessageInfo[]>\n   * @throws Error if the QueueClient or the underlying connection is closed.\n   * @throws MessagingError if the service returns an error while peeking for messages.\n   */\n  async peekBySequenceNumber(\n    fromSequenceNumber: Long,\n    maxMessageCount?: number\n  ): Promise<ReceivedMessageInfo[]> {\n    throwErrorIfClientOrConnectionClosed(\n      this._context.namespace,\n      this.entityPath,\n      this._context.isClosed\n    );\n\n    return this._context.managementClient!.peekBySequenceNumber(\n      fromSequenceNumber,\n      maxMessageCount\n    );\n  }\n\n  // /**\n  //  * Lists the ids of the sessions on the ServiceBus Queue.\n  //  * @param maxNumberOfSessions Maximum number of sessions.\n  //  * @param lastUpdateTime Filter to include only sessions updated after a given time. Default\n  //  * value is 3 days before the current time.\n  //  */\n  // async listMessageSessions(\n  //   maxNumberOfSessions: number,\n  //   lastUpdatedTime?: Date\n  // ): Promise<string[]> {\n  // TODO: Parameter validation if required\n  // this.throwErrorIfClientOrConnectionClosed();\n  //   return this._context.managementClient!.listMessageSessions(\n  //     0,\n  //     maxNumberOfSessions,\n  //     lastUpdatedTime\n  //   );\n  // }\n\n  /**\n   * Returns the corresponding dead letter queue name for the queue represented by the given name.\n   * Use this in the `createQueueClient` function on the `ServiceBusClient` instance to receive\n   * messages from a dead letter queue.\n   * @param queueName Name of the queue whose dead letter counterpart's name is being fetched\n   */\n  static getDeadLetterQueuePath(queueName: string): string {\n    return `${queueName}/$DeadLetterQueue`;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { Client, ClientType } from \"./client\";\nimport { Sender } from \"./sender\";\nimport {\n  getOpenSenderErrorMsg,\n  throwErrorIfClientOrConnectionClosed,\n  throwErrorIfConnectionClosed\n} from \"./util/errors\";\nimport { generate_uuid } from \"rhea-promise\";\nimport { ClientEntityContext } from \"./clientEntityContext\";\n\n/**\n * Describes the client that allows interacting with a Service Bus Topic.\n * Use the `createTopicClient` function on the ServiceBusClient object to instantiate a TopicClient\n * @class TopicClient\n */\nexport class TopicClient implements Client {\n  /**\n   * @readonly\n   * @property The path for the Service Bus Topic for which this client is created.\n   */\n  readonly entityPath: string;\n  /**\n   * @readonly\n   * @property A unique identifier for this client.\n   */\n  readonly id: string;\n  /**\n   * @property Describes the amqp connection context for the QueueClient.\n   */\n  private _context: ClientEntityContext;\n\n  private _currentSender: Sender | undefined;\n\n  /**\n   * Constructor for TopicClient.\n   * This is not meant for the user to call directly.\n   * The user should use the `createTopicClient` on the Namespace instead.\n   *\n   * @constructor\n   * @internal\n   * @param topicName - The topic name.\n   * @param context - The connection context to create the TopicClient.\n   * @throws Error if the TopicClient or the underlying connection is closed.\n   */\n  constructor(topicName: string, context: ConnectionContext) {\n    throwErrorIfConnectionClosed(context);\n    this.entityPath = String(topicName);\n    this.id = `${this.entityPath}/${generate_uuid()}`;\n    this._context = ClientEntityContext.create(\n      this.entityPath,\n      ClientType.TopicClient,\n      context,\n      this.id\n    );\n  }\n\n  /**\n   * Closes the AMQP link for the sender created by this client.\n   * Once closed, neither the TopicClient nor its senders can be used for any\n   * further operations.\n   *\n   * @returns {Promise<void>}\n   */\n  async close(): Promise<void> {\n    try {\n      // Close the corresponding client context which will take care of closing all AMQP links\n      // associated with this client\n      await this._context.close();\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while closing the TopicClient for %s: %O\",\n        this._context.namespace.connectionId,\n        this.id,\n        err\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Creates a Sender to be used for sending messages, scheduling messages to be sent at a later time\n   * and cancelling such scheduled messages.\n   *\n   * If the Topic has session enabled Subscriptions, then messages sent without the `sessionId`\n   * property will go to the dead letter queue of such subscriptions.\n   * @throws Error if the TopicClient or the underlying connection is closed.\n   * @throws Error if an open sender already exists on the TopicClient.\n   */\n  createSender(): Sender {\n    throwErrorIfClientOrConnectionClosed(\n      this._context.namespace,\n      this.entityPath,\n      this._context.isClosed\n    );\n    if (!this._currentSender || this._currentSender.isClosed) {\n      this._currentSender = new Sender(this._context);\n      return this._currentSender;\n    }\n\n    const errorMessage = getOpenSenderErrorMsg(\"TopicClient\", this.entityPath);\n    const error = new Error(errorMessage);\n    log.error(`[${this._context.namespace.connectionId}] %O`, error);\n    throw error;\n  }\n\n  /**\n   * Returns the corresponding dead letter topic name for the given topic and subscription names.\n   * Use this in the `createSubscriptionClient` function of the `ServiceBusClient` instance to\n   * receive messages from dead letter queue for given subscription.\n   * @param topicName Name of the topic whose dead letter counterpart's name is being fetched\n   * @param subscriptionName Name of the subscription whose dead letter counterpart's name is being fetched\n   */\n  static getDeadLetterTopicPath(topicName: string, subscriptionName: string): string {\n    return `${topicName}/Subscriptions/${subscriptionName}/$DeadLetterQueue`;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { Receiver, SessionReceiver } from \"./receiver\";\nimport { ReceivedMessageInfo, ReceiveMode } from \"./serviceBusMessage\";\nimport { Client, ClientType } from \"./client\";\nimport { CorrelationFilter, RuleDescription } from \"./core/managementClient\";\nimport { SessionReceiverOptions } from \"./session/messageSession\";\nimport {\n  getOpenReceiverErrorMsg,\n  throwErrorIfClientOrConnectionClosed,\n  throwErrorIfConnectionClosed\n} from \"./util/errors\";\nimport { generate_uuid } from \"rhea-promise\";\nimport { ClientEntityContext } from \"./clientEntityContext\";\nimport Long from \"long\";\n\n/**\n * Describes the client that allows interacting with a Service Bus Subscription.\n * Use the `createSubscriptionClient` function on the ServiceBusClient object to instantiate a\n * SubscriptionClient\n * @class SubscriptionClient\n */\nexport class SubscriptionClient implements Client {\n  /**\n   * @readonly\n   * @property The name of the Service Bus Topic for whose Subscription, this client is created.\n   */\n  readonly topicName: string;\n  /**\n   * @readonly\n   * @property The name of the Service Bus Subscription for which this client is created.\n   */\n  readonly subscriptionName: string;\n\n  /**\n   * @readonly\n   * @property The name of the default rule on the subscription.\n   */\n  readonly defaultRuleName: string = \"$Default\";\n\n  /**\n   * @readonly\n   * @property The path for the Service Bus Subscription for which this client is created.\n   */\n  readonly entityPath: string;\n  /**\n   * @readonly\n   * @property A unique identifier for this client.\n   */\n  readonly id: string;\n  /**\n   * @property Describes the amqp connection context for the SubscriptionClient.\n   */\n  private _context: ClientEntityContext;\n\n  private _currentReceiver: Receiver | undefined;\n\n  /**\n   * Constructor for SubscriptionClient.\n   * This is not meant for the user to call directly.\n   * The user should use the `createSubscriptionClient` on the Namespace instead.\n   *\n   * @constructor\n   * @internal\n   * @param topicName - The Topic name.\n   * @param subscriptionName - The Subscription name.\n   * @param context - The connection context to create the SubscriptionClient.\n   * @throws Error if the underlying connection is closed.\n   */\n  constructor(topicName: string, subscriptionName: string, context: ConnectionContext) {\n    throwErrorIfConnectionClosed(context);\n\n    this.topicName = String(topicName);\n    this.subscriptionName = String(subscriptionName);\n\n    this.entityPath = `${topicName}/Subscriptions/${subscriptionName}`;\n    this.id = `${this.entityPath}/${generate_uuid()}`;\n    this._context = ClientEntityContext.create(\n      this.entityPath,\n      ClientType.SubscriptionClient,\n      context,\n      this.id\n    );\n  }\n\n  /**\n   * Closes the AMQP link for the receivers created by this client.\n   * Once closed, neither the SubscriptionClient nor its receivers can be used for any\n   * further operations.\n   *\n   * @returns {Promise<void>}\n   */\n  async close(): Promise<void> {\n    try {\n      // Close the corresponding client context which will take care of closing all AMQP links\n      // associated with this client\n      await this._context.close();\n    } catch (err) {\n      log.error(\n        \"[%s] An error occurred while closing the SubscriptionClient for %s: %O\",\n        this._context.namespace.connectionId,\n        this.id,\n        err\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Creates a Receiver for receiving messages from a Subscription which does not have sessions enabled.\n   * @param receiveMode An enum indicating the mode in which messages should be received. Possible\n   * values are:\n   * - `ReceiveMode.peekLock`: Once a message is received in this mode, the receiver has a lock on\n   * the message for a particular duration. If the message is not settled by this time, it lands back\n   * on Service Bus to be fetched by the next receive operation.\n   * - `ReceiveMode.receiveAndDelete`: Messages received in this mode get automatically removed from\n   * Service Bus.\n   *\n   * @returns Receiver A receiver to receive messages from a Subscription which does not have\n   * sessions enabled.\n   * @throws Error if the SubscriptionClient or the underlying connection is closed.\n   * @throws Error if an open receiver already exists on the SubscriptionClient.\n   * @throws MessagingError with name `InvalidOperationError` if the Queue has sessions enabled\n   * (in which case, use the overload of this method which takes\n   * `sessionOptions` argument)\n   */\n  public createReceiver(receiveMode: ReceiveMode): Receiver;\n\n  /**\n   * Creates a Receiver for receiving messages from a session enabled Subscription. When no sessionId is\n   * given, a random session among the available sessions is used.\n   * @param receiveMode An enum indicating the mode in which messages should be received. Possible\n   * values are:\n   * - `ReceiveMode.peekLock`: Once a message is received in this mode, the receiver has a lock on\n   * the message for a particular duration. If the message is not settled by this time, it lands back\n   * on Service Bus to be fetched by the next receive operation.\n   * - `ReceiveMode.receiveAndDelete`: Messages received in this mode get automatically removed from\n   * Service Bus.\n   * @param sessionOptions Options to provide sessionId and duration of automatic lock renewal for\n   * the session receiver.\n   *\n   * @returns SessionReceiver A receiver to receive from a session in the Subscription.\n   * @throws Error if the SubscriptionClient or the underlying connection is closed.\n   * @throws Error if an open receiver already exists on the SubscriptionClient for given sessionId.\n   * @throws MessagingError with name `SessionCannotBeLockedError` if the Queue does not have sessions enabled (in which\n   * case do not pass the `sessionOptions` argument) or if Service Bus is not able to get a lock on\n   * the session (in which case try again after some time)\n   */\n  public createReceiver(\n    receiveMode: ReceiveMode,\n    sessionOptions: SessionReceiverOptions\n  ): SessionReceiver;\n\n  public createReceiver(\n    receiveMode: ReceiveMode,\n    sessionOptions?: SessionReceiverOptions\n  ): Receiver | SessionReceiver {\n    throwErrorIfClientOrConnectionClosed(\n      this._context.namespace,\n      this.entityPath,\n      this._context.isClosed\n    );\n\n    // Receiver for Subscription where sessions are not enabled\n    if (!sessionOptions) {\n      if (!this._currentReceiver || this._currentReceiver.isClosed) {\n        this._currentReceiver = new Receiver(this._context, receiveMode);\n        return this._currentReceiver;\n      }\n      const errorMessage = getOpenReceiverErrorMsg(ClientType.SubscriptionClient, this.entityPath);\n      const error = new Error(errorMessage);\n      log.error(`[${this._context.namespace.connectionId}] %O`, error);\n      throw error;\n    }\n\n    return new SessionReceiver(this._context, receiveMode, sessionOptions);\n  }\n\n  /**\n   * Fetches the next batch of active messages (including deferred but not deadlettered messages).\n   * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the\n   * subsequent message.\n   * - Unlike a `received` message, `peeked` message is a read-only version of the message.\n   * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.\n   *\n   * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.\n   * @returns Promise<ReceivedSBMessage[]>\n   * @throws Error if the SubscriptionClient or the underlying connection is closed.\n   * @throws MessagingError if the service returns an error while peeking for messages.\n   */\n  async peek(maxMessageCount?: number): Promise<ReceivedMessageInfo[]> {\n    throwErrorIfClientOrConnectionClosed(\n      this._context.namespace,\n      this.entityPath,\n      this._context.isClosed\n    );\n\n    return this._context.managementClient!.peek(maxMessageCount);\n  }\n\n  /**\n   * Peeks the desired number of active messages (including deferred but not deadlettered messages)\n   * from the specified sequence number.\n   * - Unlike a `received` message, `peeked` message is a read-only version of the message.\n   * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.\n   *\n   * @param fromSequenceNumber The sequence number from where to read the message.\n   * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.\n   * @returns Promise<ReceivedSBMessage[]>\n   * @throws Error if the SubscriptionClient or the underlying connection is closed.\n   * @throws MessagingError if the service returns an error while peeking for messages.\n   */\n  async peekBySequenceNumber(\n    fromSequenceNumber: Long,\n    maxMessageCount?: number\n  ): Promise<ReceivedMessageInfo[]> {\n    throwErrorIfClientOrConnectionClosed(\n      this._context.namespace,\n      this.entityPath,\n      this._context.isClosed\n    );\n\n    return this._context.managementClient!.peekBySequenceNumber(\n      fromSequenceNumber,\n      maxMessageCount\n    );\n  }\n\n  // #region topic-filters\n\n  /**\n   * Gets all rules associated with the subscription\n   * @throws Error if the SubscriptionClient or the underlying connection is closed.\n   * @throws MessagingError if the service returns an error while retrieving rules.\n   */\n  async getRules(): Promise<RuleDescription[]> {\n    throwErrorIfClientOrConnectionClosed(\n      this._context.namespace,\n      this.entityPath,\n      this._context.isClosed\n    );\n    return this._context.managementClient!.getRules();\n  }\n\n  /**\n   * Removes the rule on the subscription identified by the given rule name.\n   *\n   * **Caution**: If all rules on a subscription are removed, then the subscription will not receive\n   * any more messages.\n   * @param ruleName\n   * @throws Error if the SubscriptionClient or the underlying connection is closed.\n   * @throws MessagingError if the service returns an error while removing rules.\n   */\n  async removeRule(ruleName: string): Promise<void> {\n    throwErrorIfClientOrConnectionClosed(\n      this._context.namespace,\n      this.entityPath,\n      this._context.isClosed\n    );\n    return this._context.managementClient!.removeRule(ruleName);\n  }\n\n  /**\n   * Adds a rule on the subscription as defined by the given rule name, filter and action.\n   *\n   * **Note**: Remove the default true filter on the subscription before adding a rule.\n   * Otherwise, the added rule will have no affect as the true filter will always result in\n   * the subscription receiving all messages.\n   * @param ruleName Name of the rule\n   * @param filter A Boolean, SQL expression or a Correlation filter. For SQL Filter syntax, see\n   * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-filter SQLFilter syntax}.\n   * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression. For SQL Rule Action syntax,\n   * see {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-rule-action SQLRuleAction syntax}.\n   * @throws Error if the SubscriptionClient or the underlying connection is closed.\n   * @throws MessagingError if the service returns an error while adding rules.\n   */\n  async addRule(\n    ruleName: string,\n    filter: boolean | string | CorrelationFilter,\n    sqlRuleActionExpression?: string\n  ): Promise<void> {\n    throwErrorIfClientOrConnectionClosed(\n      this._context.namespace,\n      this.entityPath,\n      this._context.isClosed\n    );\n    return this._context.managementClient!.addRule(ruleName, filter, sqlRuleActionExpression);\n  }\n\n  // #endregion\n\n  // #region sessions\n\n  // /**\n  //  * Lists the ids of the sessions on the ServiceBus Subscription.\n  //  * @param maxNumberOfSessions Maximum number of sessions.\n  //  * @param lastUpdateTime Filter to include only sessions updated after a given time. Default\n  //  * value is 3 days before the current time.\n  //  */\n  // async listMessageSessions(\n  //   maxNumberOfSessions: number,\n  //   lastUpdatedTime?: Date\n  // ): Promise<string[]> {\n  // TODO: Parameter validation if required\n  // this.throwErrorIfClientOrConnectionClosed();\n  //   return this._context.managementClient!.listMessageSessions(\n  //     0,\n  //     maxNumberOfSessions,\n  //     lastUpdatedTime\n  //   );\n  // }\n\n  // #endregion\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\n\nimport {\n  ApplicationTokenCredentials,\n  DeviceTokenCredentials,\n  UserTokenCredentials,\n  MSITokenCredentials\n} from \"@azure/ms-rest-nodeauth\";\n\nimport { WebSocketImpl } from \"rhea-promise\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { QueueClient } from \"./queueClient\";\nimport { TopicClient } from \"./topicClient\";\nimport {\n  ConnectionConfig,\n  DataTransformer,\n  TokenProvider,\n  AadTokenProvider,\n  SasTokenProvider\n} from \"@azure/amqp-common\";\nimport { SubscriptionClient } from \"./subscriptionClient\";\nimport { isNode } from \"./util/utils\";\n\n/**\n * Describes the options that can be provided while creating the ServiceBusClient.\n * @interface ServiceBusClientOptions\n */\nexport interface ServiceBusClientOptions {\n  /**\n   * @property The data transformer that will be used to encode\n   * and decode the sent and received messages respectively. If not provided then we will use the\n   * DefaultDataTransformer. The default transformer should handle majority of the cases. This\n   * option needs to be used only for specialized scenarios.\n   */\n  dataTransformer?: DataTransformer;\n  /**\n   * @property The WebSocket constructor used to create an AMQP connection\n   * over a WebSocket. In browsers, the built-in WebSocket will be  used by default. In Node, a\n   * TCP socket will be used if a WebSocket constructor is not provided.\n   */\n  webSocket?: WebSocketImpl;\n  /**\n   * @property Options to be passed to the WebSocket constructor\n   */\n  webSocketConstructorOptions?: any;\n}\n\n/**\n * Describes the client that allows interacting with a Service Bus instance.\n * Holds the AMQP connection to the Service Bus Namespace and is the entry point for using Queues,\n * Topics and Subscriptions.\n */\nexport class ServiceBusClient {\n  /**\n   * @readonly\n   * @property The name of the Service Bus Namespace.\n   */\n  readonly name: string;\n  /**\n   * @property Describes the amqp connection context for the Namespace.\n   * @private\n   */\n  private _context: ConnectionContext;\n\n  /**\n   * Instantiates a ServiceBusClient to interact with a Service Bus Namespace.\n   *\n   * @constructor\n   * @param {ConnectionConfig} config - The connection configuration needed to connect to the\n   * Service Bus Namespace.\n   * @param {TokenProvider} [tokenProvider] - The token provider that provides the token for\n   * authentication.\n   * @param {ServiceBusClientOptions} - Options to control ways to interact with the Service Bus\n   * Namespace.\n   */\n  private constructor(\n    config: ConnectionConfig,\n    tokenProvider: TokenProvider,\n    options?: ServiceBusClientOptions\n  ) {\n    if (!options) options = {};\n    this.name = config.endpoint;\n    this._context = ConnectionContext.create(config, tokenProvider, options);\n  }\n\n  /**\n   * Creates a QueueClient for an existing Service Bus Queue.\n   * @param {string} queueName The queue name.\n   * @returns QueueClient.\n   * @throws Error if the underlying connection is closed.\n   */\n  createQueueClient(queueName: string): QueueClient {\n    const client = new QueueClient(queueName, this._context);\n    log.ns(\"Created the QueueClient for Queue: %s\", queueName);\n    return client;\n  }\n\n  /**\n   * Creates a TopicClient for an existing Service Bus Topic.\n   * @param {string} topicName The topic name.\n   * @returns TopicClient.\n   * @throws\n   * @throws Error if the underlying connection is closed.\n   */\n  createTopicClient(topicName: string): TopicClient {\n    const client = new TopicClient(topicName, this._context);\n    log.ns(\"Created the TopicClient for Topic: %s\", topicName);\n    return client;\n  }\n\n  /**\n   * Creates a SubscriptionClient for an existing Service Bus Subscription.\n   * @param {string} topicName The topic name.\n   * @param {string} subscriptionName The subscription name.\n   * @returns SubscriptionClient.\n   * @throws Error if the underlying connection is closed.\n   */\n  createSubscriptionClient(topicName: string, subscriptionName: string): SubscriptionClient {\n    const client = new SubscriptionClient(topicName, subscriptionName, this._context);\n    log.ns(\n      \"Created the SubscriptionClient for Topic: %s and Subscription: %s\",\n      topicName,\n      subscriptionName\n    );\n    return client;\n  }\n\n  /**\n   * Closes the AMQP connection created by this ServiceBusClient along with AMQP links for\n   * sender/receivers created by the queue/topic/subscription clients created by this\n   * ServiceBusClient.\n   * Once closed,\n   * - the clients created by this ServiceBusClient cannot be used to send/receive messages anymore.\n   * - this ServiceBusClient cannot be used to create any new queues/topics/subscriptions clients.\n   * @returns {Promise<any>}\n   */\n  async close(): Promise<any> {\n    try {\n      if (this._context.connection.isOpen()) {\n        log.ns(\"Closing the amqp connection '%s' on the client.\", this._context.connectionId);\n\n        // Close all the clients.\n        for (const id of Object.keys(this._context.clientContexts)) {\n          const clientContext = this._context.clientContexts[id];\n          await clientContext.close();\n        }\n        await this._context.cbsSession.close();\n\n        await this._context.connection.close();\n        this._context.wasConnectionCloseCalled = true;\n        log.ns(\"Closed the amqp connection '%s' on the client.\", this._context.connectionId);\n      }\n    } catch (err) {\n      const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));\n      log.error(\n        `An error occurred while closing the connection \"${this._context.connectionId}\":\\n${errObj}`\n      );\n      throw errObj;\n    }\n  }\n\n  /**\n   * Creates a ServiceBusClient for the Service Bus Namespace represented in the given connection\n   * string.\n   * @param {string} connectionString - Connection string of the form\n   * 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'\n   * @param {ServiceBusClientOptions} [options] Options to control ways to interact with the\n   * Service Bus Namespace.\n   * @returns {ServiceBusClient}\n   */\n  static createFromConnectionString(\n    connectionString: string,\n    options?: ServiceBusClientOptions\n  ): ServiceBusClient {\n    const config = ConnectionConfig.create(connectionString);\n\n    config.webSocket = options && options.webSocket;\n    config.webSocketEndpointPath = \"$servicebus/websocket\";\n    config.webSocketConstructorOptions = options && options.webSocketConstructorOptions;\n\n    ConnectionConfig.validate(config);\n    const tokenProvider = new SasTokenProvider(\n      config.endpoint,\n      config.sharedAccessKeyName,\n      config.sharedAccessKey\n    );\n    return new ServiceBusClient(config, tokenProvider, options);\n  }\n\n  /**\n   * Creates a ServiceBusClient for the Service Bus Namespace represented by the given host using\n   * the given TokenProvider.\n   * @param {string} host - Fully qualified domain name for Servicebus. Most likely,\n   * `<yournamespace>.servicebus.windows.net`.\n   * @param {TokenProvider} tokenProvider - Your custom implementation of the {@link https://github.com/Azure/amqp-common-js/blob/master/lib/auth/token.ts Token Provider}\n   * interface.\n   * @param {ServiceBusClientOptions} options - Options to control ways to interact with the\n   * Service Bus Namespace.\n   * @returns {ServiceBusClient}\n   */\n  static createFromTokenProvider(\n    host: string,\n    tokenProvider: TokenProvider,\n    options?: ServiceBusClientOptions\n  ): ServiceBusClient {\n    host = String(host);\n    if (!tokenProvider) {\n      throw new TypeError('Missing parameter \"tokenProvider\"');\n    }\n    if (!host.endsWith(\"/\")) host += \"/\";\n    const connectionString =\n      `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;` +\n      `SharedAccessKey=defaultKeyValue`;\n    const config = ConnectionConfig.create(connectionString);\n\n    config.webSocket = options && options.webSocket;\n    config.webSocketEndpointPath = \"$servicebus/websocket\";\n    config.webSocketConstructorOptions = options && options.webSocketConstructorOptions;\n\n    ConnectionConfig.validate(config);\n    return new ServiceBusClient(config, tokenProvider, options);\n  }\n\n  /**\n   * Creates a ServiceBusClient for the Service Bus Namespace represented by the given host using\n   * the TokenCredentials generated using the `@azure/ms-rest-nodeauth` library.\n   * @param {string} host - Fully qualified domain name for ServiceBus.\n   * Most likely, {yournamespace}.servicebus.windows.net\n   * @param {ServiceClientCredentials} credentials - The Token credentials generated by using the\n   * `@azure/ms-rest-nodeauth` library. It can be one of the following:\n   *  - ApplicationTokenCredentials\n   *  - UserTokenCredentials\n   *  - DeviceTokenCredentials\n   *  - MSITokenCredentials\n   * Token audience (or resource in case of MSI based credentials) to use when creating the credentials is https://servicebus.azure.net/\n   * @param {ServiceBusClientOptions} options - Options to control ways to interact with the\n   * Service Bus Namespace.\n   * @returns {ServiceBusClient}\n   * @throws Error if `createFromAadTokenCredentials` is accessed in browser context, as AAD support is not present in browser.\n   */\n  static createFromAadTokenCredentials(\n    host: string,\n    credentials:\n      | ApplicationTokenCredentials\n      | UserTokenCredentials\n      | DeviceTokenCredentials\n      | MSITokenCredentials,\n    options?: ServiceBusClientOptions\n  ): ServiceBusClient {\n    if (!isNode) {\n      throw new Error(\n        \"`createFromAadTokenCredentials` cannot be used to create ServiceBusClient as AAD support is not present in browser.\"\n      );\n    }\n    host = String(host);\n    const tokenProvider = new AadTokenProvider(credentials);\n    return ServiceBusClient.createFromTokenProvider(host, tokenProvider, options);\n  }\n}\n"],"names":["os.type","os.release","ConnectionContextBase","log.connectionCtxt","log.error","delay","Constants","error","ConnectionEvents","generate_uuid","Buffer","log.utils","ReceiveMode","log.message","uuid_to_string","translate","ErrorNameConditionMapper","log.link","defaultLock","link","log.sender","SenderEvents","randomNumberFromInterval","RetryOperationType","retry","RheaMessageUtil","messageProperties","log.receiver","isAmqpError","ConditionErrorNameMapper","ReceiverEvents","SessionEvents","MessagingError","log.batching","log.messageSession","log.mgmt","RequestResponseLink","types","string_to_uuid","AsyncLock","log.map","log.sessionManager","log.entityCtxt","log.ns","ConnectionConfig","SasTokenProvider","AadTokenProvider"],"mappings":";;;;;;;;;;;;;;;AAAA;AAIA;;;;AAIO,MAAM,IAAI,GAAG,WAAW,CAAC,8BAA8B,CAAC,CAAC;AAChE;;;;AAIO,MAAM,KAAK,GAAG,WAAW,CAAC,yBAAyB,CAAC,CAAC;AAC5D;;;;AAIO,MAAM,OAAO,GAAG,WAAW,CAAC,2BAA2B,CAAC,CAAC;AAChE;;;;AAIO,MAAM,IAAI,GAAG,WAAW,CAAC,8BAA8B,CAAC,CAAC;AAChE;;;;AAIO,MAAM,MAAM,GAAG,WAAW,CAAC,0BAA0B,CAAC,CAAC;AAC9D;;;;AAIO,MAAM,QAAQ,GAAG,WAAW,CAAC,4BAA4B,CAAC,CAAC;AAClE;;;;AAIO,MAAM,QAAQ,GAAG,WAAW,CAAC,oCAAoC,CAAC,CAAC;AAC1E;;;;AAIO,MAAM,SAAS,GAAG,WAAW,CAAC,qCAAqC,CAAC,CAAC;AAC5E;;;;AAIO,MAAM,cAAc,GAAG,WAAW,CAAC,qCAAqC,CAAC,CAAC;AACjF;;;;AAIO,MAAM,UAAU,GAAG,WAAW,CAAC,uCAAuC,CAAC,CAAC;AAC/E;;;;AAIO,MAAM,EAAE,GAAG,WAAW,CAAC,6BAA6B,CAAC,CAAC;AAC7D;;;;AAIO,MAAM,OAAO,GAAG,WAAW,CAAC,qCAAqC,CAAC,CAAC;AAC1E;;;;AAIO,MAAM,GAAG,GAAG,WAAW,CAAC,iCAAiC,CAAC,CAAC;AAClE;;;;AAIO,MAAM,KAAK,GAAG,WAAW,CAAC,yBAAyB,CAAC,CAAC;AAC5D;;;;AAIO,MAAM,cAAc,GAAG,WAAW,CAAC,kCAAkC,CAAC,CAAC;AAC9E;;;;AAIO,MAAM,SAAS,GAAG,WAAW,CAAC,6BAA6B,CAAC,CAAC;AACpE;;;;AAIO,MAAM,cAAc,GAAG,WAAW,CAAC,kCAAkC,CAAC,CAAC;AAC9E;;;;AAIO,MAAM,WAAW,GAAG,WAAW,CAAC,4BAA4B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;AC7FpE;AACA;AAEA,AAAO,MAAM,eAAe,GAAG;IAC7B,IAAI,EAAE,oBAAoB;IAC1B,OAAO,EAAE,OAAO;CACjB,CAAC;AAEF,AAEO,MAAM,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC;;ACVlD;AACA,AAgCA;;;AAGA,IAAiB,iBAAiB,CA+JjC;AA/JD,WAAiB,iBAAiB;;;;;IAKnB,2BAAS,GAAW,4BAC/B,eAAe,CAAC,OAClB,kBAAkB,OAAO,CAAC,OAAO,KAAKA,OAAO,EAAE,IAAIC,UAAU,EAAE,GAAG,CAAC;IAEnE,SAAgB,MAAM,CACpB,MAAwB,EACxB,aAA4B,EAC5B,OAAiC;QAEjC,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,CAAC;QAC3B,MAAM,UAAU,GAA0C;YACxD,MAAM,EAAE,MAAM;YACd,aAAa,EAAE,aAAa;YAC5B,eAAe,EAAE,OAAO,CAAC,eAAe;YACxC,oBAAoB,EAAE,KAAK;YAC3B,oBAAoB,EAAE;gBACpB,OAAO,EAAE,YAAY;gBACrB,SAAS,EAAE,kBAAA,SAAS;gBACpB,OAAO,EAAE,eAAe,CAAC,OAAO;aACjC;SACF,CAAC;;QAEF,MAAM,iBAAiB,GAAGC,gCAAqB,CAAC,MAAM,CAAC,UAAU,CAAsB,CAAC;QACxF,iBAAiB,CAAC,cAAc,GAAG,EAAE,CAAC;;;QAItC,MAAM,gBAAgB,GAAgB,CAAC,OAAqB;YAC1D,iBAAiB,CAAC,wBAAwB,GAAG,KAAK,CAAC;YACnDC,cAAkB,CAChB,+EAA+E,EAC/E,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,iBAAiB,CAAC,wBAAwB,CAC3C,CAAC;SACH,CAAC;QAEF,MAAM,YAAY,GAAgB,CAAO,OAAqB;YAC5D,MAAM,eAAe,GACnB,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,CAAC,KAAK,GAAG,OAAO,CAAC,UAAU,CAAC,KAAK,GAAG,SAAS,CAAC;YACxF,IAAI,eAAe,EAAE;gBACnBC,KAAS,CACP,2EAA2E,EAC3E,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,eAAe,CAChB,CAAC;aACH;YACD,MAAM,YAAY,GAAG,OAAO,CAAC,KAAK,CAAC;YACnC,IAAI,YAAY,EAAE;gBAChBA,KAAS,CACP,gEAAgE,EAChE,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,YAAY,CACb,CAAC;aACH;YACD,MAAM,KAAK,GAGN;gBACH,wBAAwB,EAAE,iBAAiB,CAAC,wBAAwB;gBACpE,UAAU,EAAE,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,CAAC,MAAM;aACjE,CAAC;;;YAIF,iBAAiB,CAAC,UAAU,CAAC,iBAAiB,EAAE,CAAC;;YAGjD,MAAM,iBAAiB,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;;YAG3C,KAAK,MAAM,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,EAAE;gBAC9D,MAAM,aAAa,GAAG,iBAAiB,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;gBAC3D,IAAI,aAAa,CAAC,gBAAgB,EAAE;oBAClC,MAAM,aAAa,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC;iBAC9C;aACF;;;YAIDA,KAAS,CAAC,gBAAgB,EAAE,iBAAiB,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;YACnE,IAAI,CAAC,KAAK,CAAC,wBAAwB,IAAI,KAAK,CAAC,UAAU,EAAE;gBACvDA,KAAS,CACP,0EAA0E;oBACxE,+BAA+B,EACjC,iBAAiB,CAAC,UAAU,CAAC,EAAE,CAChC,CAAC;gBACF,MAAMC,gBAAK,CAACC,oBAAS,CAAC,wBAAwB,CAAC,CAAC;;gBAEhD,KAAK,MAAM,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,EAAE;oBAC9D,MAAM,aAAa,GAAG,iBAAiB,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;oBAC3DF,KAAS,CACP,uCAAuC,EACvC,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,aAAa,CAAC,QAAQ,CACvB,CAAC;oBACF,aAAa,CAAC,UAAU,CAAC,eAAe,IAAI,YAAY,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG;wBAClEA,KAAS,CACP,gEAAgE,EAChE,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,aAAa,CAAC,QAAQ,EACtB,GAAG,CACJ,CAAC;qBACH,CAAC,CAAC;iBACJ;aACF;SACF,CAAA,CAAC;QAEF,MAAM,aAAa,GAAgB,CAAO,OAAqB;YAC7D,IAAI,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,CAAC,KAAK,EAAE;gBAClDA,KAAS,CACP,2EAA2E,EAC3E,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,CAAC,KAAK,CAC/C,CAAC;aACH;YACD,IAAI,OAAO,CAAC,KAAK,EAAE;gBACjBA,KAAS,CACP,gEAAgE,EAChE,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,OAAO,CAAC,KAAK,CACd,CAAC;aACH;SACF,CAAA,CAAC;QAEF,MAAMG,OAAK,GAAgB,CAAO,OAAqB;YACrD,IAAI,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,CAAC,KAAK,EAAE;gBAClDH,KAAS,CACP,2EAA2E,EAC3E,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,CAAC,KAAK,CAC/C,CAAC;aACH;YACD,IAAI,OAAO,CAAC,KAAK,EAAE;gBACjBA,KAAS,CACP,gEAAgE,EAChE,iBAAiB,CAAC,UAAU,CAAC,EAAE,EAC/B,OAAO,CAAC,KAAK,CACd,CAAC;aACH;SACF,CAAA,CAAC;;QAGF,iBAAiB,CAAC,UAAU,CAAC,EAAE,CAACI,4BAAgB,CAAC,cAAc,EAAE,gBAAgB,CAAC,CAAC;QACnF,iBAAiB,CAAC,UAAU,CAAC,EAAE,CAACA,4BAAgB,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;QAC7E,iBAAiB,CAAC,UAAU,CAAC,EAAE,CAACA,4BAAgB,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;QAC/E,iBAAiB,CAAC,UAAU,CAAC,EAAE,CAACA,4BAAgB,CAAC,KAAK,EAAED,OAAK,CAAC,CAAC;QAE/DJ,cAAkB,CAChB,+CAA+C,EAC/C,iBAAiB,CAAC,YAAY,CAC/B,CAAC;QAEF,OAAO,iBAAiB,CAAC;KAC1B;IArJe,wBAAM,SAqJrB,CAAA;AACH,CAAC,EA/JgB,iBAAiB,KAAjB,iBAAiB,QA+JjC;;ACnMD;AACA;AAsBA;;;AAGA,AAAA,IAAY,UAIX;AAJD,WAAY,UAAU;IACpB,yCAA2B,CAAA;IAC3B,yCAA2B,CAAA;IAC3B,uDAAyC,CAAA;AAC3C,CAAC,EAJW,UAAU,KAAV,UAAU,QAIrB;;AC9BD;AACA,AAqBA;;;;;;AAMA,SAAgB,aAAa,CAAC,IAAY;IACxC,OAAO,GAAG,IAAI,IAAIM,yBAAa,EAAE,EAAE,CAAC;AACtC,CAAC;AAED;;;;;;;;;AASA,SAAgB,gBAAgB,CAAC,cAAsB;IACrD,IAAI,CAAC,cAAc,IAAI,CAACC,aAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE;QACvD,OAAO,cAAc,CAAC;KACvB;IAED,OAAOA,aAAM,CAAC,IAAI,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QAEjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QAEjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QAEjB,cAAc,CAAC,CAAC,CAAC;QACjB,cAAc,CAAC,CAAC,CAAC;QAEjB,cAAc,CAAC,EAAE,CAAC;QAClB,cAAc,CAAC,EAAE,CAAC;QAClB,cAAc,CAAC,EAAE,CAAC;QAClB,cAAc,CAAC,EAAE,CAAC;QAClB,cAAc,CAAC,EAAE,CAAC;QAClB,cAAc,CAAC,EAAE,CAAC;KACnB,CAAC,CAAC;AACL,CAAC;AAED;;;;;AAKA,SAAgB,2BAA2B,CAAC,cAAoB;IAC9D,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IACvB,MAAM,WAAW,GAAG,cAAc,CAAC,OAAO,EAAE,CAAC;IAC7C,MAAM,aAAa,GAAG,WAAW,GAAG,GAAG,CAAC;IACxCC,KAAS,CAAC,wBAAwB,EAAE,WAAW,CAAC,CAAC;IACjDA,KAAS,CAAC,wBAAwB,EAAE,GAAG,CAAC,CAAC;IACzCA,KAAS,CAAC,wBAAwB,EAAE,aAAa,CAAC,CAAC;IACnD,IAAI,aAAa,GAAG,IAAI,EAAE;QACxB,OAAO,CAAC,CAAC;KACV;IACD,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,aAAa,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;IAClD,MAAM,UAAU,GAAG,aAAa,GAAG,MAAM,CAAC;IAC1CA,KAAS,CAAC,wBAAwB,EAAE,UAAU,CAAC,CAAC;IAChD,OAAO,UAAU,CAAC;AACpB,CAAC;AAED;;;;;;;;;;;;;;AAcA,SAAgB,kBAAkB,CAAC,GAAa;IAC9C,MAAM,cAAc,GAAW,kBAAkB,CAAC;IAClD,MAAM,SAAS,GAAS,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;IAC9C,MAAM,QAAQ,GAAG,SAAS;SACvB,GAAG,CAAC,cAAc,CAAC;SACnB,GAAG,CAAC,KAAK,CAAC;SACV,QAAQ,EAAE,CAAC;IACd,MAAM,MAAM,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;IAClCA,KAAS,CAAC,2BAA2B,EAAE,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC1D,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;AAIA,SAAgB,iBAAiB;IAC/B,AAAY;QACV,MAAM,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QACzB,OAAO,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC;KACzB,AAEA;AACH,CAAC;AAED;;;;;AAKA,SAAgB,QAAQ,CAAC,KAAU;IACjC,IAAI,MAAW,CAAC;IAChBA,KAAS,CACP,mFAAmF,EACnF,KAAK,CACN,CAAC;IACF,IAAI,QAAQ,CAAC,KAAK,CAAC,EAAE;QACnB,MAAM,GAAG,KAAK,CAAC;KAChB;SAAM;;;;QAIL,IAAI,KAAK,KAAK,SAAS;YAAE,KAAK,GAAG,IAAI,CAAC;QACtC,IAAI;YACF,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YACvC,MAAM,GAAGD,aAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;SACxC;QAAC,OAAO,GAAG,EAAE;YACZ,MAAM,GAAG,GACP,wEAAwE;gBACxE,KAAK;gBACL,GAAG,GAAG,YAAY,KAAK,GAAG,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC;YAC9DN,KAAS,CAAC,mBAAmB,GAAG,GAAG,CAAC,CAAC;YACrC,MAAM,GAAG,YAAY,KAAK,GAAG,GAAG,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC;SACnD;KACF;IACDO,KAAS,CAAC,+CAA+C,EAAE,MAAM,CAAC,CAAC;IACnE,OAAO,MAAM,CAAC;AAChB,CAAC;;AClKD;AACA,AAOA;;;;;AAKA,SAAgB,4BAA4B,CAAC,OAA0B;IACrE,IAAI,OAAO,IAAI,OAAO,CAAC,wBAAwB,EAAE;QAC/C,MAAM,YAAY,GAAG,2CAA2C,CAAC;QACjE,MAAMJ,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;QACtCH,KAAS,CAAC,IAAI,OAAO,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;QACjD,MAAMA,OAAK,CAAC;KACb;AACH,CAAC;AAED;;;;;;;AAOA,SAAgB,oCAAoC,CAClD,OAA0B,EAC1B,UAAkB,EAClB,cAAuB;IAEvB,4BAA4B,CAAC,OAAO,CAAC,CAAC;IACtC,IAAI,OAAO,IAAI,cAAc,EAAE;QAC7B,MAAM,YAAY,GAAG,uBAAuB,CAAC,UAAU,CAAC,CAAC;QACzD,MAAMA,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;QACtCH,KAAS,CAAC,IAAI,OAAO,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;QACjD,MAAMA,OAAK,CAAC;KACb;AACH,CAAC;AAED;;;;;;AAMA,SAAgB,qBAAqB,CAAC,UAAkB,EAAE,UAAkB;IAC1E,QACE,wCAAwC,UAAU,SAAS,UAAU,KAAK;QAC1E,8CAA8C,UAAU,YAAY,EACpE;AACJ,CAAC;AAED;;;;;;;AAOA,SAAgB,uBAAuB,CACrC,UAAsB,EACtB,UAAkB,EAClB,SAAkB;IAElB,IAAI,CAAC,SAAS,EAAE;QACd,QACE,0CAA0C,UAAU,SAAS,UAAU,KAAK;YAC5E,8CAA8C,UAAU,YAAY,EACpE;KACH;IACD,QACE,oDAAoD,SAAS,YAAY,UAAU,OAAO;QAC1F,IAAI,UAAU,iDAAiD,UAAU,YAAY,EACrF;AACJ,CAAC;AAED;;;;;AAKA,SAAgB,uBAAuB,CAAC,UAAkB;IACxD,QACE,mBAAmB,UAAU,+CAA+C;QAC5E,mEAAmE,EACnE;AACJ,CAAC;AAED;;;;;;;AAOA,SAAgB,uBAAuB,CACrC,UAAkB,EAClB,UAAsB,EACtB,cAAuB;IAEvB,IAAI,cAAc,EAAE;QAClB,QACE,mBAAmB,UAAU,qEAAqE;YAClG,mEAAmE,EACnE;KACH;IACD,QACE,mBAAmB,UAAU,+CAA+C;QAC5E,uEAAuE,UAAU,GAAG,EACpF;AACJ,CAAC;AAED;;;;;;;;AAQA,SAAgB,yBAAyB,CACvC,UAAkB,EAClB,UAAsB,EACtB,cAAuB,EACvB,SAAkB;IAElB,IAAI,cAAc,EAAE;QAClB,QACE,mBAAmB,UAAU,uEAAuE;YACpG,mEAAmE,EACnE;KACH;IACD,IAAI,SAAS,IAAI,SAAS,EAAE;QAC1B,QACE,qBAAqB,UAAU,+CAA+C;YAC9E,2EAA2E,UAAU,GAAG,EACxF;KACH;IACD,QACE,6BAA6B,SAAS,SAAS,UAAU,+BAA+B;QACxF,mFAAmF,EACnF;AACJ,CAAC;AAED;;;;;AAKA,SAAgB,2BAA2B,CAAC,UAAkB,EAAE,SAAkB;IAChF,IAAI,SAAS,IAAI,SAAS,EAAE;QAC1B,OAAO,qBAAqB,UAAU,kCAAkC,CAAC;KAC1E;IACD,OAAO,6BAA6B,SAAS,UAAU,UAAU,kCAAkC,CAAC;AACtG,CAAC;AAED;;;;;;;AAOA,SAAgB,gCAAgC,CAC9C,YAAoB,EACpB,aAAqB,EACrB,cAAmB;IAEnB,IAAI,cAAc,KAAK,SAAS,IAAI,cAAc,KAAK,IAAI,EAAE;QAC3D,MAAMA,OAAK,GAAG,IAAI,SAAS,CAAC,sBAAsB,aAAa,GAAG,CAAC,CAAC;QACpEH,KAAS,CAAC,IAAI,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;QACzC,MAAMA,OAAK,CAAC;KACb;AACH,CAAC;AAED;;;;;;;;AAQA,SAAgB,qCAAqC,CACnD,YAAoB,EACpB,aAAqB,EACrB,cAAmB,EACnB,YAAoB;IAEpB,IAAI,OAAO,cAAc,KAAK,YAAY,EAAE;QAC1C,MAAMA,OAAK,GAAG,IAAI,SAAS,CACzB,kBAAkB,aAAa,wBAAwB,YAAY,GAAG,CACvE,CAAC;QACFH,KAAS,CAAC,IAAI,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;QACzC,MAAMA,OAAK,CAAC;KACb;AACH,CAAC;AAED;;;;;;;AAOA,SAAgB,gCAAgC,CAC9C,YAAoB,EACpB,aAAqB,EACrB,cAAmB;IAEnB,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE;QAC/B,OAAO;KACR;IACD,MAAMA,OAAK,GAAG,IAAI,SAAS,CAAC,kBAAkB,aAAa,4BAA4B,CAAC,CAAC;IACzFH,KAAS,CAAC,IAAI,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;IACzC,MAAMA,OAAK,CAAC;AACd,CAAC;AAED;;;;;;;AAOA,SAAgB,qCAAqC,CACnD,YAAoB,EACpB,aAAqB,EACrB,cAAqB;IAErB,IAAI,cAAc,CAAC,KAAK,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE;QACrD,OAAO;KACR;IACD,MAAMA,OAAK,GAAG,IAAI,SAAS,CAAC,kBAAkB,aAAa,qCAAqC,CAAC,CAAC;IAClGH,KAAS,CAAC,IAAI,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;IACzC,MAAMA,OAAK,CAAC;AACd,CAAC;AAED;;;;;;;AAOA,SAAgB,sCAAsC,CACpD,YAAoB,EACpB,aAAqB,EACrB,cAAsB;IAEtB,IAAI,cAAc,KAAK,EAAE,EAAE;QACzB,OAAO;KACR;IACD,MAAMA,OAAK,GAAG,IAAI,SAAS,CAAC,0CAA0C,aAAa,GAAG,CAAC,CAAC;IACxFH,KAAS,CAAC,IAAI,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;IACzC,MAAMA,OAAK,CAAC;AACd,CAAC;AAED;;;;;;AAMA,SAAgB,iDAAiD,CAAC,UAAkB;IAClF,OAAO,aAAa,UAAU,iEAAiE,CAAC;AAClG,CAAC;;AC9QD;AACA,AAsBA,WAAY,WAAW;;;;;;;IAOrB,qDAAY,CAAA;;;;;IAMZ,qEAAoB,CAAA;AACtB,CAAC,EAdWK,mBAAW,KAAXA,mBAAW,QActB;AAED;;;AAGA,AAAA,IAAY,eAKX;AALD,WAAY,eAAe;IACzB,wCAAqB,CAAA;IACrB,4CAAyB,CAAA;IACzB,sCAAmB,CAAA;IACnB,kCAAe,CAAA;AACjB,CAAC,EALW,eAAe,KAAf,eAAe,QAK1B;AAED;;;AAGA,AAAA,IAAY,iBAMX;AAND,WAAY,iBAAiB;IAC3B,4CAAuB,CAAA;IACvB,wCAAmB,CAAA;IACnB,4CAAuB,CAAA;IACvB,4CAAuB,CAAA;IACvB,wCAAmB,CAAA;AACrB,CAAC,EANW,iBAAiB,KAAjB,iBAAiB,QAM5B;AA0LD;;;;AAIA,SAAgB,mCAAmC,CAAC,GAAwB;IAC1E,IAAI,GAAG,CAAC,WAAW,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,WAAW,KAAK,QAAQ,EAAE;QAClE,OAAO,IAAI,SAAS,CAAC,oEAAoE,CAAC,CAAC;KAC5F;IAED,IAAI,GAAG,CAAC,KAAK,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,KAAK,KAAK,QAAQ,EAAE;QACtD,OAAO,IAAI,SAAS,CAAC,8DAA8D,CAAC,CAAC;KACtF;IAED,IAAI,GAAG,CAAC,EAAE,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,QAAQ,EAAE;QAChD,OAAO,IAAI,SAAS,CAAC,2DAA2D,CAAC,CAAC;KACnF;IAED,IAAI,GAAG,CAAC,OAAO,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,OAAO,KAAK,QAAQ,EAAE;QAC1D,OAAO,IAAI,SAAS,CAAC,gEAAgE,CAAC,CAAC;KACxF;IAED,IAAI,GAAG,CAAC,gBAAgB,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,gBAAgB,KAAK,QAAQ,EAAE;QAC5E,OAAO,IAAI,SAAS,CAAC,yEAAyE,CAAC,CAAC;KACjG;IAED,IAAI,GAAG,CAAC,UAAU,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,UAAU,KAAK,QAAQ,EAAE;QAChE,OAAO,IAAI,SAAS,CAAC,mEAAmE,CAAC,CAAC;KAC3F;IAED,IAAI,GAAG,CAAC,SAAS,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC,SAAS,KAAK,QAAQ,EAAE;QAC9D,OAAO,IAAI,SAAS,CAAC,kEAAkE,CAAC,CAAC;KAC1F;IAED,IACE,GAAG,CAAC,SAAS,IAAI,IAAI;QACrB,OAAO,GAAG,CAAC,SAAS,KAAK,QAAQ;QACjC,OAAO,GAAG,CAAC,SAAS,KAAK,QAAQ;QACjC,CAACF,aAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,EAC/B;QACA,OAAO,IAAI,SAAS,CAClB,kFAAkF,CACnF,CAAC;KACH;IAED,IACE,GAAG,CAAC,aAAa,IAAI,IAAI;QACzB,OAAO,GAAG,CAAC,aAAa,KAAK,QAAQ;QACrC,OAAO,GAAG,CAAC,aAAa,KAAK,QAAQ;QACrC,CAACA,aAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,aAAa,CAAC,EACnC;QACA,OAAO,IAAI,SAAS,CAClB,sFAAsF,CACvF,CAAC;KACH;IACD,OAAO;AACT,CAAC;AAED;;;;AAIA,SAAgB,aAAa,CAAC,GAAwB;IACpD,MAAM,OAAO,GAAgB;QAC3B,IAAI,EAAE,GAAG,CAAC,IAAI;QACd,mBAAmB,EAAE,EAAE;KACxB,CAAC;IACF,IAAI,GAAG,CAAC,cAAc,IAAI,IAAI,EAAE;QAC9B,OAAO,CAAC,sBAAsB,GAAG,GAAG,CAAC,cAAc,CAAC;KACrD;IACD,IAAI,GAAG,CAAC,WAAW,IAAI,IAAI,EAAE;QAC3B,OAAO,CAAC,YAAY,GAAG,GAAG,CAAC,WAAW,CAAC;KACxC;IACD,IAAI,GAAG,CAAC,SAAS,IAAI,IAAI,EAAE;QACzB,IAAI,GAAG,CAAC,SAAS,CAAC,MAAM,GAAGJ,oBAAS,CAAC,kBAAkB,EAAE;YACvD,MAAM,IAAI,KAAK,CACb,sFAAsF,CACvF,CAAC;SACH;QACD,OAAO,CAAC,QAAQ,GAAG,GAAG,CAAC,SAAS,CAAC;KAClC;IACD,IAAI,GAAG,CAAC,OAAO,IAAI,IAAI,EAAE;QACvB,OAAO,CAAC,QAAQ,GAAG,GAAG,CAAC,OAAO,CAAC;KAChC;IACD,IAAI,GAAG,CAAC,EAAE,IAAI,IAAI,EAAE;QAClB,OAAO,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,CAAC;KACrB;IACD,IAAI,GAAG,CAAC,KAAK,IAAI,IAAI,EAAE;QACrB,OAAO,CAAC,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC;KAC7B;IACD,IAAI,GAAG,CAAC,SAAS,IAAI,IAAI,EAAE;QACzB,IAAI,OAAO,GAAG,CAAC,SAAS,KAAK,QAAQ,IAAI,GAAG,CAAC,SAAS,CAAC,MAAM,GAAGA,oBAAS,CAAC,kBAAkB,EAAE;YAC5F,MAAM,IAAI,KAAK,CACb,sFAAsF,CACvF,CAAC;SACH;QACD,OAAO,CAAC,UAAU,GAAG,GAAG,CAAC,SAAS,CAAC;KACpC;IACD,IAAI,GAAG,CAAC,aAAa,IAAI,IAAI,EAAE;QAC7B,OAAO,CAAC,cAAc,GAAG,GAAG,CAAC,aAAa,CAAC;KAC5C;IACD,IAAI,GAAG,CAAC,gBAAgB,IAAI,IAAI,EAAE;QAChC,OAAO,CAAC,iBAAiB,GAAG,GAAG,CAAC,gBAAgB,CAAC;KAClD;IACD,IAAI,GAAG,CAAC,UAAU,IAAI,IAAI,IAAI,GAAG,CAAC,UAAU,KAAKA,oBAAS,CAAC,gBAAgB,EAAE;QAC3E,OAAO,CAAC,GAAG,GAAG,GAAG,CAAC,UAAU,CAAC;QAC7B,OAAO,CAAC,aAAa,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACnC,IAAIA,oBAAS,CAAC,qBAAqB,GAAG,OAAO,CAAC,aAAa,GAAG,OAAO,CAAC,GAAG,EAAE;YACzE,OAAO,CAAC,oBAAoB,GAAG,OAAO,CAAC,aAAa,GAAG,OAAO,CAAC,GAAG,CAAC;SACpE;aAAM;YACL,OAAO,CAAC,oBAAoB,GAAGA,oBAAS,CAAC,qBAAqB,CAAC;SAChE;KACF;IACD,IAAI,GAAG,CAAC,YAAY,IAAI,IAAI,EAAE;QAC5B,IAAI,GAAG,CAAC,YAAY,CAAC,MAAM,GAAGA,oBAAS,CAAC,qBAAqB,EAAE;YAC7D,MAAM,IAAI,KAAK,CACb,yFAAyF,CAC1F,CAAC;SACH;QACD,OAAO,CAAC,mBAAoB,CAACA,oBAAS,CAAC,YAAY,CAAC,GAAG,GAAG,CAAC,YAAY,CAAC;KACzE;IACD,IAAI,GAAG,CAAC,eAAe,IAAI,IAAI,EAAE;QAC/B,IAAI,GAAG,CAAC,eAAe,CAAC,MAAM,GAAGA,oBAAS,CAAC,qBAAqB,EAAE;YAChE,MAAM,IAAI,KAAK,CACb,4FAA4F,CAC7F,CAAC;SACH;QACD,OAAO,CAAC,mBAAoB,CAACA,oBAAS,CAAC,eAAe,CAAC,GAAG,GAAG,CAAC,eAAe,CAAC;KAC/E;IACD,IAAI,GAAG,CAAC,uBAAuB,IAAI,IAAI,EAAE;QACvC,OAAO,CAAC,mBAAoB,CAACA,oBAAS,CAAC,oBAAoB,CAAC,GAAG,GAAG,CAAC,uBAAuB,CAAC;KAC5F;IACDO,OAAW,CAAC,8BAA8B,EAAE,OAAO,CAAC,CAAC;IACrD,OAAO,OAAO,CAAC;AACjB,CAAC;AA8ED;;;;AAIA,SAAgB,eAAe,CAC7B,GAAgB,EAChB,QAAmB,EACnB,sBAAgC;IAEhC,IAAI,CAAC,GAAG,EAAE;QACR,GAAG,GAAG;YACJ,IAAI,EAAE,SAAS;SAChB,CAAC;KACH;IACD,MAAM,KAAK,GAAwB;QACjC,IAAI,EAAE,GAAG,CAAC,IAAI;KACf,CAAC;IAEF,IAAI,GAAG,CAAC,sBAAsB,IAAI,IAAI,EAAE;QACtC,KAAK,CAAC,cAAc,GAAG,GAAG,CAAC,sBAAsB,CAAC;KACnD;IACD,IAAI,GAAG,CAAC,YAAY,IAAI,IAAI,EAAE;QAC5B,KAAK,CAAC,WAAW,GAAG,GAAG,CAAC,YAAY,CAAC;KACtC;IACD,IAAI,GAAG,CAAC,QAAQ,IAAI,IAAI,EAAE;QACxB,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,QAAQ,CAAC;KAChC;IACD,IAAI,GAAG,CAAC,QAAQ,IAAI,IAAI,EAAE;QACxB,KAAK,CAAC,OAAO,GAAG,GAAG,CAAC,QAAQ,CAAC;KAC9B;IACD,IAAI,GAAG,CAAC,EAAE,IAAI,IAAI,EAAE;QAClB,KAAK,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,CAAC;KACnB;IACD,IAAI,GAAG,CAAC,GAAG,IAAI,IAAI,EAAE;QACnB,KAAK,CAAC,UAAU,GAAG,GAAG,CAAC,GAAG,CAAC;KAC5B;IACD,IAAI,GAAG,CAAC,OAAO,IAAI,IAAI,EAAE;QACvB,KAAK,CAAC,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC;KAC3B;IACD,IAAI,GAAG,CAAC,UAAU,IAAI,IAAI,EAAE;QAC1B,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,UAAU,CAAC;KAClC;IACD,IAAI,GAAG,CAAC,cAAc,IAAI,IAAI,EAAE;QAC9B,KAAK,CAAC,aAAa,GAAG,GAAG,CAAC,cAAc,CAAC;KAC1C;IACD,IAAI,GAAG,CAAC,iBAAiB,IAAI,IAAI,EAAE;QACjC,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,iBAAiB,CAAC;KAChD;IAED,IAAI,GAAG,CAAC,mBAAmB,IAAI,IAAI,EAAE;QACnC,IAAI,GAAG,CAAC,mBAAmB,CAACP,oBAAS,CAAC,YAAY,CAAC,IAAI,IAAI,EAAE;YAC3D,KAAK,CAAC,YAAY,GAAG,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,YAAY,CAAC,CAAC;SACtE;QACD,IAAI,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,eAAe,CAAC,IAAI,IAAI,EAAE;YAC9D,KAAK,CAAC,eAAe,GAAG,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,eAAe,CAAC,CAAC;SAC5E;QACD,IAAI,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,oBAAoB,CAAC,IAAI,IAAI,EAAE;YACnE,KAAK,CAAC,uBAAuB,GAAG,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,oBAAoB,CAAC,CAAC;SACzF;KACF;IAED,MAAM,KAAK,GAAQ,EAAE,CAAC;IACtB,IAAI,GAAG,CAAC,mBAAmB,IAAI,IAAI,EAAE;QACnC,IAAI,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,gBAAgB,CAAC,IAAI,IAAI,EAAE;YAC/D,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,gBAAgB,CAAC,CAAC;SAC9E;QACD,IAAI,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,qBAAqB,CAAC,IAAI,IAAI,EAAE;YACpE,KAAK,CAAC,sBAAsB,GAAG,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,qBAAqB,CAAC,CAAC;SACzF;QACD,IAAI,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,cAAc,CAAC,IAAI,IAAI,EAAE;YAC7D,IAAII,aAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,mBAAmB,CAACJ,oBAAS,CAAC,cAAc,CAAC,CAAC,EAAE;gBACtE,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,cAAc,CAAC,CAAC,CAAC;aAC5F;iBAAM;gBACL,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,cAAc,CAAC,CAAC,CAAC;aAC3F;SACF;QACD,IAAI,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,YAAY,CAAC,IAAI,IAAI,EAAE;YAC3D,KAAK,CAAC,eAAe,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,YAAY,CAAW,CAAC,CAAC;SAC7F;QACD,IAAI,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,WAAW,CAAC,IAAI,IAAI,EAAE;YAC1D,KAAK,CAAC,cAAc,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,mBAAmB,CAACA,oBAAS,CAAC,WAAW,CAAW,CAAC,CAAC;SAC3F;KACF;IACD,IAAI,GAAG,CAAC,GAAG,IAAI,IAAI,IAAI,GAAG,CAAC,GAAG,IAAIA,oBAAS,CAAC,gBAAgB,GAAG,KAAK,CAAC,eAAe,CAAC,OAAO,EAAE,EAAE;QAC9F,KAAK,CAAC,YAAY,GAAG,IAAI,IAAI,CAACA,oBAAS,CAAC,gBAAgB,CAAC,CAAC;KAC3D;SAAM;QACL,KAAK,CAAC,YAAY,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,OAAO,EAAE,GAAG,GAAG,CAAC,GAAI,CAAC,CAAC;KAC3E;IAED,MAAM,SAAS,iCACb,YAAY,EAAE,GAAG,EACjB,SAAS,EAAE,QAAQ,EACnB,aAAa,EAAE,GAAG,CAAC,cAAc,EACjC,SAAS,EACP,QAAQ,IAAI,QAAQ,CAAC,GAAG,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC;cACjDQ,0BAAc,CACZ,sBAAsB,KAAK,IAAI;kBAC3B,gBAAgB,CACd,OAAO,QAAQ,CAAC,GAAG,KAAK,QAAQ,GAAGJ,aAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,GAAG,CAC5E;kBACD,OAAO,QAAQ,CAAC,GAAG,KAAK,QAAQ;sBAChCA,aAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC;sBACzB,QAAQ,CAAC,GAAG,CACjB;cACD,SAAS,IACZ,KAAK,GACL,KAAK,CACT,CAAC;IAEFG,OAAW,CAAC,sCAAsC,EAAE,SAAS,CAAC,CAAC;IAC/D,OAAO,SAAS,CAAC;AACnB,CAAC;AA0CD;;;;AAIA,MAAa,iBAAiB;;;;IA6L5B,YACE,OAA4B,EAC5B,GAAgB,EAChB,QAAkB,EAClB,sBAA+B;QAE/B,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,eAAe,CAAC,GAAG,EAAE,QAAQ,EAAE,sBAAsB,CAAC,CAAC,CAAC;QAC5E,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,GAAG,CAAC,IAAI,EAAE;YACZ,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,eAAe,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SACtE;QACD,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC;QACxB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;KAC1B;;;;;IAzBD,IAAW,SAAS;QAClB,OAAO,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC;KACrC;;;;;;;;;;;;;;;;;;;;;;IA8CK,QAAQ;;YACZA,OAAW,CACT,2CAA2C,EAC3C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,SAAS,CACf,CAAC;YACF,IAAI,IAAI,CAAC,QAAQ,CAAC,6BAA6B,CAAC,GAAG,CAAC,IAAI,CAAC,SAAU,CAAC,EAAE;gBACpE,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,uBAAuB,CAC3D,IAAI,CAAC,SAAU,EACf,iBAAiB,CAAC,SAAS,EAC3B;oBACE,SAAS,EAAE,IAAI,CAAC,SAAS;iBAC1B,CACF,CAAC;;gBAGF,IAAI,CAAC,QAAQ,CAAC,6BAA6B,CAAC,MAAM,CAAC,IAAI,CAAC,SAAU,CAAC,CAAC;gBACpE,OAAO;aACR;YACD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YACpF,IAAI,CAAC,6BAA6B,CAAC,QAAQ,EAAE,eAAe,CAAC,QAAQ,CAAC,CAAC;YAEvE,OAAO,QAAS,CAAC,aAAa,CAAC,IAAI,EAAE,eAAe,CAAC,QAAQ,CAAC,CAAC;SAChE;KAAA;;;;;;;;;;;;;;;;;;;;;;;;;IAyBK,OAAO,CAAC,kBAA2C;;;YAEvDA,OAAW,CACT,2CAA2C,EAC3C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,SAAS,CACf,CAAC;YACF,IAAI,IAAI,CAAC,QAAQ,CAAC,6BAA6B,CAAC,GAAG,CAAC,IAAI,CAAC,SAAU,CAAC,EAAE;gBACpE,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,uBAAuB,CAC3D,IAAI,CAAC,SAAU,EACf,iBAAiB,CAAC,SAAS,EAC3B,EAAE,kBAAkB,EAAE,kBAAkB,EAAE,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,CACtE,CAAC;;gBAGF,IAAI,CAAC,QAAQ,CAAC,6BAA6B,CAAC,MAAM,CAAC,IAAI,CAAC,SAAU,CAAC,CAAC;gBACpE,OAAO;aACR;YACD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YACpF,IAAI,CAAC,6BAA6B,CAAC,QAAQ,EAAE,eAAe,CAAC,OAAO,CAAC,CAAC;YAEtE,OAAO,QAAS,CAAC,aAAa,CAAC,IAAI,EAAE,eAAe,CAAC,OAAO,EAAE;gBAC5D,kBAAkB,EAAE,kBAAkB;aACvC,CAAC,CAAC;SACJ;KAAA;;;;;;;;;;;;;;;;;;;;;;;;;IA0BK,KAAK,CAAC,kBAA2C;;YACrDA,OAAW,CACT,0CAA0C,EAC1C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,SAAS,CACf,CAAC;YACF,IAAI,IAAI,CAAC,QAAQ,CAAC,6BAA6B,CAAC,GAAG,CAAC,IAAI,CAAC,SAAU,CAAC,EAAE;gBACpE,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,uBAAuB,CAC3D,IAAI,CAAC,SAAU,EACf,iBAAiB,CAAC,OAAO,EACzB,EAAE,kBAAkB,EAAE,kBAAkB,EAAE,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,CACtE,CAAC;;gBAGF,IAAI,CAAC,QAAQ,CAAC,6BAA6B,CAAC,MAAM,CAAC,IAAI,CAAC,SAAU,CAAC,CAAC;gBACpE,OAAO;aACR;YACD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YACpF,IAAI,CAAC,6BAA6B,CAAC,QAAQ,EAAE,eAAe,CAAC,KAAK,CAAC,CAAC;YAEpE,OAAO,QAAS,CAAC,aAAa,CAAC,IAAI,EAAE,eAAe,CAAC,KAAK,EAAE;gBAC1D,kBAAkB,EAAE,kBAAkB;aACvC,CAAC,CAAC;SACJ;KAAA;;;;;;;;;;;;;;;;;;;;;;;;;;IA2BK,UAAU,CAAC,OAA2B;;YAC1C,MAAM,KAAK,GAAc;gBACvB,SAAS,EAAEP,oBAAS,CAAC,cAAc;aACpC,CAAC;YACF,IAAI,OAAO,EAAE;gBACX,KAAK,CAAC,IAAI,GAAG;oBACX,gBAAgB,EAAE,OAAO,CAAC,gBAAgB;oBAC1C,0BAA0B,EAAE,OAAO,CAAC,0BAA0B;iBAC/D,CAAC;aACH;YACDO,OAAW,CACT,8CAA8C,EAC9C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,SAAS,CACf,CAAC;YACF,IAAI,IAAI,CAAC,QAAQ,CAAC,6BAA6B,CAAC,GAAG,CAAC,IAAI,CAAC,SAAU,CAAC,EAAE;gBACpE,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,uBAAuB,CAC3D,IAAI,CAAC,SAAU,EACf,iBAAiB,CAAC,SAAS,EAC3B;oBACE,gBAAgB,EAAE,KAAK,CAAC,SAAS;oBACjC,qBAAqB,EAAE,KAAK,CAAC,WAAW;oBACxC,SAAS,EAAE,IAAI,CAAC,SAAS;iBAC1B,CACF,CAAC;;gBAGF,IAAI,CAAC,QAAQ,CAAC,6BAA6B,CAAC,MAAM,CAAC,IAAI,CAAC,SAAU,CAAC,CAAC;gBACpE,OAAO;aACR;YACD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YACpF,IAAI,CAAC,6BAA6B,CAAC,QAAQ,EAAE,eAAe,CAAC,UAAU,CAAC,CAAC;YAEzE,OAAO,QAAS,CAAC,aAAa,CAAC,IAAI,EAAE,eAAe,CAAC,UAAU,EAAE;gBAC/D,KAAK,EAAE,KAAK;aACb,CAAC,CAAC;SACJ;KAAA;;;;;IAMD,KAAK;;QAEH,MAAM,KAAK,GAAwB;YACjC,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,WAAW,EAAE,IAAI,CAAC,WAAW;YAC7B,aAAa,EAAE,IAAI,CAAC,aAAa;YACjC,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,SAAS,EAAE,IAAI,CAAC,SAAS;YACzB,YAAY,EAAE,IAAI,CAAC,YAAY;YAC/B,OAAO,EAAE,IAAI,CAAC,OAAO;YACrB,gBAAgB,EAAE,IAAI,CAAC,gBAAgB;YACvC,uBAAuB,EAAE,IAAI,CAAC,uBAAuB;YACrD,SAAS,EAAE,IAAI,CAAC,SAAS;YACzB,UAAU,EAAE,IAAI,CAAC,UAAU;YAC3B,EAAE,EAAE,IAAI,CAAC,EAAE;YACX,cAAc,EAAE,IAAI,CAAC,cAAc;YACnC,eAAe,EAAE,IAAI,CAAC,eAAe;SACtC,CAAC;QAEF,OAAO,KAAK,CAAC;KACd;;;;;;;IAQO,6BAA6B,CACnC,QAAsD,EACtD,SAA0B;QAE1B,IAAIN,OAAwB,CAAC;QAE7B,IAAI,QAAQ,IAAI,QAAQ,CAAC,WAAW,KAAKK,mBAAW,CAAC,QAAQ,EAAE;YAC7DL,OAAK,GAAG,IAAI,KAAK,CACf,iDAAiD,CAAC,GAAG,SAAS,cAAc,CAAC,CAC9E,CAAC;SACH;aAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE;YACvCA,OAAK,GAAG,IAAI,KAAK,CAAC,aAAa,SAAS,kDAAkD,CAAC,CAAC;SAC7F;aAAM,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE;YAC1C,MAAM,YAAY,GAChB,aAAa,SAAS,2DAA2D;gBACjF,8BAA8B,CAAC;YACjC,IAAI,IAAI,CAAC,SAAS,IAAI,SAAS,EAAE;gBAC/BA,OAAK,GAAGQ,oBAAS,CAAC;oBAChB,WAAW,EAAE,YAAY;oBACzB,SAAS,EAAEC,mCAAwB,CAAC,oBAAoB;iBACzD,CAAC,CAAC;aACJ;iBAAM;gBACLT,OAAK,GAAGQ,oBAAS,CAAC;oBAChB,WAAW,EAAE,YAAY;oBACzB,SAAS,EAAEC,mCAAwB,CAAC,oBAAoB;iBACzD,CAAC,CAAC;aACJ;SACF;QACD,IAAI,CAACT,OAAK,EAAE;YACV,OAAO;SACR;QACDH,KAAS,CACP,8DAA8D;YAC5D,6EAA6E,EAC/E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EACvB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,IAAI,GAAG,QAAQ,EAC9CG,OAAK,CACN,CAAC;QAEF,MAAMA,OAAK,CAAC;KACb;CACF;;AC1kCD;AACA,AAuBA;;;;;AAKA,MAAa,UAAU;;;;;;;IA4DrB,YAAY,IAAY,EAAE,OAA4B,EAAE,OAA2B;;;;;QAnBnF,iBAAY,GAAY,KAAK,CAAC;QAoB5B,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,IAAI,EAAE,CAAC;QACrC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,EAAE,CAAC;QACvC,IAAI,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;KACjC;;;;;;;IAQe,eAAe,CAAC,eAAyB;;;;;;YAKvDU,IAAQ,CACN,oFAAoF;gBAClF,0BAA0B,EAC5B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,OAAO,EAC1C,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;YACF,MAAMC,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,OAAO,EAAE;gBACpE,OAAO,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;aAClD,CAAC,CAAC;YACH,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACxFD,IAAQ,CACN,oDAAoD,EACpD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,QAAQ,CACd,CAAC;;YAEFA,IAAQ,CACN,4EAA4E,EAC5E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,kBAAkB,EAC1C,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;YACF,MAAMC,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,kBAAkB,EAAE;gBACpE,OAAO,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;aACtF,CAAC,CAAC;YACHD,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;YACF,IAAI,eAAe,EAAE;gBACnB,MAAM,IAAI,CAAC,mBAAmB,EAAE,CAAC;aAClC;SACF;KAAA;;;;;;IAOe,mBAAmB;;YACjC,MAAM,uBAAuB,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,aAAa,CAAC,uBAAuB,CAAC;YAC9F,MAAM,2BAA2B,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,aAAa;iBACtE,2BAA2B,CAAC;YAC/B,MAAM,kBAAkB,GAAG,CAAC,uBAAuB,GAAG,2BAA2B,IAAI,IAAI,CAAC;YAC1F,IAAI,CAAC,kBAAkB,GAAG,UAAU,CAAC;gBACnC,IAAI;oBACF,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;iBAClC;gBAAC,OAAO,GAAG,EAAE;;oBAEZb,KAAS,CACP,8EAA8E,EAC9E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,GAAG,CACJ,CAAC;iBACH;aACF,CAAA,EAAE,kBAAkB,CAAC,CAAC;YACvBa,IAAQ,CACN,2EAA2E,EAC3E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,kBAAkB,GAAG,IAAI,EACzB,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,kBAAkB,CAAC,CAAC,QAAQ,EAAE,CACrD,CAAC;SACH;KAAA;;;;;;;;IASe,UAAU,CAACE,MAAwB;;YACjD,YAAY,CAAC,IAAI,CAAC,kBAAkC,CAAC,CAAC;YACtD,IAAIA,MAAI,EAAE;gBACR,IAAI;;;oBAGF,MAAMA,MAAI,CAAC,KAAK,EAAE,CAAC;oBACnBF,IAAQ,CACN,wCAAwC,EACxC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;iBACH;gBAAC,OAAO,GAAG,EAAE;oBACZb,KAAS,CACP,sDAAsD,EACtD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,GAAG,CACJ,CAAC;iBACH;aACF;SACF;KAAA;;;;;IAMD,IAAY,KAAK;QACf,IAAI,MAAM,GAAG,YAAY,CAAC;QAC1B,IAAK,IAAY,CAAC,WAAW,IAAK,IAAY,CAAC,WAAW,CAAC,IAAI,EAAE;YAC/D,MAAM,GAAI,IAAY,CAAC,WAAW,CAAC,IAAI,CAAC;SACzC;QACD,OAAO,MAAM,CAAC;KACf;CACF;;ACxOD;AACA,AA4CA;;;;;AAKA,MAAa,aAAc,SAAQ,UAAU;;;;;;IA0C3C,YAAY,OAA4B;QACtC,KAAK,CAAC,OAAO,CAAC,UAAU,EAAE,OAAO,EAAE;YACjC,OAAO,EAAE,OAAO,CAAC,UAAU;YAC3B,QAAQ,EAAE,GAAG,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,GAAG,OAAO,CAAC,UAAU,EAAE;SACtE,CAAC,CAAC;;;;;;QAxCI,eAAU,GAAW,UAAUK,yBAAa,EAAE,EAAE,CAAC;QAyCxD,IAAI,CAAC,YAAY,GAAG,CAAC,OAAqB;YACxC,MAAM,WAAW,GAAG,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC;YAC3D,IAAI,WAAW,EAAE;gBACf,MAAM,GAAG,GAAGM,oBAAS,CAAC,WAAW,CAAC,CAAC;gBACnCX,KAAS,CACP,6CAA6C,EAC7C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,GAAG,CACJ,CAAC;aACH;SACF,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAC,OAAqB;YAC3C,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAC9D,IAAI,YAAY,EAAE;gBAChB,MAAM,GAAG,GAAGW,oBAAS,CAAC,YAAY,CAAC,CAAC;gBACpCX,KAAS,CACP,2DAA2D,EAC3D,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,GAAG,CACJ,CAAC;aACH;SACF,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG,CAAO,OAAqB;YAC9C,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,MAAO,CAAC;YAC/C,MAAM,WAAW,GAAG,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC;YAC3D,IAAI,WAAW,EAAE;gBACfA,KAAS,CACP,wEAAwE;oBACtE,6BAA6B,EAC/B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,WAAW,CACZ,CAAC;aACH;YACD,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,EAAE;gBACtC,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACtBA,KAAS,CACP,0EAA0E;wBACxE,oFAAoF;wBACpF,2CAA2C,EAC7C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;oBACF,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;iBACpC;qBAAM;oBACLA,KAAS,CACP,0EAA0E;wBACxE,kFAAkF;wBAClF,6DAA6D,EAC/D,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;iBACH;aACF;iBAAM;gBACLA,KAAS,CACP,0EAA0E;oBACxE,gFAAgF;oBAChF,aAAa,EACf,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;aACH;SACF,CAAA,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAO,OAAqB;YACjD,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,MAAO,CAAC;YAC/C,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAC9D,IAAI,YAAY,EAAE;gBAChBA,KAAS,CACP,yEAAyE;oBACvE,6BAA6B,EAC/B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,YAAY,CACb,CAAC;aACH;YACD,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,qBAAqB,EAAE,EAAE;gBAC7C,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACtBA,KAAS,CACP,yEAAyE;wBACvE,kFAAkF;wBAClF,4BAA4B,EAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;oBACF,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;iBACrC;qBAAM;oBACLA,KAAS,CACP,yEAAyE;wBACvE,iFAAiF;wBACjF,+EAA+E,EACjF,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;iBACH;aACF;iBAAM;gBACLA,KAAS,CACP,iFAAiF;oBAC/E,wFAAwF;oBACxF,aAAa,EACf,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;aACH;SACF,CAAA,CAAC;KACH;IAEO,gBAAgB;QACtB,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;QACzB,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;QAC5BA,KAAS,CACP,uEAAuE,EACvE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;KACH;IAEO,oBAAoB,CAAC,OAA4B;QACvD,IAAI,OAAO,CAAC,OAAO;YAAE,IAAI,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QACzE,MAAM,SAAS,GAAkB;YAC/B,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,MAAM,EAAE;gBACN,OAAO,EAAE,IAAI,CAAC,OAAO;aACtB;YACD,OAAO,EAAE,IAAI,CAAC,YAAY;YAC1B,OAAO,EAAE,IAAI,CAAC,YAAY;YAC1B,cAAc,EAAE,IAAI,CAAC,eAAe;YACpC,cAAc,EAAE,IAAI,CAAC,eAAe;SACrC,CAAC;QACFgB,MAAU,CAAC,kCAAkC,EAAE,SAAS,CAAC,CAAC;QAC1D,OAAO,SAAS,CAAC;KAClB;;;;;;;;;;;;IAaO,QAAQ,CAAC,cAAsB,EAAE,SAAmB;QAC1D,MAAM,gBAAgB,GAAG,MACvB,IAAI,OAAO,CAAO,CAAO,OAAO,EAAE,MAAM;YACtC,IAAI,SAAc,CAAC;YACnBA,MAAU,CACR,4CAA4C,EAC5C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAQ,CAAC,MAAM,EACpB,IAAI,CAAC,OAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,SAAS,EAAE,CAC3C,CAAC;YACF,IAAI,CAAC,IAAI,CAAC,OAAQ,CAAC,QAAQ,EAAE,EAAE;gBAC7BA,MAAU,CACR,sEAAsE,EACtE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,CACV,CAAC;gBAEF,MAAMf,gBAAK,CAAC,IAAI,CAAC,CAAC;gBAElBe,MAAU,CACR,uEAAuE,EACvE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAQ,CAAC,MAAM,EACpB,IAAI,CAAC,OAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,SAAS,EAAE,CAC3C,CAAC;aACH;YACD,IAAI,IAAI,CAAC,OAAQ,CAAC,QAAQ,EAAE,EAAE;gBAC5B,IAAI,UAAoC,CAAC;gBACzC,IAAI,UAAoC,CAAC;gBACzC,IAAI,UAAoC,CAAC;gBACzC,IAAI,UAAoC,CAAC;gBACzC,MAAM,eAAe,GAAG;oBACtB,YAAY,CAAC,SAAS,CAAC,CAAC;;;oBAGxB,IAAI,IAAI,CAAC,OAAO,EAAE;wBAChB,IAAI,CAAC,OAAO,CAAC,cAAc,CAACC,wBAAY,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;wBAC/D,IAAI,CAAC,OAAO,CAAC,cAAc,CAACA,wBAAY,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;wBAC/D,IAAI,CAAC,OAAO,CAAC,cAAc,CAACA,wBAAY,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;wBAC/D,IAAI,CAAC,OAAO,CAAC,cAAc,CAACA,wBAAY,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;qBAChE;iBACF,CAAC;gBAEF,UAAU,GAAG,CAAC,OAAqB;;;;oBAIjC,eAAe,EAAE,CAAC;oBAClBD,MAAU,CACR,uCAAuC,EACvC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,OAAO,EAAE,CAAC;iBACX,CAAC;gBACF,UAAU,GAAG,CAAC,OAAqB;oBACjC,eAAe,EAAE,CAAC;oBAClBhB,KAAS,CACP,uCAAuC,EACvC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,MAAM,GAAG,GAAGW,oBAAS,CAAC,OAAQ,CAAC,QAAS,CAAC,YAAa,CAAC,KAAK,CAAC,CAAC;oBAC9D,MAAM,CAAC,GAAG,CAAC,CAAC;iBACb,CAAC;gBACF,UAAU,GAAG,CAAC,OAAqB;oBACjC,eAAe,EAAE,CAAC;oBAClBX,KAAS,CACP,uCAAuC,EACvC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,IAAI,GAAU,CAAC;oBACf,IAAI,OAAQ,CAAC,QAAS,CAAC,YAAa,CAAC,KAAK,EAAE;wBAC1C,GAAG,GAAGW,oBAAS,CAAC,OAAQ,CAAC,QAAS,CAAC,YAAa,CAAC,KAAK,CAAC,CAAC;qBACzD;yBAAM;wBACL,GAAG,GAAG,IAAI,KAAK,CACb,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,YAAY,IAAI,CAAC,IAAI,KAAK;4BAChE,oEAAoE,CACvE,CAAC;qBACH;oBACD,MAAM,CAAC,GAAG,CAAC,CAAC;iBACb,CAAC;gBACF,UAAU,GAAG,CAAC,OAAqB;oBACjC,eAAe,EAAE,CAAC;oBAClBX,KAAS,CACP,uCAAuC,EACvC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,IAAI,GAAU,CAAC;oBACf,IAAI,OAAQ,CAAC,QAAS,CAAC,YAAa,CAAC,KAAK,EAAE;wBAC1C,GAAG,GAAGW,oBAAS,CAAC,OAAQ,CAAC,QAAS,CAAC,YAAa,CAAC,KAAK,CAAC,CAAC;qBACzD;yBAAM;wBACL,GAAG,GAAG,IAAI,KAAK,CACb,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,YAAY,IAAI,CAAC,IAAI,KAAK;4BAChE,qEAAqE,CACxE,CAAC;qBACH;oBACD,MAAM,CAAC,GAAG,CAAC,CAAC;iBACb,CAAC;gBAEF,MAAM,kBAAkB,GAAG;oBACzB,eAAe,EAAE,CAAC;oBAClB,MAAM,IAAI,GACR,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,aAAa,IAAI,CAAC,IAAI,IAAI;wBAClE,iBAAiB,IAAI,CAAC,OAAO,qDAAqD;wBAClF,uBAAuB,CAAC;oBAC1BX,KAAS,CAAC,IAAI,CAAC,CAAC;oBAChB,MAAM,CAAC,GAAc;wBACnB,SAAS,EAAEY,mCAAwB,CAAC,uBAAuB;wBAC3D,WAAW,EAAE,IAAI;qBAClB,CAAC;oBACF,OAAO,MAAM,CAACD,oBAAS,CAAC,CAAC,CAAC,CAAC,CAAC;iBAC7B,CAAC;gBAEF,IAAI,CAAC,OAAQ,CAAC,EAAE,CAACM,wBAAY,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;gBACpD,IAAI,CAAC,OAAQ,CAAC,EAAE,CAACA,wBAAY,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;gBACpD,IAAI,CAAC,OAAQ,CAAC,EAAE,CAACA,wBAAY,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;gBACpD,IAAI,CAAC,OAAQ,CAAC,EAAE,CAACA,wBAAY,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;gBACpD,SAAS,GAAG,UAAU,CACpB,kBAAkB,EAClBf,oBAAS,CAAC,gCAAgC,GAAG,IAAI,CAClD,CAAC;gBACF,IAAI;oBACF,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAQ,CAAC,IAAI,CACjC,cAAc,EACd,SAAS,EACT,SAAS,GAAG,UAAU,GAAG,CAAC,CAC3B,CAAC;oBACFc,MAAU,CACR,qDAAqD,EACrD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,QAAQ,CAAC,EAAE,CACZ,CAAC;iBACH;gBAAC,OAAO,KAAK,EAAE;oBACd,eAAe,EAAE,CAAC;oBAClB,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;iBACtB;aACF;iBAAM;;gBAEL,MAAM,GAAG,GACP,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,aAAa,IAAI,CAAC,IAAI,KAAK;oBACnE,sDAAsD,CAAC;gBACzDhB,KAAS,CAAC,GAAG,CAAC,CAAC;gBACf,MAAM,SAAS,GAAc;oBAC3B,SAAS,EAAEY,mCAAwB,CAAC,eAAe;oBACnD,WAAW,EAAE,GAAG;iBACjB,CAAC;gBACF,MAAM,CAACD,oBAAS,CAAC,SAAS,CAAC,CAAC,CAAC;aAC9B;SACF,CAAA,CAAC,CAAC;QAEL,MAAM,eAAe,GAAGO,mCAAwB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACvD,MAAM,MAAM,GAAsB;YAChC,SAAS,EAAE,gBAAgB;YAC3B,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAa;YACnD,aAAa,EAAEC,6BAAkB,CAAC,WAAW;YAC7C,KAAK,EAAEjB,oBAAS,CAAC,oBAAoB;YACrC,cAAc,EAAEA,oBAAS,CAAC,4CAA4C,GAAG,eAAe;SACzF,CAAC;QAEF,OAAOkB,gBAAK,CAAO,MAAM,CAAC,CAAC;KAC5B;;;;IAKa,KAAK,CAAC,OAAuB;;YACzC,IAAI;;;;;;gBAMF,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE;oBAClBpB,KAAS,CACP,0EAA0E;wBACxE,kDAAkD,EACpD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;oBACF,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;oBACzB,MAAM,IAAI,CAAC,eAAe,EAAE,CAAC;oBAC7BA,KAAS,CACP,sCAAsC,EACtC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,IAAI,CAAC,OAAO,EAAE;wBACZ,OAAO,GAAG,IAAI,CAAC,oBAAoB,CAAC,EAAE,CAAC,CAAC;qBACzC;oBACD,IAAI,CAAC,OAAO,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;oBAC9E,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;oBAC1BA,KAAS,CACP,4DAA4D,EAC5D,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;oBACF,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;oBACnCA,KAAS,CACP,0EAA0E,EAC1E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,CACV,CAAC;oBACFA,KAAS,CACP,kDAAkD,EAClD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,OAAO,CACR,CAAC;;;oBAGF,IAAI,CAAC,IAAI,CAAC,OAAO;wBAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC;oBAC/C,MAAM,IAAI,CAAC,mBAAmB,EAAE,CAAC;iBAClC;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ,GAAG,GAAGW,oBAAS,CAAC,GAAG,CAAC,CAAC;gBACrBX,KAAS,CACP,qDAAqD,EACrD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;;IAOK,UAAU,CAAC,WAA+B;;YAC9C,IAAI;gBACF,MAAM,iBAAiB,GAAG,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,CAAC;;;gBAGxE,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;;gBAEpC,IAAI,YAAY,GAAG,KAAK,CAAC;gBACzB,IAAI,WAAW,IAAI,CAAC,iBAAiB,EAAE;oBACrC,MAAM,eAAe,GAAGW,oBAAS,CAAC,WAAW,CAAC,CAAC;oBAC/C,IAAI,eAAe,CAAC,SAAS,EAAE;wBAC7B,YAAY,GAAG,IAAI,CAAC;wBACpBX,KAAS,CACP,6EAA6E;4BAC3E,wFAAwF;4BACxF,kBAAkB,EACpB,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;qBACH;yBAAM;wBACLA,KAAS,CACP,6EAA6E;4BAC3E,+EAA+E;4BAC/E,kBAAkB,EACpB,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;qBACH;iBACF;qBAAM,IAAI,CAAC,iBAAiB,EAAE;oBAC7B,YAAY,GAAG,IAAI,CAAC;oBACpBA,KAAS,CACP,6EAA6E;wBAC3E,6EAA6E;wBAC7E,kBAAkB,EACpB,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;iBACH;qBAAM;oBACL,MAAM,KAAK,GAAQ;wBACjB,iBAAiB,EAAE,iBAAiB;wBACpC,WAAW,EAAE,WAAW;wBACxB,OAAO,EAAE,IAAI,CAAC,OAAO;qBACtB,CAAC;oBACFA,KAAS,CACP,0EAA0E,EAC1E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,KAAK,CACN,CAAC;iBACH;gBACD,IAAI,YAAY,EAAE;oBAChB,MAAMc,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE;wBACzC,MAAM,OAAO,GAAkB,IAAI,CAAC,oBAAoB,CAAC;4BACvD,OAAO,EAAE,IAAI;yBACd,CAAC,CAAC;;;wBAGH,MAAM,MAAM,GAAsB;4BAChC,SAAS,EAAE,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;4BACpC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAa;4BACnD,aAAa,EAAEK,6BAAkB,CAAC,UAAU;4BAC5C,KAAK,EAAEjB,oBAAS,CAAC,8BAA8B;4BAC/C,cAAc,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI;4BACnD,cAAc,EAAE,EAAE;yBACnB,CAAC;wBACF,OAAOkB,gBAAK,CAAO,MAAM,CAAC,CAAC;qBAC5B,CAAC,CAAC;iBACJ;aACF;YAAC,OAAO,GAAG,EAAE;gBACZpB,KAAS,CACP,iFAAiF;oBAC/E,UAAU,EACZ,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,GAAG,CACJ,CAAC;aACH;SACF;KAAA;;;;;IAMK,KAAK;;YACT,IAAI,IAAI,CAAC,OAAO,EAAE;gBAChBgB,MAAU,CACR,8CAA8C,EAC9C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,QAAQ,CAAC,UAAU,CACzB,CAAC;gBACF,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC;gBAChC,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBACxB,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;aACnC;SACF;KAAA;;;;;IAMD,MAAM;QACJ,MAAM,MAAM,GAAY,IAAI,CAAC,OAAQ,IAAI,IAAI,CAAC,OAAQ,CAAC,MAAM,EAAE,CAAC;QAChEhB,KAAS,CACP,mDAAmD,EACnD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,MAAM,CACP,CAAC;QACF,OAAO,MAAM,CAAC;KACf;;;;;;;IAQK,IAAI,CAAC,IAAyB;;YAClC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,IAAI;gBACF,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE;oBAClBgB,MAAU,CACR,6DAA6D;wBAC3D,0BAA0B,EAC5B,IAAI,CAAC,UAAU,CAChB,CAAC;oBACF,MAAMF,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE;wBACzC,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;qBACrB,CAAC,CAAC;iBACJ;gBACD,MAAM,WAAW,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;gBACxC,WAAW,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAE7E,IAAI,cAAc,CAAC;gBACnB,IAAI;oBACF,cAAc,GAAGO,mBAAe,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;iBACtD;gBAAC,OAAO,KAAK,EAAE;oBACd,IAAI,KAAK,YAAY,SAAS,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;;;;;wBAK5D,MAAM,mCAAmC,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;qBAC1D;oBACD,MAAM,KAAK,CAAC;iBACb;gBACDL,MAAU,CACR,8CAA8C,EAC9C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CACL,CAAC;gBACF,OAAO,MAAM,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;aAC5C;YAAC,OAAO,GAAG,EAAE;gBACZhB,KAAS,CACP,8EAA8E,EAC9E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,EACJ,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;;;;;IAUK,SAAS,CAAC,aAAoC;;YAClD,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,IAAI;gBACF,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;oBACjC,aAAa,GAAG,CAAC,aAAa,CAAC,CAAC;iBACjC;gBAED,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE;oBAClBgB,MAAU,CACR,6DAA6D;wBAC3D,0BAA0B,EAC5B,IAAI,CAAC,UAAU,CAChB,CAAC;oBACF,MAAMF,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE;wBACzC,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;qBACrB,CAAC,CAAC;iBACJ;gBACDE,MAAU,CACR,gDAAgD,EAChD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,aAAa,CACd,CAAC;gBACF,MAAM,YAAY,GAAkB,EAAE,CAAC;gBACvC,MAAM,eAAe,GAAG,EAAE,CAAC;;gBAE3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC7C,MAAM,WAAW,GAAG,aAAa,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpD,WAAW,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,eAAe,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;oBACzF,YAAY,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC;oBAC9B,IAAI;wBACF,eAAe,CAAC,CAAC,CAAC,GAAGK,mBAAe,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;qBAC1D;oBAAC,OAAO,KAAK,EAAE;wBACd,IAAI,KAAK,YAAY,SAAS,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;4BAC5D,MAAM,mCAAmC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;yBACtE;wBACD,MAAM,KAAK,CAAC;qBACb;iBACF;;gBAGD,MAAM,YAAY,GAAgB;oBAChC,IAAI,EAAEA,mBAAe,CAAC,aAAa,CAAC,eAAe,CAAC;iBACrD,CAAC;;;gBAGF,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,mBAAmB,EAAE;oBACvC,YAAY,CAAC,mBAAmB,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC;iBACxE;gBACD,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,sBAAsB,EAAE;oBAC1C,YAAY,CAAC,sBAAsB,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,sBAAsB,CAAC;iBAC9E;gBACD,KAAK,MAAM,IAAI,IAAIC,6BAAiB,EAAE;oBACpC,IAAK,YAAY,CAAC,CAAC,CAAS,CAAC,IAAI,CAAC,EAAE;wBACjC,YAAoB,CAAC,IAAI,CAAC,GAAI,YAAY,CAAC,CAAC,CAAS,CAAC,IAAI,CAAC,CAAC;qBAC9D;iBACF;;gBAGD,MAAM,mBAAmB,GAAGD,mBAAe,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;gBACjEL,MAAU,CACR,iDAAiD,EACjD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,mBAAmB,CACpB,CAAC;gBACF,OAAO,MAAM,IAAI,CAAC,QAAQ,CAAC,mBAAmB,EAAE,IAAI,CAAC,CAAC;aACvD;YAAC,OAAO,GAAG,EAAE;gBACZhB,KAAS,CACP,+EAA+E,EAC/E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,aAAa,EACb,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;;;IAQD,OAAO,MAAM,CAAC,OAA4B;QACxC,4BAA4B,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAChD,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;YACnB,OAAO,CAAC,MAAM,GAAG,IAAI,aAAa,CAAC,OAAO,CAAC,CAAC;SAC7C;QACD,OAAO,OAAO,CAAC,MAAM,CAAC;KACvB;CACF;;AC3vBD;AACA,AAeA;;;;;;;AAOA,MAAa,MAAM;;;;;IAcjB,YAAY,OAA4B;;;;QANhC,cAAS,GAAY,KAAK,CAAC;QAOjC,4BAA4B,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAChD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;KACzB;IAEO,gCAAgC;QACtC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QACtD,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,YAAY,GAAG,uBAAuB,CAC1C,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;YACF,MAAMG,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtCH,KAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;YACjE,MAAMA,OAAK,CAAC;SACb;KACF;;;;;IAMD,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC;KACjD;;;;;;;;;;;;IAaK,IAAI,CAAC,OAA4B;;YACrC,IAAI,CAAC,gCAAgC,EAAE,CAAC;YACxC,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;YAC3F,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACnD,OAAO,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SAC7B;KAAA;;;;;;;;;;;;;;;;IAiBK,SAAS,CAAC,QAA+B;;YAC7C,IAAI,CAAC,gCAAgC,EAAE,CAAC;YACxC,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;YAC7F,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;gBAC5B,QAAQ,GAAG,CAAC,QAAQ,CAAC,CAAC;aACvB;YACD,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACnD,OAAO,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;SACnC;KAAA;;;;;;;;;;;;;;;;;;;;;;;;IAyBK,eAAe,CACnB,uBAA6B,EAC7B,OAA4B;;YAE5B,IAAI,CAAC,gCAAgC,EAAE,CAAC;YACxC,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,yBAAyB,EACzB,uBAAuB,CACxB,CAAC;YACF,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;YAE3F,MAAM,QAAQ,GAAG,CAAC,OAAO,CAAC,CAAC;YAC3B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,gBAAgB,CACnE,uBAAuB,EACvB,QAAQ,CACT,CAAC;YACF,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;SAClB;KAAA;;;;;;;;;;;;;;;;;;;;;;;;IAyBK,gBAAgB,CACpB,uBAA6B,EAC7B,QAA+B;;YAE/B,IAAI,CAAC,gCAAgC,EAAE,CAAC;YACxC,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,yBAAyB,EACzB,uBAAuB,CACxB,CAAC;YACF,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;YAC7F,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;gBAC5B,QAAQ,GAAG,CAAC,QAAQ,CAAC,CAAC;aACvB;YAED,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,gBAAgB,CAAC,uBAAuB,EAAE,QAAQ,CAAC,CAAC;SAC5F;KAAA;;;;;;;;IASK,sBAAsB,CAAC,cAAoB;;YAC/C,IAAI,CAAC,gCAAgC,EAAE,CAAC;YACxC,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,gBAAgB,EAChB,cAAc,CACf,CAAC;YACF,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,gBAAgB,EAChB,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,uBAAuB,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;SAClF;KAAA;;;;;;;;IASK,uBAAuB,CAAC,eAAuB;;YACnD,IAAI,CAAC,gCAAgC,EAAE,CAAC;YACxC,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,iBAAiB,EACjB,eAAe,CAChB,CAAC;YACF,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,EAAE;gBACnC,eAAe,GAAG,CAAC,eAAe,CAAC,CAAC;aACrC;YACD,qCAAqC,CACnC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,iBAAiB,EACjB,eAAe,CAChB,CAAC;YAEF,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,uBAAuB,CAAC,eAAe,CAAC,CAAC;SACjF;KAAA;;;;;;;;IASK,KAAK;;YACT,IAAI;gBACF,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;gBACtB,IACE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU;oBAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,EAAE;oBAC3C,IAAI,CAAC,QAAQ,CAAC,MAAM,EACpB;oBACA,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;iBACpC;aACF;YAAC,OAAO,GAAG,EAAE;gBACZH,KAAS,CACP,4DAA4D,EAC5D,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;CACF;;AC3QD;AACA,AA+DA;;;AAGA,AAAA,IAAY,YAGX;AAHD,WAAY,YAAY;IACtB,qCAAqB,CAAA;IACrB,uCAAuB,CAAA;AACzB,CAAC,EAHW,YAAY,KAAZ,YAAY,QAGvB;AAiCD;;;;;AAKA,MAAa,eAAgB,SAAQ,UAAU;IAuI7C,YAAY,OAA4B,EAAE,YAA0B,EAAE,OAAwB;QAC5F,KAAK,CAAC,OAAO,CAAC,UAAU,EAAE,OAAO,EAAE;YACjC,OAAO,EAAE,OAAO,CAAC,UAAU;YAC3B,QAAQ,EAAE,GAAG,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,GAAG,OAAO,CAAC,UAAU,EAAE;SACtE,CAAC,CAAC;;;;;;;QAhIL,uBAAkB,GAAW,CAAC,CAAC;;;;;;QAwCrB,4BAAuB,GAA6B,IAAI,GAAG,EAAuB,CAAC;;;;;;QA2DnF,4BAAuB,GAA0C,IAAI,GAAG,EAG/E,CAAC;QA2BF,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;QAC/B,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,IAAIQ,mBAAW,CAAC,QAAQ,CAAC;QAC/D,IAAI,OAAO,OAAO,CAAC,kBAAkB,KAAK,QAAQ,IAAI,OAAO,CAAC,kBAAkB,GAAG,CAAC,EAAE;YACpF,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;SACtD;QACD,IAAI,CAAC,8BAA8B,GAAG;;SAErC,CAAC;;QAEF,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY,KAAK,KAAK,GAAG,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC;QACjF,IAAI,CAAC,6BAA6B;YAChC,OAAO,CAAC,wCAAwC,IAAI,IAAI;kBACpD,OAAO,CAAC,wCAAwC;kBAChD,GAAG,CAAC;QACV,IAAI,CAAC,aAAa;YAChB,IAAI,CAAC,6BAA6B,GAAG,CAAC,IAAI,IAAI,CAAC,WAAW,KAAKA,mBAAW,CAAC,QAAQ,CAAC;QACtF,IAAI,CAAC,2BAA2B,GAAG,CAAC,SAAiB;YACnD,IAAI,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;gBAC/C,YAAY,CAAC,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,SAAS,CAAiB,CAAC,CAAC;gBAC1Ee,QAAY,CACV,qEAAqE,EACrE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,SAAS,CACV,CAAC;gBACF,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;aAChD;SACF,CAAC;QACF,IAAI,CAAC,+BAA+B,GAAG;YACrCA,QAAY,CACV,sEAAsE,EACtE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;YACF,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,EAAE;gBAC3D,IAAI,CAAC,2BAA2B,CAAC,SAAS,CAAC,CAAC;aAC7C;SACF,CAAC;;QAEF,IAAI,CAAC,UAAU,GAAG,CAAC,OAAqB;YACtC,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;YAClC,IAAI,QAAQ,EAAE;gBACZ,MAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC;gBACvB,MAAM,KAAK,GAAG,QAAQ,CAAC,YAAY,CAAC;gBACpC,MAAM,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC;gBACxCA,QAAY,CACV,0EAA0E,GAAG,WAAW,EACxF,YAAY,EACZ,EAAE,EACF,OAAO,EACP,KAAK,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,GAAG,KAAK,CAC3C,CAAC;gBACF,IAAI,OAAO,IAAI,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;oBACnD,MAAM,OAAO,GAAG,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,EAAE,CAAgB,CAAC;oBACpE,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;oBAC5BA,QAAY,CACV,sEAAsE,EACtE,YAAY,EACZ,EAAE,CACH,CAAC;oBACF,MAAM,YAAY,GAAG,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;oBAC7DA,QAAY,CACV,iEAAiE,EACjE,YAAY,EACZ,EAAE,EACF,YAAY,CACb,CAAC;oBACF,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;wBAC9E,MAAM,KAAK,GAAGZ,oBAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;wBACrC,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;qBAC9B;oBAED,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;iBAC1B;aACF;SACF,CAAC;QAEF,IAAI,CAAC,cAAc,GAAG,CAAO,OAAqB;;;YAGhD,IACE,IAAI,CAAC,WAAW,KAAKH,mBAAW,CAAC,QAAQ;iBACxC,CAAC,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,EAC7C;gBACAR,KAAS,CACP,sEAAsE;oBACpE,gCAAgC,EAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,CACV,CAAC;gBACF,OAAO;aACR;YAED,IAAI,CAAC,8BAA8B,EAAE,CAAC;YACtC,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,QAAQ,GAAsB,IAAI,iBAAiB,CACvD,IAAI,CAAC,QAAQ,EACb,OAAO,CAAC,OAAQ,EAChB,OAAO,CAAC,QAAS,EACjB,IAAI,CACL,CAAC;YAEF,IAAI,IAAI,CAAC,aAAa,IAAI,QAAQ,CAAC,SAAS,EAAE;gBAC5C,MAAM,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC;;;;;;;;;gBASrC,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAmB,EAAE,SAAS,CAAC,CAAC;gBAC1EuB,QAAY,CACV,+CAA+C,EAC/C,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,QAAQ,CAAC,cAAe,CAAC,QAAQ,EAAE,CACpC,CAAC;gBACF,MAAM,0BAA0B,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,6BAA6B,GAAG,IAAI,CAAC;gBAC1FA,QAAY,CACV,iEAAiE,EACjE,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,IAAI,IAAI,CAAC,0BAA0B,CAAC,CAAC,QAAQ,EAAE,CAChD,CAAC;gBACF,MAAM,iBAAiB,GAAG;oBACxB,IACE,IAAI,IAAI,CAAC,0BAA0B,CAAC,GAAG,QAAQ,CAAC,cAAe;wBAC/D,IAAI,CAAC,GAAG,EAAE,GAAG,0BAA0B,EACvC;wBACA,IAAI,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAmB,CAAC,EAAE;;;;;4BAKlE,MAAM,MAAM,GAAG,2BAA2B,CAAC,QAAQ,CAAC,cAAe,CAAC,CAAC;4BACrEA,QAAY,CACV,gEAAgE;gCAC9D,2BAA2B,EAC7B,YAAY,EACZ,MAAM,EACN,QAAQ,CAAC,SAAS,CACnB,CAAC;;;;4BAIF,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAC9B,QAAQ,CAAC,SAAmB,EAC5B,UAAU,CAAC;gCACT,IAAI;oCACFA,QAAY,CACV,6DAA6D,EAC7D,YAAY,EACZ,QAAQ,CAAC,SAAS,CACnB,CAAC;oCACF,QAAQ,CAAC,cAAc,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,SAAS,CACvE,SAAS,CACV,CAAC;oCACFA,QAAY,CACV,8DAA8D,EAC9D,YAAY,EACZ,QAAQ,CAAC,SAAS,CACnB,CAAC;oCACFA,QAAY,CACV,6DAA6D,GAAG,UAAU,EAC1E,YAAY,EACZ,QAAQ,CAAC,SAAS,CACnB,CAAC;oCACF,iBAAiB,EAAE,CAAC;iCACrB;gCAAC,OAAO,GAAG,EAAE;oCACZvB,KAAS,CACP,kEAAkE;wCAChE,+BAA+B,EACjC,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,QAAQ,CAAC,SAAS,EAClB,GAAG,CACJ,CAAC;;oCAEF,IAAI,CAAC,QAAS,CAAC,GAAG,CAAC,CAAC;iCACrB;6BACF,CAAA,EAAE,MAAM,CAAC,CACX,CAAC;yBACH;6BAAM;4BACLuB,QAAY,CACV,gEAAgE;gCAC9D,mCAAmC,EACrC,YAAY,EACZ,QAAQ,CAAC,SAAS,CACnB,CAAC;yBACH;qBACF;yBAAM;wBACLA,QAAY,CACV,uEAAuE;4BACrE,wEAAwE,EAC1E,YAAY,EACZ,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,QAAQ,EAAE,EAC/B,IAAI,IAAI,CAAC,0BAA0B,CAAC,CAAC,QAAQ,EAAE,EAC/C,QAAQ,CAAC,SAAS,CACnB,CAAC;wBACF,IAAI,CAAC,2BAA2B,CAAC,QAAQ,CAAC,SAAmB,CAAC,CAAC;qBAChE;iBACF,CAAC;;gBAEF,iBAAiB,EAAE,CAAC;aACrB;YACD,IAAI;gBACF,MAAM,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;gBAChC,IAAI,CAAC,2BAA2B,CAAC,QAAQ,CAAC,SAAmB,CAAC,CAAC;aAChE;YAAC,OAAO,GAAG,EAAE;;gBAEZ,IAAI,CAACC,uBAAW,CAAC,GAAG,CAAC,EAAE;oBACrBxB,KAAS,CACP,8EAA8E;wBAC5E,uCAAuC,EACzC,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,EACT,GAAG,CACJ,CAAC;oBACF,IAAI,CAAC,QAAS,CAAC,GAAG,CAAC,CAAC;iBACrB;;;gBAID,IAAI,CAAC,2BAA2B,CAAC,QAAQ,CAAC,SAAmB,CAAC,CAAC;gBAC/D,MAAMG,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;;gBAE7B,IACE,CAAC,QAAQ,CAAC,QAAQ,CAAC,cAAc;oBACjCR,OAAK,CAAC,IAAI,KAAKsB,mCAAwB,CAAC,iCAAiC,CAAC;oBAC1E,IAAI,CAAC,WAAW,KAAKjB,mBAAW,CAAC,QAAQ;oBACzC,IAAI,CAAC,MAAM,EAAE;kBACb;oBACA,IAAI;wBACFR,KAAS,CACP,sEAAsE;4BACpE,uBAAuB,EACzB,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,EACTG,OAAK,CACN,CAAC;wBACF,MAAM,QAAQ,CAAC,OAAO,EAAE,CAAC;qBAC1B;oBAAC,OAAO,YAAY,EAAE;wBACrB,MAAM,eAAe,GAAGQ,oBAAS,CAAC,YAAY,CAAC,CAAC;wBAChDX,KAAS,CACP,0EAA0E;4BACxE,oBAAoB,EACtB,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,EACT,eAAe,CAChB,CAAC;wBACF,IAAI,CAAC,QAAS,CAAC,eAAe,CAAC,CAAC;qBACjC;iBACF;gBACD,OAAO;aACR;oBAAS;gBACR,IAAI,IAAI,CAAC,SAAS,EAAE;oBAClB,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;iBAC7B;aACF;;;YAID,IACE,IAAI,CAAC,YAAY;gBACjB,IAAI,CAAC,WAAW,KAAKQ,mBAAW,CAAC,QAAQ;gBACzC,CAAC,QAAQ,CAAC,QAAQ,CAAC,cAAc,EACjC;gBACA,IAAI;oBACF,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,CACpB,mDAAmD,GAAG,oBAAoB,EAC1E,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,MAAM,QAAQ,CAAC,QAAQ,EAAE,CAAC;iBAC3B;gBAAC,OAAO,aAAa,EAAE;oBACtB,MAAM,eAAe,GAAGG,oBAAS,CAAC,aAAa,CAAC,CAAC;oBACjDX,KAAS,CACP,0EAA0E;wBACxE,oBAAoB,EACtB,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,EACT,eAAe,CAChB,CAAC;oBACF,IAAI,CAAC,QAAS,CAAC,eAAe,CAAC,CAAC;iBACjC;aACF;SACF,CAAA,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG,CAAC,OAAqB;YACxC,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,QAAS,CAAC;YACrD,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC;YACjE,IAAI,aAAa,EAAE;gBACjB,MAAM,OAAO,GAAGW,oBAAS,CAAC,aAAa,CAAC,CAAC;gBACzCX,KAAS,CACP,+CAA+C,EAC/C,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,OAAO,CACR,CAAC;gBACF,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;oBACtB,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,EAAE;wBAC1CA,KAAS,CACP,sEAAsE;4BACpE,+EAA+E,EACjF,YAAY,CACb,CAAC;wBACF,IAAI,CAAC,QAAS,CAAC,OAAO,CAAC,CAAC;qBACzB;yBAAM;wBACLA,KAAS,CACP,sEAAsE;4BACpE,mEAAmE,EACrE,YAAY,CACb,CAAC;qBACH;iBACF;qBAAM;oBACLA,KAAS,CACP,wEAAwE;wBACtE,gBAAgB,EAClB,YAAY,CACb,CAAC;iBACH;aACF;YACD,IAAI,IAAI,CAAC,wBAAwB,EAAE;gBACjC,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;aAC7C;SACF,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAC,OAAqB;YAC3C,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,QAAS,CAAC;YACrD,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAC9D,IAAI,YAAY,EAAE;gBAChB,MAAM,OAAO,GAAGW,oBAAS,CAAC,YAAY,CAAC,CAAC;gBACxCX,KAAS,CACP,8DAA8D,EAC9D,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,OAAO,CACR,CAAC;gBACF,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,qBAAqB,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;oBACvEA,KAAS,CACP,8EAA8E;wBAC5E,+EAA+E,EACjF,YAAY,CACb,CAAC;oBACF,IAAI,CAAC,QAAS,CAAC,OAAO,CAAC,CAAC;iBACzB;aACF;YACD,IAAI,IAAI,CAAC,wBAAwB,EAAE;gBACjC,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;aAC7C;SACF,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG,CAAO,OAAqB;YAC9C,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC;YACjE,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,QAAS,CAAC;YACrD,IAAI,aAAa,EAAE;gBACjBA,KAAS,CACP,4EAA4E;oBAC1E,6BAA6B,EAC/B,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,aAAa,CACd,CAAC;aACH;YACD,IAAI,CAAC,+BAA+B,EAAE,CAAC;YACvC,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,EAAE;gBAC1C,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACtBA,KAAS,CACP,8EAA8E;wBAC5E,sFAAsF;wBACtF,2CAA2C,EAC7C,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;oBACF,MAAM,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;iBACtC;qBAAM;oBACLA,KAAS,CACP,8EAA8E;wBAC5E,oFAAoF;wBACpF,6DAA6D,EAC/D,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;iBACH;aACF;iBAAM;gBACLA,KAAS,CACP,8EAA8E;oBAC5E,gFAAgF;oBAChF,aAAa,EACf,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;aACH;SACF,CAAA,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAO,OAAqB;YACjD,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,QAAS,CAAC;YACrD,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAC9D,IAAI,YAAY,EAAE;gBAChBA,KAAS,CACP,2EAA2E;oBACzE,6BAA6B,EAC/B,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,YAAY,CACb,CAAC;aACH;YACD,IAAI,CAAC,+BAA+B,EAAE,CAAC;YACvC,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,qBAAqB,EAAE,EAAE;gBACjD,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACtBA,KAAS,CACP,2EAA2E;wBACzE,kFAAkF;wBAClF,4BAA4B,EAC9B,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;oBACF,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;iBACrC;qBAAM;oBACLA,KAAS,CACP,2EAA2E;wBACzE,mFAAmF;wBACnF,+EAA+E,EACjF,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;iBACH;aACF;iBAAM;gBACLA,KAAS,CACP,mFAAmF;oBACjF,wFAAwF;oBACxF,aAAa,EACf,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;aACH;SACF,CAAA,CAAC;KACH;;;;IAKS,sBAAsB,CAC9B,UAAoB,EACpB,OAA+B;QAE/B,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,GAAG;gBACR,SAAS,EAAE,CAAC,OAAqB,KAC/B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC;;iBAElC,CAAC;gBACJ,OAAO,EAAE,CAAC,OAAqB,KAC7B,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC;;iBAEhC,CAAC;gBACJ,cAAc,EAAE,CAAC,OAAqB,KACpC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC;;iBAEnC,CAAC;gBACJ,OAAO,EAAE,IAAI,CAAC,YAAY;gBAC1B,cAAc,EAAE,IAAI,CAAC,eAAe;gBACpC,SAAS,EAAE,IAAI,CAAC,UAAU;aAC3B,CAAC;SACH;QACD,MAAM,WAAW,mBACf,IAAI,EAAE,UAAU,GAAG,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,IAAI,EACtE,UAAU,EAAE,IAAI,CAAC,WAAW,KAAKQ,mBAAW,CAAC,gBAAgB,GAAG,IAAI,GAAG,KAAK;;YAE5E,eAAe,EAAE,IAAI,CAAC,WAAW,KAAKA,mBAAW,CAAC,gBAAgB,GAAG,CAAC,GAAG,CAAC;;YAE1E,eAAe,EAAE,IAAI,CAAC,WAAW,KAAKA,mBAAW,CAAC,gBAAgB,GAAG,CAAC,GAAG,CAAC,EAC1E,MAAM,EAAE;gBACN,OAAO,EAAE,IAAI,CAAC,OAAO;aACtB,EACD,aAAa,EAAE,CAAC,IACb,OAAO,CACX,CAAC;QAEF,OAAO,WAAW,CAAC;KACpB;;;;;;;IAQe,KAAK,CAAC,OAAyB;;YAC7C,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,IAAI;gBACF,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACxCR,KAAS,CACP,4EAA4E;wBAC1E,kDAAkD,EACpD,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;oBAEF,IAAI,OAAO,IAAI,OAAO,CAAC,IAAI,EAAE;wBAC3B,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;qBAC1B;oBAED,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;oBACzB,MAAM,IAAI,CAAC,eAAe,EAAE,CAAC;oBAC7B,IAAI,CAAC,OAAO,EAAE;wBACZ,OAAO,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;qBACzC;oBACDA,KAAS,CACP,qDAAqD,EACrD,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,OAAO,CACR,CAAC;oBAEF,IAAI,CAAC,SAAS,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;oBAClF,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;oBAC1BA,KAAS,CACP,8DAA8D,EAC9D,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;oBACF,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,CACpB,2CAA2C,GAAG,8BAA8B,EAC5E,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,CACpB,sDAAsD,EACtD,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,OAAO,CACR,CAAC;;;oBAGF,IAAI,IAAI,CAAC,YAAY,KAAK,YAAY,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,iBAAiB,EAAE;wBACpF,IAAI,CAAC,QAAQ,CAAC,iBAAiB,GAAG,IAAW,CAAC;qBAC/C;yBAAM,IAAI,IAAI,CAAC,YAAY,KAAK,YAAY,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE;wBACzF,IAAI,CAAC,QAAQ,CAAC,gBAAgB,GAAG,IAAW,CAAC;qBAC9C;oBACD,MAAM,IAAI,CAAC,mBAAmB,EAAE,CAAC;iBAClC;qBAAM;oBACLA,KAAS,CACP,2EAA2E;wBACzE,gCAAgC,EAClC,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,MAAM,EAAE,EACb,IAAI,CAAC,YAAY,CAClB,CAAC;iBACH;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;gBAC1B,GAAG,GAAGW,oBAAS,CAAC,GAAG,CAAC,CAAC;gBACrBX,KAAS,CACP,4DAA4D,EAC5D,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;IAES,gBAAgB;QACxB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,IAAI,CAAC,YAAY,KAAK,YAAY,CAAC,SAAS,EAAE;YAChD,IAAI,CAAC,QAAQ,CAAC,iBAAiB,GAAG,SAAS,CAAC;SAC7C;aAAM,IAAI,IAAI,CAAC,YAAY,KAAK,YAAY,CAAC,QAAQ,EAAE;YACtD,IAAI,CAAC,QAAQ,CAAC,gBAAgB,GAAG,SAAS,CAAC;SAC5C;QACDA,KAAS,CACP,uDAAuD,EACvD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,CACV,CAAC;KACH;;;;;;IAOK,UAAU,CAAC,aAAiC;;YAChD,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,IAAI;;;gBAGF,MAAM,iBAAiB,GAAG,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,CAAC;;;gBAG5E,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBAEtC,IAAI,IAAI,CAAC,YAAY,KAAK,YAAY,CAAC,QAAQ,EAAE;oBAC/CA,KAAS,CACP,iFAAiF;wBAC/E,oCAAoC,EACtC,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;oBACF,OAAO;iBACR;;gBAGD,IAAI,YAAY,GAAG,KAAK,CAAC;gBACzB,IAAI,aAAa,IAAI,CAAC,iBAAiB,EAAE;oBACvC,MAAM,eAAe,GAAGW,oBAAS,CAAC,aAAa,CAAC,CAAC;oBACjD,IAAI,eAAe,CAAC,SAAS,EAAE;wBAC7B,YAAY,GAAG,IAAI,CAAC;wBACpBX,KAAS,CACP,+EAA+E;4BAC7E,yFAAyF;4BACzF,oBAAoB,EACtB,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;qBACH;yBAAM;wBACLA,KAAS,CACP,+EAA+E;4BAC7E,+EAA+E;4BAC/E,oBAAoB,EACtB,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;qBACH;iBACF;qBAAM,IAAI,CAAC,iBAAiB,EAAE;oBAC7B,YAAY,GAAG,IAAI,CAAC;oBACpBA,KAAS,CACP,yEAAyE;wBACvE,mFAAmF;wBACnF,oBAAoB,EACtB,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;iBACH;qBAAM;oBACL,MAAM,KAAK,GAAQ;wBACjB,iBAAiB,EAAE,iBAAiB;wBACpC,aAAa,EAAE,aAAa;wBAC5B,SAAS,EAAE,IAAI,CAAC,SAAS;qBAC1B,CAAC;oBACFA,KAAS,CACP,4EAA4E,EAC5E,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,KAAK,CACN,CAAC;iBACH;gBACD,IAAI,YAAY,EAAE;;;oBAGhB,MAAM,OAAO,GAAoB,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;;;oBAInE,MAAM,MAAM,GAAsB;wBAChC,SAAS,EAAE,MACT,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC;4BACvB,IAAI,IAAI,CAAC,iBAAiB,EAAE;gCAC1BA,KAAS,CACP,qEAAqE;oCACnE,sGAAsG,EACxG,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;gCACF,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;6BACpB;iCAAM;gCACL,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,YAAY,KAAK,YAAY,CAAC,SAAS,EAAE;oCAClE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;iCACnD;6BACF;4BACD,OAAO;yBACR,CAAA,CAAC;wBACJ,YAAY,EAAE,YAAY;wBAC1B,aAAa,EAAEmB,6BAAkB,CAAC,YAAY;wBAC9C,KAAK,EAAEjB,oBAAS,CAAC,8BAA8B;wBAC/C,cAAc,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI;wBACnD,cAAc,EAAE,EAAE;qBACnB,CAAC;oBACF,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;wBAC3B,MAAMkB,gBAAK,CAAO,MAAM,CAAC,CAAC;qBAC3B;iBACF;aACF;YAAC,OAAO,GAAG,EAAE;gBACZpB,KAAS,CACP,0EAA0E,EAC1E,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,GAAG,CACJ,CAAC;gBACF,IAAI,OAAO,IAAI,CAAC,QAAQ,KAAK,UAAU,EAAE;oBACvCA,KAAS,CACP,yEAAyE,EACzE,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;oBACF,IAAI;wBACF,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;qBACpB;oBAAC,OAAO,GAAG,EAAE;wBACZA,KAAS,CACP,mEAAmE,EACnE,YAAY,EACZ,GAAG,CACJ,CAAC;qBACH;iBACF;aACF;SACF;KAAA;;;;;IAMK,KAAK;;YACT,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;YAC9BuB,QAAY,CACV,gDAAgD,EAChD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,QAAQ,CAAC,UAAU,CACzB,CAAC;YACF,IAAI,IAAI,CAAC,wBAAwB;gBAAE,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;YAC/E,IAAI,CAAC,+BAA+B,EAAE,CAAC;YACvC,IAAI,IAAI,CAAC,SAAS,EAAE;gBAClB,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC;gBACpC,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBACxB,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;aACrC;SACF;KAAA;;;;;;;IAQK,aAAa,CACjB,OAA0B,EAC1B,SAA0B,EAC1B,OAA4B;;YAE5B,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM;gBACjC,IAAI,CAAC,OAAO;oBAAE,OAAO,GAAG,EAAE,CAAC;gBAC3B,IAAI,SAAS,CAAC,KAAK,CAAC,uCAAuC,CAAC,IAAI,IAAI,EAAE;oBACpE,OAAO,MAAM,CAAC,IAAI,KAAK,CAAC,eAAe,SAAS,6BAA6B,CAAC,CAAC,CAAC;iBACjF;gBACD,IAAI,CAAC,2BAA2B,CAAC,OAAO,CAAC,SAAmB,CAAC,CAAC;gBAC9D,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;gBAClC,MAAM,KAAK,GAAG,UAAU,CAAC;oBACvB,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;oBAEjDA,QAAY,CACV,6EAA6E;wBAC3E,iDAAiD,EACnD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,QAAQ,CAAC,EAAE,EACXrB,oBAAS,CAAC,gCAAgC,GAAG,IAAI,CAClD,CAAC;oBAEF,MAAM,CAAC,GAAc;wBACnB,SAAS,EAAEU,mCAAwB,CAAC,uBAAuB;wBAC3D,WAAW,EACT,wEAAwE;4BACxE,sCAAsC;qBACzC,CAAC;oBACF,OAAO,MAAM,CAACD,oBAAS,CAAC,CAAC,CAAC,CAAC,CAAC;iBAC7B,EAAET,oBAAS,CAAC,gCAAgC,GAAG,IAAI,CAAC,CAAC;gBACtD,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,EAAE;oBAC5C,OAAO,EAAE,OAAO;oBAChB,MAAM,EAAE,MAAM;oBACd,KAAK,EAAE,KAAK;iBACb,CAAC,CAAC;gBACH,IAAI,SAAS,KAAK,eAAe,CAAC,QAAQ,EAAE;oBAC1C,QAAQ,CAAC,MAAM,EAAE,CAAC;iBACnB;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,OAAO,EAAE;oBAChD,MAAM,MAAM,GAAQ;wBAClB,kBAAkB,EAAE,KAAK;qBAC1B,CAAC;oBACF,IAAI,OAAO,CAAC,kBAAkB;wBAAE,MAAM,CAAC,mBAAmB,GAAG,OAAO,CAAC,kBAAkB,CAAC;oBACxF,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;iBAC3B;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,KAAK,EAAE;oBAC9C,MAAM,MAAM,GAAQ;wBAClB,kBAAkB,EAAE,IAAI;qBACzB,CAAC;oBACF,IAAI,OAAO,CAAC,kBAAkB;wBAAE,MAAM,CAAC,mBAAmB,GAAG,OAAO,CAAC,kBAAkB,CAAC;oBACxF,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;iBAC3B;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,UAAU,EAAE;oBACnD,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;iBACtC;aACF,CAAC,CAAC;SACJ;KAAA;;;;;IAMD,MAAM;QACJ,MAAM,MAAM,GAAY,IAAI,CAAC,SAAU,IAAI,IAAI,CAAC,SAAU,CAAC,MAAM,EAAE,CAAC;QACpEF,KAAS,CACP,qDAAqD,EACrD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,EACZ,MAAM,CACP,CAAC;QACF,OAAO,MAAM,CAAC;KACf;CACF;;AC5jCD;AACA,AA6CA;;;;;;;AAOA,MAAa,iBAAkB,SAAQ,eAAe;;;;;;;;IAQpD,YAAY,OAA4B,EAAE,OAAwB;QAChE,KAAK,CAAC,OAAO,EAAE,YAAY,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAEhD,IAAI,CAAC,8BAA8B,GAAG;YACpC,IAAI,IAAI,CAAC,wBAAwB;gBAAE,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;YAC/E,IAAI,IAAI,CAAC,8BAA8B,EAAE;gBACvC,IAAI,CAAC,wBAAwB,GAAG,UAAU,CAAC;oBACzC,MAAM,GAAG,GACP,sBAAsB,IAAI,CAAC,IAAI,oCAAoC;wBACnE,YAAY,IAAI,CAAC,8BAA8B,YAAY;wBAC3D,sCAAsC,CAAC;oBACzCA,KAAS,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;oBAEhE,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;iBACpB,CAAA,EAAE,IAAI,CAAC,8BAA8B,GAAG,IAAI,CAAC,CAAC;aAChD;SACF,CAAC;KACH;;;;;;;IAQD,OAAO,CAAC,SAAoB,EAAE,OAAgB;QAC5C,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QACtD,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAExB,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;SACnD;KACF;;;;;;;;;IAUD,OAAa,MAAM,CACjB,OAA4B,EAC5B,OAAwB;;YAExB,4BAA4B,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;YAChD,IAAI,CAAC,OAAO;gBAAE,OAAO,GAAG,EAAE,CAAC;YAC3B,IAAI,OAAO,CAAC,YAAY,IAAI,IAAI;gBAAE,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC;YAC9D,MAAM,SAAS,GAAG,IAAI,iBAAiB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YAC1D,MAAM,SAAS,CAAC,KAAK,EAAE,CAAC;YACxB,OAAO,CAAC,iBAAiB,GAAG,SAAS,CAAC;YACtC,OAAO,SAAS,CAAC;SAClB;KAAA;CACF;;ACpHD;AACA,AAgBA;;;;;;;AAOA,MAAa,gBAAiB,SAAQ,eAAe;;;;;;;;IAuBnD,YAAY,OAA4B,EAAE,OAAwB;QAChE,KAAK,CAAC,OAAO,EAAE,YAAY,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;;;;;QAnBjD,wBAAmB,GAAY,KAAK,CAAC;;;;;;QAO7B,kBAAa,GAAkC,SAAS,CAAC;QAEzD,wBAAmB,GAA6B,SAAS,CAAC;QAWhE,IAAI,CAAC,8BAA8B,GAAG,CAAC,CAAC;KACzC;;;;;;IAOK,UAAU,CAAC,aAAiC;;;YAEhD,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACtC,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;YACnC,IAAI,IAAI,CAAC,mBAAmB,IAAI,OAAO,IAAI,CAAC,mBAAmB,KAAK,UAAU,EAAE;gBAC9E,IAAI,CAAC,mBAAmB,EAAE,CAAC;aAC5B;SACF;KAAA;;;;;;;;;;IAWD,OAAO,CAAC,eAAuB,EAAE,oBAA6B;QAC5D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QAEtD,IAAI,oBAAoB,IAAI,IAAI,EAAE;YAChC,oBAAoB,GAAGE,oBAAS,CAAC,gCAAgC,CAAC;SACnE;QAED,MAAM,gBAAgB,GAAwB,EAAE,CAAC;QAEjD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;QAChC,OAAO,IAAI,OAAO,CAAsB,CAAC,OAAO,EAAE,MAAM;YACtD,IAAI,cAAwC,CAAC;YAE7C,MAAM,cAAc,GAAgB,CAAC,OAAqB;gBACxD,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;gBACjC,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,QAAS,CAAC;gBACrD,QAAQ,CAAC,cAAc,CAACwB,0BAAc,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC;gBACtE,QAAQ,CAAC,cAAc,CAACA,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;gBAClE,QAAQ,CAAC,cAAc,CAACA,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;gBACxE,QAAQ,CAAC,OAAO,CAAC,cAAc,CAACC,yBAAa,CAAC,YAAY,EAAE,cAAc,CAAC,CAAC;gBAE5E,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;gBAC9D,IAAIxB,OAAK,GAAG,IAAIyB,yBAAc,CAAC,6CAA6C,CAAC,CAAC;gBAC9E,IAAI,YAAY,EAAE;oBAChBzB,OAAK,GAAGQ,oBAAS,CAAC,YAAY,CAAC,CAAC;oBAChCX,KAAS,CACP,8EAA8E,EAC9E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACTG,OAAK,CACN,CAAC;iBACH;gBACD,IAAI,cAAc,EAAE;oBAClB,YAAY,CAAC,cAAc,CAAC,CAAC;iBAC9B;gBACD,IAAI,IAAI,CAAC,wBAAwB,EAAE;oBACjC,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;iBAC7C;gBACD,MAAM,CAACA,OAAK,CAAC,CAAC;aACf,CAAC;;YAGF,MAAM,WAAW,IAAI,IAAI,CAAC,mBAAmB,GAAG;;gBAE9C,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;gBACrC,IAAI,IAAI,CAAC,wBAAwB,EAAE;oBACjC,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;iBAC7C;gBACD,IAAI,cAAc,EAAE;oBAClB,YAAY,CAAC,cAAc,CAAC,CAAC;iBAC9B;;gBAGD,IAAI,IAAI,CAAC,SAAS,EAAE;oBAClB,IAAI,CAAC,SAAS,CAAC,cAAc,CAACuB,0BAAc,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC;oBAC5E,IAAI,CAAC,SAAS,CAAC,cAAc,CAACA,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;oBACxE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,cAAc,CAACC,yBAAa,CAAC,YAAY,EAAE,cAAc,CAAC,CAAC;iBACnF;;;;;gBAMD,IACE,IAAI,CAAC,aAAa;qBACjB,IAAI,CAAC,WAAW,KAAKnB,mBAAW,CAAC,gBAAgB,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC,CAAC,EACpF;oBACA,IAAI,IAAI,CAAC,SAAS,EAAE;wBAClB,IAAI,CAAC,SAAS,CAAC,cAAc,CAACkB,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;qBAC/E;oBACD,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;oBACjC,MAAM,GAAG,GAAGf,oBAAS,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;oBAC1C,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;iBACpB;;gBAGD,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;oBACtEkB,QAAY,CACV,oDAAoD,EACpD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,CAAC,MAAM,CACtB,CAAC;;oBAGF,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC;oBAC5B,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;iBAC7B;qBAAM;oBACL,IAAI,IAAI,CAAC,SAAS,EAAE;wBAClB,IAAI,CAAC,SAAS,CAAC,cAAc,CAACH,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;qBAC/E;oBAED,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;oBACjCG,QAAY,CACV,mEAAmE,EACnE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,gBAAgB,CAAC,MAAM,CACxB,CAAC;oBACF,OAAO,CAAC,gBAAgB,CAAC,CAAC;iBAC3B;aACF,CAAC,CAAC;;YAGH,MAAM,gBAAgB,GAAyB,CAAO,OAAqB;gBACzE,IAAI,CAAC,8BAA8B,EAAE,CAAC;gBACtC,IAAI;oBACF,MAAM,IAAI,GAAsB,IAAI,iBAAiB,CACnD,IAAI,CAAC,QAAQ,EACb,OAAO,CAAC,OAAQ,EAChB,OAAO,CAAC,QAAS,EACjB,IAAI,CACL,CAAC;oBACF,IAAI,gBAAgB,CAAC,MAAM,GAAG,eAAe,EAAE;wBAC7C,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;qBAC7B;iBACF;gBAAC,OAAO,GAAG,EAAE;oBACZ,MAAM,MAAM,GAAG,GAAG,YAAY,KAAK,GAAG,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;oBAC3E7B,KAAS,CACP,6FAA6F,EAC7F,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,MAAM,CACP,CAAC;oBACF,MAAM,CAAC,MAAM,CAAC,CAAC;iBAChB;gBACD,IAAI,gBAAgB,CAAC,MAAM,KAAK,eAAe,EAAE;oBAC/C,WAAW,EAAE,CAAC;iBACf;aACF,CAAA,CAAC;YAEF,MAAM,cAAc,GAAyB,CAAO,OAAqB;gBACvE,IAAI;oBACF,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;oBACjC,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;oBAC9D,IAAI,YAAY,EAAE;wBAChBA,KAAS,CACP,oFAAoF,EACpF,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,YAAY,CACb,CAAC;qBACH;iBACF;gBAAC,OAAO,GAAG,EAAE;oBACZA,KAAS,CACP,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACTW,oBAAS,CAAC,GAAG,CAAC,CACf,CAAC;iBACH;aACF,CAAA,CAAC;;YAGF,MAAM,cAAc,GAAgB;gBAClC,IAAI,IAAI,CAAC,SAAS,EAAE;oBAClB,IAAI,CAAC,SAAS,CAAC,cAAc,CAACe,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;oBAC9E,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG,KAAK,CAAC;iBAC9B;gBAED,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;gBAEjCG,QAAY,CACV,2EAA2E,EAC3E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,gBAAgB,CAAC,MAAM,CACxB,CAAC;gBAEF,OAAO,CAAC,gBAAgB,CAAC,CAAC;aAC3B,CAAC;YAEF,MAAM,cAAc,GAAyB,CAAO,OAAqB;gBACvE,IAAI;oBACF,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;oBACjC,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC;oBACjE,IAAI,aAAa,EAAE;wBACjB7B,KAAS,CACP,mEAAmE,EACnE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,aAAa,CACd,CAAC;qBACH;iBACF;gBAAC,OAAO,GAAG,EAAE;oBACZA,KAAS,CACP,kDAAkD,EAClD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACTW,oBAAS,CAAC,GAAG,CAAC,CACf,CAAC;iBACH;aACF,CAAA,CAAC;;YAGF,MAAM,cAAc,GAAgB,CAAC,OAAqB;gBACxD,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;gBACjC,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,QAAS,CAAC;gBACrD,QAAQ,CAAC,cAAc,CAACe,0BAAc,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC;gBACtE,QAAQ,CAAC,cAAc,CAACA,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;gBAClE,QAAQ,CAAC,cAAc,CAACA,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;gBACxE,QAAQ,CAAC,OAAO,CAAC,cAAc,CAACC,yBAAa,CAAC,YAAY,EAAE,cAAc,CAAC,CAAC;gBAE5E,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC;gBACjE,IAAIxB,OAAK,GAAG,IAAIyB,yBAAc,CAAC,6CAA6C,CAAC,CAAC;gBAC9E,IAAI,aAAa,EAAE;oBACjBzB,OAAK,GAAGQ,oBAAS,CAAC,aAAa,CAAC,CAAC;oBACjCX,KAAS,CACP,2CAA2C,EAC3C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACTG,OAAK,CACN,CAAC;iBACH;gBACD,IAAI,cAAc,EAAE;oBAClB,YAAY,CAAC,cAAc,CAAC,CAAC;iBAC9B;gBACD,IAAI,IAAI,CAAC,wBAAwB,EAAE;oBACjC,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;iBAC7C;gBACD,MAAM,CAACA,OAAK,CAAC,CAAC;aACf,CAAC;;YAGF,IAAI,IAAI,CAAC,WAAW,KAAKK,mBAAW,CAAC,QAAQ,EAAE;;;;;;gBAM7C,IAAI,CAAC,8BAA8B,GAAG;oBACpC,IAAI,IAAI,CAAC,wBAAwB;wBAAE,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;oBAC/E,IAAI,IAAI,CAAC,8BAA8B,EAAE;wBACvC,IAAI,CAAC,wBAAwB,GAAG,UAAU,CAAC;4BACzC,MAAM,GAAG,GACP,qBAAqB,IAAI,CAAC,IAAI,6CAA6C;gCAC3E,GAAG,IAAI,CAAC,8BAA8B,YAAY;gCAClD,4CAA4C,CAAC;4BAC/CR,KAAS,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;4BAChE,WAAW,EAAE,CAAC;yBACf,CAAA,EAAE,IAAI,CAAC,8BAA8B,GAAG,IAAI,CAAC,CAAC;qBAChD;iBACF,CAAC;aACH;;YAGD,MAAM,sBAAsB,GAAG;gBAC7B6B,QAAY,CACV,gEAAgE,EAChE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,oBAAoB,CACrB,CAAC;gBACF,OAAO,WAAW,EAAE,CAAC;aACtB,CAAC;YAEF,MAAM,SAAS,GAAgB,CAAC,OAAqB;gBACnD,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;gBAC1D,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;gBAClC,IAAI,QAAQ,EAAE;oBACZ,MAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC;oBACvB,MAAM,KAAK,GAAG,QAAQ,CAAC,YAAY,CAAC;oBACpC,MAAM,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC;oBACxCN,QAAY,CACV,0EAA0E;wBACxE,WAAW,EACb,YAAY,EACZ,EAAE,EACF,OAAO,EACP,KAAK,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,GAAG,KAAK,CAC3C,CAAC;oBACF,IAAI,OAAO,IAAI,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;wBACnD,MAAM,OAAO,GAAG,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,EAAE,CAAgB,CAAC;wBACpE,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;wBAC5BA,QAAY,CACV,sEAAsE,EACtE,YAAY,EACZ,EAAE,CACH,CAAC;wBACF,MAAM,YAAY,GAAG,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;wBAC7DA,QAAY,CACV,iEAAiE,EACjE,YAAY,EACZ,EAAE,EACF,YAAY,CACb,CAAC;wBACF,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;4BAC9E,MAAM,KAAK,GAAGZ,oBAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;4BACrC,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;yBAC9B;wBAED,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;qBAC1B;iBACF;aACF,CAAC;YAEF,MAAM,oBAAoB,GAAG,CAAC,KAAe;gBAC3CkB,QAAY,CACV,8DAA8D,EAC9D,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,eAAe,CAChB,CAAC;;;;;gBAKF,IAAI,CAAC,SAAU,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;gBAC3C,IAAI,GAAG,GAAW,+DAA+D,CAAC;gBAClF,IAAI,KAAK;oBAAE,GAAG,IAAI,mDAAmD,CAAC;gBACtEA,QAAY,CAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,oBAAoB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;gBACzF,cAAc,GAAG,UAAU,CACzB,sBAAsB,EACrB,oBAA+B,GAAG,IAAI,CACxC,CAAC;;;;;;;;;;;;aAYH,CAAC;YAEF,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE;;gBAElB,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;gBAC/BA,QAAY,CACV,wDAAwD,EACxD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,CACV,CAAC;;;;gBAIF,IAAI,CAAC,kBAAkB,GAAG,CAAC,CAAC;gBAC5B,MAAM,WAAW,GAAG,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE;oBACrD,SAAS,EAAE,gBAAgB;oBAC3B,OAAO,EAAE,cAAc;oBACvB,cAAc,EAAE,cAAc;oBAC9B,SAAS,EAAE,SAAS;oBACpB,OAAO,EAAE,cAAc;oBACvB,cAAc,EAAE,cAAc;iBAC/B,CAAC,CAAC;gBACH,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;qBACpB,IAAI,CAAC;oBACJ,IAAI,CAAC,SAAU,CAAC,EAAE,CAACH,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;oBACnE,oBAAoB,EAAE,CAAC;oBACvB,OAAO;iBACR,CAAC;qBACD,KAAK,CAAC,MAAM,CAAC,CAAC;aAClB;iBAAM;gBACL,oBAAoB,CAAC,IAAI,CAAC,CAAC;gBAC3B,IAAI,CAAC,SAAU,CAAC,EAAE,CAACA,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;gBAC7D,IAAI,CAAC,SAAU,CAAC,EAAE,CAACA,0BAAc,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC;gBACjE,IAAI,CAAC,SAAU,CAAC,EAAE,CAACA,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;gBACnE,IAAI,CAAC,SAAU,CAAC,OAAO,CAAC,EAAE,CAACC,yBAAa,CAAC,YAAY,EAAE,cAAc,CAAC,CAAC;aACxE;SACF,CAAC,CAAC;KACJ;;;;;;;;IASD,OAAO,MAAM,CAAC,OAA4B,EAAE,OAAwB;QAClE,4BAA4B,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAChD,MAAM,SAAS,GAAG,IAAI,gBAAgB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QACzD,OAAO,CAAC,gBAAgB,GAAG,SAAS,CAAC;QACrC,OAAO,SAAS,CAAC;KAClB;CACF;;ACpcD;AACA,AAgCA;;;;AAIA,AAAA,IAAY,aAGX;AAHD,WAAY,aAAa;IACvB,0CAAyB,CAAA;IACzB,kDAAiC,CAAA;AACnC,CAAC,EAHW,aAAa,KAAb,aAAa,QAGxB;AAwFD;;;;AAIA,MAAa,cAAe,SAAQ,UAAU;IAyV5C,YAAY,OAA4B,EAAE,OAA+B;QACvE,KAAK,CAAC,OAAO,CAAC,UAAU,EAAE,OAAO,EAAE;YACjC,OAAO,EAAE,OAAO,CAAC,UAAU;YAC3B,QAAQ,EAAE,GAAG,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,GAAG,OAAO,CAAC,UAAU,EAAE;SACtE,CAAC,CAAC;;;;;;;QAxUL,uBAAkB,GAAW,CAAC,CAAC;;;;;;QAiDvB,4BAAuB,GAA6B,IAAI,GAAG,EAAuB,CAAC;QAwRzF,IAAI,CAAC,QAAQ,CAAC,gBAAgB,GAAG,IAAI,CAAC;QACtC,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;QACjC,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,CAAC;QACjD,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAC1B,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,IAAInB,mBAAW,CAAC,QAAQ,CAAC;QAC/D,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,IAAI,aAAa,CAAC,UAAU,CAAC;QACzD,IAAI,CAAC,6BAA6B;YAChC,OAAO,CAAC,wCAAwC,IAAI,IAAI;kBACpD,OAAO,CAAC,wCAAwC;kBAChD,GAAG,CAAC;QACV,IAAI,CAAC,2BAA2B,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,6BAA6B,GAAG,IAAI,CAAC;QAC1F,IAAI,CAAC,aAAa;YAChB,IAAI,CAAC,6BAA6B,GAAG,CAAC,IAAI,IAAI,CAAC,WAAW,KAAKA,mBAAW,CAAC,QAAQ,CAAC;;QAGtF,IAAI,CAAC,UAAU,GAAG,CAAC,OAAqB;YACtC,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;YAClC,IAAI,QAAQ,EAAE;gBACZ,MAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC;gBACvB,MAAM,KAAK,GAAG,QAAQ,CAAC,YAAY,CAAC;gBACpC,MAAM,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC;gBACxCe,QAAY,CACV,0EAA0E,GAAG,WAAW,EACxF,YAAY,EACZ,EAAE,EACF,OAAO,EACP,KAAK,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,GAAG,KAAK,CAC3C,CAAC;gBACF,IAAI,OAAO,IAAI,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;oBACnD,MAAM,OAAO,GAAG,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,EAAE,CAAgB,CAAC;oBACpE,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;oBAC5BA,QAAY,CACV,sEAAsE,EACtE,YAAY,EACZ,EAAE,CACH,CAAC;oBACF,MAAM,YAAY,GAAG,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;oBAC7DA,QAAY,CACV,iEAAiE,EACjE,YAAY,EACZ,EAAE,EACF,YAAY,CACb,CAAC;oBACF,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;wBAC9E,MAAM,KAAK,GAAGZ,oBAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;wBACrC,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;qBAC9B;oBAED,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;iBAC1B;aACF;SACF,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG,CAACR,OAA6B;YAChD,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjB,IAAI,CAAC,QAAQ,CAACA,OAAK,CAAC,CAAC;gBACrBH,KAAS,CACP,yEAAyE;oBACvE,gBAAgB,EAClB,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,CACV,CAAC;aACH;SACF,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG,CAAC,OAAqB;YACxC,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC;YACjE,IAAI,aAAa,EAAE;gBACjB,MAAM,OAAO,GAAGW,oBAAS,CAAC,aAAa,CAAC,CAAC;gBACzC,IAAI,OAAO,CAAC,IAAI,KAAK,sBAAsB,EAAE;oBAC3C,IAAI,CAAC,QAAQ,CAAC,sBAAsB,CAAC,IAAI,CAAC,SAAU,CAAC,GAAG,IAAI,CAAC;oBAC7D,OAAO,CAAC,OAAO,GAAG,uDAAuD,IAAI,CAAC,SAAS,GAAG,CAAC;iBAC5F;gBACDX,KAAS,CACP,+CAA+C,EAC/C,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,OAAO,CACR,CAAC;gBACF,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;aAC5B;SACF,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAC,OAAqB;YAC3C,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAC9D,IAAI,YAAY,EAAE;gBAChB,MAAM,OAAO,GAAGW,oBAAS,CAAC,YAAY,CAAC,CAAC;gBACxCX,KAAS,CACP,8DAA8D,EAC9D,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,OAAO,CACR,CAAC;gBACF,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;aAC5B;SACF,CAAC;QAEF,IAAI,CAAC,YAAY,GAAG,CAAO,OAAqB;YAC9C,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC;YACjE,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,QAAS,CAAC;YACrD,IAAI,mBAAmB,GAAG,KAAK,CAAC;YAChC,IAAI,aAAa,EAAE;gBACjB,MAAM,OAAO,GAAGW,oBAAS,CAAC,aAAa,CAAC,CAAC;gBACzC,IAAI,OAAO,CAAC,IAAI,KAAK,sBAAsB,EAAE;oBAC3C,mBAAmB,GAAG,IAAI,CAAC;iBAC5B;gBACDX,KAAS,CACP,6EAA6E;oBAC3E,6BAA6B,EAC/B,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,EACd,OAAO,CACR,CAAC;;;aAGH;YACD,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,EAAE;gBAC1CA,KAAS,CACP,+EAA+E;oBAC7E,gFAAgF,EAClF,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,CACf,CAAC;gBACF,IAAI;oBACF,MAAM,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC;iBACvC;gBAAC,OAAO,GAAG,EAAE;oBACZA,KAAS,CACP,gFAAgF,EAChF,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,EACd,GAAG,CACJ,CAAC;iBACH;aACF;iBAAM;gBACLA,KAAS,CACP,+EAA+E;oBAC7E,8EAA8E,EAChF,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,CACf,CAAC;aACH;SACF,CAAA,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,CAAO,OAAqB;YACjD,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,QAAS,CAAC;YACrD,MAAM,YAAY,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;YAC9D,IAAI,YAAY,EAAE;gBAChB,MAAM,OAAO,GAAGW,oBAAS,CAAC,YAAY,CAAC,CAAC;gBACxCX,KAAS,CACP,4EAA4E;oBAC1E,6BAA6B,EAC/B,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,EACd,OAAO,CACR,CAAC;;;aAGH;YAED,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,qBAAqB,EAAE,EAAE;gBACjDA,KAAS,CACP,8EAA8E;oBAC5E,gFAAgF,EAClF,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,CACf,CAAC;gBACF,IAAI;oBACF,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;iBACpB;gBAAC,OAAO,GAAG,EAAE;oBACZA,KAAS,CACP,gFAAgF,EAChF,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,EACd,GAAG,CACJ,CAAC;iBACH;aACF;iBAAM;gBACLA,KAAS,CACP,8EAA8E;oBAC5E,8EAA8E,EAChF,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,CACf,CAAC;aACH;SACF,CAAA,CAAC;KACH;;;;;IApaO,yBAAyB;QAC/B,IACE,IAAI,CAAC,aAAa;YAClB,IAAI,IAAI,CAAC,IAAI,CAAC,2BAA2B,CAAC,GAAG,IAAI,CAAC,qBAAsB;YACxE,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,2BAA2B;YAC7C,IAAI,CAAC,MAAM,EAAE,EACb;YACA,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,kBAAkB,GAAG,2BAA2B,CAAC,IAAI,CAAC,qBAAsB,CAAC,CAAC;YACpF,IAAI,CAAC,wBAAwB,GAAG,UAAU,CAAC;gBACzC,IAAI;oBACF8B,cAAkB,CAChB,oEAAoE;wBAClE,iBAAiB,EACnB,YAAY,EACZ,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,IAAI,CAAC,qBAAqB,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,gBAAgB,CACjF,IAAI,CAAC,SAAU,EACf;wBACE,cAAc,EAAE,CAAC;wBACjB,gBAAgB,EAAE,EAAE;wBACpB,KAAK,EAAE,CAAC;qBACT,CACF,CAAC;oBACFP,QAAY,CACV,qEAAqE;wBACnE,iBAAiB,EACnB,YAAY,EACZ,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,CACV,CAAC;oBACFA,QAAY,CACV,yEAAyE,EACzE,YAAY,EACZ,IAAI,CAAC,SAAS,CACf,CAAC;oBACF,IAAI,CAAC,yBAAyB,EAAE,CAAC;iBAClC;gBAAC,OAAO,GAAG,EAAE;oBACZvB,KAAS,CACP,4EAA4E;wBAC1E,yBAAyB,EAC3B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,GAAG,CACJ,CAAC;iBACH;aACF,CAAA,EAAE,kBAAkB,CAAC,CAAC;YACvB8B,cAAkB,CAChB,yEAAyE;gBACvE,sBAAsB,EACxB,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,EACT,kBAAkB,GAAG,IAAI,EACzB,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,kBAAkB,CAAC,CAAC,QAAQ,EAAE,CACrD,CAAC;SACH;KACF;;;;IAKO,gBAAgB;QACtB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,OAAO,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,SAAU,CAAC,CAAC;QACtD9B,KAAS,CACP,2EAA2E,EAC3E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,CACf,CAAC;KACH;;;;IAKa,KAAK;;YACjB,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,IAAI;gBACF,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACxCA,KAAS,CACP,4EAA4E;wBAC1E,kDAAkD,EACpD,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;oBACF,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;oBACzB,MAAM,IAAI,CAAC,eAAe,EAAE,CAAC;oBAE7B,MAAM,OAAO,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;oBAEpDA,KAAS,CACP,qDAAqD,EACrD,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,OAAO,CACR,CAAC;oBAEF,IAAI,CAAC,SAAS,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;oBAClF,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;oBAC1B,MAAM,iBAAiB,GACrB,IAAI,CAAC,SAAS,CAAC,MAAM;wBACrB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM;wBAC5B,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAACE,oBAAS,CAAC,iBAAiB,CAAC,CAAC;oBAC5D,IAAI,YAAY,GAAW,EAAE,CAAC;;oBAE9B,IAAI,iBAAiB,IAAI,IAAI,EAAE;wBAC7B,YAAY;4BACV,oCAAoC,iBAAiB,mBAAmB;gCACxE,iBAAiB,IAAI,CAAC,IAAI,IAAI,CAAC;qBAClC;oBACD,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,IAAI,iBAAiB,KAAK,IAAI,CAAC,SAAS,EAAE;wBAClE,YAAY;4BACV,uBAAuB,iBAAiB,gCAAgC;gCACxE,cAAc,IAAI,CAAC,SAAS,kCAAkC,IAAI,CAAC,IAAI,IAAI,CAAC;qBAC/E;oBACD,IAAI,YAAY,EAAE;wBAChB,MAAMC,OAAK,GAAGQ,oBAAS,CAAC;4BACtB,WAAW,EAAE,YAAY;4BACzB,SAAS,EAAEC,mCAAwB,CAAC,0BAA0B;yBAC/D,CAAC,CAAC;wBACHZ,KAAS,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAEG,OAAK,CAAC,CAAC;wBAClE,MAAMA,OAAK,CAAC;qBACb;oBACD,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI;wBAAE,IAAI,CAAC,SAAS,GAAG,iBAAiB,CAAC;oBAC/D,IAAI,CAAC,qBAAqB,GAAG,kBAAkB,CAC7C,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,gCAAgC,CAAC,CAC5D,CAAC;oBACF2B,cAAkB,CAChB,kDAAkD,EAClD,YAAY,EACZ,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,CACzC,CAAC;oBACF9B,KAAS,CACP,+DAA+D,EAC/D,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,CACf,CAAC;oBACF8B,cAAkB,CAChB,2CAA2C,GAAG,8BAA8B,EAC5E,IAAI,CAAC,IAAI,CACV,CAAC;oBACFA,cAAkB,CAChB,sDAAsD,EACtD,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,OAAO,CACR,CAAC;oBACF,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,SAAU,CAAC,EAAE;wBACnD,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,SAAU,CAAC,GAAG,IAAI,CAAC;qBACvD;oBACD,IAAI,CAAC,2BAA2B,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,6BAA6B,GAAG,IAAI,CAAC;oBAC1F,MAAM,IAAI,CAAC,mBAAmB,EAAE,CAAC;oBACjC,MAAM,IAAI,CAAC,yBAAyB,EAAE,CAAC;iBACxC;qBAAM;oBACL9B,KAAS,CACP,4EAA4E;wBAC1E,gCAAgC,EAClC,YAAY,EACZ,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,MAAM,EAAE,EACb,IAAI,CAAC,YAAY,CAClB,CAAC;iBACH;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;gBAC1B,MAAM,MAAM,GAAGW,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC9BX,KAAS,CACP,4DAA4D,EAC5D,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,MAAM,CACP,CAAC;gBACF,MAAM,MAAM,CAAC;aACd;SACF;KAAA;;;;IAKO,4BAA4B;QAClC,MAAM,WAAW,GAAoB;YACnC,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,UAAU,EAAE,KAAK;;YAEjB,eAAe,EAAE,IAAI,CAAC,WAAW,KAAKQ,mBAAW,CAAC,gBAAgB,GAAG,CAAC,GAAG,CAAC;;YAE1E,eAAe,EAAE,IAAI,CAAC,WAAW,KAAKA,mBAAW,CAAC,gBAAgB,GAAG,CAAC,GAAG,CAAC;YAC1E,MAAM,EAAE;gBACN,OAAO,EAAE,IAAI,CAAC,OAAO;gBACrB,MAAM,EAAE,EAAE;aACX;YACD,aAAa,EAAE,CAAC;YAChB,OAAO,EAAE,CAAC,OAAO,KACf,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC;;aAEhC,CAAC;YACJ,cAAc,EAAE,CAAC,OAAO,KACtB,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC;;aAEnC,CAAC;YACJ,OAAO,EAAE,IAAI,CAAC,YAAY;YAC1B,cAAc,EAAE,IAAI,CAAC,eAAe;YACpC,SAAS,EAAE,IAAI,CAAC,UAAU;SAC3B,CAAC;QACD,WAAW,CAAC,MAAc,CAAC,MAAM,CAACN,oBAAS,CAAC,iBAAiB,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACjF,OAAO,WAAW,CAAC;KACpB;;;;;;;IAsNK,KAAK,CAAC,mBAA6B;;YACvC,IAAI;gBACF4B,cAAkB,CAChB,sDAAsD,EACtD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,IAAI,CACV,CAAC;gBAEF,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;gBACjC,IAAI,IAAI,CAAC,wBAAwB;oBAAE,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;gBAC/E,IAAI,IAAI,CAAC,wBAAwB;oBAAE,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;gBAC/EA,cAAkB,CAChB,iEAAiE;oBAC/D,8BAA8B,EAChC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBAEF,IAAI,CAAC,mBAAmB,EAAE;oBACxB,OAAO,IAAI,CAAC,QAAQ,CAAC,sBAAsB,CAAC,IAAI,CAAC,SAAU,CAAC,CAAC;iBAC9D;gBAED,IAAI,IAAI,CAAC,SAAS,EAAE;oBAClB,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC;oBACpC,IAAI,CAAC,gBAAgB,EAAE,CAAC;oBACxB,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;iBACrC;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ9B,KAAS,CACP,4EAA4E,EAC5E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,SAAS,EACd,GAAG,CACJ,CAAC;aACH;SACF;KAAA;;;;IAKD,MAAM;QACJ,MAAM,MAAM,GAAY,IAAI,CAAC,SAAU,IAAI,IAAI,CAAC,SAAU,CAAC,MAAM,EAAE,CAAC;QACpE8B,cAAkB,CAChB,sDAAsD,EACtD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,EACd,MAAM,CACP,CAAC;QACF,OAAO,MAAM,CAAC;KACf;;;;;;;;;;;;;;;IAgBD,OAAO,CAAC,SAAoB,EAAE,OAAgB,EAAE,OAAsC;QACpF,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;QAChC,IAAI,OAAO,OAAO,CAAC,kBAAkB,KAAK,QAAQ,IAAI,OAAO,CAAC,kBAAkB,GAAG,CAAC,EAAE;YACpF,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;SACtD;;QAGD,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY,KAAK,KAAK,GAAG,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC;QACjF,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;;;;;;QAO1D,MAAM,8BAA8B,GAAG;YACrC,IAAI,IAAI,CAAC,wBAAwB;gBAAE,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;YAC/E,IAAI,IAAI,CAAC,8BAA8B,EAAE;gBACvC,IAAI,CAAC,wBAAwB,GAAG,UAAU,CAAC;oBACzC,MAAM,GAAG,GACP,mBAAmB,IAAI,CAAC,SAAS,gBAAgB,IAAI,CAAC,IAAI,oBAAoB;wBAC9E,4BAA4B,IAAI,CAAC,8BAA8B,6BAA6B,CAAC;oBAC/F9B,KAAS,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;oBAEhE,IAAI,IAAI,CAAC,MAAM,KAAK,aAAa,CAAC,cAAc,EAAE;;;wBAGhD,MAAM,KAAK,GAAGW,oBAAS,CAAC;4BACtB,SAAS,EAAE,oCAAoC;4BAC/C,WAAW,EAAE,GAAG;yBACjB,CAAC,CAAC;wBACH,IAAI,CAAC,YAAY,CAACA,oBAAS,CAAC,KAAK,CAAC,CAAC,CAAC;qBACrC;oBACD,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;iBACpB,CAAA,EAAE,IAAI,CAAC,8BAA8B,GAAG,IAAI,CAAC,CAAC;aAChD;SACF,CAAC;QAEF,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,EAAE;YAC7C,MAAM,gBAAgB,GAAG,CAAO,OAAqB;;;gBAGnD,IACE,IAAI,CAAC,WAAW,KAAKH,mBAAW,CAAC,QAAQ;qBACxC,CAAC,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,EAC7C;oBACAR,KAAS,CACP,sEAAsE;wBACpE,gCAAgC,EAClC,YAAY,EACZ,IAAI,CAAC,IAAI,CACV,CAAC;oBACF,OAAO;iBACR;gBAED,8BAA8B,EAAE,CAAC;gBACjC,MAAM,QAAQ,GAAsB,IAAI,iBAAiB,CACvD,IAAI,CAAC,QAAQ,EACb,OAAO,CAAC,OAAQ,EAChB,OAAO,CAAC,QAAS,EACjB,IAAI,CACL,CAAC;gBACF,IAAI;oBACF,MAAM,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;iBACjC;gBAAC,OAAO,GAAG,EAAE;;oBAEZ,IAAI,CAACwB,uBAAW,CAAC,GAAG,CAAC,EAAE;wBACrBxB,KAAS,CACP,8EAA8E;4BAC5E,uCAAuC,EACzC,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,EACT,GAAG,CACJ,CAAC;wBACF,IAAI,CAAC,QAAS,CAAC,GAAG,CAAC,CAAC;qBACrB;oBAED,MAAMG,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;;oBAE7B,IACE,CAAC,QAAQ,CAAC,QAAQ,CAAC,cAAc;wBACjC,IAAI,CAAC,WAAW,KAAKH,mBAAW,CAAC,QAAQ;wBACzC,IAAI,CAAC,MAAM,EAAE;sBACb;wBACA,IAAI;4BACFR,KAAS,CACP,sEAAsE;gCACpE,uBAAuB,EACzB,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,EACTG,OAAK,CACN,CAAC;4BACF,MAAM,QAAQ,CAAC,OAAO,EAAE,CAAC;yBAC1B;wBAAC,OAAO,YAAY,EAAE;4BACrB,MAAM,eAAe,GAAGQ,oBAAS,CAAC,YAAY,CAAC,CAAC;4BAChDX,KAAS,CACP,0EAA0E;gCACxE,oBAAoB,EACtB,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,EACT,eAAe,CAChB,CAAC;4BACF,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC;yBACpC;qBACF;oBACD,OAAO;iBACR;wBAAS;oBACR,IAAI,IAAI,CAAC,SAAS,EAAE;wBAClB,IAAI,CAAC,SAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;qBAC9B;iBACF;;;gBAID,IACE,IAAI,CAAC,YAAY;oBACjB,IAAI,CAAC,WAAW,KAAKQ,mBAAW,CAAC,QAAQ;oBACzC,CAAC,QAAQ,CAAC,QAAQ,CAAC,cAAc,EACjC;oBACA,IAAI;wBACFsB,cAAkB,CAChB,mDAAmD,GAAG,oBAAoB,EAC1E,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,CACV,CAAC;wBACF,MAAM,QAAQ,CAAC,QAAQ,EAAE,CAAC;qBAC3B;oBAAC,OAAO,aAAa,EAAE;wBACtB,MAAM,eAAe,GAAGnB,oBAAS,CAAC,aAAa,CAAC,CAAC;wBACjDX,KAAS,CACP,0EAA0E;4BACxE,oBAAoB,EACtB,YAAY,EACZ,QAAQ,CAAC,SAAS,EAClB,IAAI,CAAC,IAAI,EACT,eAAe,CAChB,CAAC;wBACF,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC;qBACpC;iBACF;aACF,CAAA,CAAC;;YAEF,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC0B,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;;YAE5D,IAAI,CAAC,SAAU,CAAC,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;SACpD;aAAM;YACL,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;YACjC,MAAM,GAAG,GACP,kCAAkC,IAAI,CAAC,SAAS,eAAe,IAAI,CAAC,IAAI,IAAI;gBAC5E,6CAA6C,CAAC;YAChD1B,KAAS,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;YAChE,IAAI,CAAC,YAAY,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;SACnC;KACF;;;;;;;;;;;IAYK,eAAe,CACnB,eAAuB,EACvB,oBAA6B;;YAE7B,IAAI,oBAAoB,IAAI,IAAI,EAAE;gBAChC,oBAAoB,GAAGE,oBAAS,CAAC,gCAAgC,CAAC;aACnE;YAED,MAAM,gBAAgB,GAAwB,EAAE,CAAC;YACjD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;YAEhC,OAAO,IAAI,OAAO,CAAsB,CAAC,OAAO,EAAE,MAAM;gBACtD,IAAI,cAAmB,CAAC;gBAExB,MAAM,iCAAiC,GAAG,CAAC,KAAc;oBACvD,IAAI,CAAC,8BAA8B,GAAG,KAAK,CAAC;iBAC7C,CAAC;gBAEF,iCAAiC,CAAC,CAAC,CAAC,CAAC;;gBAGrC,MAAM,cAAc,GAAgB;oBAClC,IAAI,CAAC,SAAU,CAAC,cAAc,CAACwB,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;oBAC/E,IAAI,CAAC,SAAU,CAAC,KAAK,GAAG,KAAK,CAAC;oBAE9B,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;oBAEjCI,cAAkB,CAChB,2EAA2E,EAC3E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,gBAAgB,CAAC,MAAM,CACxB,CAAC;oBAEF,OAAO,CAAC,gBAAgB,CAAC,CAAC;iBAC3B,CAAC;;gBAGF,MAAM,sBAAsB,GAAqB;oBAC/CD,QAAY,CACV,gEAAgE,EAChE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,oBAAoB,CACrB,CAAC;oBACF,OAAO,WAAW,EAAE,CAAC;iBACtB,CAAC;;gBAGF,MAAM,gBAAgB,GAAyB,CAAO,OAAqB;oBACzE,8BAA8B,EAAE,CAAC;oBACjC,IAAI;wBACF,MAAM,IAAI,GAAsB,IAAI,iBAAiB,CACnD,IAAI,CAAC,QAAQ,EACb,OAAO,CAAC,OAAQ,EAChB,OAAO,CAAC,QAAS,EACjB,IAAI,CACL,CAAC;wBACF,IAAI,gBAAgB,CAAC,MAAM,GAAG,eAAe,EAAE;4BAC7C,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBAC7B;qBACF;oBAAC,OAAO,GAAG,EAAE;;wBAEZ,IAAI,IAAI,CAAC,SAAS,EAAE;4BAClB,IAAI,CAAC,SAAS,CAAC,cAAc,CAACH,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;4BACxE,IAAI,CAAC,SAAS,CAAC,cAAc,CAACA,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;yBAC/E;wBAED1B,KAAS,CACP,6FAA6F,EAC7F,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,GAAG,CACJ,CAAC;wBACF,MAAM,CAAC,GAAG,YAAY,KAAK,GAAG,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;qBACrE;oBACD,IAAI,gBAAgB,CAAC,MAAM,KAAK,eAAe,EAAE;wBAC/C,WAAW,EAAE,CAAC;qBACf;iBACF,CAAA,CAAC;gBAEF,IAAI,CAAC,QAAQ,GAAG,CAAC,KAA6B;oBAC5C,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;;;oBAGjC,iCAAiC,EAAE,CAAC;oBACpC,IAAI,cAAc,EAAE;wBAClB,YAAY,CAAC,cAAc,CAAC,CAAC;qBAC9B;;oBAED,IAAI,IAAI,CAAC,SAAS,EAAE;wBAClB,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC0B,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;wBACxE,IAAI,CAAC,SAAS,CAAC,cAAc,CAACA,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;qBAC/E;oBACD,MAAM,CAAC,KAAK,CAAC,CAAC;iBACf,CAAC;;gBAGF,MAAM,WAAW,GAAG;oBAClB,IAAI,IAAI,CAAC,wBAAwB,EAAE;wBACjC,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;qBAC7C;oBACD,IAAI,cAAc,EAAE;wBAClB,YAAY,CAAC,cAAc,CAAC,CAAC;qBAC9B;;;oBAID,iCAAiC,EAAE,CAAC;;oBAGpC,IAAI,IAAI,CAAC,SAAS,EAAE;wBAClB,IAAI,CAAC,SAAS,CAAC,cAAc,CAACA,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;qBACzE;oBAED,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;wBAC/CI,cAAkB,CAChB,oDAAoD,EACpD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,SAAS,CAAC,MAAM,CACtB,CAAC;;wBAGF,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC;wBAC5B,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;qBAC7B;yBAAM;wBACL,IAAI,IAAI,CAAC,SAAS,EAAE;4BAClB,IAAI,CAAC,SAAS,CAAC,cAAc,CAACJ,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;yBAC/E;wBAED,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;wBACjCI,cAAkB,CAChB,mEAAmE,EACnE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,gBAAgB,CAAC,MAAM,CACxB,CAAC;wBACF,OAAO,CAAC,gBAAgB,CAAC,CAAC;qBAC3B;iBACF,CAAC;;;;;;;gBAQF,MAAM,8BAA8B,GAClC,IAAI,CAAC,WAAW,KAAKtB,mBAAW,CAAC,QAAQ;sBACrC;wBACE,IAAI,IAAI,CAAC,wBAAwB;4BAAE,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;wBAC/E,IAAI,IAAI,CAAC,8BAA8B,EAAE;4BACvC,IAAI,CAAC,wBAAwB,GAAG,UAAU,CAAC;gCACzC,MAAM,GAAG,GACP,mBAAmB,IAAI,CAAC,SAAS,gBAAgB,IAAI,CAAC,IAAI,oBAAoB;oCAC9E,4BAA4B,IAAI,CAAC,8BAA8B,6BAA6B,CAAC;gCAC/FR,KAAS,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;gCAChE,WAAW,EAAE,CAAC;gCACd,IAAI,IAAI,CAAC,MAAM,KAAK,aAAa,CAAC,cAAc,EAAE;oCAChD,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;iCACpB;6BACF,CAAA,EAAE,IAAI,CAAC,8BAA8B,GAAG,IAAI,CAAC,CAAC;yBAChD;qBACF;sBACD,SAAQ,CAAC;gBAEf,MAAM,oBAAoB,GAAG,CAAC,KAAe;oBAC3C6B,QAAY,CACV,8DAA8D,EAC9D,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,IAAI,EACT,eAAe,CAChB,CAAC;;;;;oBAKF,IAAI,CAAC,SAAU,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;oBAC3C,IAAI,GAAG,GAAW,+DAA+D,CAAC;oBAClF,IAAI,KAAK;wBAAE,GAAG,IAAI,mDAAmD,CAAC;oBACtEA,QAAY,CAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,oBAAoB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;oBACzF,cAAc,GAAG,UAAU,CACzB,sBAAsB,EACrB,oBAA+B,GAAG,IAAI,CACxC,CAAC;iBACH,CAAC;gBAEF,IAAI,IAAI,CAAC,MAAM,EAAE,EAAE;oBACjB,IAAI,CAAC,SAAU,CAAC,EAAE,CAACH,0BAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;oBAC7D,IAAI,CAAC,SAAU,CAAC,EAAE,CAACA,0BAAc,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;oBACnE,oBAAoB,CAAC,IAAI,CAAC,CAAC;iBAC5B;qBAAM;oBACL,MAAM,GAAG,GACP,mBAAmB,IAAI,CAAC,IAAI,qBAAqB,IAAI,CAAC,SAAS,KAAK;wBACpE,8DAA8D,CAAC;oBACjE1B,KAAS,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;oBAChE,MAAM,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;iBACxB;aACF,CAAC,CAAC;SACJ;KAAA;;;;;;;IAQK,aAAa,CACjB,OAA0B,EAC1B,SAA0B,EAC1B,OAA4B;;YAE5B,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM;gBACjC,IAAI,CAAC,OAAO;oBAAE,OAAO,GAAG,EAAE,CAAC;gBAC3B,IAAI,SAAS,CAAC,KAAK,CAAC,uCAAuC,CAAC,IAAI,IAAI,EAAE;oBACpE,OAAO,MAAM,CAAC,IAAI,KAAK,CAAC,eAAe,SAAS,6BAA6B,CAAC,CAAC,CAAC;iBACjF;gBACD,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;gBAClC,MAAM,KAAK,GAAG,UAAU,CAAC;oBACvB,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;oBACjDuB,QAAY,CACV,6EAA6E;wBAC3E,gDAAgD,EAClD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,QAAQ,CAAC,EAAE,EACXrB,oBAAS,CAAC,gCAAgC,GAAG,IAAI,CAClD,CAAC;oBAEF,MAAM,CAAC,GAAc;wBACnB,SAAS,EAAEU,mCAAwB,CAAC,uBAAuB;wBAC3D,WAAW,EACT,wEAAwE;4BACxE,sCAAsC;qBACzC,CAAC;oBACF,OAAO,MAAM,CAACD,oBAAS,CAAC,CAAC,CAAC,CAAC,CAAC;iBAC7B,EAAET,oBAAS,CAAC,gCAAgC,GAAG,IAAI,CAAC,CAAC;gBACtD,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,EAAE;oBAC5C,OAAO,EAAE,OAAO;oBAChB,MAAM,EAAE,MAAM;oBACd,KAAK,EAAE,KAAK;iBACb,CAAC,CAAC;gBACH,IAAI,SAAS,KAAK,eAAe,CAAC,QAAQ,EAAE;oBAC1C,QAAQ,CAAC,MAAM,EAAE,CAAC;iBACnB;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,OAAO,EAAE;oBAChD,MAAM,MAAM,GAAQ;wBAClB,kBAAkB,EAAE,KAAK;qBAC1B,CAAC;oBACF,IAAI,OAAO,CAAC,kBAAkB;wBAAE,MAAM,CAAC,mBAAmB,GAAG,OAAO,CAAC,kBAAkB,CAAC;oBACxF,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;iBAC3B;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,KAAK,EAAE;oBAC9C,MAAM,MAAM,GAAQ;wBAClB,kBAAkB,EAAE,IAAI;qBACzB,CAAC;oBACF,IAAI,OAAO,CAAC,kBAAkB;wBAAE,MAAM,CAAC,mBAAmB,GAAG,OAAO,CAAC,kBAAkB,CAAC;oBACxF,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;iBAC3B;qBAAM,IAAI,SAAS,KAAK,eAAe,CAAC,UAAU,EAAE;oBACnD,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;iBACtC;aACF,CAAC,CAAC;SACJ;KAAA;;;;;;IAOD,OAAa,MAAM,CACjB,OAA4B,EAC5B,OAA+B;;YAE/B,4BAA4B,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;YAChD,MAAM,cAAc,GAAG,IAAI,cAAc,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YAC5D,MAAM,cAAc,CAAC,KAAK,EAAE,CAAC;YAC7B,OAAO,cAAc,CAAC;SACvB;KAAA;CACF;;ACzpCD;;;;;;AAMA,MAAa,QAAQ;;;;;IAenB,YAAY,OAA4B,EAAE,WAAwB;;;;QAN1D,cAAS,GAAY,KAAK,CAAC;QAOjC,4BAA4B,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAChD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAExB,IAAI,CAAC,YAAY;YACf,WAAW,KAAKM,mBAAW,CAAC,gBAAgB,GAAG,WAAW,GAAGA,mBAAW,CAAC,QAAQ,CAAC;KACrF;IAEO,wBAAwB;QAC9B,IAAI,IAAI,CAAC,mBAAmB,EAAE,EAAE;YAC9B,MAAM,YAAY,GAAG,2BAA2B,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC3E,MAAML,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtCH,KAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;YACjE,MAAMA,OAAK,CAAC;SACb;KACF;IAEO,kCAAkC;QACxC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QACtD,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,YAAY,GAAG,yBAAyB,CAC5C,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;YACF,MAAMA,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtCH,KAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;YACjE,MAAMA,OAAK,CAAC;SACb;KACF;;;;;IAMD,IAAW,WAAW;QACpB,OAAO,IAAI,CAAC,YAAY,CAAC;KAC1B;;;;;;IAOD,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC;KACjD;;;;;;;;;;;;;;;;;;;;;;IAuBD,sBAAsB,CACpB,SAAoB,EACpB,OAAgB,EAChB,OAA+B;QAE/B,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;QACpD,gCAAgC,CAAC,MAAM,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;QACjE,gCAAgC,CAAC,MAAM,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;QAC7D,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE;YACnC,MAAM,IAAI,SAAS,CAAC,uDAAuD,CAAC,CAAC;SAC9E;QACD,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;YACjC,MAAM,IAAI,SAAS,CAAC,qDAAqD,CAAC,CAAC;SAC5E;QAED,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,kCACjC,OAAO,KACV,WAAW,EAAE,IAAI,CAAC,YAAY,IAC9B;aACC,IAAI,CAAC,CAAO,SAAS;YACpB,IAAI,CAAC,SAAS,EAAE;gBACd,OAAO;aACR;YACD,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAClB,SAAS,CAAC,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;aACvC;iBAAM;gBACL,MAAM,SAAS,CAAC,KAAK,EAAE,CAAC;aACzB;YACD,OAAO;SACR,CAAA,CAAC;aACD,KAAK,CAAC,CAAC,GAAG;YACT,OAAO,CAAC,GAAG,CAAC,CAAC;SACd,CAAC,CAAC;KACN;;;;;;;;;;;;;;;;;;IAmBK,eAAe,CACnB,eAAuB,EACvB,oBAA6B;;YAE7B,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAEhC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,MAAM,EAAE,EAAE;gBAC/E,MAAM,OAAO,GAAmB;oBAC9B,kBAAkB,EAAE,CAAC;oBACrB,WAAW,EAAE,IAAI,CAAC,YAAY;iBAC/B,CAAC;gBACF,IAAI,CAAC,QAAQ,CAAC,gBAAgB,GAAG,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;aAClF;YAED,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,OAAO,CAAC,eAAe,EAAE,oBAAoB,CAAC,CAAC;SACtF;KAAA;;;;;;;;;;;;;IAcM,kBAAkB;;YACvB,OAAO,IAAI,EAAE;gBACX,MAAM,YAAY,GAAG,oBAAM,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAA,CAAC;gBACnD,0BAAM,YAAY,CAAC,CAAC,CAAC,CAAA,CAAC;aACvB;SACF;KAAA;;;;;;;;;;;;;;IAeK,gBAAgB,CAAC,kBAA8C;;YACnE,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,IAAI,IAAI,CAAC,YAAY,KAAKK,mBAAW,CAAC,QAAQ,EAAE;gBAC9C,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,wBAAwB,CAAC,CAAC,CAAC;aAC9F;YACD,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,oBAAoB,EACpB,kBAAkB,CACnB,CAAC;YAEF,MAAM,SAAS,GACb,kBAAkB,YAAY,iBAAiB;kBAC3C,MAAM,CAAC,kBAAkB,CAAC,SAAS,CAAC;kBACpC,MAAM,CAAC,kBAAkB,CAAC,CAAC;YAEjC,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;YAElF,OAAO,cAAc,CAAC;SACvB;KAAA;;;;;;;;;;IAWK,sBAAsB,CAAC,cAAoB;;YAC/C,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,gBAAgB,EAChB,cAAc,CACf,CAAC;YACF,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,gBAAgB,EAChB,cAAc,CACf,CAAC;YAEF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,uBAAuB,CAC5E,CAAC,cAAc,CAAC,EAChB,IAAI,CAAC,YAAY,CAClB,CAAC;YACF,OAAO,QAAQ,CAAC,CAAC,CAAC,CAAC;SACpB;KAAA;;;;;;;;;;IAWK,uBAAuB,CAAC,eAAuB;;YACnD,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,iBAAiB,EACjB,eAAe,CAChB,CAAC;YACF,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,EAAE;gBACnC,eAAe,GAAG,CAAC,eAAe,CAAC,CAAC;aACrC;YACD,qCAAqC,CACnC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,iBAAiB,EACjB,eAAe,CAChB,CAAC;YAEF,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,uBAAuB,CAC5D,eAAe,EACf,IAAI,CAAC,YAAY,CAClB,CAAC;SACH;KAAA;;;;;;;;;IAUK,KAAK;;YACT,IAAI;gBACF,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;gBACtB,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE;;oBAErF,IAAI,IAAI,CAAC,QAAQ,CAAC,iBAAiB,EAAE;wBACnC,MAAM,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,KAAK,EAAE,CAAC;qBAC/C;;oBAGD,IAAI,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE;wBAClC,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC;qBAC9C;;oBAGD,IAAI,CAAC,QAAQ,CAAC,6BAA6B,CAAC,KAAK,EAAE,CAAC;iBACrD;aACF;YAAC,OAAO,GAAG,EAAE;gBACZR,KAAS,CACP,8DAA8D,EAC9D,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;IAMD,mBAAmB;QACjB,IAAI,IAAI,CAAC,QAAQ,CAAC,iBAAiB,IAAI,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,MAAM,EAAE,EAAE;YAC/E,OAAO,IAAI,CAAC;SACb;QACD,IACE,IAAI,CAAC,QAAQ,CAAC,gBAAgB;YAC9B,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,MAAM,EAAE;YACvC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,mBAAmB,EAClD;YACA,OAAO,IAAI,CAAC;SACb;QACD,OAAO,KAAK,CAAC;KACd;CACF;AAED;;;;;;;;AAQA,MAAa,eAAe;;;;;;IAoB1B,YACE,OAA4B,EAC5B,WAAwB,EACxB,cAAsC;;;;QAXhC,cAAS,GAAY,KAAK,CAAC;QAajC,4BAA4B,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAChD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,YAAY;YACf,WAAW,KAAKQ,mBAAW,CAAC,gBAAgB,GAAG,WAAW,GAAGA,mBAAW,CAAC,QAAQ,CAAC;QACpF,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;QAEtC,IAAI,cAAc,CAAC,SAAS,EAAE;YAC5B,cAAc,CAAC,SAAS,GAAG,MAAM,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;;YAG5D,IACE,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,cAAc,CAAC,SAAS,CAAC;gBACvD,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC,MAAM,EAAE,EAChE;gBACA,MAAM,YAAY,GAAG,uBAAuB,CAC1C,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,cAAc,CAAC,SAAS,CACzB,CAAC;gBACF,MAAML,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;gBACtCH,KAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;gBACjE,MAAMA,OAAK,CAAC;aACb;SACF;KACF;IAEO,kCAAkC;QACxC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QACtD,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,YAAY,GAAG,yBAAyB,CAC5C,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,IAAI,CAAC,QAAQ,CAAC,QAAQ,EACtB,IAAI,CAAC,SAAU,CAChB,CAAC;YACF,MAAMA,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtCH,KAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;YACjE,MAAMA,OAAK,CAAC;SACb;KACF;IAEa,kCAAkC;;YAC9C,IAAI,IAAI,CAAC,eAAe,EAAE;gBACxB,OAAO;aACR;YACD,IAAI,CAAC,QAAQ,CAAC,gBAAgB,GAAG,IAAI,CAAC;YACtC,IAAI,CAAC,eAAe,GAAG,MAAM,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAChE,SAAS,EAAE,IAAI,CAAC,eAAe,CAAC,SAAS;gBACzC,wCAAwC,EAAE,IAAI,CAAC,eAAe;qBAC3D,wCAAwC;gBAC3C,WAAW,EAAE,IAAI,CAAC,YAAY;aAC/B,CAAC,CAAC;;;YAGH,IAAI,IAAI,CAAC,eAAe,CAAC,SAAS,IAAI,IAAI,EAAE;gBAC1C,MAAMA,OAAK,GAAG,IAAI,KAAK,CAAC,8CAA8C,CAAC,CAAC;gBACxEH,KAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;gBACjE,MAAMA,OAAK,CAAC;aACb;YACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC;YACjD,OAAO,IAAI,CAAC,QAAQ,CAAC,sBAAsB,CAAC,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;SAC7E;KAAA;IAEO,wBAAwB;QAC9B,IAAI,IAAI,CAAC,mBAAmB,EAAE,EAAE;YAC9B,MAAM,YAAY,GAAG,2BAA2B,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YAC3F,MAAMA,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtCH,KAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;YACjE,MAAMA,OAAK,CAAC;SACb;KACF;;;;;IAMD,IAAW,WAAW;QACpB,OAAO,IAAI,CAAC,YAAY,CAAC;KAC1B;;;;;;IAOD,IAAW,QAAQ;QACjB,QACE,IAAI,CAAC,SAAS,KAAK,IAAI,CAAC,SAAS,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC,EAC3F;KACH;;;;;;IAOD,IAAW,SAAS;QAClB,OAAO,IAAI,CAAC,UAAU,CAAC;KACxB;;;;;;;;;;IAWD,IAAW,qBAAqB;QAC9B,OAAO,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC,qBAAqB,GAAG,SAAS,CAAC;KACtF;;;;;;;;;;;;;;;IAgBK,gBAAgB;;YACpB,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,MAAM,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAEhD,IAAI,CAAC,eAAgB,CAAC,qBAAqB,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,gBAAgB,CAClG,IAAI,CAAC,SAAU,CAChB,CAAC;YACF,OAAO,IAAI,CAAC,eAAgB,CAAC,qBAAsB,CAAC;SACrD;KAAA;;;;;;;;IASK,QAAQ,CAAC,KAAU;;YACvB,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,MAAM,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,eAAe,CAAC,IAAI,CAAC,SAAU,EAAE,KAAK,CAAC,CAAC;SAChF;KAAA;;;;;;;;IASK,QAAQ;;YACZ,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,MAAM,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,eAAe,CAAC,IAAI,CAAC,SAAU,CAAC,CAAC;SACzE;KAAA;;;;;;;;;;;;;;IAeK,IAAI,CAAC,eAAwB;;YACjC,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,MAAM,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,qBAAqB,CAAC,IAAI,CAAC,SAAU,EAAE,eAAe,CAAC,CAAC;SAChG;KAAA;;;;;;;;;;;;;IAcK,oBAAoB,CACxB,kBAAwB,EACxB,eAAwB;;YAExB,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,MAAM,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,oBAAoB,CACzD,kBAAkB,EAClB,eAAe,EACf,IAAI,CAAC,SAAS,CACf,CAAC;SACH;KAAA;;;;;;;;;;IAWK,sBAAsB,CAAC,cAAoB;;YAC/C,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,gBAAgB,EAChB,cAAc,CACf,CAAC;YACF,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,gBAAgB,EAChB,cAAc,CACf,CAAC;YAEF,MAAM,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAChD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,uBAAuB,CAC5E,CAAC,cAAc,CAAC,EAChB,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,SAAS,CACf,CAAC;YACF,OAAO,QAAQ,CAAC,CAAC,CAAC,CAAC;SACpB;KAAA;;;;;;;;;;IAWK,uBAAuB,CAAC,eAAuB;;YACnD,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,gCAAgC,CAC9B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,iBAAiB,EACjB,eAAe,CAChB,CAAC;YACF,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,EAAE;gBACnC,eAAe,GAAG,CAAC,eAAe,CAAC,CAAC;aACrC;YACD,qCAAqC,CACnC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,iBAAiB,EACjB,eAAe,CAChB,CAAC;YAEF,MAAM,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,uBAAuB,CAC5D,eAAe,EACf,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,SAAS,CACf,CAAC;SACH;KAAA;;;;;;;;;;;;;;;;;;IAmBK,eAAe,CACnB,eAAuB,EACvB,oBAA6B;;YAE7B,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAChC,MAAM,IAAI,CAAC,kCAAkC,EAAE,CAAC;YAChD,OAAO,IAAI,CAAC,eAAgB,CAAC,eAAe,CAAC,eAAe,EAAE,oBAAoB,CAAC,CAAC;SACrF;KAAA;;;;;;;;;;;;;;;;;;;;;;;IAwBD,sBAAsB,CACpB,SAAoB,EACpB,OAAgB,EAChB,OAAsC;QAEtC,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;QACpD,gCAAgC,CAAC,MAAM,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;QACjE,gCAAgC,CAAC,MAAM,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;QAC7D,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE;YACnC,MAAM,IAAI,SAAS,CAAC,uDAAuD,CAAC,CAAC;SAC9E;QACD,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;YACjC,MAAM,IAAI,SAAS,CAAC,qDAAqD,CAAC,CAAC;SAC5E;QAED,IAAI,CAAC,kCAAkC,EAAE;aACtC,IAAI,CAAC;YACJ,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;gBACzB,OAAO;aACR;YACD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;gBACnB,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;aAC3D;iBAAM;gBACL,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;aACpC;YACD,OAAO;SACR,CAAA,CAAC;aACD,KAAK,CAAC,CAAC,GAAG;YACT,OAAO,CAAC,GAAG,CAAC,CAAC;SACd,CAAC,CAAC;KACN;;;;;;;;;;;;;IAcM,kBAAkB;;YACvB,OAAO,IAAI,EAAE;gBACX,MAAM,YAAY,GAAG,oBAAM,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAA,CAAC;gBACnD,0BAAM,YAAY,CAAC,CAAC,CAAC,CAAA,CAAC;aACvB;SACF;KAAA;;;;;;;;;IAUK,KAAK;;YACT,IAAI;gBACF,IAAI,IAAI,CAAC,eAAe,EAAE;oBACxB,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;oBACnC,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;iBAClC;aACF;YAAC,OAAO,GAAG,EAAE;gBACZH,KAAS,CACP,mFAAmF,EACnF,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,QAAQ,CAAC,UAAU,EACxB,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;oBAAS;gBACR,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;aACvB;SACF;KAAA;;;;;IAMD,mBAAmB;QACjB,OAAO,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC,mBAAmB,GAAG,KAAK,CAAC;KAChF;CACF;;AC5xBD;AACA,AAkHA,MAAM,qBAAqB,GAAG;IAC5B,eAAe;IACf,WAAW;IACX,IAAI;IACJ,SAAS;IACT,OAAO;IACP,WAAW;IACX,kBAAkB;IAClB,aAAa;IACb,gBAAgB;CACjB,CAAC;AAqCF;;;;;;AAMA,MAAa,gBAAiB,SAAQ,UAAU;;;;;;;;IA6B9C,YAAY,OAA4B,EAAE,OAAiC;QACzE,KAAK,CAAC,GAAG,OAAO,CAAC,UAAU,cAAc,EAAE,OAAO,EAAE;YAClD,OAAO,EAAE,OAAO,IAAI,OAAO,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,GAAGE,oBAAS,CAAC,UAAU;YAC5E,QAAQ,EACN,OAAO,IAAI,OAAO,CAAC,QAAQ;kBACvB,OAAO,CAAC,QAAQ;kBAChB,GAAG,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,GAAG,OAAO,CAAC,UAAU,cAAc;SAC9E,CAAC,CAAC;QAnCI,mBAAc,GAAW,GAAGA,oBAAS,CAAC,oBAAoB,IAAIG,yBAAa,EAAE,EAAE,CAAC;;;;QASzF,YAAO,GAAWA,yBAAa,EAAE,CAAC;;;;;QAU1B,8BAAyB,GAAS,IAAI,CAAC,IAAI,CAAC;QAiBlD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,UAAoB,CAAC;KACjE;IAEa,KAAK;;YACjB,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,IAAI;gBACF,IAAI,CAAC,IAAI,CAAC,8BAA8B,EAAE,EAAE;oBAC1C,MAAM,IAAI,CAAC,eAAe,EAAE,CAAC;oBAC7B,MAAM,KAAK,GAAoB;wBAC7B,MAAM,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE;wBACjC,IAAI,EAAE,IAAI,CAAC,OAAO;wBAClB,MAAM,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE;wBACjC,cAAc,EAAE,CAAC,OAAqB;4BACpC,MAAM,EAAE,GAAG,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE,CAAC;4BACzC,MAAM,OAAO,GAAGM,oBAAS,CAAC,OAAO,CAAC,OAAQ,CAAC,KAAM,CAAC,CAAC;4BACnDX,KAAS,CACP,uEAAuE;gCACrE,iBAAiB,EACnB,EAAE,EACF,OAAO,CACR,CAAC;yBACH;qBACF,CAAC;oBACF,MAAM,KAAK,GAAkB,EAAE,MAAM,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,EAAE,CAAC;oBACnE+B,IAAQ,CACN,iFAAiF;wBAC/E,+BAA+B,EACjC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,KAAK,EACL,KAAK,CACN,CAAC;oBACF,IAAI,CAAC,eAAe,GAAG,MAAMC,8BAAmB,CAAC,MAAM,CACrD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,EAClC,KAAK,EACL,KAAK,CACN,CAAC;oBACF,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,EAAE,CAACf,wBAAY,CAAC,WAAW,EAAE,CAAC,OAAqB;wBAC7E,MAAM,EAAE,GAAG,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE,CAAC;wBACzC,MAAM,OAAO,GAAGN,oBAAS,CAAC,OAAO,CAAC,MAAO,CAAC,KAAM,CAAC,CAAC;wBAClDX,KAAS,CAAC,4DAA4D,EAAE,EAAE,EAAE,OAAO,CAAC,CAAC;qBACtF,CAAC,CAAC;oBACH,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE,CAAC0B,0BAAc,CAAC,aAAa,EAAE,CAAC,OAAqB;wBACnF,MAAM,EAAE,GAAG,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE,CAAC;wBACzC,MAAM,OAAO,GAAGf,oBAAS,CAAC,OAAO,CAAC,QAAS,CAAC,KAAM,CAAC,CAAC;wBACpDX,KAAS,CAAC,8DAA8D,EAAE,EAAE,EAAE,OAAO,CAAC,CAAC;qBACxF,CAAC,CAAC;oBACH+B,IAAQ,CACN,4EAA4E,EAC5E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,EAChC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,IAAI,CACnC,CAAC;oBACF,MAAM,IAAI,CAAC,mBAAmB,EAAE,CAAC;iBAClC;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ,GAAG,GAAGpB,oBAAS,CAAC,GAAG,CAAC,CAAC;gBACrBX,KAAS,CACP,oEAAoE,EACpE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;IAEO,8BAA8B;QACpC,OAAO,IAAI,CAAC,eAAgB,IAAI,IAAI,CAAC,eAAgB,CAAC,MAAM,EAAE,CAAC;KAChE;;;;IAKO,6BAA6B,CAAC,IAAa,EAAE,KAAa;QAChE,OAAO,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,GAAG,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC;cAC5D,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK;cACjB,SAAS,CAAC;KACf;;;;;;IAOO,0BAA0B,CAChC,mBAAwC,EACxC,SAAkB;QAElB,IAAI,SAAS,IAAI,SAAS,EAAE;YAC1B,IAAI,mBAAmB,CAAC,eAAe,CAAC,SAAS,CAAC,EAAE;gBAClD,OAAO,mBAAmB,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC;aAC5D;SACF;QACD,IAAI,mBAAmB,CAAC,gBAAgB,EAAE;YACxC,OAAO,mBAAmB,CAAC,gBAAgB,CAAC,IAAI,CAAC;SAClD;QACD,IAAI,mBAAmB,CAAC,iBAAiB,EAAE;YACzC,OAAO,mBAAmB,CAAC,iBAAiB,CAAC,IAAI,CAAC;SACnD;QACD,OAAO;KACR;;;;;;IAOK,KAAK;;YACT,IAAI;gBACF,IAAI,IAAI,CAAC,8BAA8B,EAAE,EAAE;oBACzC,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC;oBACtC,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;oBACjC,YAAY,CAAC,IAAI,CAAC,kBAAkC,CAAC,CAAC;oBACtD,MAAM,QAAS,CAAC,KAAK,EAAE,CAAC;oBACxB+B,IAAQ,CAAC,6CAA6C,CAAC,CAAC;iBACzD;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ/B,KAAS,CACP,kEAAkE,EAClE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;;;;;;;;IAaK,IAAI,CAAC,YAAqB;;YAC9B,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,OAAO,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC;SACvF;KAAA;;;;;;;;;;;;;IAcK,qBAAqB,CACzB,SAAiB,EACjB,YAAqB;;YAErB,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,OAAO,IAAI,CAAC,oBAAoB,CAC9B,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,CAAC,CAAC,EACrC,YAAY,EACZ,SAAS,CACV,CAAC;SACH;KAAA;;;;;;;;IASK,oBAAoB,CACxB,kBAAwB,EACxB,eAAwB,EACxB,SAAkB;;YAElB,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;;YAGpD,gCAAgC,CAAC,MAAM,EAAE,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;YACnF,gCAAgC,CAAC,MAAM,EAAE,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;;YAGnF,IAAI,eAAe,KAAK,SAAS,EAAE;gBACjC,qCAAqC,CAAC,MAAM,EAAE,iBAAiB,EAAE,eAAe,EAAE,QAAQ,CAAC,CAAC;gBAC5F,IAAI,eAAe,IAAI,CAAC,EAAE;oBACxB,OAAO,EAAE,CAAC;iBACX;aACF;iBAAM;gBACL,eAAe,GAAG,CAAC,CAAC;aACrB;YAED,MAAM,WAAW,GAA0B,EAAE,CAAC;YAC9C,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,WAAW,CAACE,oBAAS,CAAC,kBAAkB,CAAC,GAAG+B,iBAAK,CAAC,SAAS,CACzD3B,aAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,SAAS,EAAE,CAAC,CAC5C,CAAC;gBACF,WAAW,CAACJ,oBAAS,CAAC,YAAY,CAAC,GAAG+B,iBAAK,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC;gBACtE,IAAI,SAAS,IAAI,SAAS,EAAE;oBAC1B,WAAW,CAAC/B,oBAAS,CAAC,eAAe,CAAC,GAAG,SAAS,CAAC;iBACpD;gBACD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,UAAU,EAAEG,yBAAa,EAAE;oBAC3B,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEH,oBAAS,CAAC,UAAU,CAAC,WAAW;qBAC5C;iBACF,CAAC;gBACF,MAAM,kBAAkB,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;gBACrF,IAAI,kBAAkB,EAAE;oBACtB,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,kBAAkB,CAAC,GAAG,kBAAkB,CAAC;iBACpF;gBACD,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBACxE0B,IAAQ,CACN,gDAAgD,EAChD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBAEH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;gBAChE,IAAI,MAAM,CAAC,sBAAuB,CAAC,UAAU,KAAK,GAAG,EAAE;oBACrD,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,QAAiC,CAAC;oBAC/D,KAAK,MAAM,GAAG,IAAI,QAAQ,EAAE;wBAC1B,MAAM,cAAc,GAAGO,mBAAe,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;wBAC3D,MAAM,OAAO,GAAG,eAAe,CAAC,cAAqB,CAAC,CAAC;wBACvD,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,eAAe,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;wBAC5E,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;wBAC1B,IAAI,CAAC,yBAAyB,GAAG,OAAO,CAAC,cAAe,CAAC;qBAC1D;iBACF;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMlB,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,kEAAkE;oBAChE,0BAA0B,EAC5BG,OAAK,CACN,CAAC;;gBAEF,IAAIA,OAAK,CAAC,IAAI,KAAKsB,mCAAwB,CAAC,iCAAiC,CAAC,EAAE;oBAC9E,MAAMtB,OAAK,CAAC;iBACb;aACF;YACD,OAAO,WAAW,CAAC;SACpB;KAAA;;;;;;;;;;;;;;;IAgBK,SAAS,CAAC,SAAiB,EAAE,OAA4B;;YAC7D,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,IAAI,CAAC,OAAO;gBAAE,OAAO,GAAG,EAAE,CAAC;YAC3B,IAAI,OAAO,CAAC,cAAc,IAAI,IAAI;gBAAE,OAAO,CAAC,cAAc,GAAG,CAAC,CAAC;YAC/D,IAAI,OAAO,CAAC,gBAAgB,IAAI,IAAI;gBAAE,OAAO,CAAC,gBAAgB,GAAG,CAAC,CAAC;YACnE,IAAI,OAAO,CAAC,KAAK,IAAI,IAAI;gBAAE,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC;YAE7C,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAE5B,WAAW,CAACD,oBAAS,CAAC,UAAU,CAAC,GAAG+B,iBAAK,CAAC,UAAU,CAClD,CAACC,0BAAc,CAAC,SAAS,CAAC,CAAC,EAC3B,IAAI,EACJ,SAAS,CACV,CAAC;gBACF,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEhC,oBAAS,CAAC,UAAU,CAAC,SAAS;qBAC1C;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBACxE,MAAM,kBAAkB,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC1E,IAAI,kBAAkB,EAAE;oBACtB,OAAO,CAAC,sBAAuB,CAACH,oBAAS,CAAC,kBAAkB,CAAC,GAAG,kBAAkB,CAAC;iBACpF;gBACD6B,IAAQ,CACN,sCAAsC,EACtC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CACR,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBACH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gBACzE,MAAM,cAAc,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC5D,OAAO,cAAc,CAAC;aACvB;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMX,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,wEAAwE,GAAG,cAAc,EACzFG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;;;;;;;;IASK,gBAAgB,CACpB,uBAA6B,EAC7B,QAA+B;;YAE/B,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,MAAM,WAAW,GAAU,EAAE,CAAC;YAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACxC,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACzB,IAAI,CAAC,IAAI,CAAC,SAAS;oBAAE,IAAI,CAAC,SAAS,GAAGE,yBAAa,EAAE,CAAC;gBACtD,IAAI,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;gBACvD,MAAM,WAAW,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;gBAExC,IAAI;oBACF,MAAM,KAAK,GAAQ;wBACjB,OAAO,EAAEgB,mBAAe,CAAC,MAAM,CAAC,WAAW,CAAC;wBAC5C,YAAY,EAAE,IAAI,CAAC,SAAS;qBAC7B,CAAC;oBACF,IAAI,IAAI,CAAC,SAAS,EAAE;wBAClB,KAAK,CAACnB,oBAAS,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;qBACnD;oBACD,IAAI,IAAI,CAAC,YAAY,EAAE;wBACrB,KAAK,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC;qBAC5C;oBACD,IAAI,IAAI,CAAC,eAAe,EAAE;wBACxB,KAAK,CAAC,mBAAmB,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC;qBACnD;oBAED,MAAM,YAAY,GAAG+B,iBAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;oBAC3C,WAAW,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;iBAChC;gBAAC,OAAO,GAAG,EAAE;oBACZ,IAAI9B,OAAY,CAAC;oBACjB,IAAI,GAAG,YAAY,SAAS,IAAI,GAAG,CAAC,IAAI,KAAK,WAAW,EAAE;;;;;wBAKxDA,OAAK,GAAGQ,oBAAS,CAAC,mCAAmC,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;qBACrE;yBAAM;wBACLR,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;qBACxB;oBACDX,KAAS,CACP,gFAAgF,GAAG,MAAM,EACzF,CAAC,EACDG,OAAK,CACN,CAAC;oBACF,MAAMA,OAAK,CAAC;iBACb;aACF;YACD,IAAI;gBACF,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,EAAE,QAAQ,EAAE,WAAW,EAAE;oBAC/B,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAED,oBAAS,CAAC,UAAU,CAAC,eAAe;qBAChD;iBACF,CAAC;gBACF,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;oBACxB,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAO,CAAC,IAAI,CAAC;iBAC5F;gBACD,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBACxE0B,IAAQ,CACN,0CAA0C,EAC1C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBACH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;gBAChE,MAAM,eAAe,GAAG,MAAM,CAAC,IAAI,CAACZ,oBAAS,CAAC,eAAe,CAAC,CAAC;gBAC/D,MAAM,qBAAqB,GAAG,EAAE,CAAC;gBACjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC/C,IAAI,OAAO,eAAe,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;wBAC1C,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;qBACjE;yBAAM;wBACL,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;qBAClE;iBACF;gBACD,OAAO,qBAAqB,CAAC;aAC9B;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMC,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,sEAAsE;oBACpE,0BAA0B,EAC5BG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;;;;;;IAOK,uBAAuB,CAAC,eAAuB;;YACnD,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,MAAM,WAAW,GAAQ,EAAE,CAAC;YAC5B,WAAW,CAACD,oBAAS,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC;YAC5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC/C,MAAM,cAAc,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;gBAC1C,IAAI;oBACF,WAAW,CAACA,oBAAS,CAAC,eAAe,CAAC,CAAC,IAAI,CAACI,aAAM,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;iBACtF;gBAAC,OAAO,GAAG,EAAE;oBACZ,MAAMH,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;oBAC7BX,KAAS,CACP,kEAAkE;wBAChE,2BAA2B,EAC7B,CAAC,EACDG,OAAK,CACN,CAAC;oBACF,MAAMA,OAAK,CAAC;iBACb;aACF;YAED,IAAI;gBACF,WAAW,CAACD,oBAAS,CAAC,eAAe,CAAC,GAAG+B,iBAAK,CAAC,UAAU,CACvD,WAAW,CAAC/B,oBAAS,CAAC,eAAe,CAAC,EACtC,IAAI,EACJ,SAAS,CACV,CAAC;gBACF,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,UAAU,EAAEG,yBAAa,EAAE;oBAC3B,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEH,oBAAS,CAAC,UAAU,CAAC,sBAAsB;qBACvD;iBACF,CAAC;gBAEF,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;oBACxB,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAO,CAAC,IAAI,CAAC;iBAC5F;gBACD,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBACxE0B,IAAQ,CACN,kDAAkD,EAClD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBACH,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;aAClD;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMX,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,iFAAiF;oBAC/E,0BAA0B,EAC5BG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;;;;;;;;;;IAWK,uBAAuB,CAC3B,eAAuB,EACvB,WAAwB,EACxB,SAAkB;;YAElB,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YAEtD,MAAM,WAAW,GAAwB,EAAE,CAAC;YAC5C,MAAM,WAAW,GAAQ,EAAE,CAAC;YAC5B,WAAW,CAACD,oBAAS,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC;YAC5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC/C,MAAM,cAAc,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;gBAC1C,IAAI;oBACF,WAAW,CAACA,oBAAS,CAAC,eAAe,CAAC,CAAC,IAAI,CAACI,aAAM,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;iBACtF;gBAAC,OAAO,GAAG,EAAE;oBACZ,MAAMH,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;oBAC7BX,KAAS,CACP,kEAAkE;wBAChE,2BAA2B,EAC7B,CAAC,EACDG,OAAK,CACN,CAAC;oBACF,MAAMA,OAAK,CAAC;iBACb;aACF;YAED,IAAI;gBACF,WAAW,CAACD,oBAAS,CAAC,eAAe,CAAC,GAAG+B,iBAAK,CAAC,UAAU,CACvD,WAAW,CAAC/B,oBAAS,CAAC,eAAe,CAAC,EACtC,IAAI,EACJ,SAAS,CACV,CAAC;gBACF,MAAM,kBAAkB,GAAW,WAAW,KAAKM,mBAAW,CAAC,gBAAgB,GAAG,CAAC,GAAG,CAAC,CAAC;gBACxF,WAAW,CAACN,oBAAS,CAAC,kBAAkB,CAAC,GAAG+B,iBAAK,CAAC,SAAS,CAAC,kBAAkB,CAAC,CAAC;gBAChF,IAAI,SAAS,IAAI,IAAI,EAAE;oBACrB,WAAW,CAAC/B,oBAAS,CAAC,eAAe,CAAC,GAAG,SAAS,CAAC;iBACpD;gBACD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,UAAU,EAAEG,yBAAa,EAAE;oBAC3B,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEH,oBAAS,CAAC,UAAU,CAAC,uBAAuB;qBACxD;iBACF,CAAC;gBACF,MAAM,kBAAkB,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;gBACrF,IAAI,kBAAkB,EAAE;oBACtB,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,kBAAkB,CAAC,GAAG,kBAAkB,CAAC;iBACpF;gBACD,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBACxE0B,IAAQ,CACN,kDAAkD,EAClD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBAEH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;gBAChE,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,QAG1B,CAAC;gBACJ,KAAK,MAAM,GAAG,IAAI,QAAQ,EAAE;oBAC1B,MAAM,cAAc,GAAGO,mBAAe,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;oBAC3D,MAAM,OAAO,GAAG,IAAI,iBAAiB,CACnC,IAAI,CAAC,QAAQ,EACb,cAAqB,EACrB,EAAE,GAAG,EAAE,GAAG,CAAC,YAAY,CAAC,EAAS,EACjC,KAAK,CACN,CAAC;oBACF,IAAI,OAAO,CAAC,SAAS,IAAI,OAAO,CAAC,cAAc,EAAE;wBAC/C,IAAI,CAAC,QAAQ,CAAC,6BAA6B,CAAC,GAAG,CAC7C,OAAO,CAAC,SAAS,EACjB,OAAO,CAAC,cAAc,CACvB,CAAC;qBACH;oBACD,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBAC3B;gBACD,OAAO,WAAW,CAAC;aACpB;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMlB,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,8EAA8E;oBAC5E,0BAA0B,EAC5BG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;;;;;;;;;;IAWK,uBAAuB,CAC3B,SAAiB,EACjB,iBAAoC,EACpC,OAAkC;;YAElC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YAEtD,IAAI,CAAC,OAAO;gBAAE,OAAO,GAAG,EAAE,CAAC;YAC3B,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,MAAM,eAAe,GAAa,EAAE,CAAC;gBACrC,eAAe,CAAC,IAAI,CAAC+B,0BAAc,CAAC,SAAS,CAAC,CAAC,CAAC;gBAChD,WAAW,CAAChC,oBAAS,CAAC,UAAU,CAAC,GAAG+B,iBAAK,CAAC,UAAU,CAAC,eAAe,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;gBACvF,WAAW,CAAC/B,oBAAS,CAAC,iBAAiB,CAAC,GAAG,iBAAiB,CAAC;gBAC7D,IAAI,OAAO,CAAC,qBAAqB,IAAI,IAAI,EAAE;oBACzC,WAAW,CAACA,oBAAS,CAAC,qBAAqB,CAAC,GAAG,OAAO,CAAC,qBAAqB,CAAC;iBAC9E;gBACD,IAAI,OAAO,CAAC,gBAAgB,IAAI,IAAI,EAAE;oBACpC,WAAW,CAACA,oBAAS,CAAC,gBAAgB,CAAC,GAAG,OAAO,CAAC,gBAAgB,CAAC;iBACpE;gBACD,IAAI,OAAO,CAAC,kBAAkB,IAAI,IAAI,EAAE;oBACtC,WAAW,CAACA,oBAAS,CAAC,kBAAkB,CAAC,GAAG,OAAO,CAAC,kBAAkB,CAAC;iBACxE;gBACD,IAAI,OAAO,CAAC,SAAS,IAAI,IAAI,EAAE;oBAC7B,WAAW,CAACA,oBAAS,CAAC,eAAe,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC;iBAC5D;gBACD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,UAAU,EAAEG,yBAAa,EAAE;oBAC3B,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEH,oBAAS,CAAC,UAAU,CAAC,iBAAiB;qBAClD;iBACF,CAAC;gBACF,MAAM,kBAAkB,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;gBAC7F,IAAI,kBAAkB,EAAE;oBACtB,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,kBAAkB,CAAC,GAAG,kBAAkB,CAAC;iBACpF;gBACD,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBACxE0B,IAAQ,CACN,kDAAkD,EAClD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBACH,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;aAClD;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMX,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,8EAA8E;oBAC5E,0BAA0B,EAC5BG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;;;;;;;IAQK,gBAAgB,CAAC,SAAiB,EAAE,OAA4B;;YACpE,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,IAAI,CAAC,OAAO;gBAAE,OAAO,GAAG,EAAE,CAAC;YAC3B,IAAI,OAAO,CAAC,cAAc,IAAI,IAAI;gBAAE,OAAO,CAAC,cAAc,GAAG,CAAC,CAAC;YAC/D,IAAI,OAAO,CAAC,gBAAgB,IAAI,IAAI;gBAAE,OAAO,CAAC,gBAAgB,GAAG,CAAC,CAAC;YACnE,IAAI,OAAO,CAAC,KAAK,IAAI,IAAI;gBAAE,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC;YAC7C,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,WAAW,CAACD,oBAAS,CAAC,eAAe,CAAC,GAAG,SAAS,CAAC;gBACnD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEA,oBAAS,CAAC,UAAU,CAAC,gBAAgB;qBACjD;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBACxE,MAAM,kBAAkB,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;gBACrF,IAAI,kBAAkB,EAAE;oBACtB,OAAO,CAAC,sBAAuB,CAACH,oBAAS,CAAC,kBAAkB,CAAC,GAAG,kBAAkB,CAAC;iBACpF;gBACD6B,IAAQ,CACN,2CAA2C,EAC3C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBACH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gBACzE,MAAM,cAAc,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBACxDiB,IAAQ,CACN,+CAA+C,EAC/C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,SAAS,EACT,cAAc,CAAC,QAAQ,EAAE,CAC1B,CAAC;gBACF,OAAO,cAAc,CAAC;aACvB;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM5B,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,wEAAwE,GAAG,cAAc,EACzFG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;;;;;;;IAQK,eAAe,CAAC,SAAiB,EAAE,KAAU;;YACjD,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YAEtD,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,WAAW,CAACD,oBAAS,CAAC,eAAe,CAAC,GAAG,SAAS,CAAC;gBACnD,WAAW,CAAC,eAAe,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;gBAC/C,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEA,oBAAS,CAAC,UAAU,CAAC,eAAe;qBAChD;iBACF,CAAC;gBACF,MAAM,kBAAkB,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;gBACrF,IAAI,kBAAkB,EAAE;oBACtB,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,kBAAkB,CAAC,GAAG,kBAAkB,CAAC;iBACpF;gBACD,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBACxE0B,IAAQ,CACN,0CAA0C,EAC1C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBACH,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;aAClD;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMX,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,wEAAwE,GAAG,cAAc,EACzFG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;;;;;;IAOK,eAAe,CAAC,SAAiB;;YACrC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,WAAW,CAACD,oBAAS,CAAC,eAAe,CAAC,GAAG,SAAS,CAAC;gBACnD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAEA,oBAAS,CAAC,UAAU,CAAC,eAAe;qBAChD;iBACF,CAAC;gBACF,MAAM,kBAAkB,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;gBACrF,IAAI,kBAAkB,EAAE;oBACtB,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,kBAAkB,CAAC,GAAG,kBAAkB,CAAC;iBACpF;gBACD,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBACxE0B,IAAQ,CACN,0CAA0C,EAC1C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBACH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;gBAChE,OAAO,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC;sBAC/B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,eAAe,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;sBAC5E,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;aAClC;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMX,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,wEAAwE,GAAG,cAAc,EACzFG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;;;;;;;;IASK,mBAAmB,CAAC,IAAY,EAAE,GAAW,EAAE,eAAsB;;YACzE,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,MAAM,wCAAwC,GAAW,SAAS,CAAC;YACnE,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;gBAC5B,MAAM,IAAI,KAAK,CAAC,8DAA8D,CAAC,CAAC;aACjF;YACD,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;gBAC3B,MAAM,IAAI,KAAK,CAAC,6DAA6D,CAAC,CAAC;aAChF;YACD,IAAI,eAAe,IAAI,EAAE,eAAe,YAAY,IAAI,CAAC,EAAE;gBACzD,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;aAC9D;YACD,IAAI,CAAC,eAAe,EAAE;gBACpB,eAAe,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,wCAAwC,CAAC,CAAC;aACnF;YACD,IAAI;gBACF,MAAM,WAAW,GAAQ,EAAE,CAAC;gBAC5B,WAAW,CAAC,mBAAmB,CAAC,GAAG,eAAe,CAAC;gBACnD,WAAW,CAAC,MAAM,CAAC,GAAG8B,iBAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAC3C,WAAW,CAAC,KAAK,CAAC,GAAGA,iBAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;gBACzC,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE,WAAW;oBACjB,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAE/B,oBAAS,CAAC,UAAU,CAAC,iBAAiB;qBAClD;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBACxE0B,IAAQ,CACN,sCAAsC,EACtC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBACH,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;gBAElE,OAAO,CAAC,QAAQ,IAAI,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;aAC3E;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMX,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,wEAAwE,GAAG,cAAc,EACzFG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;;;;;IAMK,QAAQ;;YACZ,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,IAAI;gBACF,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE;wBACJ,GAAG,EAAE8B,iBAAK,CAAC,QAAQ,CAAC,cAAc,CAAC;wBACnC,IAAI,EAAEA,iBAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;qBACxB;oBACD,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAE/B,oBAAS,CAAC,UAAU,CAAC,cAAc;qBAC/C;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBAExE0B,IAAQ,CACN,kCAAkC,EAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBAEH,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;gBAClE,IACE,QAAQ,CAAC,sBAAuB,CAAC,UAAU,KAAK,GAAG;oBACnD,CAAC,QAAQ,CAAC,IAAI;oBACd,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,EACnC;oBACA,OAAO,EAAE,CAAC;iBACX;;gBAGD,MAAM,MAAM,GAAoC,QAAQ,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;gBAC1E,MAAM,KAAK,GAAsB,EAAE,CAAC;gBACpC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;oBACf,MAAM,cAAc,GAAG,CAAC,CAAC,kBAAkB,CAAC,CAAC;;oBAG7C,IACE,CAAC,cAAc;wBACf,CAAC,cAAc,CAAC,UAAU;wBAC1B,cAAc,CAAC,UAAU,CAAC,KAAK,KAAKZ,oBAAS,CAAC,eAAe,CAAC,mBAAmB;wBACjF,CAAC,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC;wBACpC,cAAc,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAC/B;wBACA,OAAO;qBACR;oBAED,MAAM,cAAc,GAAU,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBACtD,MAAM,cAAc,GAAU,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBACtD,MAAM,IAAI,GAAoB;wBAC5B,IAAI,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK;qBACpC,CAAC;oBAEF,QAAQ,cAAc,CAAC,UAAU,CAAC,KAAK;wBACrC,KAAKA,oBAAS,CAAC,eAAe,CAAC,cAAc;4BAC3C,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;4BACpB,MAAM;wBACR,KAAKA,oBAAS,CAAC,eAAe,CAAC,eAAe;4BAC5C,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;4BACpB,MAAM;wBACR,KAAKA,oBAAS,CAAC,eAAe,CAAC,aAAa;4BAC1C,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;4BAC1E,MAAM;wBACR,KAAKA,oBAAS,CAAC,eAAe,CAAC,qBAAqB;4BAClD,IAAI,CAAC,MAAM,GAAG;gCACZ,aAAa,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCAC1E,SAAS,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCACtE,EAAE,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCAC/D,OAAO,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCACpE,KAAK,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCAClE,SAAS,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCACtE,gBAAgB,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCAC7E,WAAW,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;gCACxE,cAAc,EAAE,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC;6BAC5E,CAAC;4BACF,MAAM;wBACR;4BACE6B,IAAQ,CACN,oDAAoD,cAAc,CAAC,UAAU,CAAC,KAAK,EAAE,CACtF,CAAC;4BACF,MAAM;qBACT;oBAED,IACE,cAAc,CAAC,UAAU,CAAC,KAAK,KAAK7B,oBAAS,CAAC,eAAe,CAAC,iBAAiB;wBAC/E,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC;wBACnC,cAAc,CAAC,KAAK,CAAC,MAAM,EAC3B;wBACA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;qBAC3E;oBAED,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAClB,CAAC,CAAC;gBAEH,OAAO,KAAK,CAAC;aACd;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMC,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,uEAAuE,GAAG,cAAc,EACxFG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;;;;;IAMK,UAAU,CAAC,QAAgB;;YAC/B,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YACtD,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;YAC7F,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC5B,sCAAsC,CACpC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,UAAU,EACV,QAAQ,CACT,CAAC;YAEF,IAAI;gBACF,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE;wBACJ,WAAW,EAAE8B,iBAAK,CAAC,WAAW,CAAC,QAAQ,CAAC;qBACzC;oBACD,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAE/B,oBAAS,CAAC,UAAU,CAAC,UAAU;qBAC3C;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBAExE0B,IAAQ,CACN,oCAAoC,EACpC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBAEH,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;aAClD;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMX,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,yEAAyE,GAAG,cAAc,EAC1FG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;;;;;;;IAQK,OAAO,CACX,QAAgB,EAChB,MAA4C,EAC5C,uBAAgC;;YAEhC,4BAA4B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YAEtD,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;YAC7F,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC5B,sCAAsC,CACpC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,UAAU,EACV,QAAQ,CACT,CAAC;YAEF,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;YACzF,IACE,OAAO,MAAM,KAAK,SAAS;gBAC3B,OAAO,MAAM,KAAK,QAAQ;gBAC1B,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,aAAa,KAAK,MAAM,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC,EACpF;gBACA,MAAM,IAAI,SAAS,CACjB,yGAAyG,CAC1G,CAAC;aACH;YAED,IAAI;gBACF,MAAM,eAAe,GAAQ,EAAE,CAAC;gBAChC,QAAQ,OAAO,MAAM;oBACnB,KAAK,SAAS;wBACZ,eAAe,CAAC,YAAY,CAAC,GAAG;4BAC9B,UAAU,EAAE,MAAM,GAAG,KAAK,GAAG,KAAK;yBACnC,CAAC;wBACF,MAAM;oBACR,KAAK,QAAQ;wBACX,eAAe,CAAC,YAAY,CAAC,GAAG;4BAC9B,UAAU,EAAE,MAAM;yBACnB,CAAC;wBACF,MAAM;oBACR;wBACE,eAAe,CAAC,oBAAoB,CAAC,GAAG;4BACtC,gBAAgB,EAAE,MAAM,CAAC,aAAa;4BACtC,YAAY,EAAE,MAAM,CAAC,SAAS;4BAC9B,EAAE,EAAE,MAAM,CAAC,EAAE;4BACb,UAAU,EAAE,MAAM,CAAC,OAAO;4BAC1B,KAAK,EAAE,MAAM,CAAC,KAAK;4BACnB,YAAY,EAAE,MAAM,CAAC,SAAS;4BAC9B,qBAAqB,EAAE,MAAM,CAAC,gBAAgB;4BAC9C,cAAc,EAAE,MAAM,CAAC,WAAW;4BAClC,UAAU,EAAE,MAAM,CAAC,cAAc;yBAClC,CAAC;wBACF,MAAM;iBACT;gBAED,IAAI,uBAAuB,KAAK,SAAS,EAAE;oBACzC,eAAe,CAAC,iBAAiB,CAAC,GAAG;wBACnC,UAAU,EAAE,MAAM,CAAC,uBAAuB,CAAC;qBAC5C,CAAC;iBACH;gBACD,MAAM,OAAO,GAAgB;oBAC3B,IAAI,EAAE;wBACJ,WAAW,EAAE8B,iBAAK,CAAC,WAAW,CAAC,QAAQ,CAAC;wBACxC,kBAAkB,EAAEA,iBAAK,CAAC,QAAQ,CAAC,eAAe,CAAC;qBACpD;oBACD,QAAQ,EAAE,IAAI,CAAC,OAAO;oBACtB,sBAAsB,EAAE;wBACtB,SAAS,EAAE/B,oBAAS,CAAC,UAAU,CAAC,OAAO;qBACxC;iBACF,CAAC;gBACF,OAAO,CAAC,sBAAuB,CAACA,oBAAS,CAAC,UAAU,CAAC,GAAGG,yBAAa,EAAE,CAAC;gBAExE0B,IAAQ,CACN,iCAAiC,EACjC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,OAAO,CAAC,IAAI,CACb,CAAC;gBACFA,IAAQ,CACN,yDAAyD,EACzD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CACrC,CAAC;gBACF,MAAMjB,sBAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE;oBAC7C,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;iBACrB,CAAC,CAAC;gBAEH,MAAM,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;aAClD;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAMX,OAAK,GAAGQ,oBAAS,CAAC,GAAG,CAAC,CAAC;gBAC7BX,KAAS,CACP,sEAAsE,GAAG,cAAc,EACvFG,OAAK,CACN,CAAC;gBACF,MAAMA,OAAK,CAAC;aACb;SACF;KAAA;CACF;;AC10CD;AACA,AAMA;;;;;AAKA,MAAa,qBAAqB;IAOhC,YAAY,OAAmD;QAN9C,SAAI,GAAoB,IAAI,GAAG,EAAE,CAAC;QAC3C,sBAAiB,GAAY,KAAK,CAAC;QAEnC,YAAO,GAAWE,yBAAa,EAAE,CAAC;QAClC,eAAU,GAAc,IAAI8B,oBAAS,CAAC,EAAE,UAAU,EAAE,OAAO,EAAE,CAAC,CAAC;QAGrE,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,6BAA6B,GAAG,OAAO,CAAC,4BAA4B,IAAI,EAAE,CAAC;KACjF;IAEa,gBAAgB;;YAC5B,IAAI,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,EAAE;gBAClD,OAAO;aACR;YAED,MAAM,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE;gBAC1C,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;gBAC9B,IAAI,CAAC,sBAAsB,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG;oBACtCnC,KAAS,CAAC,wDAAwD,EAAE,GAAG,CAAC,CAAC;iBAC1E,CAAC,CAAC;aACJ,CAAC,CAAC;SACJ;KAAA;IAEa,sBAAsB;;YAClC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,EAAE;gBACxB,OAAO;aACR;YAED,MAAMC,gBAAK,CAAC,IAAI,CAAC,6BAA6B,CAAC,CAAC;YAChD,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;YAC/B,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE;gBAClC,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC,OAAO,EAAE,EAAE;oBAC9C,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;oBACtBmC,GAAO,CAAC,oCAAoC,EAAE,GAAG,CAAC,CAAC;iBACpD;aACF;YACD,IAAI,CAAC,gBAAgB,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG;gBAChCpC,KAAS,CACP,wDAAwD,GAAG,gCAAgC,EAC3F,GAAG,CACJ,CAAC;aACH,CAAC,CAAC;SACJ;KAAA;;;;;;;IAQD,GAAG,CAAC,GAAS,EAAE,UAAgB;QAC7B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;QAC/B,IAAI,CAAC,gBAAgB,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG;YAChCA,KAAS,CACP,wDAAwD,GAAG,2BAA2B,EACtF,GAAG,EACH,GAAG,CACJ,CAAC;SACH,CAAC,CAAC;KACJ;;;;;;IAOD,GAAG,CAAC,GAAS;QACX,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAS,CAAC;QACzC,MAAM,MAAM,GAAY,KAAK,IAAI,KAAK,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC9DoC,GAAO,CAAC,uCAAuC,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;QAC9D,OAAO,MAAM,CAAC;KACf;;;;;;IAOD,MAAM,CAAC,GAAS;QACdA,GAAO,CAAC,gCAAgC,EAAE,GAAG,CAAC,CAAC;QAC/C,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;KAC9B;;;;IAKD,KAAK;QACHA,GAAO,CAAC,qCAAqC,CAAC,CAAC;QAC/C,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;KACnB;CACF;;ACxGD;AACA;AAEA;;;;;AAKA,MAAa,SAAS;IAOpB,YAAY,KAAa;QAFjB,WAAM,GAA+D,EAAE,CAAC;QACxE,UAAK,GAAW,CAAC,CAAC;QAExB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC7B,MAAM,IAAI,SAAS,CAAC,sCAAsC,OAAO,KAAK,EAAE,CAAC,CAAC;SAC3E;QAED,IAAI,KAAK,GAAG,CAAC,EAAE;YACb,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;SAChD;QACD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;KACpB;;;;;IAMD,OAAO;QACL,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE;YAC3B,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC;YAChB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;SAC1B;QAED,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO;YACzB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SAC3B,CAAC,CAAC;KACJ;;;;IAKD,OAAO;QACL,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACtB,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;YACjC,IAAI,IAAI,EAAE;gBACR,IAAI,EAAE,CAAC;aACR;SACF;aAAM;YACL,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC;SACjB;KACF;;;;;;;IAQD,GAAG,CAAI,EAA4B;QACjC,OAAO,IAAI,CAAC,OAAO,EAAE;aAClB,IAAI,CAAC,EAAE,CAAC;aACR,IAAI,CAAC,CAAC,GAAG;YACR,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,GAAG,CAAC;SACZ,CAAC;aACD,KAAK,CAAC,CAAC,GAAG;YACT,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,MAAM,GAAG,CAAC;SACX,CAAC,CAAC;KACN;;;;IAKD,gBAAgB;QACd,OAAO,IAAI,CAAC,KAAK,CAAC;KACnB;;;;IAKD,gBAAgB;QACd,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;KAC3B;CACF;;ACvFD;AACA,AAUA;;;;AAIA,AAAA,IAAY,iBAGX;AAHD,WAAY,iBAAiB;IAC3B,oCAAe,CAAA;IACf,kDAA6B,CAAA;AAC/B,CAAC,EAHW,iBAAiB,KAAjB,iBAAiB,QAG5B;AAED;;;AAGA,MAAa,cAAc;IAwCzB,YAAY,OAA4B;QAbhC,wBAAmB,GAAY,KAAK,CAAC;QAGrC,uBAAkB,GAAY,KAAK,CAAC;QAW1C,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;KACnC;;;;;;IArCD,IAAI,qBAAqB,CAAC,KAAa;QACrC,IAAI,KAAK,IAAI,CAAC,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;SACnE;QACD,IAAI,CAAC,sBAAsB,GAAG,KAAK,CAAC;QACpC,IAAI,CAAC,kCAAkC,GAAG,KAAK,CAAC;KACjD;IACD,IAAI,oBAAoB;QACtB,OAAO,IAAI,CAAC,sBAAsB,CAAC;KACpC;;;;;IAKD,IAAI,kCAAkC,CAAC,KAAa;QAClD,IAAI,CAAC,mCAAmC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,iBAAiB,EAAE,CAAC,CAAC;KACjF;IACD,IAAI,kCAAkC;QACpC,OAAO,IAAI,CAAC,mCAAmC,CAAC;KACjD;;;;;;;IA0Ba,gCAAgC,CAC5C,SAAoB,EACpB,OAAgB,EAChB,OAA+B;;YAE/B,IAAI,CAAC,OAAO,EAAE;gBACZ,OAAO,GAAG,EAAE,CAAC;aACd;YACD,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,MAAM,+BAA+B,GAAG,EAAE,CAAC;YAC3C,OAAO,CAAC,IAAI,CAAC,kBAAkB,EAAE;gBAC/B,IAAI;oBACF,MAAM,IAAI,CAAC,+BAA+B,CAAC,OAAO,EAAE,CAAC;oBACrDC,cAAkB,CAChB,kEAAkE,EAClE,YAAY,EACZ,IAAI,CAAC,+BAA+B,CAAC,gBAAgB,EAAE,EACvD,IAAI,CAAC,+BAA+B,CAAC,gBAAgB,EAAE,CACxD,CAAC;oBAEF,MAAM,IAAI,CAAC,kCAAkC,CAAC,OAAO,EAAE,CAAC;oBACxDA,cAAkB,CAChB,sEAAsE,EACtE,YAAY,EACZ,IAAI,CAAC,kCAAkC,CAAC,gBAAgB,EAAE,EAC1D,IAAI,CAAC,kCAAkC,CAAC,gBAAgB,EAAE,CAC3D,CAAC;oBAEF,MAAM,mBAAmB,GAAG,CAAO,cAA8B;wBAC/D,IAAI;4BACF,MAAM,IAAI,CAAC,+BAA+B,CAAC,OAAO,EAAE,CAAC;4BACrDA,cAAkB,CAChB,mEAAmE,EACnE,YAAY,EACZ,IAAI,CAAC,+BAA+B,CAAC,gBAAgB,EAAE,EACvD,IAAI,CAAC,+BAA+B,CAAC,gBAAgB,EAAE,CACxD,CAAC;4BACF,IAAI,cAAc,CAAC,MAAM,EAAE,EAAE;gCAC3B,MAAM,cAAc,CAAC,KAAK,EAAE,CAAC;6BAC9B;yBACF;wBAAC,OAAO,GAAG,EAAE;4BACZrC,KAAS,CACP,8EAA8E;gCAC5E,mDAAmD,EACrD,YAAY,EACZ,cAAc,CAAC,SAAS,EACxB,GAAG,CACJ,CAAC;yBACH;qBACF,CAAA,CAAC;;oBAEF,MAAM,cAAc,GAAG,MAAM,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,kBAC9D,SAAS,EAAE,SAAS,EACpB,MAAM,EAAE,aAAa,CAAC,cAAc,IACjC,OAAO,EACV,CAAC;oBAEH,cAAc,CAAC,8BAA8B,GAAG,OAAO,CAAC,8BAA8B,CAAC;oBAEvF,IAAI,IAAI,CAAC,kBAAkB,EAAE;wBAC3BqC,cAAkB,CAChB,uFAAuF,EACvF,YAAY,EACZ,cAAc,CAAC,SAAS,CACzB,CAAC;wBACF,MAAM,mBAAmB,CAAC,cAAc,CAAC,CAAC;qBAC3C;oBACD,MAAM,SAAS,GAAG,cAAc,CAAC,SAAS,CAAC;oBAC3C,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,SAAmB,CAAC,GAAG,cAAc,CAAC;oBAEpEA,cAAkB,CAAC,2CAA2C,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC;oBACzF,MAAM,cAAc,GAAY,CAAO,KAAK;wBAC1CA,cAAkB,CAChB,wEAAwE,EACxE,YAAY,EACZ,SAAS,EACT,KAAK,CACN,CAAC;wBACF,MAAM,mBAAmB,CAAC,cAAc,CAAC,CAAC;wBAC1C,IAAI,KAAK,CAAC,IAAI,KAAKZ,mCAAwB,CAAC,oCAAoC,CAAC,EAAE;;4BAEjF,OAAO,CAAC,KAAK,CAAC,CAAC;yBAChB;qBACF,CAAA,CAAC;oBACF,cAAc,CAAC,OAAO,CAAC,SAAS,EAAE,cAAc,EAAE,OAAO,CAAC,CAAC;iBAC5D;gBAAC,OAAO,GAAG,EAAE;oBACZzB,KAAS,CAAC,6DAA6D,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC;oBAC5F,IAAI,CAAC,+BAA+B,CAAC,OAAO,EAAE,CAAC;oBAC/CqC,cAAkB,CAChB,2DAA2D;wBACzD,mCAAmC,EACrC,YAAY,EACZ,IAAI,CAAC,+BAA+B,CAAC,gBAAgB,EAAE,EACvD,IAAI,CAAC,+BAA+B,CAAC,gBAAgB,EAAE,CACxD,CAAC;;;;;;;;;;;oBAWF,IACE,GAAG,CAAC,IAAI,KAAKZ,mCAAwB,CAAC,wBAAwB,CAAC;wBAC/D,GAAG,CAAC,IAAI,KAAKA,mCAAwB,CAAC,uBAAuB,CAAC;wBAC9D,GAAG,CAAC,IAAI,KAAKA,mCAAwB,CAAC,wCAAwC,CAAC,EAC/E;;wBAEA,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE;4BAC5BY,cAAkB,CAChB,kFAAkF;gCAChF,wBAAwB,EAC1B,YAAY,EACZ,+BAA+B,CAChC,CAAC;4BACF,MAAMpC,gBAAK,CAAC,+BAA+B,GAAG,IAAI,CAAC,CAAC;yBACrD;qBACF;yBAAM;;wBAEL,OAAO,CAAC,GAAG,CAAC,CAAC;qBACd;iBACF;wBAAS;oBACR,IAAI,CAAC,kCAAkC,CAAC,OAAO,EAAE,CAAC;oBAClDoC,cAAkB,CAChB,oEAAoE;wBAClE,4BAA4B,EAC9B,YAAY,EACZ,IAAI,CAAC,kCAAkC,CAAC,gBAAgB,EAAE,EAC1D,IAAI,CAAC,kCAAkC,CAAC,gBAAgB,EAAE,CAC3D,CAAC;iBACH;aACF;SACF;KAAA;;;;;;;;;;;IAYK,qBAAqB,CACzB,UAA6B,EAC7B,SAAoB,EACpB,OAAgB,EAChB,OAA+B;;YAE/B,IAAI,IAAI,CAAC,mBAAmB,EAAE;gBAC5B,MAAM,IAAI,KAAK,CACb,GAAG,UAAU,eAAe,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,UAAU,IAAI;oBACvE,kEAAkE,UAAU,YAAY;oBACxF,qDAAqD,CACxD,CAAC;aACH;YACD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;YAChC,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;YAChC,IAAI,CAAC,OAAO;gBAAE,OAAO,GAAG,EAAE,CAAC;YAC3B,IAAI,OAAO,CAAC,qBAAqB;gBAAE,IAAI,CAAC,qBAAqB,GAAG,OAAO,CAAC,qBAAqB,CAAC;;;YAG9F,IAAI,CAAC,OAAO,CAAC,8BAA8B,EAAE;gBAC3C,OAAO,CAAC,8BAA8B,GAAGnC,oBAAS,CAAC,gCAAgC,CAAC;aACrF;YACD,IAAI,CAAC,+BAA+B,GAAG,IAAI,SAAS,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;YAChF,IAAI,CAAC,kCAAkC,GAAG,IAAI,SAAS,CACrD,IAAI,CAAC,kCAAkC,CACxC,CAAC;YAEF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,mCAAmC,EAAE,CAAC,EAAE,EAAE;gBACjE,IAAI,CAAC,gCAAgC,CAAC,SAAS,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG;oBAC3EF,KAAS,CAAC,GAAG,CAAC,CAAC;iBAChB,CAAC,CAAC;aACJ;SACF;KAAA;;;;IAKD,KAAK;QACHqC,cAAkB,CAChB,kDAAkD,EAClD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,QAAQ,CAAC,UAAU,CACzB,CAAC;QACF,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;QAC/B,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;KAClC;CACF;;AC3QD;AACA,AA8GA;;;AAGA,IAAiB,mBAAmB,CAyOnC;AAzOD,WAAiB,mBAAmB;;;;IAIlC,SAAgB,MAAM,CACpB,UAAkB,EAClB,UAAsB,EACtB,OAA0B,EAC1B,QAAgB,EAChB,OAAoC;QAEpCC,UAAc,CACZ,gDAAgD,EAChD,OAAO,CAAC,YAAY,EACpB,QAAQ,CACT,CAAC;QAEF,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,CAAC;QAC3B,MAAM,aAAa,GAA4B;YAC7C,SAAS,EAAE,OAAO;YAClB,UAAU,EAAE,UAAU;YACtB,UAAU,EAAE,UAAU;YACtB,QAAQ,EAAE,QAAQ;YAClB,QAAQ,EAAE,KAAK;YACf,6BAA6B,EAAE,IAAI,qBAAqB,EAAU;YAClE,gBAAgB,EAAE,CAAC,CAAC,OAAO,CAAC,gBAAgB;YAC5C,eAAe,EAAE,EAAE;YACnB,sBAAsB,EAAE,EAAE;SAC3B,CAAC;QAED,aAAqC,CAAC,cAAc,GAAG,IAAI,cAAc,CACxE,aAAoC,CACrC,CAAC;QAED,aAAqC,CAAC,WAAW,GAAG,CAAC,IAAY,EAAE,SAAkB;YACpF,IAAI,SAAS,IAAI,SAAS,IAAI,aAAa,CAAC,sBAAsB,CAAC,SAAS,CAAC,EAAE;gBAC7E,MAAMnC,OAAK,GAAG,IAAI,KAAK,CACrB,uDAAuD,SAAS,GAAG,CACpE,CAAC;gBACFA,OAAK,CAAC,IAAI,GAAG,sBAAsB,CAAC;gBACpCH,KAAS,CACP,0EAA0E,EAC1E,aAAa,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,EACJ,SAAS,CACV,CAAC;gBACF,MAAMG,OAAK,CAAC;aACb;YAED,IACE,SAAS,IAAI,IAAI;gBACjB,aAAa,CAAC,eAAe,CAAC,SAAS,CAAC;gBACxC,aAAa,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,IAAI,KAAK,IAAI,EACtD;gBACA,OAAO,aAAa,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;aACjD;YAED,IAAI,aAAa,CAAC,iBAAiB,IAAI,aAAa,CAAC,iBAAiB,CAAC,IAAI,KAAK,IAAI,EAAE;gBACpF,OAAO,aAAa,CAAC,iBAAiB,CAAC;aACxC;YAED,IAAI,aAAa,CAAC,gBAAgB,IAAI,aAAa,CAAC,gBAAgB,CAAC,IAAI,KAAK,IAAI,EAAE;gBAClF,OAAO,aAAa,CAAC,gBAAgB,CAAC;aACvC;YAED,IAAI,iBAAiB,GAAG,EAAE,CAAC;YAC3B,IAAI,SAAS,IAAI,IAAI,IAAI,aAAa,CAAC,eAAe,CAAC,SAAS,CAAC,EAAE;gBACjE,iBAAiB,GAAG,aAAa,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC;aACnE;iBAAM;gBACL,IAAI,aAAa,CAAC,iBAAiB,EAAE;oBACnC,iBAAiB,GAAG,aAAa,CAAC,iBAAiB,CAAC,IAAI,CAAC;iBAC1D;gBACD,IAAI,aAAa,CAAC,gBAAgB,EAAE;oBAClC,iBAAiB;wBACf,CAAC,iBAAiB,GAAG,IAAI,GAAG,EAAE,IAAI,aAAa,CAAC,gBAAgB,CAAC,IAAI,CAAC;iBACzE;aACF;YAEDH,KAAS,CACP,gEAAgE,EAChE,aAAa,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,EACJ,iBAAiB,CAClB,CAAC;YACF,OAAO;SACR,CAAC;QAED,aAAqC,CAAC,UAAU,GAAG,CAAOG,OAAyB;YAClF,MAAM,YAAY,GAAG,aAAa,CAAC,SAAS,CAAC,YAAY,CAAC;;YAG1D,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC;YACpC,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE;gBAClC,IAAI;oBACFH,KAAS,CAAC,uCAAuC,EAAE,YAAY,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;oBAC9E,MAAM,MAAM,CAAC,UAAU,EAAE,CAAC;iBAC3B;gBAAC,OAAO,GAAG,EAAE;oBACZA,KAAS,CACP,wEAAwE,EACxE,YAAY,EACZ,MAAM,CAAC,IAAI,EACX,GAAG,CACJ,CAAC;iBACH;aACF;;YAGD,MAAM,gBAAgB,GAAG,aAAa,CAAC,gBAAgB,CAAC;YACxD,IAAI,gBAAgB,IAAI,CAAC,gBAAgB,CAAC,YAAY,EAAE;gBACtD,IAAI;oBACFA,KAAS,CACP,kDAAkD,EAClD,YAAY,EACZ,gBAAgB,CAAC,IAAI,CACtB,CAAC;oBACF,MAAM,gBAAgB,CAAC,UAAU,CAACG,OAAK,CAAC,CAAC;iBAC1C;gBAAC,OAAO,GAAG,EAAE;oBACZH,KAAS,CACP,sFAAsF,EACtF,YAAY,EACZ,gBAAgB,CAAC,IAAI,EACrB,GAAG,CACJ,CAAC;iBACH;aACF;;YAGD,MAAM,iBAAiB,GAAG,aAAa,CAAC,iBAAiB,CAAC;YAC1D,IAAI,iBAAiB,IAAI,CAAC,iBAAiB,CAAC,YAAY,EAAE;gBACxD,IAAI;oBACFA,KAAS,CACP,mDAAmD,EACnD,YAAY,EACZ,iBAAiB,CAAC,IAAI,CACvB,CAAC;oBACF,MAAM,iBAAiB,CAAC,UAAU,CAACG,OAAK,CAAC,CAAC;iBAC3C;gBAAC,OAAO,GAAG,EAAE;oBACZH,KAAS,CACP,uFAAuF,EACvF,YAAY,EACZ,iBAAiB,CAAC,IAAI,EACtB,GAAG,CACJ,CAAC;iBACH;aACF;SACF,CAAA,CAAC;QAEF,MAAM,wCAAwC,GAAG;YAC/C,KAAK,MAAM,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE;gBACpD,IACE,OAAO,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC,UAAU,KAAK,aAAa,CAAC,UAAU;oBAClE,OAAO,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC,QAAQ,KAAK,aAAa,CAAC,QAAQ,EAC9D;oBACA,OAAO,IAAI,CAAC;iBACb;aACF;YACD,OAAO,KAAK,CAAC;SACd,CAAC;QAED,aAAqC,CAAC,KAAK,GAAG;YAC7C,IAAI,CAAC,OAAO,CAAC,UAAU,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE;gBACvD,OAAO;aACR;YAEDsC,UAAc,CACZ,+CAA+C,EAC/C,OAAO,CAAC,YAAY,EACpB,QAAQ,CACT,CAAC;;YAGF,IAAI,aAAa,CAAC,MAAM,EAAE;gBACxB,MAAM,aAAa,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;aACpC;;YAGD,IAAI,aAAa,CAAC,gBAAgB,EAAE;gBAClC,MAAM,aAAa,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC;aAC9C;;YAGD,IAAI,aAAa,CAAC,iBAAiB,EAAE;gBACnC,MAAM,aAAa,CAAC,iBAAiB,CAAC,KAAK,EAAE,CAAC;aAC/C;;YAGD,KAAK,MAAM,gBAAgB,IAAI,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,EAAE;gBACzE,MAAM,aAAa,CAAC,eAAe,CAAC,gBAAgB,CAAC,CAAC,KAAK,EAAE,CAAC;aAC/D;;YAGD,IAAI,aAAa,CAAC,cAAc,EAAE;gBAChC,aAAa,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;aACtC;;YAGD,aAAa,CAAC,6BAA6B,CAAC,KAAK,EAAE,CAAC;;YAGpD,OAAO,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;;YAGxC,IAAI,aAAa,CAAC,gBAAgB,IAAI,CAAC,wCAAwC,EAAE,EAAE;gBACjF,MAAM,aAAa,CAAC,gBAAgB,CAAC,KAAK,EAAE,CAAC;gBAC7C,aAAa,CAAC,gBAAgB,GAAG,SAAS,CAAC;aAC5C;YAED,aAAa,CAAC,QAAQ,GAAG,IAAI,CAAC;YAE9BA,UAAc,CACZ,8CAA8C,EAC9C,OAAO,CAAC,YAAY,EACpB,QAAQ,CACT,CAAC;SACH,CAAA,CAAC;QAEF,IAAI,gBAAgB,GAAG,mBAAmB,CAAC,OAAO,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC;QAC/E,IAAI,CAAC,gBAAgB,EAAE;YACrB,MAAM,QAAQ,GAA4B;gBACxC,OAAO,EAAE,OAAO,CAAC,uBAAuB,IAAI,GAAG,UAAU,cAAc;gBACvE,QAAQ,EAAE,OAAO,CAAC,wBAAwB;aAC3C,CAAC;YACF,gBAAgB,GAAG,IAAI,gBAAgB,CAAC,aAAoC,EAAE,QAAQ,CAAC,CAAC;SACzF;QACD,aAAa,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QAElD,MAAM,mBAAmB,GAAG,aAAoC,CAAC;QACjE,OAAO,CAAC,cAAc,CAAC,aAAa,CAAC,QAAQ,CAAC,GAAG,mBAAmB,CAAC;QAErEA,UAAc,CAAC,+CAA+C,EAAE,OAAO,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC;QAEhG,OAAO,mBAAmB,CAAC;KAC5B;IApOe,0BAAM,SAoOrB,CAAA;AACH,CAAC,EAzOgB,mBAAmB,KAAnB,mBAAmB,QAyOnC;AAED;AACA,SAAS,mBAAmB,CAC1B,OAAwC,EACxC,UAAkB;IAElB,IAAI,MAAoC,CAAC;IACzC,KAAK,MAAM,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;QACrC,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC,UAAU,KAAK,UAAU,EAAE;YACzC,MAAM,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC,gBAAgB,CAAC;YACtC,MAAM;SACP;KACF;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;;AC1WD;AACA,AAmBA;;;;;AAKA,MAAa,WAAW;;;;;;;;;;;;IA8BtB,YAAY,SAAiB,EAAE,OAA0B;QACvD,4BAA4B,CAAC,OAAO,CAAC,CAAC;QACtC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC;QACpC,IAAI,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,UAAU,IAAIjC,yBAAa,EAAE,EAAE,CAAC;QAClD,IAAI,CAAC,QAAQ,GAAG,mBAAmB,CAAC,MAAM,CACxC,IAAI,CAAC,UAAU,EACf,UAAU,CAAC,WAAW,EACtB,OAAO,EACP,IAAI,CAAC,EAAE,CACR,CAAC;KACH;;;;;;;;IASK,KAAK;;YACT,IAAI;;;gBAGF,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;aAC7B;YAAC,OAAO,GAAG,EAAE;gBACZL,KAAS,CACP,iEAAiE,EACjE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,EAAE,EACP,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;;;IAQD,YAAY;QACV,oCAAoC,CAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EACvB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;QACF,IAAI,CAAC,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE;YACxD,IAAI,CAAC,cAAc,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAChD,OAAO,IAAI,CAAC,cAAc,CAAC;SAC5B;QACD,MAAM,YAAY,GAAG,qBAAqB,CAAC,aAAa,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;QAC3E,MAAMG,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;QACtCH,KAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;QACjE,MAAMA,OAAK,CAAC;KACb;IAgDM,cAAc,CACnB,WAAwB,EACxB,cAAuC;QAEvC,oCAAoC,CAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EACvB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;;QAGF,IAAI,CAAC,cAAc,EAAE;YACnB,IAAI,CAAC,IAAI,CAAC,gBAAgB,IAAI,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE;gBAC5D,IAAI,CAAC,gBAAgB,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,gBAAgB,CAAC;aAC9B;YACD,MAAM,YAAY,GAAG,uBAAuB,CAAC,UAAU,CAAC,WAAW,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;YACtF,MAAMA,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtCH,KAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;YACjE,MAAMA,OAAK,CAAC;SACb;QAED,OAAO,IAAI,eAAe,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC;KACxE;;;;;;;;;;;;;IAcK,IAAI,CAAC,eAAwB;;YACjC,oCAAoC,CAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EACvB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;YAEF,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;SAC9D;KAAA;;;;;;;;;;;;;IAcK,oBAAoB,CACxB,kBAAwB,EACxB,eAAwB;;YAExB,oCAAoC,CAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EACvB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;YAEF,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,oBAAoB,CACzD,kBAAkB,EAClB,eAAe,CAChB,CAAC;SACH;KAAA;;;;;;;;;;;;;;;;;;;;;;;;;IA2BD,OAAO,sBAAsB,CAAC,SAAiB;QAC7C,OAAO,GAAG,SAAS,mBAAmB,CAAC;KACxC;CACF;;ACrQD;AACA,AAcA;;;;;AAKA,MAAa,WAAW;;;;;;;;;;;;IA6BtB,YAAY,SAAiB,EAAE,OAA0B;QACvD,4BAA4B,CAAC,OAAO,CAAC,CAAC;QACtC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC;QACpC,IAAI,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,UAAU,IAAIE,yBAAa,EAAE,EAAE,CAAC;QAClD,IAAI,CAAC,QAAQ,GAAG,mBAAmB,CAAC,MAAM,CACxC,IAAI,CAAC,UAAU,EACf,UAAU,CAAC,WAAW,EACtB,OAAO,EACP,IAAI,CAAC,EAAE,CACR,CAAC;KACH;;;;;;;;IASK,KAAK;;YACT,IAAI;;;gBAGF,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;aAC7B;YAAC,OAAO,GAAG,EAAE;gBACZL,KAAS,CACP,iEAAiE,EACjE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,EAAE,EACP,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;;;;;;;;;;IAWD,YAAY;QACV,oCAAoC,CAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EACvB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;QACF,IAAI,CAAC,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE;YACxD,IAAI,CAAC,cAAc,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAChD,OAAO,IAAI,CAAC,cAAc,CAAC;SAC5B;QAED,MAAM,YAAY,GAAG,qBAAqB,CAAC,aAAa,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;QAC3E,MAAMG,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;QACtCH,KAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;QACjE,MAAMA,OAAK,CAAC;KACb;;;;;;;;IASD,OAAO,sBAAsB,CAAC,SAAiB,EAAE,gBAAwB;QACvE,OAAO,GAAG,SAAS,kBAAkB,gBAAgB,mBAAmB,CAAC;KAC1E;CACF;;ACxHD;AACA,AAkBA;;;;;;AAMA,MAAa,kBAAkB;;;;;;;;;;;;;IA+C7B,YAAY,SAAiB,EAAE,gBAAwB,EAAE,OAA0B;;;;;QA/B1E,oBAAe,GAAW,UAAU,CAAC;QAgC5C,4BAA4B,CAAC,OAAO,CAAC,CAAC;QAEtC,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC;QACnC,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAC;QAEjD,IAAI,CAAC,UAAU,GAAG,GAAG,SAAS,kBAAkB,gBAAgB,EAAE,CAAC;QACnE,IAAI,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,UAAU,IAAIE,yBAAa,EAAE,EAAE,CAAC;QAClD,IAAI,CAAC,QAAQ,GAAG,mBAAmB,CAAC,MAAM,CACxC,IAAI,CAAC,UAAU,EACf,UAAU,CAAC,kBAAkB,EAC7B,OAAO,EACP,IAAI,CAAC,EAAE,CACR,CAAC;KACH;;;;;;;;IASK,KAAK;;YACT,IAAI;;;gBAGF,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;aAC7B;YAAC,OAAO,GAAG,EAAE;gBACZL,KAAS,CACP,wEAAwE,EACxE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,EACpC,IAAI,CAAC,EAAE,EACP,GAAG,CACJ,CAAC;gBACF,MAAM,GAAG,CAAC;aACX;SACF;KAAA;IA+CM,cAAc,CACnB,WAAwB,EACxB,cAAuC;QAEvC,oCAAoC,CAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EACvB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;;QAGF,IAAI,CAAC,cAAc,EAAE;YACnB,IAAI,CAAC,IAAI,CAAC,gBAAgB,IAAI,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE;gBAC5D,IAAI,CAAC,gBAAgB,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,gBAAgB,CAAC;aAC9B;YACD,MAAM,YAAY,GAAG,uBAAuB,CAAC,UAAU,CAAC,kBAAkB,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;YAC7F,MAAMG,OAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtCH,KAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,MAAM,EAAEG,OAAK,CAAC,CAAC;YACjE,MAAMA,OAAK,CAAC;SACb;QAED,OAAO,IAAI,eAAe,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC;KACxE;;;;;;;;;;;;;IAcK,IAAI,CAAC,eAAwB;;YACjC,oCAAoC,CAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EACvB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;YAEF,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;SAC9D;KAAA;;;;;;;;;;;;;IAcK,oBAAoB,CACxB,kBAAwB,EACxB,eAAwB;;YAExB,oCAAoC,CAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EACvB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;YAEF,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,oBAAoB,CACzD,kBAAkB,EAClB,eAAe,CAChB,CAAC;SACH;KAAA;;;;;;;IASK,QAAQ;;YACZ,oCAAoC,CAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EACvB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;YACF,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,QAAQ,EAAE,CAAC;SACnD;KAAA;;;;;;;;;;IAWK,UAAU,CAAC,QAAgB;;YAC/B,oCAAoC,CAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EACvB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;YACF,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;SAC7D;KAAA;;;;;;;;;;;;;;;IAgBK,OAAO,CACX,QAAgB,EAChB,MAA4C,EAC5C,uBAAgC;;YAEhC,oCAAoC,CAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,EACvB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACvB,CAAC;YACF,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAiB,CAAC,OAAO,CAAC,QAAQ,EAAE,MAAM,EAAE,uBAAuB,CAAC,CAAC;SAC3F;KAAA;CA0BF;;AC5TD;AACA,AAiDA;;;;;AAKA,MAAa,gBAAgB;;;;;;;;;;;;IAuB3B,YACE,MAAwB,EACxB,aAA4B,EAC5B,OAAiC;QAEjC,IAAI,CAAC,OAAO;YAAE,OAAO,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,iBAAiB,CAAC,MAAM,CAAC,MAAM,EAAE,aAAa,EAAE,OAAO,CAAC,CAAC;KAC1E;;;;;;;IAQD,iBAAiB,CAAC,SAAiB;QACjC,MAAM,MAAM,GAAG,IAAI,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QACzDoC,EAAM,CAAC,uCAAuC,EAAE,SAAS,CAAC,CAAC;QAC3D,OAAO,MAAM,CAAC;KACf;;;;;;;;IASD,iBAAiB,CAAC,SAAiB;QACjC,MAAM,MAAM,GAAG,IAAI,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QACzDA,EAAM,CAAC,uCAAuC,EAAE,SAAS,CAAC,CAAC;QAC3D,OAAO,MAAM,CAAC;KACf;;;;;;;;IASD,wBAAwB,CAAC,SAAiB,EAAE,gBAAwB;QAClE,MAAM,MAAM,GAAG,IAAI,kBAAkB,CAAC,SAAS,EAAE,gBAAgB,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAClFA,EAAM,CACJ,mEAAmE,EACnE,SAAS,EACT,gBAAgB,CACjB,CAAC;QACF,OAAO,MAAM,CAAC;KACf;;;;;;;;;;IAWK,KAAK;;YACT,IAAI;gBACF,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE;oBACrCA,EAAM,CAAC,iDAAiD,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;;oBAGtF,KAAK,MAAM,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE;wBAC1D,MAAM,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;wBACvD,MAAM,aAAa,CAAC,KAAK,EAAE,CAAC;qBAC7B;oBACD,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;oBAEvC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;oBACvC,IAAI,CAAC,QAAQ,CAAC,wBAAwB,GAAG,IAAI,CAAC;oBAC9CA,EAAM,CAAC,gDAAgD,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;iBACtF;aACF;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,MAAM,GAAG,GAAG,YAAY,KAAK,GAAG,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC3EvC,KAAS,CACP,mDAAmD,IAAI,CAAC,QAAQ,CAAC,YAAY,OAAO,MAAM,EAAE,CAC7F,CAAC;gBACF,MAAM,MAAM,CAAC;aACd;SACF;KAAA;;;;;;;;;;IAWD,OAAO,0BAA0B,CAC/B,gBAAwB,EACxB,OAAiC;QAEjC,MAAM,MAAM,GAAGwC,2BAAgB,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;QAEzD,MAAM,CAAC,SAAS,GAAG,OAAO,IAAI,OAAO,CAAC,SAAS,CAAC;QAChD,MAAM,CAAC,qBAAqB,GAAG,uBAAuB,CAAC;QACvD,MAAM,CAAC,2BAA2B,GAAG,OAAO,IAAI,OAAO,CAAC,2BAA2B,CAAC;QAEpFA,2BAAgB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAClC,MAAM,aAAa,GAAG,IAAIC,2BAAgB,CACxC,MAAM,CAAC,QAAQ,EACf,MAAM,CAAC,mBAAmB,EAC1B,MAAM,CAAC,eAAe,CACvB,CAAC;QACF,OAAO,IAAI,gBAAgB,CAAC,MAAM,EAAE,aAAa,EAAE,OAAO,CAAC,CAAC;KAC7D;;;;;;;;;;;;IAaD,OAAO,uBAAuB,CAC5B,IAAY,EACZ,aAA4B,EAC5B,OAAiC;QAEjC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;QACpB,IAAI,CAAC,aAAa,EAAE;YAClB,MAAM,IAAI,SAAS,CAAC,mCAAmC,CAAC,CAAC;SAC1D;QACD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC;YAAE,IAAI,IAAI,GAAG,CAAC;QACrC,MAAM,gBAAgB,GACpB,iBAAiB,IAAI,sCAAsC;YAC3D,iCAAiC,CAAC;QACpC,MAAM,MAAM,GAAGD,2BAAgB,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;QAEzD,MAAM,CAAC,SAAS,GAAG,OAAO,IAAI,OAAO,CAAC,SAAS,CAAC;QAChD,MAAM,CAAC,qBAAqB,GAAG,uBAAuB,CAAC;QACvD,MAAM,CAAC,2BAA2B,GAAG,OAAO,IAAI,OAAO,CAAC,2BAA2B,CAAC;QAEpFA,2BAAgB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAClC,OAAO,IAAI,gBAAgB,CAAC,MAAM,EAAE,aAAa,EAAE,OAAO,CAAC,CAAC;KAC7D;;;;;;;;;;;;;;;;;;IAmBD,OAAO,6BAA6B,CAClC,IAAY,EACZ,WAIuB,EACvB,OAAiC;QAOjC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;QACpB,MAAM,aAAa,GAAG,IAAIE,2BAAgB,CAAC,WAAW,CAAC,CAAC;QACxD,OAAO,gBAAgB,CAAC,uBAAuB,CAAC,IAAI,EAAE,aAAa,EAAE,OAAO,CAAC,CAAC;KAC/E;CACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}