(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory((global.Azure = global.Azure || {}, global.Azure.Messaging = global.Azure.Messaging || {}, global.Azure.Messaging.ServiceBus = {})));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    var tslib_es6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        __extends: __extends,
        get __assign () { return __assign; },
        __rest: __rest,
        __decorate: __decorate,
        __param: __param,
        __metadata: __metadata,
        __awaiter: __awaiter,
        __generator: __generator,
        __exportStar: __exportStar,
        __values: __values,
        __read: __read,
        __spread: __spread,
        __spreadArrays: __spreadArrays,
        __await: __await,
        __asyncGenerator: __asyncGenerator,
        __asyncDelegator: __asyncDelegator,
        __asyncValues: __asyncValues,
        __makeTemplateObject: __makeTemplateObject,
        __importStar: __importStar,
        __importDefault: __importDefault
    });

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var browser = createCommonjsModule(function (module) {
    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    } ());
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) { return [] };

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };
    });

    /**
     * Helpers.
     */

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    var ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'weeks':
        case 'week':
        case 'w':
          return n * w;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
      }
      return ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */

    function setup(env) {
    	createDebug.debug = createDebug;
    	createDebug.default = createDebug;
    	createDebug.coerce = coerce;
    	createDebug.disable = disable;
    	createDebug.enable = enable;
    	createDebug.enabled = enabled;
    	createDebug.humanize = ms;

    	Object.keys(env).forEach(key => {
    		createDebug[key] = env[key];
    	});

    	/**
    	* Active `debug` instances.
    	*/
    	createDebug.instances = [];

    	/**
    	* The currently active debug mode names, and names to skip.
    	*/

    	createDebug.names = [];
    	createDebug.skips = [];

    	/**
    	* Map of special "%n" handling functions, for the debug "format" argument.
    	*
    	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    	*/
    	createDebug.formatters = {};

    	/**
    	* Selects a color for a debug namespace
    	* @param {String} namespace The namespace string for the for the debug instance to be colored
    	* @return {Number|String} An ANSI color code for the given namespace
    	* @api private
    	*/
    	function selectColor(namespace) {
    		let hash = 0;

    		for (let i = 0; i < namespace.length; i++) {
    			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
    			hash |= 0; // Convert to 32bit integer
    		}

    		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    	}
    	createDebug.selectColor = selectColor;

    	/**
    	* Create a debugger with the given `namespace`.
    	*
    	* @param {String} namespace
    	* @return {Function}
    	* @api public
    	*/
    	function createDebug(namespace) {
    		let prevTime;

    		function debug(...args) {
    			// Disabled?
    			if (!debug.enabled) {
    				return;
    			}

    			const self = debug;

    			// Set `diff` timestamp
    			const curr = Number(new Date());
    			const ms = curr - (prevTime || curr);
    			self.diff = ms;
    			self.prev = prevTime;
    			self.curr = curr;
    			prevTime = curr;

    			args[0] = createDebug.coerce(args[0]);

    			if (typeof args[0] !== 'string') {
    				// Anything else let's inspect with %O
    				args.unshift('%O');
    			}

    			// Apply any `formatters` transformations
    			let index = 0;
    			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
    				// If we encounter an escaped % then don't increase the array index
    				if (match === '%%') {
    					return match;
    				}
    				index++;
    				const formatter = createDebug.formatters[format];
    				if (typeof formatter === 'function') {
    					const val = args[index];
    					match = formatter.call(self, val);

    					// Now we need to remove `args[index]` since it's inlined in the `format`
    					args.splice(index, 1);
    					index--;
    				}
    				return match;
    			});

    			// Apply env-specific formatting (colors, etc.)
    			createDebug.formatArgs.call(self, args);

    			const logFn = self.log || createDebug.log;
    			logFn.apply(self, args);
    		}

    		debug.namespace = namespace;
    		debug.enabled = createDebug.enabled(namespace);
    		debug.useColors = createDebug.useColors();
    		debug.color = selectColor(namespace);
    		debug.destroy = destroy;
    		debug.extend = extend;
    		// Debug.formatArgs = formatArgs;
    		// debug.rawLog = rawLog;

    		// env-specific initialization logic for debug instances
    		if (typeof createDebug.init === 'function') {
    			createDebug.init(debug);
    		}

    		createDebug.instances.push(debug);

    		return debug;
    	}

    	function destroy() {
    		const index = createDebug.instances.indexOf(this);
    		if (index !== -1) {
    			createDebug.instances.splice(index, 1);
    			return true;
    		}
    		return false;
    	}

    	function extend(namespace, delimiter) {
    		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    		newDebug.log = this.log;
    		return newDebug;
    	}

    	/**
    	* Enables a debug mode by namespaces. This can include modes
    	* separated by a colon and wildcards.
    	*
    	* @param {String} namespaces
    	* @api public
    	*/
    	function enable(namespaces) {
    		createDebug.save(namespaces);

    		createDebug.names = [];
    		createDebug.skips = [];

    		let i;
    		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    		const len = split.length;

    		for (i = 0; i < len; i++) {
    			if (!split[i]) {
    				// ignore empty strings
    				continue;
    			}

    			namespaces = split[i].replace(/\*/g, '.*?');

    			if (namespaces[0] === '-') {
    				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    			} else {
    				createDebug.names.push(new RegExp('^' + namespaces + '$'));
    			}
    		}

    		for (i = 0; i < createDebug.instances.length; i++) {
    			const instance = createDebug.instances[i];
    			instance.enabled = createDebug.enabled(instance.namespace);
    		}
    	}

    	/**
    	* Disable debug output.
    	*
    	* @return {String} namespaces
    	* @api public
    	*/
    	function disable() {
    		const namespaces = [
    			...createDebug.names.map(toNamespace),
    			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
    		].join(',');
    		createDebug.enable('');
    		return namespaces;
    	}

    	/**
    	* Returns true if the given mode name is enabled, false otherwise.
    	*
    	* @param {String} name
    	* @return {Boolean}
    	* @api public
    	*/
    	function enabled(name) {
    		if (name[name.length - 1] === '*') {
    			return true;
    		}

    		let i;
    		let len;

    		for (i = 0, len = createDebug.skips.length; i < len; i++) {
    			if (createDebug.skips[i].test(name)) {
    				return false;
    			}
    		}

    		for (i = 0, len = createDebug.names.length; i < len; i++) {
    			if (createDebug.names[i].test(name)) {
    				return true;
    			}
    		}

    		return false;
    	}

    	/**
    	* Convert regexp to namespace
    	*
    	* @param {RegExp} regxep
    	* @return {String} namespace
    	* @api private
    	*/
    	function toNamespace(regexp) {
    		return regexp.toString()
    			.substring(2, regexp.toString().length - 2)
    			.replace(/\.\*\?$/, '*');
    	}

    	/**
    	* Coerce `val`.
    	*
    	* @param {Mixed} val
    	* @return {Mixed}
    	* @api private
    	*/
    	function coerce(val) {
    		if (val instanceof Error) {
    			return val.stack || val.message;
    		}
    		return val;
    	}

    	createDebug.enable(createDebug.load());

    	return createDebug;
    }

    var common = setup;

    var browser$1 = createCommonjsModule(function (module, exports) {
    /* eslint-env browser */

    /**
     * This is the web browser implementation of `debug()`.
     */

    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();

    /**
     * Colors.
     */

    exports.colors = [
    	'#0000CC',
    	'#0000FF',
    	'#0033CC',
    	'#0033FF',
    	'#0066CC',
    	'#0066FF',
    	'#0099CC',
    	'#0099FF',
    	'#00CC00',
    	'#00CC33',
    	'#00CC66',
    	'#00CC99',
    	'#00CCCC',
    	'#00CCFF',
    	'#3300CC',
    	'#3300FF',
    	'#3333CC',
    	'#3333FF',
    	'#3366CC',
    	'#3366FF',
    	'#3399CC',
    	'#3399FF',
    	'#33CC00',
    	'#33CC33',
    	'#33CC66',
    	'#33CC99',
    	'#33CCCC',
    	'#33CCFF',
    	'#6600CC',
    	'#6600FF',
    	'#6633CC',
    	'#6633FF',
    	'#66CC00',
    	'#66CC33',
    	'#9900CC',
    	'#9900FF',
    	'#9933CC',
    	'#9933FF',
    	'#99CC00',
    	'#99CC33',
    	'#CC0000',
    	'#CC0033',
    	'#CC0066',
    	'#CC0099',
    	'#CC00CC',
    	'#CC00FF',
    	'#CC3300',
    	'#CC3333',
    	'#CC3366',
    	'#CC3399',
    	'#CC33CC',
    	'#CC33FF',
    	'#CC6600',
    	'#CC6633',
    	'#CC9900',
    	'#CC9933',
    	'#CCCC00',
    	'#CCCC33',
    	'#FF0000',
    	'#FF0033',
    	'#FF0066',
    	'#FF0099',
    	'#FF00CC',
    	'#FF00FF',
    	'#FF3300',
    	'#FF3333',
    	'#FF3366',
    	'#FF3399',
    	'#FF33CC',
    	'#FF33FF',
    	'#FF6600',
    	'#FF6633',
    	'#FF9900',
    	'#FF9933',
    	'#FFCC00',
    	'#FFCC33'
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    // eslint-disable-next-line complexity
    function useColors() {
    	// NB: In an Electron preload script, document will be defined but not fully
    	// initialized. Since we know we're in Chrome, we'll just detect this case
    	// explicitly
    	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    		return true;
    	}

    	// Internet Explorer and Edge do not support colors.
    	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    		return false;
    	}

    	// Is webkit? http://stackoverflow.com/a/16459606/376773
    	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    		// Is firebug? http://stackoverflow.com/a/398120/376773
    		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    		// Is firefox >= v31?
    		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    		// Double check webkit in userAgent just in case we are in a worker
    		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    }

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
    	args[0] = (this.useColors ? '%c' : '') +
    		this.namespace +
    		(this.useColors ? ' %c' : ' ') +
    		args[0] +
    		(this.useColors ? '%c ' : ' ') +
    		'+' + module.exports.humanize(this.diff);

    	if (!this.useColors) {
    		return;
    	}

    	const c = 'color: ' + this.color;
    	args.splice(1, 0, c, 'color: inherit');

    	// The final "%c" is somewhat tricky, because there could be other
    	// arguments passed either before or after the %c, so we need to
    	// figure out the correct index to insert the CSS into
    	let index = 0;
    	let lastC = 0;
    	args[0].replace(/%[a-zA-Z%]/g, match => {
    		if (match === '%%') {
    			return;
    		}
    		index++;
    		if (match === '%c') {
    			// We only are interested in the *last* %c
    			// (the user may have provided their own)
    			lastC = index;
    		}
    	});

    	args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */
    function log(...args) {
    	// This hackery is required for IE8/9, where
    	// the `console.log` function doesn't have 'apply'
    	return typeof console === 'object' &&
    		console.log &&
    		console.log(...args);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
    	try {
    		if (namespaces) {
    			exports.storage.setItem('debug', namespaces);
    		} else {
    			exports.storage.removeItem('debug');
    		}
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
    	let r;
    	try {
    		r = exports.storage.getItem('debug');
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}

    	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    	if (!r && typeof browser !== 'undefined' && 'env' in browser) {
    		r = browser.env.DEBUG;
    	}

    	return r;
    }

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
    	try {
    		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    		// The Browser also has localStorage in the global context.
    		return localStorage;
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}
    }

    module.exports = common(exports);

    const {formatters} = module.exports;

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
    	try {
    		return JSON.stringify(v);
    	} catch (error) {
    		return '[UnexpectedJSONParseError]: ' + error.message;
    	}
    };
    });
    var browser_1 = browser$1.log;
    var browser_2 = browser$1.formatArgs;
    var browser_3 = browser$1.save;
    var browser_4 = browser$1.load;
    var browser_5 = browser$1.useColors;
    var browser_6 = browser$1.storage;
    var browser_7 = browser$1.colors;

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @internal
     * log statements for linkEntity
     */
    const link = browser$1("azure:service-bus:linkEntity");
    /**
     * @internal
     * log statements for error
     */
    const error = browser$1("azure:service-bus:error");
    /**
     * @internal
     * log statements for warning
     */
    const warning = browser$1("azure:service-bus:warning");
    /**
     * @internal
     * log statements for management
     */
    const mgmt = browser$1("azure:service-bus:management");
    /**
     * @internal
     * log statements for sender
     */
    const sender = browser$1("azure:service-bus:sender");
    /**
     * @internal
     * log statements for receiver
     */
    const receiver = browser$1("azure:service-bus:receiver");
    /**
     * @internal
     * log statements for receiverbatching
     */
    const batching = browser$1("azure:service-bus:receiverbatching");
    /**
     * @internal
     * log statements for receiverstreaming
     */
    const streaming = browser$1("azure:service-bus:receiverstreaming");
    /**
     * @internal
     * log statements for connectionContext
     */
    const connectionCtxt = browser$1("azure:service-bus:connectionContext");
    /**
     * @internal
     * log statements for clientEntityContext
     */
    const entityCtxt = browser$1("azure:service-bus:clientEntityContext");
    /**
     * @internal
     * log statements for namespace
     */
    const ns = browser$1("azure:service-bus:namespace");
    /**
     * @internal
     * log statements for servicebusMessage
     */
    const message = browser$1("azure:service-bus:servicebusMessage");
    /**
     * @internal
     * log statements for map
     */
    const map = browser$1("azure:service-bus:concurrentMap");
    /**
     * @internal
     * log statements for utils
     */
    const utils = browser$1("azure:service-bus:utils");
    /**
     * @internal
     * log statements for messageSession
     */
    const messageSession = browser$1("azure:service-bus:messageSession");
    /**
     * @internal
     * log statements for semaphore
     */
    const semaphore = browser$1("azure:service-bus:semaphore");
    /**
     * @internal
     * log statements for sessionManager
     */
    const sessionManager = browser$1("azure:service-bus:sessionManager");
    /**
     * @internal
     * log statements for Atom XML management API over HTTP
     */
    const httpAtomXml = browser$1("azure:service-bus:atom-xml");

    var log = /*#__PURE__*/Object.freeze({
        __proto__: null,
        link: link,
        error: error,
        warning: warning,
        mgmt: mgmt,
        sender: sender,
        receiver: receiver,
        batching: batching,
        streaming: streaming,
        connectionCtxt: connectionCtxt,
        entityCtxt: entityCtxt,
        ns: ns,
        message: message,
        map: map,
        utils: utils,
        messageSession: messageSession,
        semaphore: semaphore,
        sessionManager: sessionManager,
        httpAtomXml: httpAtomXml
    });

    function arch() { return "javascript" }
              function type() { return "Browser" }
              function release() { }

    var _rollupPluginShim5 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        arch: arch,
        type: type,
        release: release
    });

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    const packageJsonInfo = {
        name: "@azure/service-bus",
        version: "1.1.4"
    };
    const max32BitNumber = Math.pow(2, 31) - 1;

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License. See License.txt in the project root for license information.
    const associatedLinkName = "associated-link-name";
    const partitionKey = "x-opt-partition-key";
    const sequenceNumber = "x-opt-sequence-number";
    const enqueueSequenceNumber = "x-opt-enqueue-sequence-number";
    const enqueuedTime = "x-opt-enqueued-time";
    const scheduledEnqueueTime = "x-opt-scheduled-enqueue-time";
    const lockedUntil = "x-opt-locked-until";
    const viaPartitionKey = "x-opt-via-partition-key";
    const deadLetterSource = "x-opt-deadletter-source";
    const statusCode = "status-code";
    const statusDescription = "status-description";
    const errorCondition = "error-condition";
    const management = "$management";
    const TLS = "tls";
    const establishConnection = "establishConnection";
    const cbsEndpoint = "$cbs";
    const cbsReplyTo = "cbs";
    const operationPutToken = "put-token";
    const maxUserAgentLength = 512;
    const vendorString = "com.microsoft";
    const sessionFilterName = `${vendorString}:session-filter`;
    const defaultOperationTimeoutInSeconds = 60;
    const defaultConnectionIdleTimeoutInMs = 60000;
    const managementRequestKey = "managementRequest";
    const negotiateCbsKey = "negotiateCbs";
    const negotiateClaim = "negotiateClaim";
    const maxMessageIdLength = 128;
    const maxPartitionKeyLength = 128;
    const maxSessionIdLength = 128;
    // https://stackoverflow.com/questions/11526504/minimum-and-maximum-date for js
    // However we are setting this to the TimeSpan.MaxValue of C#.
    const maxDurationValue = 922337203685477;
    // https://github.com/Azure/azure-amqp/blob/master/Microsoft.Azure.Amqp/Amqp/AmqpConstants.cs#L47
    const maxAbsoluteExpiryTime = new Date("9999-12-31T07:59:59.000Z").getTime();
    const connectionReconnectDelay = 300;
    const defaultRetryAttempts = 3;
    const defaultConnectionRetryAttempts = 150;
    const defaultDelayBetweenOperationRetriesInSeconds = 5;
    const defaultDelayBetweenRetriesInSeconds = 15;
    const receiverSettleMode = "receiver-settle-mode";
    const dispositionStatus = "disposition-status";
    const fromSequenceNumber = "from-sequence-number";
    const messageCount = "message-count";
    const lockTokens = "lock-tokens";
    const sessionIdMapKey = "session-id";
    const sequenceNumbers = "sequence-numbers";
    const deadLetterReason = "deadletter-reason";
    const deadLetterDescription = "deadletter-description";
    const propertiesToModify = "properties-to-modify";
    const deadLetterName = "com.microsoft:dead-letter";
    const trackingId = "com.microsoft:tracking-id";
    const operations = {
        putToken: "put-token",
        read: "READ",
        cancelScheduledMessage: "com.microsoft:cancel-scheduled-message",
        scheduleMessage: "com.microsoft:schedule-message",
        renewLock: "com.microsoft:renew-lock",
        peekMessage: "com.microsoft:peek-message",
        receiveBySequenceNumber: "com.microsoft:receive-by-sequence-number",
        updateDisposition: "com.microsoft:update-disposition",
        renewSessionLock: "com.microsoft:renew-session-lock",
        setSessionState: "com.microsoft:set-session-state",
        getSessionState: "com.microsoft:get-session-state",
        enumerateSessions: "com.microsoft:get-message-sessions",
        addRule: "com.microsoft:add-rule",
        removeRule: "com.microsoft:remove-rule",
        enumerateRules: "com.microsoft:enumerate-rules"
    };
    const descriptorCodes = {
        ruleDescriptionList: 1335734829060,
        sqlFilterList: 83483426822,
        correlationFilterList: 83483426825,
        sqlRuleActionList: 1335734829062,
        trueFilterList: 83483426823,
        falseFilterList: 83483426824
    };

    var byteLength_1 = byteLength;
    var toByteArray_1 = toByteArray;
    var fromByteArray_1 = fromByteArray;

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;

    function getLens (b64) {
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf('=');
      if (validLen === -1) validLen = len;

      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4);

      return [validLen, placeHoldersLen]
    }

    // base64 is 4/3 + up to two characters of the original data
    function byteLength (b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function _byteLength (b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function toByteArray (b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];

      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

      var curByte = 0;

      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen;

      var i;
      for (i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = (tmp >> 16) & 0xFF;
        arr[curByte++] = (tmp >> 8) & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[curByte++] = (tmp >> 8) & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(
          uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
        ));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        );
      }

      return parts.join('')
    }

    var base64Js = {
    	byteLength: byteLength_1,
    	toByteArray: toByteArray_1,
    	fromByteArray: fromByteArray_1
    };

    var read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = (nBytes * 8) - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    };

    var write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = (nBytes * 8) - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = ((value * c) - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    };

    var ieee754 = {
    	read: read,
    	write: write
    };

    var buffer = createCommonjsModule(function (module, exports) {



    var customInspectSymbol =
      (typeof Symbol === 'function' && typeof Symbol.for === 'function')
        ? Symbol.for('nodejs.util.inspect.custom')
        : null;

    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;

    var K_MAX_LENGTH = 0x7fffffff;
    exports.kMaxLength = K_MAX_LENGTH;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Print warning and recommend using `buffer` v4.x which has an Object
     *               implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * We report that the browser does not support typed arrays if the are not subclassable
     * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
     * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
     * for __proto__ and has a buggy typed array implementation.
     */
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
        typeof console.error === 'function') {
      console.error(
        'This browser lacks typed array (Uint8Array) support which is required by ' +
        '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
      );
    }

    function typedArraySupport () {
      // Can typed array instances can be augmented?
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function () { return 42 } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42
      } catch (e) {
        return false
      }
    }

    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.buffer
      }
    });

    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.byteOffset
      }
    });

    function createBuffer (length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"')
      }
      // Return an augmented `Uint8Array` instance
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          )
        }
        return allocUnsafe(arg)
      }
      return from(arg, encodingOrOffset, length)
    }

    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    if (typeof Symbol !== 'undefined' && Symbol.species != null &&
        Buffer[Symbol.species] === Buffer) {
      Object.defineProperty(Buffer, Symbol.species, {
        value: null,
        configurable: true,
        enumerable: false,
        writable: false
      });
    }

    Buffer.poolSize = 8192; // not used by this implementation

    function from (value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset)
      }

      if (ArrayBuffer.isView(value)) {
        return fromArrayLike(value)
      }

      if (value == null) {
        throw new TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
          'or Array-like Object. Received type ' + (typeof value)
        )
      }

      if (isInstance(value, ArrayBuffer) ||
          (value && isInstance(value.buffer, ArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length)
      }

      if (typeof value === 'number') {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        )
      }

      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length)
      }

      var b = fromObject(value);
      if (b) return b

      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
          typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(
          value[Symbol.toPrimitive]('string'), encodingOrOffset, length
        )
      }

      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
        'or Array-like Object. Received type ' + (typeof value)
      )
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length)
    };

    // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    // https://github.com/feross/buffer/pull/148
    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number')
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"')
      }
    }

    function alloc (size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(size).fill(fill, encoding)
          : createBuffer(size).fill(fill)
      }
      return createBuffer(size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding)
    };

    function allocUnsafe (size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0)
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size)
    };

    function fromString (string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }

      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);

      var actual = buf.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
      }

      return buf
    }

    function fromArrayLike (array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf
    }

    function fromArrayBuffer (array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds')
      }

      var buf;
      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }

      // Return an augmented `Uint8Array` instance
      Object.setPrototypeOf(buf, Buffer.prototype);

      return buf
    }

    function fromObject (obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);

        if (buf.length === 0) {
          return buf
        }

        obj.copy(buf, 0, 0, len);
        return buf
      }

      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0)
        }
        return fromArrayLike(obj)
      }

      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data)
      }
    }

    function checked (length) {
      // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
      }
      return length | 0
    }

    function SlowBuffer (length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0;
      }
      return Buffer.alloc(+length)
    }

    Buffer.isBuffer = function isBuffer (b) {
      return b != null && b._isBuffer === true &&
        b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    };

    Buffer.compare = function compare (a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        )
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          buf = Buffer.from(buf);
        }
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
          'Received type ' + typeof string
        )
      }

      var len = string.length;
      var mustMatch = (arguments.length > 2 && arguments[2] === true);
      if (!mustMatch && len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            }
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    // reliably in a browserify context because there could be multiple different
    // copies of the 'buffer' package in use. This method works even for Buffer
    // instances that were created from another copy of the `buffer` package.
    // See: https://github.com/feross/buffer/issues/154
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.toLocaleString = Buffer.prototype.toString;

    Buffer.prototype.equals = function equals (b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
      if (this.length > max) str += ' ... ';
      return '<Buffer ' + str + '>'
    };
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. ' +
          'Received type ' + (typeof target)
        )
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset; // Coerce to Number.
      if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      var strLen = string.length;

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64Js.fromByteArray(buf)
      } else {
        return base64Js.fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
            : (firstByte > 0xBF) ? 2
              : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf = this.subarray(start, end);
      // Return an augmented `Uint8Array` instance
      Object.setPrototypeOf(newBuf, Buffer.prototype);

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
      return offset + 2
    };

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;

      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
      } else if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (var i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if ((encoding === 'utf8' && code < 128) ||
              encoding === 'latin1') {
            // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      } else if (typeof val === 'boolean') {
        val = Number(val);
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val)
          ? val
          : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val +
            '" is invalid for argument "value"')
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node takes equal signs as end of the Base64 encoding
      str = str.split('=')[0];
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = str.trim().replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }

    function base64ToBytes (str) {
      return base64Js.toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    // the `instanceof` check but they should be treated as of that type.
    // See: https://github.com/feross/buffer/issues/166
    function isInstance (obj, type) {
      return obj instanceof type ||
        (obj != null && obj.constructor != null && obj.constructor.name != null &&
          obj.constructor.name === type.name)
    }
    function numberIsNaN (obj) {
      // For IE11 support
      return obj !== obj // eslint-disable-line no-self-compare
    }

    // Create lookup table for `toString('hex')`
    // See: https://github.com/feross/buffer/issues/219
    var hexSliceLookupTable = (function () {
      var alphabet = '0123456789abcdef';
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table
    })();
    });
    var buffer_1 = buffer.Buffer;
    var buffer_2 = buffer.SlowBuffer;
    var buffer_3 = buffer.INSPECT_MAX_BYTES;
    var buffer_4 = buffer.kMaxLength;

    var isBufferBrowser = function isBuffer(arg) {
      return arg && typeof arg === 'object'
        && typeof arg.copy === 'function'
        && typeof arg.fill === 'function'
        && typeof arg.readUInt8 === 'function';
    };

    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
    var toStr = Object.prototype.toString;

    var isStandardArguments = function isArguments(value) {
    	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
    		return false;
    	}
    	return toStr.call(value) === '[object Arguments]';
    };

    var isLegacyArguments = function isArguments(value) {
    	if (isStandardArguments(value)) {
    		return true;
    	}
    	return value !== null &&
    		typeof value === 'object' &&
    		typeof value.length === 'number' &&
    		value.length >= 0 &&
    		toStr.call(value) !== '[object Array]' &&
    		toStr.call(value.callee) === '[object Function]';
    };

    var supportsStandardArguments = (function () {
    	return isStandardArguments(arguments);
    }());

    isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

    var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

    var toStr$1 = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag$1 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function () { // eslint-disable-line consistent-return
    	if (!hasToStringTag$1) {
    		return false;
    	}
    	try {
    		return Function('return function*() {}')();
    	} catch (e) {
    	}
    };
    var generatorFunc = getGeneratorFunc();
    var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};

    var isGeneratorFunction = function isGeneratorFunction(fn) {
    	if (typeof fn !== 'function') {
    		return false;
    	}
    	if (isFnRegex.test(fnToStr.call(fn))) {
    		return true;
    	}
    	if (!hasToStringTag$1) {
    		var str = toStr$1.call(fn);
    		return str === '[object GeneratorFunction]';
    	}
    	return getProto(fn) === GeneratorFunction;
    };

    var types = createCommonjsModule(function (module, exports) {






    function uncurryThis(f) {
      return f.call.bind(f);
    }

    var BigIntSupported = typeof BigInt !== 'undefined';
    var SymbolSupported = typeof Symbol !== 'undefined';
    var SymbolToStringTagSupported = SymbolSupported && typeof Symbol.toStringTag !== 'undefined';
    var Uint8ArraySupported = typeof Uint8Array !== 'undefined';
    var ArrayBufferSupported = typeof ArrayBuffer !== 'undefined';

    if (Uint8ArraySupported && SymbolToStringTagSupported) {
      var TypedArrayPrototype = Object.getPrototypeOf(Uint8Array.prototype);

      var TypedArrayProto_toStringTag =
          uncurryThis(
            Object.getOwnPropertyDescriptor(TypedArrayPrototype,
                                            Symbol.toStringTag).get);

    }

    var ObjectToString = uncurryThis(Object.prototype.toString);

    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);

    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }

    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }

    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== 'object') {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch(e) {
        return false;
      }
    }

    exports.isArgumentsObject = isArguments;

    exports.isGeneratorFunction = isGeneratorFunction;

    // Taken from here and modified for better browser support
    // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
    function isPromise(input) {
    	return (
    		(
    			typeof Promise !== 'undefined' &&
    			input instanceof Promise
    		) ||
    		(
    			input !== null &&
    			typeof input === 'object' &&
    			typeof input.then === 'function' &&
    			typeof input.catch === 'function'
    		)
    	);
    }
    exports.isPromise = isPromise;

    function isArrayBufferView(value) {
      if (ArrayBufferSupported && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }

      return (
        isTypedArray(value) ||
        isDataView(value)
      );
    }
    exports.isArrayBufferView = isArrayBufferView;

    function isTypedArray(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) !== undefined;
      } else {
        return (
          isUint8Array(value) ||
          isUint8ClampedArray(value) ||
          isUint16Array(value) ||
          isUint32Array(value) ||
          isInt8Array(value) ||
          isInt16Array(value) ||
          isInt32Array(value) ||
          isFloat32Array(value) ||
          isFloat64Array(value) ||
          isBigInt64Array(value) ||
          isBigUint64Array(value)
        );
      }
    }
    exports.isTypedArray = isTypedArray;

    function isUint8Array(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) === 'Uint8Array';
      } else {
        return (
          ObjectToString(value) === '[object Uint8Array]' ||
          // If it's a Buffer instance _and_ has a `.buffer` property,
          // this is an ArrayBuffer based buffer; thus it's an Uint8Array
          // (Old Node.js had a custom non-Uint8Array implementation)
          isBufferBrowser(value) && value.buffer !== undefined
        );
      }
    }
    exports.isUint8Array = isUint8Array;

    function isUint8ClampedArray(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) === 'Uint8ClampedArray';
      } else {
        return ObjectToString(value) === '[object Uint8ClampedArray]';
      }
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;

    function isUint16Array(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) === 'Uint16Array';
      } else {
        return ObjectToString(value) === '[object Uint16Array]';
      }
    }
    exports.isUint16Array = isUint16Array;

    function isUint32Array(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) === 'Uint32Array';
      } else {
        return ObjectToString(value) === '[object Uint32Array]';
      }
    }
    exports.isUint32Array = isUint32Array;

    function isInt8Array(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) === 'Int8Array';
      } else {
        return ObjectToString(value) === '[object Int8Array]';
      }
    }
    exports.isInt8Array = isInt8Array;

    function isInt16Array(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) === 'Int16Array';
      } else {
        return ObjectToString(value) === '[object Int16Array]';
      }
    }
    exports.isInt16Array = isInt16Array;

    function isInt32Array(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) === 'Int32Array';
      } else {
        return ObjectToString(value) === '[object Int32Array]';
      }
    }
    exports.isInt32Array = isInt32Array;

    function isFloat32Array(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) === 'Float32Array';
      } else {
        return ObjectToString(value) === '[object Float32Array]';
      }
    }
    exports.isFloat32Array = isFloat32Array;

    function isFloat64Array(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) === 'Float64Array';
      } else {
        return ObjectToString(value) === '[object Float64Array]';
      }
    }
    exports.isFloat64Array = isFloat64Array;

    function isBigInt64Array(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) === 'BigInt64Array';
      } else {
        return ObjectToString(value) === '[object BigInt64Array]';
      }
    }
    exports.isBigInt64Array = isBigInt64Array;

    function isBigUint64Array(value) {
      if (Uint8ArraySupported && SymbolToStringTagSupported) {
        return TypedArrayProto_toStringTag(value) === 'BigUint64Array';
      } else {
        return ObjectToString(value) === '[object BigUint64Array]';
      }
    }
    exports.isBigUint64Array = isBigUint64Array;

    function isMapToString(value) {
      return ObjectToString(value) === '[object Map]';
    }
    isMapToString.working = (
      typeof Map !== 'undefined' &&
      isMapToString(new Map())
    );

    function isMap(value) {
      if (typeof Map === 'undefined') {
        return false;
      }

      return isMapToString.working
        ? isMapToString(value)
        : value instanceof Map;
    }
    exports.isMap = isMap;

    function isSetToString(value) {
      return ObjectToString(value) === '[object Set]';
    }
    isSetToString.working = (
      typeof Set !== 'undefined' &&
      isSetToString(new Set())
    );
    function isSet(value) {
      if (typeof Set === 'undefined') {
        return false;
      }

      return isSetToString.working
        ? isSetToString(value)
        : value instanceof Set;
    }
    exports.isSet = isSet;

    function isWeakMapToString(value) {
      return ObjectToString(value) === '[object WeakMap]';
    }
    isWeakMapToString.working = (
      typeof WeakMap !== 'undefined' &&
      isWeakMapToString(new WeakMap())
    );
    function isWeakMap(value) {
      if (typeof WeakMap === 'undefined') {
        return false;
      }

      return isWeakMapToString.working
        ? isWeakMapToString(value)
        : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;

    function isWeakSetToString(value) {
      return ObjectToString(value) === '[object WeakSet]';
    }
    isWeakSetToString.working = (
      typeof WeakSet !== 'undefined' &&
      isWeakSetToString(new WeakSet())
    );
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;

    function isArrayBufferToString(value) {
      return ObjectToString(value) === '[object ArrayBuffer]';
    }
    isArrayBufferToString.working = (
      typeof ArrayBuffer !== 'undefined' &&
      isArrayBufferToString(new ArrayBuffer())
    );
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === 'undefined') {
        return false;
      }

      return isArrayBufferToString.working
        ? isArrayBufferToString(value)
        : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;

    function isDataViewToString(value) {
      return ObjectToString(value) === '[object DataView]';
    }
    isDataViewToString.working = (
      typeof ArrayBuffer !== 'undefined' &&
      typeof DataView !== 'undefined' &&
      isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
    );
    function isDataView(value) {
      if (typeof DataView === 'undefined') {
        return false;
      }

      return isDataViewToString.working
        ? isDataViewToString(value)
        : value instanceof DataView;
    }
    exports.isDataView = isDataView;

    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === '[object SharedArrayBuffer]';
    }
    isSharedArrayBufferToString.working = (
      typeof SharedArrayBuffer !== 'undefined' &&
      isSharedArrayBufferToString(new SharedArrayBuffer())
    );
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBuffer === 'undefined') {
        return false;
      }

      return isSharedArrayBufferToString.working
        ? isSharedArrayBufferToString(value)
        : value instanceof SharedArrayBuffer;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;

    function isAsyncFunction(value) {
      return ObjectToString(value) === '[object AsyncFunction]';
    }
    exports.isAsyncFunction = isAsyncFunction;

    function isMapIterator(value) {
      return ObjectToString(value) === '[object Map Iterator]';
    }
    exports.isMapIterator = isMapIterator;

    function isSetIterator(value) {
      return ObjectToString(value) === '[object Set Iterator]';
    }
    exports.isSetIterator = isSetIterator;

    function isGeneratorObject(value) {
      return ObjectToString(value) === '[object Generator]';
    }
    exports.isGeneratorObject = isGeneratorObject;

    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === '[object WebAssembly.Module]';
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;

    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;

    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;

    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;

    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;

    function isBoxedPrimitive(value) {
      return (
        isNumberObject(value) ||
        isStringObject(value) ||
        isBooleanObject(value) ||
        isBigIntObject(value) ||
        isSymbolObject(value)
      );
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;

    function isAnyArrayBuffer(value) {
      return Uint8ArraySupported && (
        isArrayBuffer(value) ||
        isSharedArrayBuffer(value)
      );
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;

    ['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + ' is not supported in userland');
        }
      });
    });
    });
    var types_1 = types.isArgumentsObject;
    var types_2 = types.isGeneratorFunction;
    var types_3 = types.isPromise;
    var types_4 = types.isArrayBufferView;
    var types_5 = types.isTypedArray;
    var types_6 = types.isUint8Array;
    var types_7 = types.isUint8ClampedArray;
    var types_8 = types.isUint16Array;
    var types_9 = types.isUint32Array;
    var types_10 = types.isInt8Array;
    var types_11 = types.isInt16Array;
    var types_12 = types.isInt32Array;
    var types_13 = types.isFloat32Array;
    var types_14 = types.isFloat64Array;
    var types_15 = types.isBigInt64Array;
    var types_16 = types.isBigUint64Array;
    var types_17 = types.isMap;
    var types_18 = types.isSet;
    var types_19 = types.isWeakMap;
    var types_20 = types.isWeakSet;
    var types_21 = types.isArrayBuffer;
    var types_22 = types.isDataView;
    var types_23 = types.isSharedArrayBuffer;
    var types_24 = types.isAsyncFunction;
    var types_25 = types.isMapIterator;
    var types_26 = types.isSetIterator;
    var types_27 = types.isGeneratorObject;
    var types_28 = types.isWebAssemblyCompiledModule;
    var types_29 = types.isNumberObject;
    var types_30 = types.isStringObject;
    var types_31 = types.isBooleanObject;
    var types_32 = types.isBigIntObject;
    var types_33 = types.isSymbolObject;
    var types_34 = types.isBoxedPrimitive;
    var types_35 = types.isAnyArrayBuffer;

    var inherits_browser = createCommonjsModule(function (module) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function () {};
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    });

    var util = createCommonjsModule(function (module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
      function getOwnPropertyDescriptors(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };

    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s': return String(args[i++]);
          case '%d': return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };


    // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.
    exports.deprecate = function(fn, msg) {
      if (typeof browser !== 'undefined' && browser.noDeprecation === true) {
        return fn;
      }

      // Allow for deprecating things in the process of starting up.
      if (typeof browser === 'undefined') {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }

      var warned = false;
      function deprecated() {
        if (!warned) {
          if (browser.throwDeprecation) {
            throw new Error(msg);
          } else if (browser.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }

      return deprecated;
    };


    var debugs = {};
    var debugEnvRegex = /^$/;

    if (browser.env.NODE_DEBUG) {
      var debugEnv = browser.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
        .replace(/\*/g, '.*')
        .replace(/,/g, '$|^')
        .toUpperCase();
      debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
    }
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = browser.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    };


    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        exports._extend(ctx, opts);
      }
      // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;


    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };

    // Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };


    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
               '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }


    function stylizeNoColor(str, styleType) {
      return str;
    }


    function arrayToHash(array) {
      var hash = {};

      array.forEach(function(val, idx) {
        hash[val] = true;
      });

      return hash;
    }


    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
          value &&
          isFunction(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== exports.inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '', array = false, braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }


    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }


    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }


    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }


    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }


    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    exports.types = types;

    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;

    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;

    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;

    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;

    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;

    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;

    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;

    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;

    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;

    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;

    exports.isBuffer = isBufferBrowser;

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }


    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }


    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                  'Oct', 'Nov', 'Dec'];

    // 26 Feb 16:19:34
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }


    // log is just a thin wrapper to console.log that prepends a timestamp
    exports.log = function() {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };


    /**
     * Inherit the prototype methods from one constructor into another.
     *
     * The Function.prototype.inherits from lang.js rewritten as a standalone
     * function (not on Function.prototype). NOTE: If this file is to be loaded
     * during bootstrapping this function needs to be rewritten using some native
     * functions as prototype setup using normal JavaScript does not work as
     * expected during bootstrapping (see mirror.js in r114903).
     *
     * @param {function} ctor Constructor function which needs to inherit the
     *     prototype.
     * @param {function} superCtor Constructor function to inherit prototype from.
     */
    exports.inherits = inherits_browser;

    exports._extend = function(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject(add)) return origin;

      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

    exports.promisify = function promisify(original) {
      if (typeof original !== 'function')
        throw new TypeError('The "original" argument must be of type Function');

      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== 'function') {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn, enumerable: false, writable: false, configurable: true
        });
        return fn;
      }

      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function (resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });

        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function (err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });

        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }

        return promise;
      }

      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn, enumerable: false, writable: false, configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };

    exports.promisify.custom = kCustomPromisifiedSymbol;

    function callbackifyOnRejected(reason, cb) {
      // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
      // Because `null` is a special error value in callbacks which means "no error
      // occurred", we error-wrap so the callback consumer can distinguish between
      // "the promise rejected with null" or "the promise fulfilled with undefined".
      if (!reason) {
        var newReason = new Error('Promise was rejected with a falsy value');
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }

    function callbackify(original) {
      if (typeof original !== 'function') {
        throw new TypeError('The "original" argument must be of type Function');
      }

      // We DO NOT return the promise as it gives the user a false sense that
      // the promise is actually somehow related to the callback's execution
      // and that the callback throwing will reject the promise.
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        var maybeCb = args.pop();
        if (typeof maybeCb !== 'function') {
          throw new TypeError('The last argument must be of type Function');
        }
        var self = this;
        var cb = function() {
          return maybeCb.apply(self, arguments);
        };
        // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)
        original.apply(this, args)
          .then(function(ret) { browser.nextTick(cb.bind(null, null, ret)); },
                function(rej) { browser.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
      }

      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified,
                              getOwnPropertyDescriptors(original));
      return callbackified;
    }
    exports.callbackify = callbackify;
    });
    var util_1 = util.format;
    var util_2 = util.deprecate;
    var util_3 = util.debuglog;
    var util_4 = util.inspect;
    var util_5 = util.types;
    var util_6 = util.isArray;
    var util_7 = util.isBoolean;
    var util_8 = util.isNull;
    var util_9 = util.isNullOrUndefined;
    var util_10 = util.isNumber;
    var util_11 = util.isString;
    var util_12 = util.isSymbol;
    var util_13 = util.isUndefined;
    var util_14 = util.isRegExp;
    var util_15 = util.isObject;
    var util_16 = util.isDate;
    var util_17 = util.isError;
    var util_18 = util.isFunction;
    var util_19 = util.isPrimitive;
    var util_20 = util.isBuffer;
    var util_21 = util.log;
    var util_22 = util.inherits;
    var util_23 = util._extend;
    var util_24 = util.promisify;
    var util_25 = util.callbackify;

    function ProtocolError(message) {
        Error.call(this);
        this.message = message;
        this.name = 'ProtocolError';
    }
    util.inherits(ProtocolError, Error);

    function TypeError$1(message) {
        ProtocolError.call(this, message);
        this.message = message;
        this.name = 'TypeError';
    }

    util.inherits(TypeError$1, ProtocolError);

    function ConnectionError(message, condition, connection) {
        Error.call(this, message);
        this.message = message;
        this.name = 'ConnectionError';
        this.condition = condition;
        this.description = message;
        this.connection = connection;
    }

    util.inherits(ConnectionError, Error);

    ConnectionError.prototype.toJSON = function () {
        return {
            type: this.name,
            code: this.condition,
            message: this.description
        };
    };

    var errors = {
        ProtocolError: ProtocolError,
        TypeError: TypeError$1,
        ConnectionError: ConnectionError
    };

    var util$1 = {};

    util$1.allocate_buffer = function (size) {
        return buffer_1.alloc ? buffer_1.alloc(size) : new buffer_1(size);
    };

    util$1.generate_uuid = function () {
        return util$1.uuid_to_string(util$1.uuid4());
    };

    util$1.uuid4 = function () {
        var bytes = util$1.allocate_buffer(16);
        for (var i = 0; i < bytes.length; i++) {
            bytes[i] = Math.random()*255|0;
        }

        // From RFC4122, the version bits are set to 0100
        bytes[7] &= 0x0F;
        bytes[7] |= 0x40;

        // From RFC4122, the top two bits of byte 8 get set to 01
        bytes[8] &= 0x3F;
        bytes[8] |= 0x80;

        return bytes;
    };


    util$1.uuid_to_string = function (buffer) {
        if (buffer.length === 16) {
            var chunks = [buffer.slice(0, 4), buffer.slice(4, 6), buffer.slice(6, 8), buffer.slice(8, 10), buffer.slice(10, 16)];
            return chunks.map(function (b) { return b.toString('hex'); }).join('-');
        } else {
            throw new errors.TypeError('Not a UUID, expecting 16 byte buffer');
        }
    };

    var parse_uuid = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/;

    util$1.string_to_uuid = function (uuid_string) {
        var parts = parse_uuid.exec(uuid_string.toLowerCase());
        if (parts) {
            return buffer_1.from(parts.slice(1).join(''), 'hex');
        } else {
            throw new errors.TypeError('Not a valid UUID string: ' + uuid_string);
        }
    };

    util$1.clone = function (o) {
        var copy = Object.create(o.prototype || {});
        var names = Object.getOwnPropertyNames(o);
        for (var i = 0; i < names.length; i++) {
            var key = names[i];
            copy[key] = o[key];
        }
        return copy;
    };

    util$1.and = function (f, g) {
        if (g === undefined) return f;
        return function (o) {
            return f(o) && g(o);
        };
    };

    util$1.is_sender = function (o) { return o.is_sender(); };
    util$1.is_receiver = function (o) { return o.is_receiver(); };
    util$1.sender_filter = function (filter) { return util$1.and(util$1.is_sender, filter); };
    util$1.receiver_filter = function (filter) { return util$1.and(util$1.is_receiver, filter); };

    util$1.is_defined = function (field) {
        return field !== undefined && field !== null;
    };

    var util_1$1 = util$1;

    var CAT_FIXED = 1;
    var CAT_VARIABLE = 2;
    var CAT_COMPOUND = 3;
    var CAT_ARRAY = 4;

    function Typed(type, value, code, descriptor) {
        this.type = type;
        this.value = value;
        if (code) {
            this.array_constructor = {'typecode':code};
            if (descriptor) {
                this.array_constructor.descriptor = descriptor;
            }
        }
    }

    Typed.prototype.toString = function() {
        return this.value ? this.value.toString() : null;
    };

    Typed.prototype.toLocaleString = function() {
        return this.value ? this.value.toLocaleString() : null;
    };

    Typed.prototype.valueOf = function() {
        return this.value;
    };

    Typed.prototype.toJSON = function() {
        return this.value && this.value.toJSON ? this.value.toJSON() : this.value;
    };

    function TypeDesc(name, typecode, props, empty_value) {
        this.name = name;
        this.typecode = typecode;
        var subcategory = typecode >>> 4;
        switch (subcategory) {
        case 0x4:
            this.width = 0;
            this.category = CAT_FIXED;
            break;
        case 0x5:
            this.width = 1;
            this.category = CAT_FIXED;
            break;
        case 0x6:
            this.width = 2;
            this.category = CAT_FIXED;
            break;
        case 0x7:
            this.width = 4;
            this.category = CAT_FIXED;
            break;
        case 0x8:
            this.width = 8;
            this.category = CAT_FIXED;
            break;
        case 0x9:
            this.width = 16;
            this.category = CAT_FIXED;
            break;
        case 0xA:
            this.width = 1;
            this.category = CAT_VARIABLE;
            break;
        case 0xB:
            this.width = 4;
            this.category = CAT_VARIABLE;
            break;
        case 0xC:
            this.width = 1;
            this.category = CAT_COMPOUND;
            break;
        case 0xD:
            this.width = 4;
            this.category = CAT_COMPOUND;
            break;
        case 0xE:
            this.width = 1;
            this.category = CAT_ARRAY;
            break;
        case 0xF:
            this.width = 4;
            this.category = CAT_ARRAY;
            break;
        }

        if (props) {
            if (props.read) {
                this.read = props.read;
            }
            if (props.write) {
                this.write = props.write;
            }
            if (props.encoding) {
                this.encoding = props.encoding;
            }
        }

        var t = this;
        if (subcategory === 0x4) {
            // 'empty' types don't take a value
            this.create = function () {
                return new Typed(t, empty_value);
            };
        } else if (subcategory === 0xE || subcategory === 0xF) {
            this.create = function (v, code, descriptor) {
                return new Typed(t, v, code, descriptor);
            };
        } else {
            this.create = function (v) {
                return new Typed(t, v);
            };
        }
    }

    TypeDesc.prototype.toString = function () {
        return this.name + '#' + hex(this.typecode);
    };

    function hex(i) {
        return Number(i).toString(16);
    }

    var types$1 = {'by_code':{}};
    Object.defineProperty(types$1, 'MAX_UINT', {value: 4294967295, writable: false, configurable: false});
    Object.defineProperty(types$1, 'MAX_USHORT', {value: 65535, writable: false, configurable: false});

    function define_type(name, typecode, annotations, empty_value) {
        var t = new TypeDesc(name, typecode, annotations, empty_value);
        t.create.typecode = t.typecode;//hack
        types$1.by_code[t.typecode] = t;
        types$1[name] = t.create;
    }

    function buffer_uint8_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readUInt8(offset); },
            'write': function (buffer, value, offset) { buffer.writeUInt8(value, offset); }
        };
    }

    function buffer_uint16be_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readUInt16BE(offset); },
            'write': function (buffer, value, offset) { buffer.writeUInt16BE(value, offset); }
        };
    }

    function buffer_uint32be_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readUInt32BE(offset); },
            'write': function (buffer, value, offset) { buffer.writeUInt32BE(value, offset); }
        };
    }

    function buffer_int8_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readInt8(offset); },
            'write': function (buffer, value, offset) { buffer.writeInt8(value, offset); }
        };
    }

    function buffer_int16be_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readInt16BE(offset); },
            'write': function (buffer, value, offset) { buffer.writeInt16BE(value, offset); }
        };
    }

    function buffer_int32be_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readInt32BE(offset); },
            'write': function (buffer, value, offset) { buffer.writeInt32BE(value, offset); }
        };
    }

    function buffer_floatbe_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readFloatBE(offset); },
            'write': function (buffer, value, offset) { buffer.writeFloatBE(value, offset); }
        };
    }

    function buffer_doublebe_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readDoubleBE(offset); },
            'write': function (buffer, value, offset) { buffer.writeDoubleBE(value, offset); }
        };
    }

    var MAX_UINT = 4294967296; // 2^32
    var MIN_INT = -2147483647;
    function write_ulong(buffer, value, offset) {
        if ((typeof value) === 'number' || value instanceof Number) {
            var hi = Math.floor(value / MAX_UINT);
            var lo = value % MAX_UINT;
            buffer.writeUInt32BE(hi, offset);
            buffer.writeUInt32BE(lo, offset + 4);
        } else {
            value.copy(buffer, offset);
        }
    }

    function read_ulong(buffer, offset) {
        var hi = buffer.readUInt32BE(offset);
        var lo = buffer.readUInt32BE(offset + 4);
        if (hi < 2097153) {
            return hi * MAX_UINT + lo;
        } else {
            return buffer.slice(offset, offset + 8);
        }
    }

    function write_long(buffer, value, offset) {
        if ((typeof value) === 'number' || value instanceof Number) {
            var abs = Math.abs(value);
            var hi = Math.floor(abs / MAX_UINT);
            var lo = abs % MAX_UINT;
            buffer.writeInt32BE(hi, offset);
            buffer.writeUInt32BE(lo, offset + 4);
            if (value < 0) {
                var carry = 1;
                for (var i = 0; i < 8; i++) {
                    var index = offset + (7 - i);
                    var v = (buffer[index] ^ 0xFF) + carry;
                    buffer[index] = v & 0xFF;
                    carry = v >> 8;
                }
            }
        } else {
            value.copy(buffer, offset);
        }
    }

    function read_long(buffer, offset) {
        var hi = buffer.readInt32BE(offset);
        var lo = buffer.readUInt32BE(offset + 4);
        if (hi < 2097153 && hi > -2097153) {
            return hi * MAX_UINT + lo;
        } else {
            return buffer.slice(offset, offset + 8);
        }
    }

    define_type('Null', 0x40, undefined, null);
    define_type('Boolean', 0x56, buffer_uint8_ops());
    define_type('True', 0x41, undefined, true);
    define_type('False', 0x42, undefined, false);
    define_type('Ubyte', 0x50, buffer_uint8_ops());
    define_type('Ushort', 0x60, buffer_uint16be_ops());
    define_type('Uint', 0x70, buffer_uint32be_ops());
    define_type('SmallUint', 0x52, buffer_uint8_ops());
    define_type('Uint0', 0x43, undefined, 0);
    define_type('Ulong', 0x80, {'write':write_ulong, 'read':read_ulong});
    define_type('SmallUlong', 0x53, buffer_uint8_ops());
    define_type('Ulong0', 0x44, undefined, 0);
    define_type('Byte', 0x51, buffer_int8_ops());
    define_type('Short', 0x61, buffer_int16be_ops());
    define_type('Int', 0x71, buffer_int32be_ops());
    define_type('SmallInt', 0x54, buffer_int8_ops());
    define_type('Long', 0x81, {'write':write_long, 'read':read_long});
    define_type('SmallLong', 0x55, buffer_int8_ops());
    define_type('Float', 0x72, buffer_floatbe_ops());
    define_type('Double', 0x82, buffer_doublebe_ops());
    define_type('Decimal32', 0x74);
    define_type('Decimal64', 0x84);
    define_type('Decimal128', 0x94);
    define_type('CharUTF32', 0x73, buffer_uint32be_ops());
    define_type('Timestamp', 0x83, {'write':write_long, 'read':read_long});//TODO: convert to/from Date
    define_type('Uuid', 0x98);//TODO: convert to/from stringified form?
    define_type('Vbin8', 0xa0);
    define_type('Vbin32', 0xb0);
    define_type('Str8', 0xa1, {'encoding':'utf8'});
    define_type('Str32', 0xb1, {'encoding':'utf8'});
    define_type('Sym8', 0xa3, {'encoding':'ascii'});
    define_type('Sym32', 0xb3, {'encoding':'ascii'});
    define_type('List0', 0x45, undefined, []);
    define_type('List8', 0xc0);
    define_type('List32', 0xd0);
    define_type('Map8', 0xc1);
    define_type('Map32', 0xd1);
    define_type('Array8', 0xe0);
    define_type('Array32', 0xf0);

    function is_one_of(o, typelist) {
        for (var i = 0; i < typelist.length; i++) {
            if (o.type.typecode === typelist[i].typecode) return true;
        }
        return false;
    }
    function buffer_zero(b, len, neg) {
        for (var i = 0; i < len && i < b.length; i++) {
            if (b[i] !== (neg ? 0xff : 0)) return false;
        }
        return true;
    }
    types$1.is_ulong = function(o) {
        return is_one_of(o, [types$1.Ulong, types$1.Ulong0, types$1.SmallUlong]);
    };
    types$1.is_string = function(o) {
        return is_one_of(o, [types$1.Str8, types$1.Str32]);
    };
    types$1.is_symbol = function(o) {
        return is_one_of(o, [types$1.Sym8, types$1.Sym32]);
    };
    types$1.is_list = function(o) {
        return is_one_of(o, [types$1.List0, types$1.List8, types$1.List32]);
    };
    types$1.is_map = function(o) {
        return is_one_of(o, [types$1.Map8, types$1.Map32]);
    };

    types$1.wrap_boolean = function(v) {
        return v ? types$1.True() : types$1.False();
    };
    types$1.wrap_ulong = function(l) {
        if (buffer_1.isBuffer(l)) {
            if (buffer_zero(l, 8, false)) return types$1.Ulong0();
            return buffer_zero(l, 7, false) ? types$1.SmallUlong(l[7]) : types$1.Ulong(l);
        } else {
            if (l === 0) return types$1.Ulong0();
            else return l > 255 ? types$1.Ulong(l) : types$1.SmallUlong(l);
        }
    };
    types$1.wrap_uint = function(l) {
        if (l === 0) return types$1.Uint0();
        else return l > 255 ? types$1.Uint(l) : types$1.SmallUint(l);
    };
    types$1.wrap_ushort = function(l) {
        return types$1.Ushort(l);
    };
    types$1.wrap_ubyte = function(l) {
        return types$1.Ubyte(l);
    };
    types$1.wrap_long = function(l) {
        if (buffer_1.isBuffer(l)) {
            var negFlag = (l[0] & 0x80) !== 0;
            if (buffer_zero(l, 7, negFlag) && (l[7] & 0x80) === (negFlag ? 0x80 : 0)) {
                return types$1.SmallLong(negFlag ? -((l[7] ^ 0xff) + 1) : l[7]);
            }
            return types$1.Long(l);
        } else {
            return l > 127 || l < -128 ? types$1.Long(l) : types$1.SmallLong(l);
        }
    };
    types$1.wrap_int = function(l) {
        return l > 127 || l < -128 ? types$1.Int(l) : types$1.SmallInt(l);
    };
    types$1.wrap_short = function(l) {
        return types$1.Short(l);
    };
    types$1.wrap_byte = function(l) {
        return types$1.Byte(l);
    };
    types$1.wrap_float = function(l) {
        return types$1.Float(l);
    };
    types$1.wrap_double = function(l) {
        return types$1.Double(l);
    };
    types$1.wrap_timestamp = function(l) {
        return types$1.Timestamp(l);
    };
    types$1.wrap_char = function(v) {
        return types$1.CharUTF32(v);
    };
    types$1.wrap_uuid = function(v) {
        return types$1.Uuid(v);
    };
    types$1.wrap_binary = function (s) {
        return s.length > 255 ? types$1.Vbin32(s) : types$1.Vbin8(s);
    };
    types$1.wrap_string = function (s) {
        return buffer_1.from(s).length > 255 ? types$1.Str32(s) : types$1.Str8(s);
    };
    types$1.wrap_symbol = function (s) {
        return buffer_1.from(s).length > 255 ? types$1.Sym32(s) : types$1.Sym8(s);
    };
    types$1.wrap_list = function(l) {
        if (l.length === 0) return types$1.List0();
        var items = l.map(types$1.wrap);
        return types$1.List32(items);
    };
    types$1.wrap_map = function(m, key_wrapper) {
        var items = [];
        for (var k in m) {
            items.push(key_wrapper ? key_wrapper(k) : types$1.wrap(k));
            items.push(types$1.wrap(m[k]));
        }
        return types$1.Map32(items);
    };
    types$1.wrap_symbolic_map = function(m) {
        return types$1.wrap_map(m, types$1.wrap_symbol);
    };
    types$1.wrap_array = function(l, code, descriptors) {
        if (code) {
            return types$1.Array32(l, code, descriptors);
        } else {
            console.trace('An array must specify a type for its elements');
            throw new errors.TypeError('An array must specify a type for its elements');
        }
    };
    types$1.wrap = function(o) {
        var t = typeof o;
        if (t === 'string') {
            return types$1.wrap_string(o);
        } else if (t === 'boolean') {
            return o ? types$1.True() : types$1.False();
        } else if (t === 'number' || o instanceof Number) {
            if (isNaN(o)) {
                return types$1.Null();
            } else if (Math.floor(o) - o !== 0) {
                return types$1.Double(o);
            } else if (o > 0) {
                if (o < MAX_UINT) {
                    return types$1.wrap_uint(o);
                } else {
                    return types$1.wrap_ulong(o);
                }
            } else {
                if (o > MIN_INT) {
                    return types$1.wrap_int(o);
                } else {
                    return types$1.wrap_long(o);
                }
            }
        } else if (o instanceof Date) {
            return types$1.wrap_timestamp(o.getTime());
        } else if (o instanceof Typed) {
            return o;
        } else if (o instanceof buffer_1) {
            return types$1.wrap_binary(o);
        } else if (t === 'undefined' || o === null) {
            return types$1.Null();
        } else if (Array.isArray(o)) {
            return types$1.wrap_list(o);
        } else {
            return types$1.wrap_map(o);
        }
    };

    types$1.wrap_described = function(value, descriptor) {
        var result = types$1.wrap(value);
        if (descriptor) {
            if (typeof descriptor === 'string') {
                result = types$1.described(types$1.wrap_symbol(descriptor), result);
            } else if (typeof descriptor === 'number' || descriptor instanceof Number) {
                result = types$1.described(types$1.wrap_ulong(descriptor), result);
            }
        }
        return result;
    };

    types$1.wrap_message_id = function(o) {
        var t = typeof o;
        if (t === 'string') {
            return types$1.wrap_string(o);
        } else if (t === 'number' || o instanceof Number) {
            return types$1.wrap_ulong(o);
        } else if (buffer_1.isBuffer(o)) {
            return types$1.wrap_uuid(o);
        } else {
            //TODO handle uuids
            throw new errors.TypeError('invalid message id:' + o);
        }
    };

    /**
     * Converts the list of keys and values that comprise an AMQP encoded
     * map into a proper javascript map/object.
     */
    function mapify(elements) {
        var result = {};
        for (var i = 0; i+1 < elements.length;) {
            result[elements[i++]] = elements[i++];
        }
        return result;
    }

    var by_descriptor = {};

    types$1.unwrap_map_simple = function(o) {
        return mapify(o.value.map(function (i) { return types$1.unwrap(i, true); }));
    };

    types$1.unwrap = function(o, leave_described) {
        if (o instanceof Typed) {
            if (o.descriptor) {
                var c = by_descriptor[o.descriptor.value];
                if (c) {
                    return new c(o.value);
                } else if (leave_described) {
                    return o;
                }
            }
            var u = types$1.unwrap(o.value, true);
            return types$1.is_map(o) ? mapify(u) : u;
        } else if (Array.isArray(o)) {
            return o.map(function (i) { return types$1.unwrap(i, true); });
        } else {
            return o;
        }
    };

    /*
    types.described = function (descriptor, typedvalue) {
        var o = Object.create(typedvalue);
        if (descriptor.length) {
            o.descriptor = descriptor.shift();
            return types.described(descriptor, o);
        } else {
            o.descriptor = descriptor;
            return o;
        }
    };
    */
    types$1.described_nc = function (descriptor, o) {
        if (descriptor.length) {
            o.descriptor = descriptor.shift();
            return types$1.described(descriptor, o);
        } else {
            o.descriptor = descriptor;
            return o;
        }
    };
    types$1.described = types$1.described_nc;

    function get_type(code) {
        var type = types$1.by_code[code];
        if (!type) {
            throw new errors.TypeError('Unrecognised typecode: ' + hex(code));
        }
        return type;
    }

    types$1.Reader = function (buffer) {
        this.buffer = buffer;
        this.position = 0;
    };

    types$1.Reader.prototype.read_typecode = function () {
        return this.read_uint(1);
    };

    types$1.Reader.prototype.read_uint = function (width) {
        var current = this.position;
        this.position += width;
        if (width === 1) {
            return this.buffer.readUInt8(current);
        } else if (width === 2) {
            return this.buffer.readUInt16BE(current);
        } else if (width === 4) {
            return this.buffer.readUInt32BE(current);
        } else {
            throw new errors.TypeError('Unexpected width for uint ' + width);
        }
    };

    types$1.Reader.prototype.read_fixed_width = function (type) {
        var current = this.position;
        this.position += type.width;
        if (type.read) {
            return type.read(this.buffer, current);
        } else {
            return this.buffer.slice(current, this.position);
        }
    };

    types$1.Reader.prototype.read_variable_width = function (type) {
        var size = this.read_uint(type.width);
        var slice = this.read_bytes(size);
        return type.encoding ? slice.toString(type.encoding) : slice;
    };

    types$1.Reader.prototype.read = function () {
        var constructor = this.read_constructor();
        var value = this.read_value(get_type(constructor.typecode));
        return constructor.descriptor ? types$1.described_nc(constructor.descriptor, value) : value;
    };

    types$1.Reader.prototype.read_constructor = function () {
        var code = this.read_typecode();
        if (code === 0x00) {
            var d = [];
            d.push(this.read());
            var c = this.read_constructor();
            while (c.descriptor) {
                d.push(c.descriptor);
                c = this.read_constructor();
            }
            return {'typecode': c.typecode, 'descriptor':  d.length === 1 ? d[0] : d};
        } else {
            return {'typecode': code};
        }
    };

    types$1.Reader.prototype.read_value = function (type) {
        if (type.width === 0) {
            return type.create();
        } else if (type.category === CAT_FIXED) {
            return type.create(this.read_fixed_width(type));
        } else if (type.category === CAT_VARIABLE) {
            return type.create(this.read_variable_width(type));
        } else if (type.category === CAT_COMPOUND) {
            return this.read_compound(type);
        } else if (type.category === CAT_ARRAY) {
            return this.read_array(type);
        } else {
            throw new errors.TypeError('Invalid category for type: ' + type);
        }
    };

    types$1.Reader.prototype.read_array_items = function (n, type) {
        var items = [];
        while (items.length < n) {
            items.push(this.read_value(type));
        }
        return items;
    };

    types$1.Reader.prototype.read_n = function (n) {
        var items = new Array(n);
        for (var i = 0; i < n; i++) {
            items[i] = this.read();
        }
        return items;
    };

    types$1.Reader.prototype.read_size_count = function (width) {
        return {'size': this.read_uint(width), 'count': this.read_uint(width)};
    };

    types$1.Reader.prototype.read_compound = function (type) {
        var limits = this.read_size_count(type.width);
        return type.create(this.read_n(limits.count));
    };

    types$1.Reader.prototype.read_array = function (type) {
        var limits = this.read_size_count(type.width);
        var constructor = this.read_constructor();
        return type.create(this.read_array_items(limits.count, get_type(constructor.typecode)), constructor.typecode, constructor.descriptor);
    };

    types$1.Reader.prototype.toString = function () {
        var s = 'buffer@' + this.position;
        if (this.position) s += ': ';
        for (var i = this.position; i < this.buffer.length; i++) {
            if (i > 0) s+= ',';
            s += '0x' + Number(this.buffer[i]).toString(16);
        }
        return s;
    };

    types$1.Reader.prototype.reset = function () {
        this.position = 0;
    };

    types$1.Reader.prototype.skip = function (bytes) {
        this.position += bytes;
    };

    types$1.Reader.prototype.read_bytes = function (bytes) {
        var current = this.position;
        this.position += bytes;
        return this.buffer.slice(current, this.position);
    };

    types$1.Reader.prototype.remaining = function () {
        return this.buffer.length - this.position;
    };

    types$1.Writer = function (buffer) {
        this.buffer = buffer ? buffer : util_1$1.allocate_buffer(1024);
        this.position = 0;
    };

    types$1.Writer.prototype.toBuffer = function () {
        return this.buffer.slice(0, this.position);
    };

    function max(a, b) {
        return a > b ? a : b;
    }

    types$1.Writer.prototype.ensure = function (length) {
        if (this.buffer.length < length) {
            var bigger = util_1$1.allocate_buffer(max(this.buffer.length*2, length));
            this.buffer.copy(bigger);
            this.buffer = bigger;
        }
    };

    types$1.Writer.prototype.write_typecode = function (code) {
        this.write_uint(code, 1);
    };

    types$1.Writer.prototype.write_uint = function (value, width) {
        var current = this.position;
        this.ensure(this.position + width);
        this.position += width;
        if (width === 1) {
            return this.buffer.writeUInt8(value, current);
        } else if (width === 2) {
            return this.buffer.writeUInt16BE(value, current);
        } else if (width === 4) {
            return this.buffer.writeUInt32BE(value, current);
        } else {
            throw new errors.TypeError('Unexpected width for uint ' + width);
        }
    };


    types$1.Writer.prototype.write_fixed_width = function (type, value) {
        var current = this.position;
        this.ensure(this.position + type.width);
        this.position += type.width;
        if (type.write) {
            type.write(this.buffer, value, current);
        } else if (value.copy) {
            value.copy(this.buffer, current);
        } else {
            throw new errors.TypeError('Cannot handle write for ' + type);
        }
    };

    types$1.Writer.prototype.write_variable_width = function (type, value) {
        var source = type.encoding ? buffer_1.from(value, type.encoding) : buffer_1.from(value);//TODO: avoid creating new buffers
        this.write_uint(source.length, type.width);
        this.write_bytes(source);
    };

    types$1.Writer.prototype.write_bytes = function (source) {
        var current = this.position;
        this.ensure(this.position + source.length);
        this.position += source.length;
        source.copy(this.buffer, current);
    };

    types$1.Writer.prototype.write_constructor = function (typecode, descriptor) {
        if (descriptor) {
            this.write_typecode(0x00);
            this.write(descriptor);
        }
        this.write_typecode(typecode);
    };

    types$1.Writer.prototype.write = function (o) {
        if (o.type === undefined) {
            if (o.described) {
                this.write(o.described());
            } else {
                throw new errors.TypeError('Cannot write ' + JSON.stringify(o));
            }
        } else {
            this.write_constructor(o.type.typecode, o.descriptor);
            this.write_value(o.type, o.value, o.array_constructor);
        }
    };

    types$1.Writer.prototype.write_value = function (type, value, constructor/*for arrays only*/) {
        if (type.width === 0) {
            return;//nothing further to do
        } else if (type.category === CAT_FIXED) {
            this.write_fixed_width(type, value);
        } else if (type.category === CAT_VARIABLE) {
            this.write_variable_width(type, value);
        } else if (type.category === CAT_COMPOUND) {
            this.write_compound(type, value);
        } else if (type.category === CAT_ARRAY) {
            this.write_array(type, value, constructor);
        } else {
            throw new errors.TypeError('Invalid category ' + type.category + ' for type: ' + type);
        }
    };

    types$1.Writer.prototype.backfill_size = function (width, saved) {
        var gap = this.position - saved;
        this.position = saved;
        this.write_uint(gap - width, width);
        this.position += (gap - width);
    };

    types$1.Writer.prototype.write_compound = function (type, value) {
        var saved = this.position;
        this.position += type.width;//skip size field
        this.write_uint(value.length, type.width);//count field
        for (var i = 0; i < value.length; i++) {
            if (value[i] === undefined || value[i] === null) {
                this.write(types$1.Null());
            } else {
                this.write(value[i]);
            }
        }
        this.backfill_size(type.width, saved);
    };

    types$1.Writer.prototype.write_array = function (type, value, constructor) {
        var saved = this.position;
        this.position += type.width;//skip size field
        this.write_uint(value.length, type.width);//count field
        this.write_constructor(constructor.typecode, constructor.descriptor);
        var ctype = get_type(constructor.typecode);
        for (var i = 0; i < value.length; i++) {
            this.write_value(ctype, value[i]);
        }
        this.backfill_size(type.width, saved);
    };

    types$1.Writer.prototype.toString = function () {
        var s = 'buffer@' + this.position;
        if (this.position) s += ': ';
        for (var i = 0; i < this.position; i++) {
            if (i > 0) s+= ',';
            s += ('00' + Number(this.buffer[i]).toString(16)).slice(-2);
        }
        return s;
    };

    types$1.Writer.prototype.skip = function (bytes) {
        this.ensure(this.position + bytes);
        this.position += bytes;
    };

    types$1.Writer.prototype.clear = function () {
        this.buffer.fill(0x00);
        this.position = 0;
    };

    types$1.Writer.prototype.remaining = function () {
        return this.buffer.length - this.position;
    };


    function get_constructor(typename) {
        if (typename === 'symbol') {
            return {typecode:types$1.Sym8.typecode};
        }
        throw new errors.TypeError('TODO: Array of type ' + typename + ' not yet supported');
    }

    function wrap_field(definition, instance) {
        if (instance !== undefined && instance !== null) {
            if (Array.isArray(instance)) {
                if (!definition.multiple) {
                    throw new errors.TypeError('Field ' + definition.name + ' does not support multiple values, got ' + JSON.stringify(instance));
                }
                var constructor = get_constructor(definition.type);
                return types$1.wrap_array(instance, constructor.typecode, constructor.descriptor);
            } else if (definition.type === '*') {
                return instance;
            } else {
                var wrapper = types$1['wrap_' + definition.type];
                if (wrapper) {
                    return wrapper(instance);
                } else {
                    throw new errors.TypeError('No wrapper for field ' + definition.name + ' of type ' + definition.type);
                }
            }
        } else if (definition.mandatory) {
            throw new errors.TypeError('Field ' + definition.name + ' is mandatory');
        } else {
            return types$1.Null();
        }
    }

    function get_accessors(index, field_definition) {
        var getter;
        if (field_definition.type === '*') {
            getter = function() { return this.value[index]; };
        } else {
            getter = function() { return types$1.unwrap(this.value[index]); };
        }
        var setter = function(o) { this.value[index] = wrap_field(field_definition, o); };
        return {'get': getter, 'set': setter, 'enumerable':true, 'configurable':false};
    }

    types$1.define_composite = function(def) {
        var c = function(fields) {
            this.value = fields ? fields : [];
        };
        c.descriptor = {
            numeric: def.code,
            symbolic: 'amqp:' + def.name + ':list'
        };
        c.prototype.dispatch = function (target, frame) {
            target['on_' + def.name](frame);
        };
        //c.prototype.descriptor = c.descriptor.numeric;
        //c.prototype = Object.create(types.List8.prototype);
        for (var i = 0; i < def.fields.length; i++) {
            var f = def.fields[i];
            Object.defineProperty(c.prototype, f.name, get_accessors(i, f));
        }
        c.toString = function() {
            return def.name + '#' + Number(def.code).toString(16);
        };
        c.prototype.toJSON = function() {
            var o = {};
            for (var f in this) {
                if (f !== 'value' && this[f]) {
                    o[f] = this[f];
                }
            }
            return o;
        };
        c.create = function(fields) {
            var o = new c;
            for (var f in fields) {
                o[f] = fields[f];
            }
            return o;
        };
        c.prototype.described = function() {
            return types$1.described_nc(types$1.wrap_ulong(c.descriptor.numeric), types$1.wrap_list(this.value));
        };
        return c;
    };

    function add_type(def) {
        var c = types$1.define_composite(def);
        types$1['wrap_' + def.name] = function (fields) {
            return c.create(fields).described();
        };
        by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;
        by_descriptor[c.descriptor.symbolic] = c;
    }

    add_type({
        name: 'error',
        code: 0x1d,
        fields: [
            {name:'condition', type:'symbol', mandatory:true},
            {name:'description', type:'string'},
            {name:'info', type:'map'}
        ]
    });

    var types_1$1 = types$1;

    var frames = {};
    var by_descriptor$1 = {};

    frames.read_header = function(buffer) {
        var offset = 4;
        var header = {};
        var name = buffer.toString('ascii', 0, offset);
        if (name !== 'AMQP') {
            throw new errors.ProtocolError('Invalid protocol header for AMQP ' + name);
        }
        header.protocol_id = buffer.readUInt8(offset++);
        header.major = buffer.readUInt8(offset++);
        header.minor = buffer.readUInt8(offset++);
        header.revision = buffer.readUInt8(offset++);
        //the protocol header is interpreted in different ways for
        //different versions(!); check some special cases to give clearer
        //error messages:
        if (header.protocol_id === 0 && header.major === 0 && header.minor === 9 && header.revision === 1) {
            throw new errors.ProtocolError('Unsupported AMQP version: 0-9-1');
        }
        if (header.protocol_id === 1 && header.major === 1 && header.minor === 0 && header.revision === 10) {
            throw new errors.ProtocolError('Unsupported AMQP version: 0-10');
        }
        if (header.major !== 1 || header.minor !== 0) {
            throw new errors.ProtocolError('Unsupported AMQP version: ' + JSON.stringify(header));
        }
        return header;
    };
    frames.write_header = function(buffer, header) {
        var offset = 4;
        buffer.write('AMQP', 0, offset, 'ascii');
        buffer.writeUInt8(header.protocol_id, offset++);
        buffer.writeUInt8(header.major, offset++);
        buffer.writeUInt8(header.minor, offset++);
        buffer.writeUInt8(header.revision, offset++);
        return 8;
    };
    //todo: define enumeration for frame types
    frames.TYPE_AMQP = 0x00;
    frames.TYPE_SASL = 0x01;

    frames.read_frame = function(buffer) {
        var reader = new types_1$1.Reader(buffer);
        var frame = {};
        frame.size = reader.read_uint(4);
        if (reader.remaining < frame.size) {
            return null;
        }
        var doff = reader.read_uint(1);
        if (doff < 2) {
            throw new errors.ProtocolError('Invalid data offset, must be at least 2 was ' + doff);
        }
        frame.type = reader.read_uint(1);
        if (frame.type === frames.TYPE_AMQP) {
            frame.channel = reader.read_uint(2);
        } else if (frame.type === frames.TYPE_SASL) {
            reader.skip(2);
            frame.channel = 0;
        } else {
            throw new errors.ProtocolError('Unknown frame type ' + frame.type);
        }
        if (doff > 1) {
            //ignore any extended header
            reader.skip(doff * 4 - 8);
        }
        if (reader.remaining()) {
            frame.performative = reader.read();
            var c = by_descriptor$1[frame.performative.descriptor.value];
            if (c) {
                frame.performative = new c(frame.performative.value);
            }
            if (reader.remaining()) {
                frame.payload = reader.read_bytes(reader.remaining());
            }
        }
        return frame;
    };

    frames.write_frame = function(frame) {
        var writer = new types_1$1.Writer();
        writer.skip(4);//skip size until we know how much we have written
        writer.write_uint(2, 1);//doff
        writer.write_uint(frame.type, 1);
        if (frame.type === frames.TYPE_AMQP) {
            writer.write_uint(frame.channel, 2);
        } else if (frame.type === frames.TYPE_SASL) {
            writer.write_uint(0, 2);
        } else {
            throw new errors.ProtocolError('Unknown frame type ' + frame.type);
        }
        if (frame.performative) {
            writer.write(frame.performative);
            if (frame.payload) {
                writer.write_bytes(frame.payload);
            }
        }
        var buffer = writer.toBuffer();
        buffer.writeUInt32BE(buffer.length, 0);//fill in the size
        return buffer;
    };

    frames.amqp_frame = function(channel, performative, payload) {
        return {'channel': channel || 0, 'type': frames.TYPE_AMQP, 'performative': performative, 'payload': payload};
    };
    frames.sasl_frame = function(performative) {
        return {'channel': 0, 'type': frames.TYPE_SASL, 'performative': performative};
    };

    function define_frame(type, def) {
        var c = types_1$1.define_composite(def);
        frames[def.name] = c.create;
        by_descriptor$1[Number(c.descriptor.numeric).toString(10)] = c;
        by_descriptor$1[c.descriptor.symbolic] = c;
    }

    var open = {
        name: 'open',
        code: 0x10,
        fields: [
            {name: 'container_id', type: 'string', mandatory: true},
            {name: 'hostname', type: 'string'},
            {name: 'max_frame_size', type: 'uint', default_value: 4294967295},
            {name: 'channel_max', type: 'ushort', default_value: 65535},
            {name: 'idle_time_out', type: 'uint'},
            {name: 'outgoing_locales', type: 'symbol', multiple: true},
            {name: 'incoming_locales', type: 'symbol', multiple: true},
            {name: 'offered_capabilities', type: 'symbol', multiple: true},
            {name: 'desired_capabilities', type: 'symbol', multiple: true},
            {name: 'properties', type: 'symbolic_map'}
        ]
    };

    var begin = {
        name: 'begin',
        code: 0x11,
        fields:[
            {name: 'remote_channel', type: 'ushort'},
            {name: 'next_outgoing_id', type: 'uint', mandatory: true},
            {name: 'incoming_window', type: 'uint', mandatory: true},
            {name: 'outgoing_window', type: 'uint', mandatory: true},
            {name: 'handle_max', type: 'uint', default_value: '4294967295'},
            {name: 'offered_capabilities', type: 'symbol', multiple: true},
            {name: 'desired_capabilities', type: 'symbol', multiple: true},
            {name: 'properties', type: 'symbolic_map'}
        ]
    };

    var attach = {
        name: 'attach',
        code: 0x12,
        fields:[
            {name: 'name', type: 'string', mandatory: true},
            {name: 'handle', type: 'uint', mandatory: true},
            {name: 'role', type: 'boolean', mandatory: true},
            {name: 'snd_settle_mode', type: 'ubyte', default_value: 2},
            {name: 'rcv_settle_mode', type: 'ubyte', default_value: 0},
            {name: 'source', type: '*'},
            {name: 'target', type: '*'},
            {name: 'unsettled', type: 'map'},
            {name: 'incomplete_unsettled', type: 'boolean', default_value: false},
            {name: 'initial_delivery_count', type: 'uint'},
            {name: 'max_message_size', type: 'ulong'},
            {name: 'offered_capabilities', type: 'symbol', multiple: true},
            {name: 'desired_capabilities', type: 'symbol', multiple: true},
            {name: 'properties', type: 'symbolic_map'}
        ]
    };

    var flow = {
        name: 'flow',
        code: 0x13,
        fields:[
            {name: 'next_incoming_id', type: 'uint'},
            {name: 'incoming_window', type: 'uint', mandatory: true},
            {name: 'next_outgoing_id', type: 'uint', mandatory: true},
            {name: 'outgoing_window', type: 'uint', mandatory: true},
            {name: 'handle', type: 'uint'},
            {name: 'delivery_count', type: 'uint'},
            {name: 'link_credit', type: 'uint'},
            {name: 'available', type: 'uint'},
            {name: 'drain', type: 'boolean', default_value: false},
            {name: 'echo', type: 'boolean', default_value: false},
            {name: 'properties', type: 'symbolic_map'}
        ]
    };

    var transfer = {
        name: 'transfer',
        code: 0x14,
        fields:[
            {name: 'handle', type: 'uint', mandatory: true},
            {name: 'delivery_id', type: 'uint'},
            {name: 'delivery_tag', type: 'binary'},
            {name: 'message_format', type: 'uint'},
            {name: 'settled', type: 'boolean'},
            {name: 'more', type: 'boolean', default_value: false},
            {name: 'rcv_settle_mode', type: 'ubyte'},
            {name: 'state', type: 'delivery_state'},
            {name: 'resume', type: 'boolean', default_value: false},
            {name: 'aborted', type: 'boolean', default_value: false},
            {name: 'batchable', type: 'boolean', default_value: false}
        ]
    };

    var disposition = {
        name: 'disposition',
        code: 0x15,
        fields:[
            {name: 'role', type: 'boolean', mandatory: true},
            {name: 'first', type: 'uint', mandatory: true},
            {name: 'last', type: 'uint'},
            {name: 'settled', type: 'boolean', default_value: false},
            {name: 'state', type: '*'},
            {name: 'batchable', type: 'boolean', default_value: false}
        ]
    };

    var detach = {
        name: 'detach',
        code: 0x16,
        fields: [
            {name: 'handle', type: 'uint', mandatory: true},
            {name: 'closed', type: 'boolean', default_value: false},
            {name: 'error', type: 'error'}
        ]
    };

    var end = {
        name: 'end',
        code: 0x17,
        fields: [
            {name: 'error', type: 'error'}
        ]
    };

    var close = {
        name: 'close',
        code: 0x18,
        fields: [
            {name: 'error', type: 'error'}
        ]
    };

    define_frame(frames.TYPE_AMQP, open);
    define_frame(frames.TYPE_AMQP, begin);
    define_frame(frames.TYPE_AMQP, attach);
    define_frame(frames.TYPE_AMQP, flow);
    define_frame(frames.TYPE_AMQP, transfer);
    define_frame(frames.TYPE_AMQP, disposition);
    define_frame(frames.TYPE_AMQP, detach);
    define_frame(frames.TYPE_AMQP, end);
    define_frame(frames.TYPE_AMQP, close);

    var sasl_mechanisms = {
        name: 'sasl_mechanisms',
        code: 0x40,
        fields: [
            {name: 'sasl_server_mechanisms', type: 'symbol', multiple: true, mandatory: true}
        ]
    };

    var sasl_init = {
        name: 'sasl_init',
        code: 0x41,
        fields: [
            {name: 'mechanism', type: 'symbol', mandatory: true},
            {name: 'initial_response', type: 'binary'},
            {name: 'hostname', type: 'string'}
        ]
    };

    var sasl_challenge = {
        name: 'sasl_challenge',
        code: 0x42,
        fields: [
            {name: 'challenge', type: 'binary', mandatory: true}
        ]
    };

    var sasl_response = {
        name: 'sasl_response',
        code: 0x43,
        fields: [
            {name: 'response', type: 'binary', mandatory: true}
        ]
    };

    var sasl_outcome = {
        name: 'sasl_outcome',
        code: 0x44,
        fields: [
            {name: 'code', type: 'ubyte', mandatory: true},
            {name: 'additional_data', type: 'binary'}
        ]
    };

    define_frame(frames.TYPE_SASL, sasl_mechanisms);
    define_frame(frames.TYPE_SASL, sasl_init);
    define_frame(frames.TYPE_SASL, sasl_challenge);
    define_frame(frames.TYPE_SASL, sasl_response);
    define_frame(frames.TYPE_SASL, sasl_outcome);

    var frames_1 = frames;

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */
    function setup$1(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = ms;
      Object.keys(env).forEach(function (key) {
        createDebug[key] = env[key];
      });
      /**
      * Active `debug` instances.
      */

      createDebug.instances = [];
      /**
      * The currently active debug mode names, and names to skip.
      */

      createDebug.names = [];
      createDebug.skips = [];
      /**
      * Map of special "%n" handling functions, for the debug "format" argument.
      *
      * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
      */

      createDebug.formatters = {};
      /**
      * Selects a color for a debug namespace
      * @param {String} namespace The namespace string for the for the debug instance to be colored
      * @return {Number|String} An ANSI color code for the given namespace
      * @api private
      */

      function selectColor(namespace) {
        var hash = 0;

        for (var i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0; // Convert to 32bit integer
        }

        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }

      createDebug.selectColor = selectColor;
      /**
      * Create a debugger with the given `namespace`.
      *
      * @param {String} namespace
      * @return {Function}
      * @api public
      */

      function createDebug(namespace) {
        var prevTime;

        function debug() {
          // Disabled?
          if (!debug.enabled) {
            return;
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var self = debug; // Set `diff` timestamp

          var curr = Number(new Date());
          var ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);

          if (typeof args[0] !== 'string') {
            // Anything else let's inspect with %O
            args.unshift('%O');
          } // Apply any `formatters` transformations


          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
            // If we encounter an escaped % then don't increase the array index
            if (match === '%%') {
              return match;
            }

            index++;
            var formatter = createDebug.formatters[format];

            if (typeof formatter === 'function') {
              var val = args[index];
              match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

              args.splice(index, 1);
              index--;
            }

            return match;
          }); // Apply env-specific formatting (colors, etc.)

          createDebug.formatArgs.call(self, args);
          var logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }

        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = selectColor(namespace);
        debug.destroy = destroy;
        debug.extend = extend; // Debug.formatArgs = formatArgs;
        // debug.rawLog = rawLog;
        // env-specific initialization logic for debug instances

        if (typeof createDebug.init === 'function') {
          createDebug.init(debug);
        }

        createDebug.instances.push(debug);
        return debug;
      }

      function destroy() {
        var index = createDebug.instances.indexOf(this);

        if (index !== -1) {
          createDebug.instances.splice(index, 1);
          return true;
        }

        return false;
      }

      function extend(namespace, delimiter) {
        return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      }
      /**
      * Enables a debug mode by namespaces. This can include modes
      * separated by a colon and wildcards.
      *
      * @param {String} namespaces
      * @api public
      */


      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i;
        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        var len = split.length;

        for (i = 0; i < len; i++) {
          if (!split[i]) {
            // ignore empty strings
            continue;
          }

          namespaces = split[i].replace(/\*/g, '.*?');

          if (namespaces[0] === '-') {
            createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
          } else {
            createDebug.names.push(new RegExp('^' + namespaces + '$'));
          }
        }

        for (i = 0; i < createDebug.instances.length; i++) {
          var instance = createDebug.instances[i];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      /**
      * Disable debug output.
      *
      * @api public
      */


      function disable() {
        createDebug.enable('');
      }
      /**
      * Returns true if the given mode name is enabled, false otherwise.
      *
      * @param {String} name
      * @return {Boolean}
      * @api public
      */


      function enabled(name) {
        if (name[name.length - 1] === '*') {
          return true;
        }

        var i;
        var len;

        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }

        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }

        return false;
      }
      /**
      * Coerce `val`.
      *
      * @param {Mixed} val
      * @return {Mixed}
      * @api private
      */


      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }

        return val;
      }

      createDebug.enable(createDebug.load());
      return createDebug;
    }

    var common$1 = setup$1;

    var browser$2 = createCommonjsModule(function (module, exports) {

    function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    /* eslint-env browser */

    /**
     * This is the web browser implementation of `debug()`.
     */
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    /**
     * Colors.
     */

    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */
    // eslint-disable-next-line complexity

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      } // Internet Explorer and Edge do not support colors.


      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      } // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */


    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

      if (!this.useColors) {
        return;
      }

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into

      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }

        index++;

        if (match === '%c') {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */


    function log() {
      var _console;

      // This hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */


    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {// Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */


    function load() {
      var r;

      try {
        r = exports.storage.getItem('debug');
      } catch (error) {} // Swallow
      // XXX (@Qix-) should we be logging these?
      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


      if (!r && typeof browser !== 'undefined' && 'env' in browser) {
        r = browser.env.DEBUG;
      }

      return r;
    }
    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */


    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {// Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    module.exports = common$1(exports);
    var formatters = module.exports.formatters;
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
    });
    var browser_1$1 = browser$2.log;
    var browser_2$1 = browser$2.formatArgs;
    var browser_3$1 = browser$2.save;
    var browser_4$1 = browser$2.load;
    var browser_5$1 = browser$2.useColors;
    var browser_6$1 = browser$2.storage;
    var browser_7$1 = browser$2.colors;

    if (browser$2.formatters) {
        browser$2.formatters.h = function (v) {
            return v.toString('hex');
        };
    }

    var log$1 = {
        'config' : browser$2('rhea:config'),
        'frames' : browser$2('rhea:frames'),
        'raw' : browser$2('rhea:raw'),
        'reconnect' : browser$2('rhea:reconnect'),
        'events' : browser$2('rhea:events'),
        'message' : browser$2('rhea:message'),
        'flow' : browser$2('rhea:flow'),
        'io' : browser$2('rhea:io')
    };

    var Transport = function (identifier, protocol_id, frame_type, handler) {
        this.identifier = identifier;
        this.protocol_id = protocol_id;
        this.frame_type = frame_type;
        this.handler = handler;
        this.pending = [];
        this.header_sent = undefined;
        this.header_received = undefined;
        this.write_complete = false;
        this.read_complete = false;
    };

    Transport.prototype.has_writes_pending = function () {
        return this.pending.length > 0 || !this.header_sent;
    };

    Transport.prototype.encode = function (frame) {
        this.pending.push(frame);
    };

    Transport.prototype.write = function (socket) {
        if (!this.header_sent) {
            var buffer = util_1$1.allocate_buffer(8);
            var header = {protocol_id:this.protocol_id, major:1, minor:0, revision:0};
            log$1.frames('[%s] -> %o', this.identifier, header);
            frames_1.write_header(buffer, header);
            socket.write(buffer);
            this.header_sent = header;
        }
        for (var i = 0; i < this.pending.length; i++) {
            var frame = this.pending[i];
            var buffer = frames_1.write_frame(frame);
            socket.write(buffer);
            if (frame.performative) {
                log$1.frames('[%s]:%s -> %s %j', this.identifier, frame.channel, frame.performative.constructor, frame.performative, frame.payload || '');
            } else {
                log$1.frames('[%s]:%s -> empty', this.identifier, frame.channel);
            }
            log$1.raw('[%s] SENT: %d %h', this.identifier, buffer.length, buffer);
        }
        this.pending = [];
    };

    Transport.prototype.read = function (buffer) {
        var offset = 0;
        if (!this.header_received) {
            if (buffer.length < 8) {
                return offset;
            } else {
                this.header_received = frames_1.read_header(buffer);
                log$1.frames('[%s] <- %o', this.identifier, this.header_received);
                if (this.header_received.protocol_id !== this.protocol_id) {
                    if (this.protocol_id === 3 && this.header_received.protocol_id === 0) {
                        throw new errors.ProtocolError('Expecting SASL layer');
                    } else if (this.protocol_id === 0 && this.header_received.protocol_id === 3) {
                        throw new errors.ProtocolError('SASL layer not enabled');
                    } else {
                        throw new errors.ProtocolError('Invalid AMQP protocol id ' + this.header_received.protocol_id + ' expecting: ' + this.protocol_id);
                    }
                }
                offset = 8;
            }
        }
        while (offset < (buffer.length - 4) && !this.read_complete) {
            var frame_size = buffer.readUInt32BE(offset);
            log$1.io('[%s] got frame of size %d', this.identifier, frame_size);
            if (buffer.length < offset + frame_size) {
                log$1.io('[%s] incomplete frame; have only %d of %d', this.identifier, (buffer.length - offset), frame_size);
                //don't have enough data for a full frame yet
                break;
            } else {
                var slice = buffer.slice(offset, offset + frame_size);
                log$1.raw('[%s] RECV: %d %h', this.identifier, slice.length, slice);
                var frame = frames_1.read_frame(slice);
                if (frame.performative) {
                    log$1.frames('[%s]:%s <- %s %j', this.identifier, frame.channel, frame.performative.constructor, frame.performative, frame.payload || '');
                } else {
                    log$1.frames('[%s]:%s <- empty', this.identifier, frame.channel);

                }
                if (frame.type !== this.frame_type) {
                    throw new errors.ProtocolError('Invalid frame type: ' + frame.type);
                }
                offset += frame_size;
                if (frame.performative) {
                    frame.performative.dispatch(this.handler, frame);
                }
            }
        }
        return offset;
    };

    var transport = Transport;

    var sasl_codes = {
        'OK':0,
        'AUTH':1,
        'SYS':2,
        'SYS_PERM':3,
        'SYS_TEMP':4,
    };

    var SASL_PROTOCOL_ID = 0x03;

    function extract(buffer) {
        var results = [];
        var start = 0;
        var i = 0;
        while (i < buffer.length) {
            if (buffer[i] === 0x00) {
                if (i > start) results.push(buffer.toString('utf8', start, i));
                else results.push(null);
                start = ++i;
            } else {
                ++i;
            }
        }
        if (i > start) results.push(buffer.toString('utf8', start, i));
        else results.push(null);
        return results;
    }

    var PlainServer = function(callback) {
        this.callback = callback;
        this.outcome = undefined;
        this.username = undefined;
    };

    PlainServer.prototype.start = function(response, hostname) {
        var fields = extract(response);
        if (fields.length !== 3) {
            return Promise.reject('Unexpected response in PLAIN, got ' + fields.length + ' fields, expected 3');
        }
        var self = this;
        return Promise.resolve(this.callback(fields[1], fields[2], hostname))
            .then(function (result) {
                if (result) {
                    self.outcome = true;
                    self.username = fields[1];
                } else {
                    self.outcome = false;
                }
            });
    };

    var PlainClient = function(username, password) {
        this.username = username;
        this.password = password;
    };

    PlainClient.prototype.start = function(callback) {
        var response = util_1$1.allocate_buffer(1 + this.username.length + 1 + this.password.length);
        response.writeUInt8(0, 0);
        response.write(this.username, 1);
        response.writeUInt8(0, 1 + this.username.length);
        response.write(this.password, 1 + this.username.length + 1);
        callback(undefined, response);
    };

    var AnonymousServer = function() {
        this.outcome = undefined;
        this.username = undefined;
    };

    AnonymousServer.prototype.start = function(response) {
        this.outcome = true;
        this.username = response ? response.toString('utf8') : 'anonymous';
    };

    var AnonymousClient = function(name) {
        this.username = name ? name : 'anonymous';
    };

    AnonymousClient.prototype.start = function(callback) {
        var response = util_1$1.allocate_buffer(1 + this.username.length);
        response.writeUInt8(0, 0);
        response.write(this.username, 1);
        callback(undefined, response);
    };

    var ExternalServer = function() {
        this.outcome = undefined;
        this.username = undefined;
    };

    ExternalServer.prototype.start = function() {
        this.outcome = true;
    };

    var ExternalClient = function() {
        this.username = undefined;
    };

    ExternalClient.prototype.start = function(callback) {
        callback(undefined, '');
    };

    ExternalClient.prototype.step = function(callback) {
        callback(undefined, '');
    };

    var XOAuth2Client = function(username, token) {
        this.username = username;
        this.token = token;
    };

    XOAuth2Client.prototype.start = function(callback) {
        var response = util_1$1.allocate_buffer(this.username.length + this.token.length + 5 + 12 + 3);
        var count = 0;
        response.write('user=', count);
        count += 5;
        response.write(this.username, count);
        count += this.username.length;
        response.writeUInt8(1, count);
        count += 1;
        response.write('auth=Bearer ', count);
        count += 12;
        response.write(this.token, count);
        count += this.token.length;
        response.writeUInt8(1, count);
        count += 1;
        response.writeUInt8(1, count);
        count += 1;
        callback(undefined, response);
    };

    /**
     * The mechanisms argument is a map of mechanism names to factory
     * functions for objects that implement that mechanism.
     */
    var SaslServer = function (connection, mechanisms) {
        this.connection = connection;
        this.transport = new transport(connection.amqp_transport.identifier, SASL_PROTOCOL_ID, frames_1.TYPE_SASL, this);
        this.next = connection.amqp_transport;
        this.mechanisms = mechanisms;
        this.mechanism = undefined;
        this.outcome = undefined;
        this.username = undefined;
        var mechlist = Object.getOwnPropertyNames(mechanisms);
        this.transport.encode(frames_1.sasl_frame(frames_1.sasl_mechanisms({sasl_server_mechanisms:mechlist})));
    };

    SaslServer.prototype.do_step = function (challenge) {
        if (this.mechanism.outcome === undefined) {
            this.transport.encode(frames_1.sasl_frame(frames_1.sasl_challenge({'challenge':challenge})));
            this.connection.output();
        } else {
            this.outcome = this.mechanism.outcome ? sasl_codes.OK : sasl_codes.AUTH;
            var frame = frames_1.sasl_frame(frames_1.sasl_outcome({code: this.outcome}));
            this.transport.encode(frame);
            this.connection.output();
            if (this.outcome === sasl_codes.OK) {
                this.username = this.mechanism.username;
                this.transport.write_complete = true;
                this.transport.read_complete = true;
            }
        }
    };

    SaslServer.prototype.on_sasl_init = function (frame) {
        var saslctor = this.mechanisms[frame.performative.mechanism];
        if (saslctor) {
            this.mechanism = saslctor();
            Promise.resolve(this.mechanism.start(frame.performative.initial_response, frame.performative.hostname))
                .then(this.do_step.bind(this))
                .catch(this.do_fail.bind(this));
        } else {
            this.outcome = sasl_codes.AUTH;
            this.transport.encode(frames_1.sasl_frame(frames_1.sasl_outcome({code: this.outcome})));
        }
    };

    SaslServer.prototype.on_sasl_response = function (frame) {
        Promise.resolve(this.mechanism.step(frame.performative.response))
            .then(this.do_step.bind(this))
            .catch(this.do_fail.bind(this));
    };

    SaslServer.prototype.do_fail = function (e) {
        var frame = frames_1.sasl_frame(frames_1.sasl_outcome({code: sasl_codes.SYS}));
        this.transport.encode(frame);
        this.connection.output();
        try {
            this.connection.sasl_failed('Sasl callback promise failed with ' + e, 'amqp:internal-error');
        } catch (e) {
            console.error('Uncaught error: ', e.message);
        }
    };

    SaslServer.prototype.has_writes_pending = function () {
        return this.transport.has_writes_pending() || this.next.has_writes_pending();
    };

    SaslServer.prototype.write = function (socket) {
        if (this.transport.write_complete && this.transport.pending.length === 0) {
            return this.next.write(socket);
        } else {
            return this.transport.write(socket);
        }
    };

    SaslServer.prototype.read = function (buffer) {
        if (this.transport.read_complete) {
            return this.next.read(buffer);
        } else {
            return this.transport.read(buffer);
        }
    };

    var SaslClient = function (connection, mechanisms, hostname) {
        this.connection = connection;
        this.transport = new transport(connection.amqp_transport.identifier, SASL_PROTOCOL_ID, frames_1.TYPE_SASL, this);
        this.next = connection.amqp_transport;
        this.mechanisms = mechanisms;
        this.mechanism = undefined;
        this.mechanism_name = undefined;
        this.hostname = hostname;
        this.failed = false;
    };

    SaslClient.prototype.on_sasl_mechanisms = function (frame) {
        var offered_mechanisms = [];
        if (Array.isArray(frame.performative.sasl_server_mechanisms)) {
            offered_mechanisms = frame.performative.sasl_server_mechanisms;
        } else if (frame.performative.sasl_server_mechanisms) {
            offered_mechanisms = [frame.performative.sasl_server_mechanisms];
        }
        for (var i = 0; this.mechanism === undefined && i < offered_mechanisms.length; i++) {
            var mech = offered_mechanisms[i];
            var f = this.mechanisms[mech];
            if (f) {
                this.mechanism = typeof f === 'function' ? f() : f;
                this.mechanism_name = mech;
            }
        }
        if (this.mechanism) {
            var self = this;
            this.mechanism.start(function (err, response) {
                if (err) {
                    self.failed = true;
                    self.connection.sasl_failed('SASL mechanism init failed: ' + err);
                } else {
                    var init = {'mechanism':self.mechanism_name,'initial_response':response};
                    if (self.hostname) {
                        init.hostname = self.hostname;
                    }
                    self.transport.encode(frames_1.sasl_frame(frames_1.sasl_init(init)));
                    self.connection.output();
                }
            });
        } else {
            this.failed = true;
            this.connection.sasl_failed('No suitable mechanism; server supports ' + frame.performative.sasl_server_mechanisms);
        }
    };
    SaslClient.prototype.on_sasl_challenge = function (frame) {
        var self = this;
        this.mechanism.step(frame.performative.challenge, function (err, response) {
            if (err) {
                self.failed = true;
                self.connection.sasl_failed('SASL mechanism challenge failed: ' + err);
            } else {
                self.transport.encode(frames_1.sasl_frame(frames_1.sasl_response({'response':response})));
                self.connection.output();
            }
        });
    };
    SaslClient.prototype.on_sasl_outcome = function (frame) {
        switch (frame.performative.code) {
        case sasl_codes.OK:
            this.transport.read_complete = true;
            this.transport.write_complete = true;
            break;
        case sasl_codes.SYS:
        case sasl_codes.SYS_PERM:
        case sasl_codes.SYS_TEMP:
            this.transport.write_complete = true;
            this.connection.sasl_failed('Failed to authenticate: ' + frame.performative.code, 'amqp:internal-error');
            break;
        default:
            this.transport.write_complete = true;
            this.connection.sasl_failed('Failed to authenticate: ' + frame.performative.code);
        }
    };

    SaslClient.prototype.has_writes_pending = function () {
        return this.transport.has_writes_pending() || this.next.has_writes_pending();
    };

    SaslClient.prototype.write = function (socket) {
        if (this.transport.write_complete) {
            return this.next.write(socket);
        } else {
            return this.transport.write(socket);
        }
    };

    SaslClient.prototype.read = function (buffer) {
        if (this.transport.read_complete) {
            return this.next.read(buffer);
        } else {
            return this.transport.read(buffer);
        }
    };

    var SelectiveServer = function (connection, mechanisms) {
        this.header_received = false;
        this.transports = {
            0: connection.amqp_transport,
            3: new SaslServer(connection, mechanisms)
        };
        this.selected = undefined;
    };

    SelectiveServer.prototype.has_writes_pending = function () {
        return this.header_received && this.selected.has_writes_pending();
    };

    SelectiveServer.prototype.write = function (socket) {
        if (this.selected) {
            return this.selected.write(socket);
        } else {
            return 0;
        }
    };

    SelectiveServer.prototype.read = function (buffer) {
        if (!this.header_received) {
            if (buffer.length < 8) {
                return 0;
            } else {
                this.header_received = frames_1.read_header(buffer);
                this.selected = this.transports[this.header_received.protocol_id];
                if (this.selected === undefined) {
                    throw new errors.ProtocolError('Invalid AMQP protocol id ' + this.header_received.protocol_id);
                }
            }
        }
        return this.selected.read(buffer);
    };

    var default_server_mechanisms = {
        enable_anonymous: function () {
            this['ANONYMOUS'] = function() { return new AnonymousServer(); };
        },
        enable_plain: function (callback) {
            this['PLAIN'] = function() { return new PlainServer(callback); };
        }
    };

    var default_client_mechanisms = {
        enable_anonymous: function (name) {
            this['ANONYMOUS'] = function() { return new AnonymousClient(name); };
        },
        enable_plain: function (username, password) {
            this['PLAIN'] = function() { return new PlainClient(username, password); };
        },
        enable_external: function () {
            this['EXTERNAL'] = function() { return new ExternalClient(); };
        },
        enable_xoauth2: function (username, token) {
            if (username && token) {
                this['XOAUTH2'] = function() { return new XOAuth2Client(username, token); };
            } else if (token === undefined) {
                throw Error('token must be specified');
            } else if (username === undefined) {
                throw Error('username must be specified');
            }
        }
    };

    var sasl = {
        Client : SaslClient,
        Server : SaslServer,
        Selective: SelectiveServer,
        server_mechanisms : function () {
            return Object.create(default_server_mechanisms);
        },
        client_mechanisms : function () {
            return Object.create(default_client_mechanisms);
        },
        server_add_external: function (mechs) {
            mechs['EXTERNAL'] = function() { return new ExternalServer(); };
            return mechs;
        }
    };

    /*
     * Copyright 2015 Red Hat Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var EndpointState = function () {
        this.init();
    };

    EndpointState.prototype.init = function () {
        this.local_open = false;
        this.remote_open = false;
        this.open_requests = 0;
        this.close_requests = 0;
        this.initialised = false;
        this.marker = undefined;
    };

    EndpointState.prototype.mark = function (o) {
        this.marker = o || Date.now();
        return this.marker;
    };

    EndpointState.prototype.open = function () {
        this.marker = undefined;
        this.initialised = true;
        if (!this.local_open) {
            this.local_open = true;
            this.open_requests++;
            return true;
        } else {
            return false;
        }
    };

    EndpointState.prototype.close = function () {
        this.marker = undefined;
        if (this.local_open) {
            this.local_open = false;
            this.close_requests++;
            return true;
        } else {
            return false;
        }
    };

    EndpointState.prototype.disconnected = function () {
        var was_initialised = this.initialised;
        this.was_open = this.local_open;
        this.init();
        this.initialised = was_initialised;
    };

    EndpointState.prototype.reconnect = function () {
        if (this.was_open) {
            this.open();
            this.was_open = undefined;
        }
    };

    EndpointState.prototype.remote_opened = function () {
        if (!this.remote_open) {
            this.remote_open = true;
            return true;
        } else {
            return false;
        }
    };

    EndpointState.prototype.remote_closed = function () {
        if (this.remote_open) {
            this.remote_open = false;
            return true;
        } else {
            return false;
        }
    };

    EndpointState.prototype.is_open = function () {
        return this.local_open && this.remote_open;
    };

    EndpointState.prototype.is_closed = function () {
        return this.initialised && !(this.local_open || this.was_open) && !this.remote_open;
    };

    EndpointState.prototype.has_settled = function () {
        return this.open_requests === 0 && this.close_requests === 0;
    };

    EndpointState.prototype.need_open = function () {
        if (this.open_requests > 0) {
            this.open_requests--;
            return true;
        } else {
            return false;
        }
    };

    EndpointState.prototype.need_close = function () {
        if (this.close_requests > 0) {
            this.close_requests--;
            return true;
        } else {
            return false;
        }
    };

    var endpoint = EndpointState;

    var by_descriptor$2 = {};
    var unwrappers = {};
    var wrappers = [];
    var message$1 = {};

    function define_section(descriptor, unwrap, wrap) {
        unwrap.descriptor = descriptor;
        unwrappers[descriptor.symbolic] = unwrap;
        unwrappers[Number(descriptor.numeric).toString(10)] = unwrap;
        if (wrap) {
            wrappers.push(wrap);
        }
    }

    function define_composite_section(def) {
        var c = types_1$1.define_composite(def);
        message$1[def.name] = c.create;
        by_descriptor$2[Number(c.descriptor.numeric).toString(10)] = c;
        by_descriptor$2[c.descriptor.symbolic] = c;

        var unwrap = function (msg, section) {
            var composite = new c(section.value);
            for (var i = 0; i < def.fields.length; i++) {
                var f = def.fields[i];
                var v = composite[f.name];
                if (v !== undefined && v !== null) {
                    msg[f.name] = v;
                }
            }
        };

        var wrap = function (sections, msg) {
            sections.push(c.create(msg).described());
        };
        define_section(c.descriptor, unwrap, wrap);
    }


    function define_map_section(def, symbolic) {
        var wrapper = symbolic ? types_1$1.wrap_symbolic_map : types_1$1.wrap_map;
        var descriptor = {numeric:def.code};
        descriptor.symbolic = 'amqp:' + def.name.replace(/_/g, '-') + ':map';
        var unwrap = function (msg, section) {
            msg[def.name] = types_1$1.unwrap_map_simple(section);
        };
        var wrap = function (sections, msg) {
            if (msg[def.name]) {
                sections.push(types_1$1.described_nc(types_1$1.wrap_ulong(descriptor.numeric), wrapper(msg[def.name])));
            }
        };
        define_section(descriptor, unwrap, wrap);
    }

    function Section(typecode, content, multiple) {
        this.typecode = typecode;
        this.content = content;
        this.multiple = multiple;
    }

    Section.prototype.described = function (item) {
        return types_1$1.described(types_1$1.wrap_ulong(this.typecode), types_1$1.wrap(item || this.content));
    };

    Section.prototype.collect_sections = function (sections) {
        if (this.multiple) {
            for (var i = 0; i < this.content.length; i++) {
                sections.push(this.described(this.content[i]));
            }
        } else {
            sections.push(this.described());
        }
    };

    define_composite_section({
        name:'header',
        code:0x70,
        fields:[
            {name:'durable', type:'boolean', default_value:false},
            {name:'priority', type:'ubyte', default_value:4},
            {name:'ttl', type:'uint'},
            {name:'first_acquirer', type:'boolean', default_value:false},
            {name:'delivery_count', type:'uint', default_value:0}
        ]
    });
    define_map_section({name:'delivery_annotations', code:0x71}, true);
    define_map_section({name:'message_annotations', code:0x72}, true);
    define_composite_section({
        name:'properties',
        code:0x73,
        fields:[
            {name:'message_id', type:'message_id'},
            {name:'user_id', type:'binary'},
            {name:'to', type:'string'},
            {name:'subject', type:'string'},
            {name:'reply_to', type:'string'},
            {name:'correlation_id', type:'message_id'},
            {name:'content_type', type:'symbol'},
            {name:'content_encoding', type:'symbol'},
            {name:'absolute_expiry_time', type:'timestamp'},
            {name:'creation_time', type:'timestamp'},
            {name:'group_id', type:'string'},
            {name:'group_sequence', type:'uint'},
            {name:'reply_to_group_id', type:'string'}
        ]
    });
    define_map_section({name:'application_properties', code:0x74});

    function unwrap_body_section (msg, section, typecode) {
        if (msg.body === undefined) {
            msg.body = new Section(typecode, types_1$1.unwrap(section));
        } else if (msg.body.constructor === Section && msg.body.typecode === typecode) {
            if (msg.body.multiple) {
                msg.body.content.push(types_1$1.unwrap(section));
            } else {
                msg.body.multiple = true;
                msg.body.content = [msg.body.content, types_1$1.unwrap(section)];
            }
        }
    }

    define_section({numeric:0x75, symbolic:'amqp:data:binary'}, function (msg, section) { unwrap_body_section(msg, section, 0x75); });
    define_section({numeric:0x76, symbolic:'amqp:amqp-sequence:list'}, function (msg, section) { unwrap_body_section(msg, section, 0x76); });
    define_section({numeric:0x77, symbolic:'amqp:value:*'}, function (msg, section) { msg.body = types_1$1.unwrap(section); });

    define_map_section({name:'footer', code:0x78});


    function wrap_body (sections, msg) {
        if (msg.body && msg.body.collect_sections) {
            msg.body.collect_sections(sections);
        } else {
            sections.push(types_1$1.described(types_1$1.wrap_ulong(0x77), types_1$1.wrap(msg.body)));
        }
    }

    wrappers.push(wrap_body);

    message$1.data_section = function (data) {
        return new Section(0x75, data);
    };

    message$1.sequence_section = function (list) {
        return new Section(0x76, list);
    };

    message$1.data_sections = function (data_elements) {
        return new Section(0x75, data_elements, true);
    };

    message$1.sequence_sections = function (lists) {
        return new Section(0x76, lists, true);
    };

    function copy(src, tgt) {
        for (var k in src) {
            var v = src[k];
            if (typeof v === 'object') {
                copy(v, tgt[k]);
            } else {
                tgt[k] = v;
            }
        }
    }

    function Message(o) {
        if (o) {
            copy(o, this);
        }
    }

    Message.prototype.toJSON = function () {
        var o = {};
        for (var key in this) {
            if (typeof this[key] === 'function') continue;
            o[key] = this[key];
        }
        return o;
    };

    Message.prototype.toString = function () {
        return JSON.stringify(this.toJSON());
    };


    message$1.encode = function(msg) {
        var sections = [];
        wrappers.forEach(function (wrapper_fn) { wrapper_fn(sections, msg); });
        var writer = new types_1$1.Writer();
        for (var i = 0; i < sections.length; i++) {
            log$1.message('Encoding section %d of %d: %o', (i+1), sections.length, sections[i]);
            writer.write(sections[i]);
        }
        var data = writer.toBuffer();
        log$1.message('encoded %d bytes', data.length);
        return data;
    };

    message$1.decode = function(buffer) {
        var msg = new Message();
        var reader = new types_1$1.Reader(buffer);
        while (reader.remaining()) {
            var s = reader.read();
            log$1.message('decoding section: %o of type: %o', s, s.descriptor);
            if (s.descriptor) {
                var unwrap = unwrappers[s.descriptor.value];
                if (unwrap) {
                    unwrap(msg, s);
                } else {
                    console.warn('WARNING: did not recognise message section with descriptor ' + s.descriptor);
                }
            } else {
                console.warn('WARNING: expected described message section got ' + JSON.stringify(s));
            }
        }
        return msg;
    };

    var outcomes = {};

    function define_outcome(def) {
        var c = types_1$1.define_composite(def);
        c.composite_type = def.name;
        message$1[def.name] = c.create;
        outcomes[Number(c.descriptor.numeric).toString(10)] = c;
        outcomes[c.descriptor.symbolic] = c;
        message$1['is_' + def.name] = function (o) {
            if (o && o.descriptor) {
                var c = outcomes[o.descriptor.value];
                if (c) {
                    return c.descriptor.numeric === def.code;
                }
            }
            return false;
        };
    }

    message$1.unwrap_outcome = function (outcome) {
        if (outcome && outcome.descriptor) {
            var c = outcomes[outcome.descriptor.value];
            if (c) {
                return new c(outcome.value);
            }
        }
        console.error('unrecognised outcome: ' + JSON.stringify(outcome));
        return outcome;
    };

    message$1.are_outcomes_equivalent = function(a, b) {
        if (a === undefined && b === undefined) return true;
        else if (a === undefined || b === undefined) return false;
        else return a.descriptor.value === b.descriptor.value && a.descriptor.value === 0x24;//only batch accepted
    };

    define_outcome({
        name:'received',
        code:0x23,
        fields:[
            {name:'section_number', type:'uint', mandatory:true},
            {name:'section_offset', type:'ulong', mandatory:true}
        ]});
    define_outcome({name:'accepted', code:0x24, fields:[]});
    define_outcome({name:'rejected', code:0x25, fields:[{name:'error', type:'error'}]});
    define_outcome({name:'released', code:0x26, fields:[]});
    define_outcome({
        name:'modified',
        code:0x27,
        fields:[
            {name:'delivery_failed', type:'boolean'},
            {name:'undeliverable_here', type:'boolean'},
            {name:'message_annotations', type:'map'}
        ]});

    var message_1 = message$1;

    var terminus = {};
    var by_descriptor$3 = {};

    function define_terminus(def) {
        var c = types_1$1.define_composite(def);
        terminus[def.name] = c.create;
        by_descriptor$3[Number(c.descriptor.numeric).toString(10)] = c;
        by_descriptor$3[c.descriptor.symbolic] = c;
    }

    terminus.unwrap = function(field) {
        if (field && field.descriptor) {
            var c = by_descriptor$3[field.descriptor.value];
            if (c) {
                return new c(field.value);
            } else {
                console.warn('Unknown terminus: ' + field.descriptor);
            }
        }
        return null;
    };

    define_terminus({
        name: 'source',
        code: 0x28,
        fields: [
            {name: 'address', type: 'string'},
            {name: 'durable', type: 'uint', default_value: 0},
            {name: 'expiry_policy', type: 'symbol', default_value: 'session-end'},
            {name: 'timeout', type: 'uint', default_value: 0},
            {name: 'dynamic', type: 'boolean', default_value: false},
            {name: 'dynamic_node_properties', type: 'symbolic_map'},
            {name: 'distribution_mode', type: 'symbol'},
            {name: 'filter', type: 'symbolic_map'},
            {name: 'default_outcome', type: '*'},
            {name: 'outcomes', type: 'symbol', multiple: true},
            {name: 'capabilities', type: 'symbol', multiple: true}
        ]
    });

    define_terminus({
        name: 'target',
        code: 0x29,
        fields: [
            {name: 'address', type: 'string'},
            {name: 'durable', type: 'uint', default_value: 0},
            {name: 'expiry_policy', type: 'symbol', default_value: 'session-end'},
            {name: 'timeout', type: 'uint', default_value: 0},
            {name: 'dynamic', type: 'boolean', default_value: false},
            {name: 'dynamic_node_properties', type: 'symbolic_map'},
            {name: 'capabilities', type: 'symbol', multiple: true}
        ]
    });

    var terminus_1 = terminus;

    // Copyright Joyent, Inc. and other Node contributors.

    var R = typeof Reflect === 'object' ? Reflect : null;
    var ReflectApply = R && typeof R.apply === 'function'
      ? R.apply
      : function ReflectApply(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };

    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === 'function') {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target)
          .concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target);
      };
    }

    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }

    var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
      return value !== value;
    };

    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    var events = EventEmitter;

    // Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = undefined;

    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    var defaultMaxListeners = 10;

    function checkListener(listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }

    Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        }
        defaultMaxListeners = arg;
      }
    });

    EventEmitter.init = function() {

      if (this._events === undefined ||
          this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }

      this._maxListeners = this._maxListeners || undefined;
    };

    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
      }
      this._maxListeners = n;
      return this;
    };

    function _getMaxListeners(that) {
      if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }

    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };

    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = (type === 'error');

      var events = this._events;
      if (events !== undefined)
        doError = (doError && events.error === undefined);
      else if (!doError)
        return false;

      // If there is no 'error' event listener then throw.
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          // Note: The comments on the `throw` lines are intentional, they show
          // up in Node's output if this results in an unhandled exception.
          throw er; // Unhandled 'error' event
        }
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
      }

      var handler = events[type];

      if (handler === undefined)
        return false;

      if (typeof handler === 'function') {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }

      return true;
    };

    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;

      checkListener(listener);

      events = target._events;
      if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
          target.emit('newListener', type,
                      listener.listener ? listener.listener : listener);

          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }

      if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] =
            prepend ? [listener, existing] : [existing, listener];
          // If we've already got an array, just append.
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }

        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          // No error code for this since it is a Warning
          // eslint-disable-next-line no-restricted-syntax
          var w = new Error('Possible EventEmitter memory leak detected. ' +
                              existing.length + ' ' + String(type) + ' listeners ' +
                              'added. Use emitter.setMaxListeners() to ' +
                              'increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }

      return target;
    }

    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.prependListener =
        function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };

    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }

    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }

    EventEmitter.prototype.once = function once(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };

    EventEmitter.prototype.prependOnceListener =
        function prependOnceListener(type, listener) {
          checkListener(listener);
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };

    // Emits a 'removeListener' event if and only if the listener was removed.
    EventEmitter.prototype.removeListener =
        function removeListener(type, listener) {
          var list, events, position, i, originalListener;

          checkListener(listener);

          events = this._events;
          if (events === undefined)
            return this;

          list = events[type];
          if (list === undefined)
            return this;

          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
              this._events = Object.create(null);
            else {
              delete events[type];
              if (events.removeListener)
                this.emit('removeListener', type, list.listener || listener);
            }
          } else if (typeof list !== 'function') {
            position = -1;

            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0)
              return this;

            if (position === 0)
              list.shift();
            else {
              spliceOne(list, position);
            }

            if (list.length === 1)
              events[type] = list[0];

            if (events.removeListener !== undefined)
              this.emit('removeListener', type, originalListener || listener);
          }

          return this;
        };

    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

    EventEmitter.prototype.removeAllListeners =
        function removeAllListeners(type) {
          var listeners, events, i;

          events = this._events;
          if (events === undefined)
            return this;

          // not listening for removeListener, no need to emit
          if (events.removeListener === undefined) {
            if (arguments.length === 0) {
              this._events = Object.create(null);
              this._eventsCount = 0;
            } else if (events[type] !== undefined) {
              if (--this._eventsCount === 0)
                this._events = Object.create(null);
              else
                delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === 'removeListener') continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = Object.create(null);
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
          } else if (listeners !== undefined) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }

          return this;
        };

    function _listeners(target, type, unwrap) {
      var events = target._events;

      if (events === undefined)
        return [];

      var evlistener = events[type];
      if (evlistener === undefined)
        return [];

      if (typeof evlistener === 'function')
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];

      return unwrap ?
        unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }

    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };

    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };

    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };

    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;

      if (events !== undefined) {
        var evlistener = events[type];

        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener !== undefined) {
          return evlistener.length;
        }
      }

      return 0;
    }

    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };

    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }

    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }

    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }

    var FlowController = function (window) {
        this.window = window;
    };
    FlowController.prototype.update = function (context) {
        var delta = this.window - context.receiver.credit;
        if (delta >= (this.window/4)) {
            context.receiver.flow(delta);
        }
    };

    function auto_settle(context) {
        context.delivery.settled = true;
    }

    function auto_accept(context) {
        context.delivery.update(undefined, message_1.accepted().described());
    }

    function LinkError(message, condition, link) {
        Error.call(this);
        Error.captureStackTrace(this, this.constructor);
        this.message = message;
        this.condition = condition;
        this.description = message;
        this.link = link;
    }
    util.inherits(LinkError, Error);

    var EventEmitter$1 = events.EventEmitter;

    var link$1 = Object.create(EventEmitter$1.prototype);
    link$1.dispatch = function(name) {
        log$1.events('[%s] Link got event: %s', this.connection.options.id, name);
        EventEmitter$1.prototype.emit.apply(this.observers, arguments);
        if (this.listeners(name).length) {
            EventEmitter$1.prototype.emit.apply(this, arguments);
            return true;
        } else {
            return this.session.dispatch.apply(this.session, arguments);
        }
    };
    link$1.set_source = function (fields) {
        this.local.attach.source = terminus_1.source(fields).described();
    };
    link$1.set_target = function (fields) {
        this.local.attach.target = terminus_1.target(fields).described();
    };

    link$1.attach = function () {
        if (this.state.open()) {
            this.connection._register();
        }
    };
    link$1.open = link$1.attach;

    link$1.detach = function () {
        this.local.detach.closed = false;
        if (this.state.close()) {
            this.connection._register();
        }
    };
    link$1.close = function(error) {
        if (error) this.local.detach.error = error;
        this.local.detach.closed = true;
        if (this.state.close()) {
            this.connection._register();
        }
    };

    /**
     * This forcibly removes the link from the parent session. It should
     * not be called for a link on an active session/connection, where
     * close() should be used instead.
     */
    link$1.remove = function() {
        this.session.remove_link(this);
    };

    link$1.is_open = function () {
        return this.session.is_open() && this.state.is_open();
    };

    link$1.is_remote_open = function () {
        return this.session.is_remote_open() && this.state.remote_open;
    };

    link$1.is_itself_closed = function() {
        return this.state.is_closed();
    };

    link$1.is_closed = function () {
        return this.session.is_closed() || this.is_itself_closed();
    };

    link$1._process = function () {
        do {
            if (this.state.need_open()) {
                this.session.output(this.local.attach);
            }

            if (this.issue_flow && this.state.local_open) {
                this.session._write_flow(this);
                this.issue_flow = false;
            }

            if (this.state.need_close()) {
                this.session.output(this.local.detach);
            }
        } while (!this.state.has_settled());
    };

    link$1.on_attach = function (frame) {
        if (this.state.remote_opened()) {
            if (!this.remote.handle) {
                this.remote.handle = frame.handle;
            }
            frame.performative.source = terminus_1.unwrap(frame.performative.source);
            frame.performative.target = terminus_1.unwrap(frame.performative.target);
            this.remote.attach = frame.performative;
            this.open();
            this.dispatch(this.is_receiver() ? 'receiver_open' : 'sender_open', this._context());
        } else {
            throw Error('Attach already received');
        }
    };

    link$1.prefix_event = function (event) {
        return (this.local.attach.role ? 'receiver_' : 'sender_') + event;
    };

    link$1.on_detach = function (frame) {
        if (this.state.remote_closed()) {
            if (this._incomplete) {
                this._incomplete.settled = true;
            }
            this.remote.detach = frame.performative;
            var error = this.remote.detach.error;
            if (error) {
                var handled = this.dispatch(this.prefix_event('error'), this._context());
                handled = this.dispatch(this.prefix_event('close'), this._context()) || handled;
                if (!handled) {
                    EventEmitter$1.prototype.emit.call(this.connection.container, 'error', new LinkError(error.description, error.condition, this));
                }
            } else {
                this.dispatch(this.prefix_event('close'), this._context());
            }
            var self = this;
            var token = this.state.mark();
            browser.nextTick(function () {
                if (self.state.marker === token) {
                    self.close();
                    browser.nextTick(function () { self.remove(); });
                }
            });
        } else {
            throw Error('Detach already received');
        }
    };

    function is_internal(name) {
        switch (name) {
        case 'name':
        case 'handle':
        case 'role':
        case 'initial_delivery_count':
            return true;
        default:
            return false;
        }
    }


    var aliases = [
        'snd_settle_mode',
        'rcv_settle_mode',
        'source',
        'target',
        'max_message_size',
        'offered_capabilities',
        'desired_capabilities',
        'properties'
    ];

    function remote_property_shortcut(name) {
        return function() { return this.remote.attach ? this.remote.attach[name] : undefined; };
    }

    link$1.init = function (session, name, local_handle, opts, is_receiver) {
        this.session = session;
        this.connection = session.connection;
        this.name = name;
        this.options = opts === undefined ? {} : opts;
        this.state = new endpoint();
        this.issue_flow = false;
        this.local = {'handle': local_handle};
        this.local.attach = frames_1.attach({'handle':local_handle,'name':name, role:is_receiver});
        for (var field in this.local.attach) {
            if (!is_internal(field) && this.options[field] !== undefined) {
                this.local.attach[field] = this.options[field];
            }
        }
        this.local.detach = frames_1.detach({'handle':local_handle, 'closed':true});
        this.remote = {'handle':undefined};
        this.delivery_count = 0;
        this.credit = 0;
        this.observers = new EventEmitter$1();
        for (var i in aliases) {
            var alias = aliases[i];
            Object.defineProperty(this, alias, { get: remote_property_shortcut(alias) });
        }
        Object.defineProperty(this, 'error', { get:  function() { return this.remote.detach ? this.remote.detach.error : undefined; }});
    };

    link$1._disconnect = function() {
        this.state.disconnected();
        if (!this.state.was_open) {
            this.remove();
        }
    };

    link$1._reconnect = function() {
        this.state.reconnect();
        this.remote = {'handle':undefined};
        this.delivery_count = 0;
        this.credit = 0;
    };

    link$1.has_credit = function () {
        return this.credit > 0;
    };
    link$1.is_receiver = function () {
        return this.local.attach.role;
    };
    link$1.is_sender = function () {
        return !this.is_receiver();
    };
    link$1._context = function (c) {
        var context = c ? c : {};
        if (this.is_receiver()) {
            context.receiver = this;
        } else {
            context.sender = this;
        }
        return this.session._context(context);
    };
    link$1.get_option = function (name, default_value) {
        if (this.options[name] !== undefined) return this.options[name];
        else return this.session.get_option(name, default_value);
    };

    var Sender = function (session, name, local_handle, opts) {
        this.init(session, name, local_handle, opts, false);
        this._draining = false;
        this._drained = false;
        this.local.attach.initial_delivery_count = 0;
        this.tag = 0;
        if (this.get_option('autosettle', true)) {
            this.observers.on('settled', auto_settle);
        }
        var sender = this;
        if (this.get_option('treat_modified_as_released', true)) {
            this.observers.on('modified', function (context) {
                sender.dispatch('released', context);
            });
        }
    };
    Sender.prototype = Object.create(link$1);
    Sender.prototype.constructor = Sender;
    Sender.prototype._get_drain = function () {
        if (this._draining && this._drained && this.credit) {
            while (this.credit) {
                ++this.delivery_count;
                --this.credit;
            }
            return true;
        } else {
            return false;
        }
    };
    Sender.prototype.set_drained = function (drained) {
        this._drained = drained;
        if (this._draining && this._drained) {
            this.issue_flow = true;
        }
    };
    Sender.prototype.next_tag = function () {
        return buffer_1.from(new String(this.tag++));
    };
    Sender.prototype.sendable = function () {
        return Boolean(this.credit && this.session.outgoing.available());
    };
    Sender.prototype.on_flow = function (frame) {
        var flow = frame.performative;
        this.credit = flow.delivery_count + flow.link_credit - this.delivery_count;
        this._draining = flow.drain;
        this._drained = this.credit > 0;
        if (this.is_open()) {
            this.dispatch('sender_flow', this._context());
            if (this._draining) {
                this.dispatch('sender_draining', this._context());
            }
            if (this.sendable()) {
                this.dispatch('sendable', this._context());
            }
        }
    };
    Sender.prototype.on_transfer = function () {
        throw Error('got transfer on sending link');
    };

    Sender.prototype.send = function (msg, tag, format) {
        var payload = format === undefined ? message_1.encode(msg) : msg;
        var delivery = this.session.send(this, tag ? tag : this.next_tag(), payload, format);
        if (this.local.attach.snd_settle_mode === 1) {
            delivery.settled = true;
        }
        return delivery;
    };

    var Receiver = function (session, name, local_handle, opts) {
        this.init(session, name, local_handle, opts, true);
        this.drain = false;
        this.set_credit_window(this.get_option('credit_window', 1000));
        if (this.get_option('autoaccept', true)) {
            this.observers.on('message', auto_accept);
        }
        if (this.local.attach.rcv_settle_mode === 1 && this.get_option('autosettle', true)) {
            this.observers.on('settled', auto_settle);
        }
    };
    Receiver.prototype = Object.create(link$1);
    Receiver.prototype.constructor = Receiver;
    Receiver.prototype.on_flow = function (frame) {
        this.dispatch('receiver_flow', this._context());
        if (frame.performative.drain) {
            this.credit = frame.performative.link_credit;
            this.delivery_count = frame.performative.delivery_count;
            if (frame.performative.link_credit > 0) console.error('ERROR: received flow with drain set, but non zero credit');
            else this.dispatch('receiver_drained', this._context());
        }
    };
    Receiver.prototype.flow = function(credit) {
        if (credit > 0) {
            this.credit += credit;
            this.issue_flow = true;
            this.connection._register();
        }
    };
    Receiver.prototype.add_credit = Receiver.prototype.flow;//alias
    Receiver.prototype._get_drain = function () {
        return this.drain;
    };

    Receiver.prototype.set_credit_window = function(credit_window) {
        if (credit_window > 0) {
            var flow_controller = new FlowController(credit_window);
            var listener = flow_controller.update.bind(flow_controller);
            this.observers.on('message', listener);
            this.observers.on('receiver_open', listener);
        }
    };

    var link_1 = {'Sender': Sender, 'Receiver':Receiver};

    var link$2 = link_1;






    var EventEmitter$2 = events.EventEmitter;

    function SessionError(message, condition, session) {
        Error.call(this);
        Error.captureStackTrace(this, this.constructor);
        this.message = message;
        this.condition = condition;
        this.description = message;
        this.session = session;
    }
    util.inherits(SessionError, Error);

    var CircularBuffer = function (capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.head = 0;
        this.tail = 0;
        this.entries = [];
    };

    CircularBuffer.prototype.available = function () {
        return this.capacity - this.size;
    };

    CircularBuffer.prototype.push = function (o) {
        if (this.size < this.capacity) {
            this.entries[this.tail] = o;
            this.tail = (this.tail + 1) % this.capacity;
            this.size++;
        } else {
            throw Error('circular buffer overflow: head=' + this.head + ' tail=' + this.tail + ' size=' + this.size + ' capacity=' + this.capacity);
        }
    };

    CircularBuffer.prototype.pop_if = function (f) {
        var count = 0;
        while (this.size && f(this.entries[this.head])) {
            this.entries[this.head] = undefined;
            this.head = (this.head + 1) % this.capacity;
            this.size--;
            count++;
        }
        return count;
    };

    CircularBuffer.prototype.by_id = function (id) {
        if (this.size > 0) {
            var gap = id - this.entries[this.head].id;
            if (gap < this.size) {
                return this.entries[(this.head + gap) % this.capacity];
            }
        }
        return undefined;
    };

    CircularBuffer.prototype.get_head = function () {
        return this.size > 0 ? this.entries[this.head] : undefined;
    };

    CircularBuffer.prototype.get_tail = function () {
        return this.size > 0 ? this.entries[(this.head + this.size - 1) % this.capacity] : undefined;
    };

    function write_dispositions(deliveries) {
        var first, last, next_id, i, delivery;

        for (i = 0; i < deliveries.length; i++) {
            delivery = deliveries[i];
            if (first === undefined) {
                first = delivery;
                last = delivery;
                next_id = delivery.id;
            }

            if ((first !== last && !message_1.are_outcomes_equivalent(last.state, delivery.state)) || last.settled !== delivery.settled || next_id !== delivery.id) {
                first.link.session.output(frames_1.disposition({'role' : first.link.is_receiver(), 'first' : first.id, 'last' : last.id, 'state' : first.state, 'settled' : first.settled}));
                first = delivery;
                last = delivery;
                next_id = delivery.id;
            } else {
                if (last.id !== delivery.id) {
                    last = delivery;
                }
                next_id++;
            }
        }
        if (first !== undefined && last !== undefined) {
            first.link.session.output(frames_1.disposition({'role' : first.link.is_receiver(), 'first' : first.id, 'last' : last.id, 'state' : first.state, 'settled' : first.settled}));
        }
    }

    var Outgoing = function (connection) {
        /* TODO: make size configurable? */
        this.deliveries = new CircularBuffer(2048);
        this.updated = [];
        this.pending_dispositions = [];
        this.next_delivery_id = 0;
        this.next_pending_delivery = 0;
        this.next_transfer_id = 0;
        this.window = types_1$1.MAX_UINT;
        this.remote_next_transfer_id = undefined;
        this.remote_window = undefined;
        this.connection = connection;
    };

    Outgoing.prototype.available = function () {
        return this.deliveries.available();
    };

    Outgoing.prototype.compute_max_payload = function (tag) {
        if (this.connection.max_frame_size) {
            return this.connection.max_frame_size - (50 + tag.length);
        } else {
            return undefined;
        }
    };

    Outgoing.prototype.send = function (sender, tag, data, format) {
        var fragments = [];
        var max_payload = this.compute_max_payload(tag);
        if (max_payload && data.length > max_payload) {
            var start = 0;
            while (start < data.length) {
                var end = Math.min(start + max_payload, data.length);
                fragments.push(data.slice(start, end));
                start = end;
            }
        } else {
            fragments.push(data);
        }
        var d = {
            'id':this.next_delivery_id++,
            'tag':tag,
            'link':sender,
            'data': fragments,
            'format':format ? format : 0,
            'sent': false,
            'settled': false,
            'state': undefined,
            'remote_settled': false,
            'remote_state': undefined
        };
        var self = this;
        d.update = function (settled, state) {
            self.update(d, settled, state);
        };
        this.deliveries.push(d);
        return d;
    };

    Outgoing.prototype.on_begin = function (fields) {
        this.remote_window = fields.incoming_window;
    };

    Outgoing.prototype.on_flow = function (fields) {
        this.remote_next_transfer_id = fields.next_incoming_id;
        this.remote_window = fields.incoming_window;
    };

    Outgoing.prototype.on_disposition = function (fields) {
        var last = fields.last ? fields.last : fields.first;
        for (var i = fields.first; i <= last; i++) {
            var d = this.deliveries.by_id(i);
            if (d && !d.remote_settled) {
                var updated = false;
                if (fields.settled) {
                    d.remote_settled = fields.settled;
                    updated = true;
                }
                if (fields.state && fields.state !== d.remote_state) {
                    d.remote_state = message_1.unwrap_outcome(fields.state);
                    updated = true;
                }
                if (updated) {
                    this.updated.push(d);
                }
            }
        }
    };

    Outgoing.prototype.update = function (delivery, settled, state) {
        if (delivery) {
            delivery.settled = settled;
            if (state !== undefined) delivery.state = state;
            if (!delivery.remote_settled) {
                this.pending_dispositions.push(delivery);
            }
            delivery.link.connection._register();
        }
    };

    Outgoing.prototype.transfer_window = function() {
        if (this.remote_window) {
            return this.remote_window - (this.next_transfer_id - this.remote_next_transfer_id);
        } else {
            return 0;
        }
    };

    Outgoing.prototype.process = function() {
        var d;
        // send pending deliveries for which there is credit:
        while (this.next_pending_delivery < this.next_delivery_id) {
            d = this.deliveries.by_id(this.next_pending_delivery);
            if (d) {
                if (d.link.has_credit()) {
                    if (this.transfer_window() >= d.data.length) {
                        this.window -= d.data.length;
                        for (var i = 0; i < d.data.length; i++) {
                            this.next_transfer_id++;
                            var more = (i+1) < d.data.length;
                            var transfer = frames_1.transfer({'handle':d.link.local.handle,'message_format':d.format,'delivery_id':d.id, 'delivery_tag':d.tag, 'settled':d.settled, 'more':more});
                            d.link.session.output(transfer, d.data[i]);
                            if (d.settled) {
                                d.remote_settled = true;//if sending presettled, it can now be cleaned up
                            }
                        }
                        d.link.credit--;
                        d.link.delivery_count++;
                        this.next_pending_delivery++;
                    } else {
                        log$1.flow('[%s] Incoming window of peer preventing sending further transfers: remote_window=%d, remote_next_transfer_id=%d, next_transfer_id=%d',
                            this.connection.options.id, this.remote_window, this.remote_next_transfer_id, this.next_transfer_id);
                        break;
                    }
                } else {
                    log$1.flow('[%s] Link has no credit', this.connection.options.id);
                    break;
                }
            } else {
                console.error('ERROR: Next pending delivery not found: ' + this.next_pending_delivery);
                break;
            }
        }

        // notify application of any updated deliveries:
        for (var i = 0; i < this.updated.length; i++) {
            d = this.updated[i];
            if (d.remote_state && d.remote_state.constructor.composite_type) {
                d.link.dispatch(d.remote_state.constructor.composite_type, d.link._context({'delivery':d}));
            }
            if (d.remote_settled) d.link.dispatch('settled', d.link._context({'delivery':d}));
        }
        this.updated = [];

        if (this.pending_dispositions.length) {
            write_dispositions(this.pending_dispositions);
            this.pending_dispositions = [];
        }

        // remove any fully settled deliveries:
        this.deliveries.pop_if(function (d) { return d.settled && d.remote_settled; });
    };

    var Incoming = function () {
        this.deliveries = new CircularBuffer(2048/*TODO: configurable?*/);
        this.updated = [];
        this.next_transfer_id = 0;
        this.next_delivery_id = undefined;
        Object.defineProperty(this, 'window', { get: function () { return this.deliveries.available(); } });
        this.remote_next_transfer_id = undefined;
        this.remote_window = undefined;
        this.max_transfer_id = this.next_transfer_id + this.window;
    };

    Incoming.prototype.update = function (delivery, settled, state) {
        if (delivery) {
            delivery.settled = settled;
            if (state !== undefined) delivery.state = state;
            if (!delivery.remote_settled) {
                this.updated.push(delivery);
            }
            delivery.link.connection._register();
        }
    };

    Incoming.prototype.on_transfer = function(frame, receiver) {
        this.next_transfer_id++;
        if (receiver.is_remote_open()) {
            if (this.next_delivery_id === undefined) {
                this.next_delivery_id = frame.performative.delivery_id;
            }
            var current;
            var data;
            if (receiver._incomplete) {
                current = receiver._incomplete;
                if (util_1$1.is_defined(frame.performative.delivery_id) && current.id !== frame.performative.delivery_id) {
                    throw Error('frame sequence error: delivery ' + current.id + ' not complete, got ' + frame.performative.delivery_id);
                }
                data = buffer_1.concat([current.data, frame.payload], current.data.length + frame.payload.length);
            } else if (this.next_delivery_id === frame.performative.delivery_id) {
                current = {'id':frame.performative.delivery_id,
                    'tag':frame.performative.delivery_tag,
                    'format':frame.performative.message_format,
                    'link':receiver,
                    'settled': false,
                    'state': undefined,
                    'remote_settled': frame.performative.settled === undefined ? false : frame.performative.settled,
                    'remote_state': frame.performative.state};
                var self = this;
                current.update = function (settled, state) {
                    var settled_ = settled;
                    if (settled_ === undefined) {
                        settled_ = receiver.local.attach.rcv_settle_mode !== 1;
                    }
                    self.update(current, settled_, state);
                };
                current.accept = function () { this.update(undefined, message_1.accepted().described()); };
                current.release = function (params) {
                    if (params) {
                        this.update(undefined, message_1.modified(params).described());
                    } else {
                        this.update(undefined, message_1.released().described());
                    }
                };
                current.reject = function (error) { this.update(undefined, message_1.rejected({'error':error}).described()); };
                current.modified = function (params) { this.update(undefined, message_1.modified(params).described()); };

                this.deliveries.push(current);
                this.next_delivery_id++;
                data = frame.payload;
            } else {
                //TODO: better error handling
                throw Error('frame sequence error: expected ' + this.next_delivery_id + ', got ' + frame.performative.delivery_id);
            }
            current.incomplete = frame.performative.more;
            if (current.incomplete) {
                receiver._incomplete = current;
                current.data = data;
            } else {
                receiver._incomplete = undefined;
                if (receiver.credit > 0) receiver.credit--;
                else console.error('Received transfer when credit was %d', receiver.credit);
                receiver.delivery_count++;
                var msgctxt = current.format === 0 ? {'message':message_1.decode(data), 'delivery':current} : {'message':data, 'delivery':current, 'format':current.format};
                receiver.dispatch('message', receiver._context(msgctxt));
            }
        } else {
            throw Error('transfer after detach');
        }
    };

    Incoming.prototype.process = function (session) {
        if (this.updated.length > 0) {
            write_dispositions(this.updated);
            this.updated = [];
        }

        // remove any fully settled deliveries:
        this.deliveries.pop_if(function (d) { return d.settled; });

        if (this.max_transfer_id - this.next_transfer_id < (this.window / 2)) {
            session._write_flow();
        }
    };

    Incoming.prototype.on_begin = function (fields) {
        this.remote_window = fields.outgoing_window;
        this.remote_next_transfer_id = fields.next_outgoing_id;
    };

    Incoming.prototype.on_flow = function (fields) {
        this.remote_next_transfer_id = fields.next_outgoing_id;
        this.remote_window = fields.outgoing_window;
    };

    Incoming.prototype.on_disposition = function (fields) {
        var last = fields.last ? fields.last : fields.first;
        for (var i = fields.first; i <= last; i++) {
            var d = this.deliveries.by_id(i);
            if (d && !d.remote_settled) {
                if (fields.state && fields.state !== d.remote_state) {
                    d.remote_state = message_1.unwrap_outcome(fields.state);
                }
                if (fields.settled) {
                    d.remote_settled = fields.settled;
                    d.link.dispatch('settled', d.link._context({'delivery':d}));
                }
            }
        }
    };

    var Session = function (connection, local_channel) {
        this.connection = connection;
        this.outgoing = new Outgoing(connection);
        this.incoming = new Incoming();
        this.state = new endpoint();
        this.local = {'channel': local_channel, 'handles':{}};
        this.local.begin = frames_1.begin({next_outgoing_id:this.outgoing.next_transfer_id,incoming_window:this.incoming.window,outgoing_window:this.outgoing.window});
        this.local.end = frames_1.end();
        this.remote = {'handles':{}};
        this.links = {}; // map by name
        this.options = {};
        Object.defineProperty(this, 'error', { get:  function() { return this.remote.end ? this.remote.end.error : undefined; }});
        this.observers = new EventEmitter$2();
    };
    Session.prototype = Object.create(EventEmitter$2.prototype);
    Session.prototype.constructor = Session;

    Session.prototype._disconnect = function() {
        this.state.disconnected();
        for (var l in this.links) {
            this.links[l]._disconnect();
        }
        if (!this.state.was_open) {
            this.remove();
        }
    };

    Session.prototype._reconnect = function() {
        this.state.reconnect();
        this.outgoing = new Outgoing(this.connection);
        this.incoming = new Incoming();
        this.remote = {'handles':{}};
        for (var l in this.links) {
            this.links[l]._reconnect();
        }
    };

    Session.prototype.dispatch = function(name) {
        log$1.events('[%s] Session got event: %s', this.connection.options.id, name);
        EventEmitter$2.prototype.emit.apply(this.observers, arguments);
        if (this.listeners(name).length) {
            EventEmitter$2.prototype.emit.apply(this, arguments);
            return true;
        } else {
            return this.connection.dispatch.apply(this.connection, arguments);
        }
    };
    Session.prototype.output = function (frame, payload) {
        this.connection._write_frame(this.local.channel, frame, payload);
    };

    Session.prototype.create_sender = function (name, opts) {
        return this.create_link(name, link$2.Sender, opts);
    };

    Session.prototype.create_receiver = function (name, opts) {
        return this.create_link(name, link$2.Receiver, opts);
    };

    function merge(defaults, specific) {
        for (var f in specific) {
            if (f === 'properties' && defaults.properties) {
                merge(defaults.properties, specific.properties);
            } else {
                defaults[f] = specific[f];
            }
        }
    }

    function attach$1(factory, args, remote_terminus, default_args) {
        var opts = Object.create(default_args || {});
        if (typeof args === 'string') {
            opts[remote_terminus] = args;
        } else if (args) {
            merge(opts, args);
        }
        if (!opts.name) opts.name = util_1$1.generate_uuid();
        var l = factory(opts.name, opts);
        for (var t in {'source':0, 'target':0}) {
            if (opts[t]) {
                if (typeof opts[t] === 'string') {
                    opts[t] = {'address' : opts[t]};
                }
                l['set_' + t](opts[t]);
            }
        }
        if (l.is_sender() && opts.source === undefined) {
            opts.source = l.set_source({});
        }
        if (l.is_receiver() && opts.target === undefined) {
            opts.target = l.set_target({});
        }
        l.attach();
        return l;
    }

    Session.prototype.get_option = function (name, default_value) {
        if (this.options[name] !== undefined) return this.options[name];
        else return this.connection.get_option(name, default_value);
    };

    Session.prototype.attach_sender = function (args) {
        return attach$1(this.create_sender.bind(this), args, 'target', this.get_option('sender_options', {}));
    };
    Session.prototype.open_sender = Session.prototype.attach_sender;//alias

    Session.prototype.attach_receiver = function (args) {
        return attach$1(this.create_receiver.bind(this), args, 'source', this.get_option('receiver_options', {}));
    };
    Session.prototype.open_receiver = Session.prototype.attach_receiver;//alias

    Session.prototype.find_sender = function (filter) {
        return this.find_link(util_1$1.sender_filter(filter));
    };

    Session.prototype.find_receiver = function (filter) {
        return this.find_link(util_1$1.receiver_filter(filter));
    };

    Session.prototype.find_link = function (filter) {
        for (var name in this.links) {
            var link = this.links[name];
            if (filter(link)) return link;
        }
        return undefined;
    };

    Session.prototype.each_receiver = function (action, filter) {
        this.each_link(action, util_1$1.receiver_filter(filter));
    };

    Session.prototype.each_sender = function (action, filter) {
        this.each_link(action, util_1$1.sender_filter(filter));
    };

    Session.prototype.each_link = function (action, filter) {
        for (var name in this.links) {
            var link = this.links[name];
            if (filter === undefined || filter(link)) action(link);
        }
    };

    Session.prototype.create_link = function (name, constructor, opts) {
        var i = 0;
        while (this.local.handles[i]) i++;
        var l = new constructor(this, name, i, opts);
        this.links[name] = l;
        this.local.handles[i] = l;
        return l;
    };

    Session.prototype.begin = function () {
        if (this.state.open()) {
            this.connection._register();
        }
    };
    Session.prototype.open = Session.prototype.begin;

    Session.prototype.end = function (error) {
        if (error) this.local.end.error = error;
        if (this.state.close()) {
            this.connection._register();
        }
    };
    Session.prototype.close = Session.prototype.end;

    Session.prototype.is_open = function () {
        return this.connection.is_open() && this.state.is_open();
    };

    Session.prototype.is_remote_open = function () {
        return this.connection.is_remote_open() && this.state.remote_open;
    };

    Session.prototype.is_itself_closed = function () {
        return this.state.is_closed();
    };

    Session.prototype.is_closed = function () {
        return this.connection.is_closed() || this.is_itself_closed();
    };

    function notify_sendable(sender) {
        sender.dispatch('sendable', sender._context());
    }

    function is_sender_sendable(sender) {
        return sender.is_open() && sender.sendable();
    }

    Session.prototype._process = function () {
        do {
            if (this.state.need_open()) {
                this.output(this.local.begin);
            }

            var was_blocked = this.outgoing.deliveries.available() === 0;
            this.outgoing.process();
            if (was_blocked && this.outgoing.deliveries.available()) {
                this.each_sender(notify_sendable, is_sender_sendable);
            }
            this.incoming.process(this);
            for (var k in this.links) {
                this.links[k]._process();
            }

            if (this.state.need_close()) {
                this.output(this.local.end);
            }
        } while (!this.state.has_settled());
    };

    Session.prototype.send = function (sender, tag, data, format) {
        var d = this.outgoing.send(sender, tag, data, format);
        this.connection._register();
        return d;
    };

    Session.prototype._write_flow = function (link) {
        var fields = {'next_incoming_id':this.incoming.next_transfer_id,
            'incoming_window':this.incoming.window,
            'next_outgoing_id':this.outgoing.next_transfer_id,
            'outgoing_window':this.outgoing.window
        };
        this.incoming.max_transfer_id = fields.next_incoming_id + fields.incoming_window;
        if (link) {
            if (link._get_drain()) fields.drain = true;
            fields.delivery_count = link.delivery_count;
            fields.handle = link.local.handle;
            fields.link_credit = link.credit;
        }
        this.output(frames_1.flow(fields));
    };

    Session.prototype.on_begin = function (frame) {
        if (this.state.remote_opened()) {
            if (!this.remote.channel) {
                this.remote.channel = frame.channel;
            }
            this.remote.begin = frame.performative;
            this.outgoing.on_begin(frame.performative);
            this.incoming.on_begin(frame.performative);
            this.open();
            this.dispatch('session_open', this._context());
        } else {
            throw Error('Begin already received');
        }
    };
    Session.prototype.on_end = function (frame) {
        if (this.state.remote_closed()) {
            this.remote.end = frame.performative;
            var error = this.remote.end.error;
            if (error) {
                var handled = this.dispatch('session_error', this._context());
                handled = this.dispatch('session_close', this._context()) || handled;
                if (!handled) {
                    EventEmitter$2.prototype.emit.call(this.connection.container, 'error', new SessionError(error.description, error.condition, this));
                }
            } else {
                this.dispatch('session_close', this._context());
            }
            var self = this;
            var token = this.state.mark();
            browser.nextTick(function () {
                if (self.state.marker === token) {
                    self.close();
                    browser.nextTick(function () { self.remove(); });
                }
            });
        } else {
            throw Error('End already received');
        }
    };

    Session.prototype.on_attach = function (frame) {
        var name = frame.performative.name;
        var link = this.links[name];
        if (!link) {
            // if role is true, peer is receiver, so we are sender
            link = frame.performative.role ? this.create_sender(name) : this.create_receiver(name);
        }
        this.remote.handles[frame.performative.handle] = link;
        link.on_attach(frame);
        link.remote.attach = frame.performative;
    };

    Session.prototype.on_disposition = function (frame) {
        if (frame.performative.role) {
            log$1.events('[%s] Received disposition for outgoing transfers', this.connection.options.id);
            this.outgoing.on_disposition(frame.performative);
        } else {
            log$1.events('[%s] Received disposition for incoming transfers', this.connection.options.id);
            this.incoming.on_disposition(frame.performative);
        }
        this.connection._register();
    };

    Session.prototype.on_flow = function (frame) {
        this.outgoing.on_flow(frame.performative);
        this.incoming.on_flow(frame.performative);
        if (util_1$1.is_defined(frame.performative.handle)) {
            this._get_link(frame).on_flow(frame);
        }
        this.connection._register();
    };

    Session.prototype._context = function (c) {
        var context = c ? c : {};
        context.session = this;
        return this.connection._context(context);
    };

    Session.prototype._get_link = function (frame) {
        var handle = frame.performative.handle;
        var link = this.remote.handles[handle];
        if (!link) {
            throw Error('Invalid handle ' + handle);
        }
        return link;
    };

    Session.prototype.on_detach = function (frame) {
        this._get_link(frame).on_detach(frame);
    };

    Session.prototype.remove_link = function (link) {
        delete this.remote.handles[link.remote.handle];
        delete this.local.handles[link.local.handle];
        delete this.links[link.name];
    };

    /**
     * This forcibly removes the session from the parent connection. It
     * should not be called for a link on an active connection, where
     * close() should be used instead.
     */
    Session.prototype.remove = function () {
        this.connection.remove_session(this);
    };

    Session.prototype.on_transfer = function (frame) {
        this.incoming.on_transfer(frame, this._get_link(frame));
    };

    var session = Session;

    var _rollupPluginShim1 = {};

    var _rollupPluginShim1$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _rollupPluginShim1
    });

    var _rollupPluginShim6 = {};

    var _rollupPluginShim6$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _rollupPluginShim6
    });

    var _rollupPluginShim2 = {};

    var _rollupPluginShim2$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _rollupPluginShim2
    });

    var _rollupPluginShim3 = {};

    var _rollupPluginShim3$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _rollupPluginShim3
    });

    var fs = getCjsExportFromNamespace(_rollupPluginShim1$1);

    var os = getCjsExportFromNamespace(_rollupPluginShim5);

    var path = getCjsExportFromNamespace(_rollupPluginShim6$1);

    var net = getCjsExportFromNamespace(_rollupPluginShim2$1);

    var tls = getCjsExportFromNamespace(_rollupPluginShim3$1);

    var EventEmitter$3 = events.EventEmitter;

    var AMQP_PROTOCOL_ID = 0x00;

    function find_connect_config() {
        var paths;
        if (browser.env.MESSAGING_CONNECT_FILE) {
            paths = [browser.env.MESSAGING_CONNECT_FILE];
        } else {
            paths = [browser.cwd(), path.join(os.homedir(), '.config/messaging'),'/etc/messaging'].map(function (base) { return path.join(base, '/connect.json'); });
        }
        for (var i = 0; i < paths.length; i++) {
            if (fs.existsSync(paths[i])) {
                var obj = JSON.parse(fs.readFileSync(paths[i], 'utf8'));
                log$1.config('using config from %s: %j', paths[i], obj);
                return obj;
            }
        }
        return {};
    }

    function get_default_connect_config() {
        var config = find_connect_config();
        var options = {};
        if (config.scheme === 'amqps') options.transport = 'tls';
        if (config.host) options.host = config.host;
        if(config.port === 'amqp') options.port = 5672;
        else if(config.port === 'amqps') options.port = 5671;
        else options.port = config.port;
        if (!(config.sasl && config.sasl.enabled === false)) {
            if (config.user) options.username = config.user;
            else options.username = 'anonymous';
            if (config.password) options.password = config.password;
            if (config.sasl_mechanisms) options.sasl_mechanisms = config.sasl_mechanisms;
        }
        if (config.tls) {
            if (config.tls.key) options.key = fs.readFileSync(config.tls.key);
            if (config.tls.cert) options.cert = fs.readFileSync(config.tls.cert);
            if (config.tls.ca) options.ca = [ fs.readFileSync(config.tls.ca) ];
            if (config.verify === false || config.tls.verify === false) options.rejectUnauthorized = false;
        }
        if (options.transport === 'tls') {
            options.servername = options.host;
        }
        return options;
    }

    function get_socket_id(socket) {
        if (socket.get_id_string) return socket.get_id_string();
        return socket.localAddress + ':' + socket.localPort + ' -> ' + socket.remoteAddress + ':' + socket.remotePort;
    }

    function session_per_connection(conn) {
        var ssn = null;
        return {
            'get_session' : function () {
                if (!ssn) {
                    ssn = conn.create_session();
                    ssn.observers.on('session_close', function () { ssn = null; });
                    ssn.begin();
                }
                return ssn;
            }
        };
    }

    function restrict(count, f) {
        if (count) {
            var current = count;
            var reset;
            return function (successful_attempts) {
                if (reset !== successful_attempts) {
                    current = count;
                    reset = successful_attempts;
                }
                if (current--) return f(successful_attempts);
                else return -1;
            };
        } else {
            return f;
        }
    }

    function backoff(initial, max) {
        var delay = initial;
        var reset;
        return function (successful_attempts) {
            if (reset !== successful_attempts) {
                delay = initial;
                reset = successful_attempts;
            }
            var current = delay;
            var next = delay*2;
            delay = max > next ? next : max;
            return current;
        };
    }

    function get_connect_fn(options) {
        if (options.transport === undefined || options.transport === 'tcp') {
            return net.connect;
        } else if (options.transport === 'tls' || options.transport === 'ssl') {
            return tls.connect;
        } else {
            throw Error('Unrecognised transport: ' + options.transport);
        }
    }

    function connection_details(options) {
        var details = {};
        details.connect = options.connect ? options.connect : get_connect_fn(options);
        details.host = options.host ? options.host : 'localhost';
        details.port = options.port ? options.port : 5672;
        details.options = options;
        return details;
    }

    var aliases$1 = [
        'container_id',
        'hostname',
        'max_frame_size',
        'channel_max',
        'idle_time_out',
        'outgoing_locales',
        'incoming_locales',
        'offered_capabilities',
        'desired_capabilities',
        'properties'
    ];

    function remote_property_shortcut$1(name) {
        return function() { return this.remote.open ? this.remote.open[name] : undefined; };
    }

    function connection_fields(fields) {
        var o = {};
        aliases$1.forEach(function (name) {
            if (fields[name] !== undefined) {
                o[name] = fields[name];
            }
        });
        return o;
    }

    var conn_counter = 1;

    var Connection = function (options, container) {
        this.options = {};
        if (options) {
            for (var k in options) {
                this.options[k] = options[k];
            }
            if ((options.transport === 'tls' || options.transport === 'ssl')
                && options.servername === undefined && options.host !== undefined) {
                this.options.servername = options.host;
            }
        } else {
            this.options = get_default_connect_config();
        }
        this.container = container;
        if (!this.options.id) {
            this.options.id = 'connection-' + conn_counter++;
        }
        if (!this.options.container_id) {
            this.options.container_id = container ? container.id : util_1$1.generate_uuid();
        }
        if (!this.options.connection_details) {
            var self = this;
            this.options.connection_details = function() { return connection_details(self.options); };
        }
        var reconnect = this.get_option('reconnect', true);
        if (typeof reconnect === 'boolean' && reconnect) {
            var initial = this.get_option('initial_reconnect_delay', 100);
            var max = this.get_option('max_reconnect_delay', 60000);
            this.options.reconnect = restrict(this.get_option('reconnect_limit'), backoff(initial, max));
        } else if (typeof reconnect === 'number') {
            var fixed = this.options.reconnect;
            this.options.reconnect = restrict(this.get_option('reconnect_limit'), function () { return fixed; });
        }
        this.registered = false;
        this.state = new endpoint();
        this.local_channel_map = {};
        this.remote_channel_map = {};
        this.local = {};
        this.remote = {};
        this.local.open = frames_1.open(connection_fields(this.options));
        this.local.close = frames_1.close({});
        this.session_policy = session_per_connection(this);
        this.amqp_transport = new transport(this.options.id, AMQP_PROTOCOL_ID, frames_1.TYPE_AMQP, this);
        this.sasl_transport = undefined;
        this.transport = this.amqp_transport;
        this.conn_established_counter = 0;
        this.heartbeat_out = undefined;
        this.heartbeat_in = undefined;
        this.abort_idle = false;
        this.socket_ready = false;
        this.scheduled_reconnect = undefined;
        this.default_sender = undefined;
        this.closed_with_non_fatal_error = false;

        for (var i in aliases$1) {
            var f = aliases$1[i];
            Object.defineProperty(this, f, { get: remote_property_shortcut$1(f) });
        }
        Object.defineProperty(this, 'error', { get:  function() { return this.remote.close ? this.remote.close.error : undefined; }});
    };

    Connection.prototype = Object.create(EventEmitter$3.prototype);
    Connection.prototype.constructor = Connection;
    Connection.prototype.dispatch = function(name) {
        log$1.events('[%s] Connection got event: %s', this.options.id, name);
        if (this.listeners(name).length) {
            EventEmitter$3.prototype.emit.apply(this, arguments);
            return true;
        } else if (this.container) {
            return this.container.dispatch.apply(this.container, arguments);
        } else {
            return false;
        }
    };

    Connection.prototype._disconnect = function() {
        this.state.disconnected();
        for (var k in this.local_channel_map) {
            this.local_channel_map[k]._disconnect();
        }
        this.socket_ready = false;
    };

    Connection.prototype._reconnect = function() {
        if (this.abort_idle) {
            this.abort_idle = false;
            this.local.close.error = undefined;
            this.state = new endpoint();
            this.state.open();
        }

        this.state.reconnect();
        this._reset_remote_state();
    };

    Connection.prototype._reset_remote_state = function() {
        //reset transport
        this.amqp_transport = new transport(this.options.id, AMQP_PROTOCOL_ID, frames_1.TYPE_AMQP, this);
        this.sasl_transport = undefined;
        this.transport = this.amqp_transport;

        //reset remote endpoint state
        this.remote = {};
        //reset sessions:
        this.remote_channel_map = {};
        for (var k in this.local_channel_map) {
            this.local_channel_map[k]._reconnect();
        }
    };

    Connection.prototype.connect = function () {
        this.is_server = false;
        this.abort_idle = false;
        this._reset_remote_state();
        this._connect(this.options.connection_details(this.conn_established_counter));
        this.open();
        return this;
    };

    Connection.prototype.reconnect = function () {
        this.scheduled_reconnect = undefined;
        log$1.reconnect('[%s] reconnecting...', this.options.id);
        this._reconnect();
        this._connect(this.options.connection_details(this.conn_established_counter));
        browser.nextTick(this._process.bind(this));
        return this;
    };

    Connection.prototype._connect = function (details) {
        if (details.connect) {
            this.init(details.connect(details.port, details.host, details.options, this.connected.bind(this)));
        } else {
            this.init(get_connect_fn(details)(details.port, details.host, details.options, this.connected.bind(this)));
        }
        return this;
    };

    Connection.prototype.accept = function (socket) {
        this.is_server = true;
        log$1.io('[%s] client accepted: %s', this.id, get_socket_id(socket));
        this.socket_ready = true;
        return this.init(socket);
    };


    Connection.prototype.abort_socket = function (socket) {
        if (socket === this.socket) {
            log$1.io('[%s] aborting socket', this.options.id);
            this.socket.end();
            this.socket.removeAllListeners('data');
            this.socket.removeAllListeners('error');
            this.socket.removeAllListeners('end');
            this._disconnected();
        }
    };

    Connection.prototype.init = function (socket) {
        this.socket = socket;
        if (this.get_option('tcp_no_delay', false) && this.socket.setNoDelay) {
            this.socket.setNoDelay(true);
        }
        this.socket.on('data', this.input.bind(this));
        this.socket.on('error', this.on_error.bind(this));
        this.socket.on('end', this.eof.bind(this));

        if (this.is_server) {
            var mechs;
            if (this.container && Object.getOwnPropertyNames(this.container.sasl_server_mechanisms).length) {
                mechs = this.container.sasl_server_mechanisms;
            }
            if (this.socket.encrypted && this.socket.authorized && this.get_option('enable_sasl_external', false)) {
                mechs = sasl.server_add_external(mechs ? util_1$1.clone(mechs) : {});
            }
            if (mechs) {
                if (mechs.ANONYMOUS !== undefined && !this.get_option('require_sasl', false)) {
                    this.sasl_transport = new sasl.Selective(this, mechs);
                } else {
                    this.sasl_transport = new sasl.Server(this, mechs);
                }
            } else {
                if (!this.get_option('disable_sasl', false)) {
                    var anon = sasl.server_mechanisms();
                    anon.enable_anonymous();
                    this.sasl_transport = new sasl.Selective(this, anon);
                }
            }
        } else {
            var mechanisms = this.get_option('sasl_mechanisms');
            if (!mechanisms) {
                var username = this.get_option('username');
                var password = this.get_option('password');
                var token = this.get_option('token');
                if (username) {
                    mechanisms = sasl.client_mechanisms();
                    if (password) mechanisms.enable_plain(username, password);
                    else if (token) mechanisms.enable_xoauth2(username, token);
                    else mechanisms.enable_anonymous(username);
                }
            }
            if (this.socket.encrypted && this.options.cert && this.get_option('enable_sasl_external', false)) {
                if (!mechanisms) mechanisms = sasl.client_mechanisms();
                mechanisms.enable_external();
            }

            if (mechanisms) {
                this.sasl_transport = new sasl.Client(this, mechanisms, this.options.sasl_init_hostname || this.options.servername || this.options.host);
            }
        }
        this.transport = this.sasl_transport ? this.sasl_transport : this.amqp_transport;
        return this;
    };

    Connection.prototype.attach_sender = function (options) {
        return this.session_policy.get_session().attach_sender(options);
    };
    Connection.prototype.open_sender = Connection.prototype.attach_sender;//alias

    Connection.prototype.attach_receiver = function (options) {
        if (this.get_option('tcp_no_delay', true) && this.socket.setNoDelay) {
            this.socket.setNoDelay(true);
        }
        return this.session_policy.get_session().attach_receiver(options);
    };
    Connection.prototype.open_receiver = Connection.prototype.attach_receiver;//alias

    Connection.prototype.get_option = function (name, default_value) {
        if (this.options[name] !== undefined) return this.options[name];
        else if (this.container) return this.container.get_option(name, default_value);
        else return default_value;
    };

    Connection.prototype.send = function(msg) {
        if (this.default_sender === undefined) {
            this.default_sender = this.open_sender({target:{}});
        }
        return this.default_sender.send(msg);
    };

    Connection.prototype.connected = function () {
        this.socket_ready = true;
        this.conn_established_counter++;
        log$1.io('[%s] connected %s', this.options.id, get_socket_id(this.socket));
        this.output();
    };

    Connection.prototype.sasl_failed = function (text, condition) {
        this.transport_error = new errors.ConnectionError(text, condition ? condition : 'amqp:unauthorized-access', this);
        this._handle_error();
        this.socket.end();
    };

    Connection.prototype._is_fatal = function (error_condition) {
        var non_fatal = this.get_option('non_fatal_errors', ['amqp:connection:forced']);
        return non_fatal.indexOf(error_condition) < 0;
    };

    Connection.prototype._handle_error = function () {
        var error = this.get_error();
        if (error) {
            var handled = this.dispatch('connection_error', this._context({error:error}));
            handled = this.dispatch('connection_close', this._context({error:error})) || handled;

            if (!this._is_fatal(error.condition)) {
                this.closed_with_non_fatal_error = true;
            } else if (!handled) {
                this.dispatch('error', new errors.ConnectionError(error.description, error.condition, this));
            }
            return true;
        } else {
            return false;
        }
    };

    Connection.prototype.get_error = function () {
        if (this.transport_error) return this.transport_error;
        if (this.remote.close && this.remote.close.error) {
            return new errors.ConnectionError(this.remote.close.error.description, this.remote.close.error.condition, this);
        }
        return undefined;
    };

    Connection.prototype._get_peer_details = function () {
        var s = '';
        if (this.remote.open && this.remote.open.container) {
            s += this.remote.open.container + ' ';
        }
        if (this.remote.open && this.remote.open.properties) {
            s += JSON.stringify(this.remote.open.properties);
        }
        return s;
    };

    Connection.prototype.output = function () {
        try {
            if (this.socket && this.socket_ready) {
                if (this.heartbeat_out) clearTimeout(this.heartbeat_out);
                this.transport.write(this.socket);
                if (((this.is_closed() && this.state.has_settled()) || this.abort_idle || this.transport_error) && !this.transport.has_writes_pending()) {
                    this.socket.end();
                } else if (this.is_open() && this.remote.open.idle_time_out) {
                    this.heartbeat_out = setTimeout(this._write_frame.bind(this), this.remote.open.idle_time_out / 2);
                }
                if (this.local.open.idle_time_out && this.heartbeat_in === undefined) {
                    this.heartbeat_in = setTimeout(this.idle.bind(this), this.local.open.idle_time_out);
                }
            }
        } catch (e) {
            this.saved_error = e;
            if (e.name === 'ProtocolError') {
                console.error('[' + this.options.id + '] error on write: ' + e + ' ' + this._get_peer_details() + ' ' + e.name);
                this.dispatch('protocol_error', e) || console.error('[' + this.options.id + '] error on write: ' + e + ' ' + this._get_peer_details());
            } else {
                this.dispatch('error', e);
            }
            this.socket.end();
        }
    };

    function byte_to_hex(value) {
        if (value < 16) return '0x0' + Number(value).toString(16);
        else return '0x' + Number(value).toString(16);
    }

    function buffer_to_hex(buffer) {
        var bytes = [];
        for (var i = 0; i < buffer.length; i++) {
            bytes.push(byte_to_hex(buffer[i]));
        }
        return bytes.join(',');
    }

    Connection.prototype.input = function (buff) {
        var buffer;
        try {
            if (this.heartbeat_in) clearTimeout(this.heartbeat_in);
            log$1.io('[%s] read %d bytes', this.options.id, buff.length);
            if (this.previous_input) {
                buffer = buffer_1.concat([this.previous_input, buff], this.previous_input.length + buff.length);
                this.previous_input = null;
            } else {
                buffer = buff;
            }
            var read = this.transport.read(buffer, this);
            if (read < buffer.length) {
                this.previous_input = buffer.slice(read);
            }
            if (this.local.open.idle_time_out) this.heartbeat_in = setTimeout(this.idle.bind(this), this.local.open.idle_time_out);
            if (this.transport.has_writes_pending()) {
                this.output();
            } else if (this.is_closed() && this.state.has_settled()) {
                this.socket.end();
            } else if (this.is_open() && this.remote.open.idle_time_out && !this.heartbeat_out) {
                this.heartbeat_out = setTimeout(this._write_frame.bind(this), this.remote.open.idle_time_out / 2);
            }
        } catch (e) {
            this.saved_error = e;
            if (e.name === 'ProtocolError') {
                this.dispatch('protocol_error', e) ||
                    console.error('[' + this.options.id + '] error on read: ' + e + ' ' + this._get_peer_details() + ' (buffer:' + buffer_to_hex(buffer) + ')');
            } else {
                this.dispatch('error', e);
            }
            this.socket.end();
        }

    };

    Connection.prototype.idle = function () {
        if (!this.is_closed()) {
            this.abort_idle = true;
            this.closed_with_non_fatal_error = true;
            this.local.close.error = {condition:'amqp:resource-limit-exceeded', description:'max idle time exceeded'};
            this.close();
            setTimeout(this.abort_socket.bind(this, this.socket), 1000);
        }
    };

    Connection.prototype.on_error = function (e) {
        this._disconnected(e);
    };

    Connection.prototype.eof = function (e) {
        var error = e || this.saved_error;
        this.saved_error = undefined;
        this._disconnected(error);
    };

    Connection.prototype._disconnected = function (error) {
        if (this.heartbeat_out) {
            clearTimeout(this.heartbeat_out);
            this.heartbeat_out = undefined;
        }
        if (this.heartbeat_in) {
            clearTimeout(this.heartbeat_in);
            this.heartbeat_in = undefined;
        }
        var was_closed_with_non_fatal_error = this.closed_with_non_fatal_error;
        if (this.closed_with_non_fatal_error) {
            this.closed_with_non_fatal_error = false;
            if (this.options.reconnect) this.open();
        }
        if ((!this.is_closed() || was_closed_with_non_fatal_error) && this.scheduled_reconnect === undefined) {
            this._disconnect();
            var disconnect_ctxt = {};
            if (error) {
                disconnect_ctxt.error = error;
            }
            if (!this.is_server && !this.transport_error && this.options.reconnect) {
                var delay = this.options.reconnect(this.conn_established_counter);
                if (delay >= 0) {
                    log$1.reconnect('[%s] Scheduled reconnect in ' + delay + 'ms', this.options.id);
                    this.scheduled_reconnect = setTimeout(this.reconnect.bind(this), delay);
                    disconnect_ctxt.reconnecting = true;
                } else {
                    disconnect_ctxt.reconnecting = false;
                }
            }
            if (!this.dispatch('disconnected', this._context(disconnect_ctxt))) {
                console.warn('[' + this.options.id + '] disconnected %s', disconnect_ctxt.error || '');
            }
        }
    };

    Connection.prototype.open = function () {
        if (this.state.open()) {
            this._register();
        }
    };

    Connection.prototype.close = function (error) {
        if (error) this.local.close.error = error;
        if (this.state.close()) {
            this._register();
        }
    };

    Connection.prototype.is_open = function () {
        return this.state.is_open();
    };

    Connection.prototype.is_remote_open = function () {
        return this.state.remote_open;
    };

    Connection.prototype.is_closed = function () {
        return this.state.is_closed();
    };

    Connection.prototype.create_session = function () {
        var i = 0;
        while (this.local_channel_map[i]) i++;
        var session$1 = new session(this, i);
        this.local_channel_map[i] = session$1;
        return session$1;
    };

    Connection.prototype.find_sender = function (filter) {
        return this.find_link(util_1$1.sender_filter(filter));
    };

    Connection.prototype.find_receiver = function (filter) {
        return this.find_link(util_1$1.receiver_filter(filter));
    };

    Connection.prototype.find_link = function (filter) {
        for (var channel in this.local_channel_map) {
            var session = this.local_channel_map[channel];
            var result = session.find_link(filter);
            if (result) return result;
        }
        return undefined;
    };

    Connection.prototype.each_receiver = function (action, filter) {
        this.each_link(action, util_1$1.receiver_filter(filter));
    };

    Connection.prototype.each_sender = function (action, filter) {
        this.each_link(action, util_1$1.sender_filter(filter));
    };

    Connection.prototype.each_link = function (action, filter) {
        for (var channel in this.local_channel_map) {
            var session = this.local_channel_map[channel];
            session.each_link(action, filter);
        }
    };

    Connection.prototype.on_open = function (frame) {
        if (this.state.remote_opened()) {
            this.remote.open = frame.performative;
            this.open();
            this.dispatch('connection_open', this._context());
        } else {
            throw new errors.ProtocolError('Open already received');
        }
    };

    Connection.prototype.on_close = function (frame) {
        if (this.state.remote_closed()) {
            this.remote.close = frame.performative;
            if (this.remote.close.error) {
                this._handle_error();
            } else {
                this.dispatch('connection_close', this._context());
            }
            if (this.heartbeat_out) clearTimeout(this.heartbeat_out);
            var self = this;
            browser.nextTick(function () {
                self.close();
            });
        } else {
            throw new errors.ProtocolError('Close already received');
        }
    };

    Connection.prototype._register = function () {
        if (!this.registered) {
            this.registered = true;
            browser.nextTick(this._process.bind(this));
        }
    };

    Connection.prototype._process = function () {
        this.registered = false;
        do {
            if (this.state.need_open()) {
                this._write_open();
            }
            for (var k in this.local_channel_map) {
                this.local_channel_map[k]._process();
            }
            if (this.state.need_close()) {
                this._write_close();
            }
        } while (!this.state.has_settled());
    };

    Connection.prototype._write_frame = function (channel, frame, payload) {
        this.amqp_transport.encode(frames_1.amqp_frame(channel, frame, payload));
        this.output();
    };

    Connection.prototype._write_open = function () {
        this._write_frame(0, this.local.open);
    };

    Connection.prototype._write_close = function () {
        this._write_frame(0, this.local.close);
    };

    Connection.prototype.on_begin = function (frame) {
        var session;
        if (frame.performative.remote_channel === null || frame.performative.remote_channel === undefined) {
            //peer initiated
            session = this.create_session();
            session.local.begin.remote_channel = frame.channel;
        } else {
            session = this.local_channel_map[frame.performative.remote_channel];
            if (!session) throw new errors.ProtocolError('Invalid value for remote channel ' + frame.performative.remote_channel);
        }
        session.on_begin(frame);
        this.remote_channel_map[frame.channel] = session;
    };

    Connection.prototype.get_peer_certificate = function() {
        if (this.socket && this.socket.getPeerCertificate) {
            return this.socket.getPeerCertificate();
        } else {
            return undefined;
        }
    };

    Connection.prototype.get_tls_socket = function() {
        if (this.socket && (this.options.transport === 'tls' || this.options.transport === 'ssl')) {
            return this.socket;
        } else {
            return undefined;
        }
    };

    Connection.prototype._context = function (c) {
        var context = c ? c : {};
        context.connection = this;
        if (this.container) context.container = this.container;
        return context;
    };

    Connection.prototype.remove_session = function (session) {
        if (this.remote_channel_map[session.remote.channel] === session) {
            delete this.remote_channel_map[session.remote.channel];
        }
        if (this.local_channel_map[session.local.channel] === session) {
            delete this.local_channel_map[session.local.channel];
        }
    };

    Connection.prototype.remove_all_sessions = function () {
        this.remote_channel_map = {};
        this.local_channel_map = {};
    };

    function delegate_to_session(name) {
        Connection.prototype['on_' + name] = function (frame) {
            var session = this.remote_channel_map[frame.channel];
            if (!session) {
                throw new errors.ProtocolError(name + ' received on invalid channel ' + frame.channel);
            }
            session['on_' + name](frame);
        };
    }

    delegate_to_session('end');
    delegate_to_session('attach');
    delegate_to_session('detach');
    delegate_to_session('transfer');
    delegate_to_session('disposition');
    delegate_to_session('flow');

    var connection = Connection;

    /*
     * Copyright 2018 Red Hat Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the 'License');
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an 'AS IS' BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var ReceiverEvents;
    (function (ReceiverEvents) {
        /**
         * @property {string} message Raised when a message is received.
         */
        ReceiverEvents['message'] = 'message';
        /**
         * @property {string} receiverOpen Raised when the remote peer indicates the link is
         * open (i.e. attached in AMQP parlance).
         */
        ReceiverEvents['receiverOpen'] = 'receiver_open';
        /**
         * @property {string} receiverDrained Raised when the remote peer
         * indicates that it has drained all credit (and therefore there
         * are no more messages at present that it can send).
         */
        ReceiverEvents['receiverDrained'] = 'receiver_drained';
        /**
         * @property {string} receiverFlow Raised when a flow is received for receiver.
         */
        ReceiverEvents['receiverFlow'] = 'receiver_flow';
        /**
         * @property {string} receiverError Raised when the remote peer
         * closes the receiver with an error. The context may also have an
         * error property giving some information about the reason for the
         * error.
         */
        ReceiverEvents['receiverError'] = 'receiver_error';
        /**
         * @property {string} receiverClose Raised when the remote peer indicates the link is closed.
         */
        ReceiverEvents['receiverClose'] = 'receiver_close';
        /**
         * @property {string} settled Raised when the receiver link receives a disposition.
         */
        ReceiverEvents['settled'] = 'settled';
    })(ReceiverEvents || (ReceiverEvents = {}));

    var SenderEvents;
    (function (SenderEvents) {
        /**
         * @property {string} sendable Raised when the sender has sufficient credit to be able
         * to transmit messages to its peer.
         */
        SenderEvents['sendable'] = 'sendable';
        /**
         * @property {string} senderOpen Raised when the remote peer indicates the link is
         * open (i.e. attached in AMQP parlance).
         */
        SenderEvents['senderOpen'] = 'sender_open';
        /**
         * @property {string} senderDraining Raised when the remote peer
         * requests that the sender drain its credit; sending all
         * available messages within the credit limit and ensuring credit
         * is used up..
         */
        SenderEvents['senderDraining'] = 'sender_draining';
        /**
         * @property {string} senderFlow Raised when a flow is received for sender.
         */
        SenderEvents['senderFlow'] = 'sender_flow';
        /**
         * @property {string} senderError Raised when the remote peer
         * closes the sender with an error. The context may also have an
         * error property giving some information about the reason for the
         * error.
         */
        SenderEvents['senderError'] = 'sender_error';
        /**
         * @property {string} senderClose Raised when the remote peer indicates the link is closed.
         */
        SenderEvents['senderClose'] = 'sender_close';
        /**
         * @property {string} accepted Raised when a sent message is accepted by the peer.
         */
        SenderEvents['accepted'] = 'accepted';
        /**
         * @property {string} released Raised when a sent message is released by the peer.
         */
        SenderEvents['released'] = 'released';
        /**
         * @property {string} rejected Raised when a sent message is rejected by the peer.
         */
        SenderEvents['rejected'] = 'rejected';
        /**
         * @property {string} modified Raised when a sent message is modified by the peer.
         */
        SenderEvents['modified'] = 'modified';
        /**
         * @property {string} settled Raised when the sender link receives a disposition.
         */
        SenderEvents['settled'] = 'settled';
    })(SenderEvents || (SenderEvents = {}));


    var SessionEvents;
    (function (SessionEvents) {
        /**
         * @property {string} sessionOpen Raised when the remote peer indicates the session is
         * open (i.e. attached in AMQP parlance).
         */
        SessionEvents['sessionOpen'] = 'session_open';
        /**
         * @property {string} sessionError Raised when the remote peer receives an error. The context
         * may also have an error property giving some information about the reason for the error.
         */
        SessionEvents['sessionError'] = 'session_error';
        /**
         * @property {string} sessionClose Raised when the remote peer indicates the session is closed.
         */
        SessionEvents['sessionClose'] = 'session_close';
        /**
         * @property {string} settled Raised when the session receives a disposition.
         */
        SessionEvents['settled'] = 'settled';
    })(SessionEvents || (SessionEvents = {}));

    var ConnectionEvents;
    (function (ConnectionEvents) {
        /**
         * @property {string} connectionOpen Raised when the remote peer indicates the connection is open.
         */
        ConnectionEvents['connectionOpen'] = 'connection_open';
        /**
         * @property {string} connectionClose Raised when the remote peer indicates the connection is closed.
         */
        ConnectionEvents['connectionClose'] = 'connection_close';
        /**
         * @property {string} connectionError Raised when the remote peer indicates an error occurred on
         * the connection.
         */
        ConnectionEvents['connectionError'] = 'connection_error';
        /**
         * @property {string} protocolError Raised when a protocol error is received on the underlying socket.
         */
        ConnectionEvents['protocolError'] = 'protocol_error',
        /**
         * @property {string} error Raised when an error is received on the underlying socket.
         */
        ConnectionEvents['error'] = 'error',
        /**
         * @property {string} disconnected Raised when the underlying tcp connection is lost. The context
         * has a reconnecting property which is true if the library is attempting to automatically reconnect
         * and false if it has reached the reconnect limit. If reconnect has not been enabled or if the connection
         * is a tcp server, then the reconnecting property is undefined. The context may also have an error
         * property giving some information about the reason for the disconnect.
         */
        ConnectionEvents['disconnected'] = 'disconnected';
        /**
         * @property {string} settled Raised when the connection receives a disposition.
         */
        ConnectionEvents['settled'] = 'settled';
    })(ConnectionEvents || (ConnectionEvents = {}));

    var eventTypes = {
        ReceiverEvents: ReceiverEvents,
        SenderEvents: SenderEvents,
        SessionEvents: SessionEvents,
        ConnectionEvents: ConnectionEvents
    };

    function nulltransform(data) { return data; }

    function from_arraybuffer(data) {
        if (data instanceof ArrayBuffer) return buffer_1.from(new Uint8Array(data));
        else return buffer_1.from(data);
    }

    function to_typedarray(data) {
        return new Uint8Array(data);
    }

    function wrap(ws) {
        var data_recv = nulltransform;
        var data_send = nulltransform;
        if (ws.binaryType) {
            ws.binaryType = 'arraybuffer';
            data_recv = from_arraybuffer;
            data_send = to_typedarray;
        }
        return {
            end: function() {
                ws.close();
            },
            write: function(data) {
                try {
                    ws.send(data_send(data), {binary:true});
                } catch (e) {
                    ws.onerror(e);
                }
            },
            on: function(event, handler) {
                if (event === 'data') {
                    ws.onmessage = function(msg_evt) {
                        handler(data_recv(msg_evt.data));
                    };
                } else if (event === 'end') {
                    ws.onclose = handler;
                } else if (event === 'error') {
                    ws.onerror = handler;
                } else {
                    console.error('ERROR: Attempt to set unrecognised handler on websocket wrapper: ' + event);
                }
            },
            get_id_string: function() {
                return ws.url;
            }
        };
    }

    var ws = {

        'connect': function(Impl) {
            return function (url, protocols, options) {
                return function () {
                    return {
                        connect: function(port_ignore, host_ignore, options_ignore, callback) {
                            var c = new Impl(url, protocols, options);
                            c.onopen = callback;
                            return wrap(c);
                        }
                    };
                };
            };
        },
        'wrap': wrap
    };

    var filter = {
        selector : function (s) {
            return {'jms-selector':types_1$1.wrap_described(s, 0x468C00000004)};
        }
    };

    var EventEmitter$4 = events.EventEmitter;

    var Container = function (options) {
        this.options = options ? Object.create(options) : {};
        if (!this.options.id) {
            this.options.id = util_1$1.generate_uuid();
        }
        this.id = this.options.id;
        this.sasl_server_mechanisms = sasl.server_mechanisms();
    };

    Container.prototype = Object.create(EventEmitter$4.prototype);
    Container.prototype.constructor = Container;
    Container.prototype.dispatch = function(name) {
        log$1.events('[%s] Container got event: ' + name, this.id);
        EventEmitter$4.prototype.emit.apply(this, arguments);
        if (this.listeners(name).length) {
            return true;
        } else {
            return false;
        }
    };

    Container.prototype.connect = function (options) {
        return new connection(options, this).connect();
    };

    Container.prototype.create_connection = function (options) {
        return new connection(options, this);
    };

    Container.prototype.listen = function (options) {
        var container = this;
        var server;
        if (options.transport === undefined || options.transport === 'tcp') {
            server = net.createServer();
            server.on('connection', function (socket) {
                new connection(options, container).accept(socket);
            });
        } else if (options.transport === 'tls' || options.transport === 'ssl') {
            server = tls.createServer(options);
            server.on('secureConnection', function (socket) {
                new connection(options, container).accept(socket);
            });
        } else {
            throw Error('Unrecognised transport: ' + options.transport);
        }
        if (browser.version.match(/v0\.10\.\d+/)) {
            server.listen(options.port, options.host);
        } else {
            server.listen(options);
        }
        return server;
    };

    Container.prototype.create_container = function (options) {
        return new Container(options);
    };

    Container.prototype.get_option = function (name, default_value) {
        if (this.options[name] !== undefined) return this.options[name];
        else return default_value;
    };

    Container.prototype.generate_uuid = util_1$1.generate_uuid;
    Container.prototype.string_to_uuid = util_1$1.string_to_uuid;
    Container.prototype.uuid_to_string = util_1$1.uuid_to_string;

    Container.prototype.websocket_accept = function(socket, options) {
        new connection(options, this).accept(ws.wrap(socket));
    };
    Container.prototype.websocket_connect = ws.connect;
    Container.prototype.filter = filter;
    Container.prototype.types = types_1$1;
    Container.prototype.message = message_1;
    Container.prototype.sasl = sasl;
    Container.prototype.ReceiverEvents = eventTypes.ReceiverEvents;
    Container.prototype.SenderEvents = eventTypes.SenderEvents;
    Container.prototype.SessionEvents = eventTypes.SessionEvents;
    Container.prototype.ConnectionEvents = eventTypes.ConnectionEvents;

    var container = new Container();

    var log$2 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * @ignore
     * log statements for container
     */
    exports.container = browser$2("rhea-promise:container");
    /**
     * @ignore
     * log statements for connection
     */
    exports.connection = browser$2("rhea-promise:connection");
    /**
     * @ignore
     * log statements for session
     */
    exports.session = browser$2("rhea-promise:session");
    /**
     * @ignore
     * log statements for sender
     */
    exports.sender = browser$2("rhea-promise:sender");
    /**
     * @ignore
     * log statements for receiver
     */
    exports.receiver = browser$2("rhea-promise:receiver");
    /**
     * @ignore
     * log statements for error
     */
    exports.error = browser$2("rhea-promise:error");
    /**
     * @ignore
     * log statements for error
     */
    exports.eventHandler = browser$2("rhea-promise:eventhandler");
    /**
     * @ignore
     * log statements for error
     */
    exports.contextTranslator = browser$2("rhea-promise:translate");

    });

    unwrapExports(log$2);
    var log_1 = log$2.container;
    var log_2 = log$2.connection;
    var log_3 = log$2.session;
    var log_4 = log$2.sender;
    var log_5 = log$2.receiver;
    var log_6 = log$2.error;
    var log_7 = log$2.eventHandler;
    var log_8 = log$2.contextTranslator;

    var utils$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });


    /**
     * Defines a mapping for Http like response status codes for different status-code values
     * provided by an AMQP broker.
     * @enum AmqpResponseStatusCode
     */
    var AmqpResponseStatusCode;
    (function (AmqpResponseStatusCode) {
        AmqpResponseStatusCode[AmqpResponseStatusCode["Continue"] = 100] = "Continue";
        AmqpResponseStatusCode[AmqpResponseStatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
        AmqpResponseStatusCode[AmqpResponseStatusCode["OK"] = 200] = "OK";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Created"] = 201] = "Created";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Accepted"] = 202] = "Accepted";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NoContent"] = 204] = "NoContent";
        AmqpResponseStatusCode[AmqpResponseStatusCode["ResetContent"] = 205] = "ResetContent";
        AmqpResponseStatusCode[AmqpResponseStatusCode["PartialContent"] = 206] = "PartialContent";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Ambiguous"] = 300] = "Ambiguous";
        AmqpResponseStatusCode[AmqpResponseStatusCode["MultipleChoices"] = 300] = "MultipleChoices";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Moved"] = 301] = "Moved";
        AmqpResponseStatusCode[AmqpResponseStatusCode["MovedPermanently"] = 301] = "MovedPermanently";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Found"] = 302] = "Found";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Redirect"] = 302] = "Redirect";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RedirectMethod"] = 303] = "RedirectMethod";
        AmqpResponseStatusCode[AmqpResponseStatusCode["SeeOther"] = 303] = "SeeOther";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NotModified"] = 304] = "NotModified";
        AmqpResponseStatusCode[AmqpResponseStatusCode["UseProxy"] = 305] = "UseProxy";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Unused"] = 306] = "Unused";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RedirectKeepVerb"] = 307] = "RedirectKeepVerb";
        AmqpResponseStatusCode[AmqpResponseStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
        AmqpResponseStatusCode[AmqpResponseStatusCode["BadRequest"] = 400] = "BadRequest";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Unauthorized"] = 401] = "Unauthorized";
        AmqpResponseStatusCode[AmqpResponseStatusCode["PaymentRequired"] = 402] = "PaymentRequired";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Forbidden"] = 403] = "Forbidden";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NotFound"] = 404] = "NotFound";
        AmqpResponseStatusCode[AmqpResponseStatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NotAcceptable"] = 406] = "NotAcceptable";
        AmqpResponseStatusCode[AmqpResponseStatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Conflict"] = 409] = "Conflict";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Gone"] = 410] = "Gone";
        AmqpResponseStatusCode[AmqpResponseStatusCode["LengthRequired"] = 411] = "LengthRequired";
        AmqpResponseStatusCode[AmqpResponseStatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RequestUriTooLong"] = 414] = "RequestUriTooLong";
        AmqpResponseStatusCode[AmqpResponseStatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
        AmqpResponseStatusCode[AmqpResponseStatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
        AmqpResponseStatusCode[AmqpResponseStatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
        AmqpResponseStatusCode[AmqpResponseStatusCode["InternalServerError"] = 500] = "InternalServerError";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NotImplemented"] = 501] = "NotImplemented";
        AmqpResponseStatusCode[AmqpResponseStatusCode["BadGateway"] = 502] = "BadGateway";
        AmqpResponseStatusCode[AmqpResponseStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
        AmqpResponseStatusCode[AmqpResponseStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
        AmqpResponseStatusCode[AmqpResponseStatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
    })(AmqpResponseStatusCode = exports.AmqpResponseStatusCode || (exports.AmqpResponseStatusCode = {}));
    /**
     * Provides a list of predefined (amqp) protocol level properties for an amqp message.
     */
    exports.messageProperties = [
        "message_id", "reply_to", "to", "correlation_id", "content_type", "absolute_expiry_time",
        "group_id", "group_sequence", "reply_to_group_id", "content_encoding", "creation_time", "subject",
        "user_id"
    ];
    /**
     * Provides a list of predefined (amqp) protocol level properties for an amqp message header.
     */
    exports.messageHeader = [
        "first_acquirer", "delivery_count", "ttl", "durable", "priority"
    ];
    /**
     * Determines whether the given error object is like an AmqpError object.
     * @param {object} err The AmqpError object
     * @returns {boolean} result - `true` if it is an AMQP Error; `false` otherwise.
     */
    function isAmqpError(err) {
        if (!err || typeof err !== "object") {
            throw new Error("err is a required parameter and must be of type 'object'.");
        }
        let result = false;
        if (((err.condition && typeof err.condition === "string") && (err.description && typeof err.description === "string"))
            || (err.value && Array.isArray(err.value))
            || (err.constructor && err.constructor.name === "c")) {
            result = true;
        }
        return result;
    }
    exports.isAmqpError = isAmqpError;
    /**
     * A wrapper for setTimeout that resolves a promise after t milliseconds.
     * @param {number} t - The number of milliseconds to be delayed.
     * @param {T} value - The value to be resolved with after a timeout of t milliseconds.
     * @returns {Promise<T>} - Resolved promise
     */
    function delay(t, value) {
        return new Promise((resolve) => setTimeout(() => resolve(value), t));
    }
    exports.delay = delay;
    /**
     * Parses the connection string and returns an object of type T.
     * @param {string} connectionString The connection string to be parsed.
     * @returns {ParsedOutput<T>} ParsedOutput<T>.
     */
    function parseConnectionString(connectionString, options) {
        if (!options)
            options = {};
        const entitySeperator = options.entitySeperator || ";";
        const keyValueSeparator = options.keyValueSeparator || "=";
        return connectionString.split(entitySeperator).reduce((acc, part) => {
            const splitIndex = part.indexOf(keyValueSeparator);
            return Object.assign({}, acc, { [part.substring(0, splitIndex)]: part.substring(splitIndex + 1) });
        }, {});
    }
    exports.parseConnectionString = parseConnectionString;
    /**
     * @ignore
     * Emits an event.
     * @param params parameters needed to emit an event from one of the rhea-promise objects.
     * @returns void
     */
    function emitEvent(params) {
        const emit = () => {
            log$2[params.emitterType]("[%s] %s got event: '%s'. Re-emitting the translated context.", params.connectionId, params.emitterType, params.eventName);
            params.emitter.emit(params.eventName, eventContext.EventContext.translate(params.rheaContext, params.emitter, params.eventName));
        };
        if (params.eventName.indexOf("error") !== -1 && params.emitter.actionInitiated > 0) {
            log$2[params.emitterType]("[%s] %s got event: '%s'. Will re-emit in the next tick, since " +
                "this happened before the promise for create/close was resolved.", params.connectionId, params.emitterType, params.eventName);
            // setTimeout() without any time is equivalent to process.nextTick() and works in node.js and
            // browsers. We wait for a tick to emit error events in general. This should give enough
            // time for promises to resolve on *_open (create) and *_close (close).
            setTimeout(emit);
        }
        else {
            emit();
        }
    }
    exports.emitEvent = emitEvent;
    //# sourceMappingURL=utils.js.map
    });

    unwrapExports(utils$1);
    var utils_1 = utils$1.AmqpResponseStatusCode;
    var utils_2 = utils$1.messageProperties;
    var utils_3 = utils$1.messageHeader;
    var utils_4 = utils$1.isAmqpError;
    var utils_5 = utils$1.delay;
    var utils_6 = utils$1.parseConnectionString;
    var utils_7 = utils$1.emitEvent;

    var entity = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * Abstract base class for all the entities like Connection, Session, Sender, Receiver in the
     * AMQP protocol.
     * @class Entity
     */
    class Entity extends events.EventEmitter {
        constructor() {
            super();
            /**
             * @property actionInitiated Indicates whether the action of creating or closing an entity has
             * been initiated. Whenever an action has been initiated, the count will be incremented by 1.
             * Whenever the action completes (succeeds/fails) the count will be decremented by 1.
             * Default value: `0`.
             */
            this.actionInitiated = 0;
        }
    }
    exports.Entity = Entity;

    });

    unwrapExports(entity);
    var entity_1 = entity.Entity;

    var operationTimeoutError = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Defines the error that occurs when an operation timeout occurs.
     */
    class OperationTimeoutError extends Error {
        constructor(message) {
            super(message);
            /**
             * Describes the name of the error.
             */
            this.name = "OperationTimeoutError";
            /**
             * Provides a logical amqp error condition.
             */
            this.condition = "amqp:operation-timeout";
            this.description = message;
        }
    }
    exports.OperationTimeoutError = OperationTimeoutError;

    });

    unwrapExports(operationTimeoutError);
    var operationTimeoutError_1 = operationTimeoutError.OperationTimeoutError;

    var link$3 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });






    var LinkType;
    (function (LinkType) {
        LinkType["sender"] = "sender";
        LinkType["receiver"] = "receiver";
    })(LinkType = exports.LinkType || (exports.LinkType = {}));
    class Link extends entity.Entity {
        constructor(type, session, link, options) {
            super();
            this.type = type;
            this._session = session;
            this._link = link;
            this.linkOptions = options;
            this._initializeEventListeners();
        }
        get name() {
            return this._link.name;
        }
        get error() {
            return this._link.error;
        }
        get properties() {
            return this._link.properties;
        }
        get sendSettleMode() {
            return this._link.snd_settle_mode;
        }
        get receiveSettleMode() {
            return this._link.rcv_settle_mode;
        }
        get source() {
            return this._link.source;
        }
        set source(fields) {
            this._link.set_source(fields);
        }
        get target() {
            return this._link.target;
        }
        set target(fields) {
            this._link.set_source(fields);
        }
        get maxMessageSize() {
            return this._link.max_message_size;
        }
        get offeredCapabilities() {
            return this._link.offered_capabilities;
        }
        get desiredCapabilities() {
            return this._link.desired_capabilities;
        }
        get address() {
            return this.source.address;
        }
        get credit() {
            return this._link.credit;
        }
        get session() {
            return this._session;
        }
        get connection() {
            return this._session.connection;
        }
        /**
         * Determines whether the sender link and its underlying session is open.
         * @returns {boolean} `true` open. `false` closed.
         */
        isOpen() {
            let result = false;
            if (this._session.isOpen() && this._link.is_open()) {
                result = true;
            }
            return result;
        }
        /**
         * Determines whether the remote end of the link is open.
         * @return {boolean} boolean `true` - is open; `false` otherwise.
         */
        isRemoteOpen() {
            return this._link.is_remote_open();
        }
        /**
         * Determines whether the link has credit.
         * @return {boolean} boolean `true` - has credit; `false` otherwise.
         */
        hasCredit() {
            return this._link.has_credit();
        }
        /**
         * Determines whether the link is a sender.
         * @return {boolean} boolean `true` - sender; `false` otherwise.
         */
        isSender() {
            return this._link.is_sender();
        }
        /**
         * Determines whether the link is a receiver.
         * @return {boolean} boolean `true` - receiver; `false` otherwise.
         */
        isReceiver() {
            return this._link.is_receiver();
        }
        /**
         * Determines whether both local and remote endpoint for link or it's underlying session
         * or it's underlying connection are closed.
         * Within the "sender_close", "session_close" event handler, if this
         * method returns `false` it means that the local end is still open. It can be useful to
         * determine whether the close was initiated locally under such circumstances.
         *
         * @returns {boolean} `true` if closed, `false` otherwise.
         */
        isClosed() {
            return this._link.is_closed();
        }
        /**
         * Determines whether both local and remote endpoint for just the link itself are closed.
         * Within the "sender_close" event handler, if this method returns `false` it
         * means that the local end is still open. It can be useful to determine whether the close
         * was initiated locally under such circumstances.
         *
         * @returns {boolean} `true` - closed, `false` otherwise.
         */
        isItselfClosed() {
            return this._link.is_itself_closed();
        }
        /**
         * Determines whether both local and remote endpoint for session or it's underlying
         * connection are closed.
         *
         * Within the "session_close" event handler, if this method returns `false` it means that
         * the local end is still open. It can be useful to determine whether the close
         * was initiated locally under such circumstances.
         *
         * @returns {boolean} `true` - closed, `false` otherwise.
         */
        isSessionClosed() {
            return this._session.isClosed();
        }
        /**
         * Determines whether both local and remote endpoint for just the session itself are closed.
         * Within the "session_close" event handler, if this method returns `false` it means that
         * the local end is still open. It can be useful to determine whether the close
         * was initiated locally under such circumstances.
         *
         * @returns {boolean} `true` - closed, `false` otherwise.
         */
        isSessionItselfClosed() {
            return this._session.isItselfClosed();
        }
        /**
         * Removes the underlying amqp link and it's session from the internal map in rhea. Also removes
         * all the event handlers added in the rhea-promise library on the link and it's session.
         * @returns {void} void
         */
        remove() {
            if (this._link) {
                // Remove our listeners and listeners from rhea's link object.
                this.removeAllListeners();
                this._link.removeAllListeners();
                this._link.remove();
            }
            if (this._session) {
                this._session.remove();
            }
        }
        /**
         * Closes the underlying amqp link and session in rhea if open. Also removes all the event
         * handlers added in the rhea-promise library on the link and it's session
         * @return {Promise<void>} Promise<void>
         * - **Resolves** the promise when rhea emits the "sender_close" | "receiver_close" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the
         * "sender_error" | "receiver_error" event while trying to close the amqp link.
         */
        close() {
            return tslib_es6.__awaiter(this, void 0, void 0, function* () {
                this.removeAllListeners();
                yield new Promise((resolve, reject) => {
                    log$2.error("[%s] The %s is open ? -> %s", this.connection.id, this.type, this.isOpen());
                    if (this.isOpen()) {
                        const errorEvent = this.type === LinkType.sender
                            ? container.SenderEvents.senderError
                            : container.ReceiverEvents.receiverError;
                        const closeEvent = this.type === LinkType.sender
                            ? container.SenderEvents.senderClose
                            : container.ReceiverEvents.receiverClose;
                        let onError;
                        let onClose;
                        let waitTimer;
                        const removeListeners = () => {
                            clearTimeout(waitTimer);
                            this.actionInitiated--;
                            this._link.removeListener(errorEvent, onError);
                            this._link.removeListener(closeEvent, onClose);
                        };
                        onClose = (context) => {
                            removeListeners();
                            log$2[this.type]("[%s] Resolving the promise as the amqp %s has been closed.", this.connection.id, this.type);
                            return resolve();
                        };
                        onError = (context) => {
                            removeListeners();
                            log$2.error("[%s] Error occurred while closing amqp %s: %O.", this.connection.id, this.type, context.session.error);
                            return reject(context.session.error);
                        };
                        const actionAfterTimeout = () => {
                            removeListeners();
                            const msg = `Unable to close the amqp %s ${this.name} due to operation timeout.`;
                            log$2.error("[%s] %s", this.connection.id, this.type, msg);
                            return reject(new operationTimeoutError.OperationTimeoutError(msg));
                        };
                        // listeners that we add for completing the operation are added directly to rhea's objects.
                        this._link.once(closeEvent, onClose);
                        this._link.once(errorEvent, onError);
                        waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
                        this._link.close();
                        this.actionInitiated++;
                    }
                    else {
                        return resolve();
                    }
                });
                log$2[this.type]("[%s] %s has been closed, now closing it's session.", this.connection.id, this.type);
                return this._session.close();
            });
        }
        /**
         * Adds event listeners for the possible events that can occur on the link object and
         * re-emits the same event back with the received arguments from rhea's event emitter.
         * @private
         * @returns {void} void
         */
        _initializeEventListeners() {
            const events = this.type === LinkType.sender ? container.SenderEvents : container.ReceiverEvents;
            for (const eventName in events) {
                this._link.on(events[eventName], (context) => {
                    const params = {
                        rheaContext: context,
                        emitter: this,
                        eventName: events[eventName],
                        emitterType: this.type,
                        connectionId: this.connection.id
                    };
                    utils$1.emitEvent(params);
                });
            }
            if (typeof this._link.eventNames === "function") {
                log$2.eventHandler("[%s] rhea-promise '%s' object is listening for events: %o " +
                    "emitted by rhea's '%s' object.", this.connection.id, this.type, this._link.eventNames(), this.type);
            }
            if (typeof this._link.listenerCount === "function") {
                log$2.eventHandler("[%s] ListenerCount for event '%s_error' on rhea's '%s' object is: %d.", this.connection.id, this.type, this.type, this._link.listenerCount(`${this.type}_error`));
            }
        }
    }
    exports.Link = Link;

    });

    unwrapExports(link$3);
    var link_1$1 = link$3.LinkType;
    var link_2 = link$3.Link;

    var receiver$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * Describes the receiver that wraps the rhea receiver.
     * @class Receiver.
     */
    class Receiver extends link$3.Link {
        constructor(session, receiver, options) {
            super(link$3.LinkType.receiver, session, receiver, options);
        }
        get drain() {
            return this._link.drain;
        }
        set drain(value) {
            this._link.drain = value;
        }
        addCredit(credit) {
            this._link.add_credit(credit);
        }
        setCreditWindow(creditWindow) {
            this._link.set_credit_window(creditWindow);
        }
    }
    exports.Receiver = Receiver;

    });

    unwrapExports(receiver$1);
    var receiver_1 = receiver$1.Receiver;

    var sender$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * Describes the sender that wraps the rhea sender.
     * @class Sender
     */
    class Sender extends link$3.Link {
        constructor(session, sender, options) {
            super(link$3.LinkType.sender, session, sender, options);
        }
        setDrained(drained) {
            this._link.set_drained(drained);
        }
        /**
         * Determines whether the message is sendable.
         * @returns {boolean} `true` Sendable. `false` Not Sendable.
         */
        sendable() {
            return this._link.sendable();
        }
        /**
         * Sends the message
         * @param {Message | Buffer} msg The AMQP message to be sent.
         * @param {Buffer | string} [tag] The optional tag that can be sent
         * @param {number} [format] The format in which the message needs to be sent.
         * @returns {Delivery} Delivery The delivery information about the sent message.
         */
        send(msg, tag, format) {
            return this._link.send(msg, tag, format);
        }
    }
    exports.Sender = Sender;
    //# sourceMappingURL=sender.js.map
    });

    unwrapExports(sender$1);
    var sender_1 = sender$1.Sender;

    var session$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });







    /**
     * Describes the session that wraps the rhea session.
     * @class Session
     */
    class Session extends entity.Entity {
        constructor(connection, session) {
            super();
            this._connection = connection;
            this._session = session;
            this._initializeEventListeners();
        }
        /**
         * @property {Connection} connection The underlying AMQP connection.
         * @readonly
         */
        get connection() {
            return this._connection;
        }
        get outgoing() {
            return this._session.outgoing;
        }
        get error() {
            return this._session.error;
        }
        /**
         * Determines whether the session and the underlying connection is open.
         * @returns {boolean} result `true` - is open; `false` otherwise.
         */
        isOpen() {
            let result = false;
            if (this._connection.isOpen() && this._session.is_open()) {
                result = true;
            }
            return result;
        }
        /**
         * Determines whether the close from the peer is a response to a locally initiated close request.
         * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
         */
        isClosed() {
            return this._session.is_closed();
        }
        /**
         * Determines whether both local and remote endpoint for just the session itself are closed.
         * Within the "session_close" event handler, if this method returns `false` it means that
         * the local end is still open. It can be useful to determine whether the close
         * was initiated locally under such circumstances.
         *
         * @returns {boolean} `true` - closed, `false` otherwise.
         */
        isItselfClosed() {
            return this._session.is_itself_closed();
        }
        /**
         * Removes the underlying amqp session from the internal map in rhea.
         * Also removes all the event handlers added in the rhea-promise library on the session.
         */
        remove() {
            if (this._session) {
                // Remove our listeners and listeners from rhea's 'session' object.
                this.removeAllListeners();
                this._session.removeAllListeners();
                this._session.remove();
            }
        }
        begin() {
            if (this._session) {
                this._session.begin();
            }
        }
        /**
         * Closes the underlying amqp session in rhea if open. Also removes all the event
         * handlers added in the rhea-promise library on the session
         * @return {Promise<void>} Promise<void>
         * - **Resolves** the promise when rhea emits the "session_close" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "session_error" event while trying
         * to close an amqp session.
         */
        close() {
            this.removeAllListeners();
            return new Promise((resolve, reject) => {
                log$2.error("[%s] The session is open ? -> %s", this.connection.id, this.isOpen());
                if (this.isOpen()) {
                    let onError;
                    let onClose;
                    let waitTimer;
                    const removeListeners = () => {
                        clearTimeout(waitTimer);
                        this.actionInitiated--;
                        this._session.removeListener(container.SessionEvents.sessionError, onError);
                        this._session.removeListener(container.SessionEvents.sessionClose, onClose);
                    };
                    onClose = (context) => {
                        removeListeners();
                        log$2.session("[%s] Resolving the promise as the amqp session has been closed.", this.connection.id);
                        return resolve();
                    };
                    onError = (context) => {
                        removeListeners();
                        log$2.error("[%s] Error occurred while closing amqp session.", this.connection.id, context.session.error);
                        reject(context.session.error);
                    };
                    const actionAfterTimeout = () => {
                        removeListeners();
                        const msg = `Unable to close the amqp session due to operation timeout.`;
                        log$2.error("[%s] %s", this.connection.id, msg);
                        reject(new operationTimeoutError.OperationTimeoutError(msg));
                    };
                    // listeners that we add for completing the operation are added directly to rhea's objects.
                    this._session.once(container.SessionEvents.sessionClose, onClose);
                    this._session.once(container.SessionEvents.sessionError, onError);
                    log$2.session("[%s] Calling session.close()", this.connection.id);
                    waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
                    this._session.close();
                    this.actionInitiated++;
                }
                else {
                    return resolve();
                }
            });
        }
        /**
         * Creates an amqp receiver on this session.
         * @param {Session} session The amqp session object on which the receiver link needs to be established.
         * @param {ReceiverOptions} [options] Options that can be provided while creating an amqp receiver.
         * @return {Promise<Receiver>} Promise<Receiver>
         * - **Resolves** the promise with the Receiver object when rhea emits the "receiver_open" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "receiver_close" event while trying
         * to create an amqp receiver or the operation timeout occurs.
         */
        createReceiver(options) {
            return new Promise((resolve, reject) => {
                if (options &&
                    ((options.onMessage && !options.onError) || (options.onError && !options.onMessage))) {
                    if (options.credit_window !== 0) {
                        // - If the 'onMessage' handler is not provided and the credit_window is not set to 0,
                        // then messages may be lost between the receiver link getting created and the message
                        // handler being attached.
                        // - It can be possible for a service to initially accept the link attach, which would
                        // cause the promise to resolve. However, moments later the service may send a detach
                        // due to some internal or configuration issue. If no error handler is attached, then
                        // the error may fall through.
                        // - Hence it is advised to either provide both 'onMessage' and 'onError' handlers, or
                        // please set the credit_window to `0`, if you want to provide only the 'onError' handler.
                        return reject(new Error("Either provide both 'onMessage' and 'onError' handlers, or pl" +
                            "ease set the credit_window to 0, if you want to provide only the 'onError' " +
                            "handler. This ensures no messages are lost between the receiver getting created " +
                            " and the 'onMessage' handler being added."));
                    }
                }
                // Register session handlers for session_error and session_close if provided.
                // listeners provided by the user in the options object should be added
                // to our (rhea-promise) object.
                if (options && options.onSessionError) {
                    this.on(container.SessionEvents.sessionError, options.onSessionError);
                    log$2.session("[%s] Added event handler for event '%s' on rhea-promise 'session', " +
                        "while creating the 'receiver'.", this.connection.id, container.SessionEvents.sessionError);
                }
                if (options && options.onSessionClose) {
                    this.on(container.SessionEvents.sessionClose, options.onSessionClose);
                    log$2.session("[%s] Added event handler for event '%s' on rhea-promise 'session', " +
                        " while creating the 'receiver'.", this.connection.id, container.SessionEvents.sessionClose);
                }
                const rheaReceiver = this._session.attach_receiver(options);
                const receiver = new receiver$1.Receiver(this, rheaReceiver, options);
                receiver.actionInitiated++;
                let onOpen;
                let onClose;
                let waitTimer;
                if (options && options.onMessage) {
                    receiver.on(container.ReceiverEvents.message, options.onMessage);
                    log$2.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, container.ReceiverEvents.message);
                }
                if (options && options.onError) {
                    receiver.on(container.ReceiverEvents.receiverError, options.onError);
                    log$2.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, container.ReceiverEvents.receiverError);
                }
                if (options && options.onClose) {
                    receiver.on(container.ReceiverEvents.receiverClose, options.onClose);
                    log$2.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, container.ReceiverEvents.receiverClose);
                }
                if (options && options.onSettled) {
                    receiver.on(container.ReceiverEvents.settled, options.onSettled);
                    log$2.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, container.ReceiverEvents.settled);
                }
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    receiver.actionInitiated--;
                    rheaReceiver.removeListener(container.ReceiverEvents.receiverOpen, onOpen);
                    rheaReceiver.removeListener(container.ReceiverEvents.receiverClose, onClose);
                };
                onOpen = (context) => {
                    removeListeners();
                    log$2.receiver("[%s] Resolving the promise with amqp receiver '%s'.", this.connection.id, receiver.name);
                    return resolve(receiver);
                };
                onClose = (context) => {
                    removeListeners();
                    log$2.error("[%s] Error occurred while creating a receiver over amqp connection: %O.", this.connection.id, context.receiver.error);
                    return reject(context.receiver.error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to create the amqp receiver ${receiver.name} due to ` +
                        `operation timeout.`;
                    log$2.error("[%s] %s", this.connection.id, msg);
                    return reject(new operationTimeoutError.OperationTimeoutError(msg));
                };
                // listeners that we add for completing the operation are added directly to rhea's objects.
                rheaReceiver.once(container.ReceiverEvents.receiverOpen, onOpen);
                rheaReceiver.once(container.ReceiverEvents.receiverClose, onClose);
                waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
            });
        }
        /**
         * Creates an amqp sender on this session.
         * @param {SenderOptions} [options] Options that can be provided while creating an amqp sender.
         * @return {Promise<Sender>} Promise<Sender>
         * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while trying
         * to create an amqp sender or the operation timeout occurs.
         */
        createSender(options) {
            return new Promise((resolve, reject) => {
                // Register session handlers for session_error and session_close if provided.
                if (options && options.onSessionError) {
                    this.on(container.SessionEvents.sessionError, options.onSessionError);
                    log$2.session("[%s] Added event handler for event '%s' on rhea-promise 'session', " +
                        "while creating the sender.", this.connection.id, container.SessionEvents.sessionError);
                }
                if (options && options.onSessionClose) {
                    this.on(container.SessionEvents.sessionClose, options.onSessionClose);
                    log$2.session("[%s] Added event handler for event '%s' on rhea-promise 'session', " +
                        "while creating the sender.", this.connection.id, container.SessionEvents.sessionClose);
                }
                const rheaSender = this._session.attach_sender(options);
                const sender = new sender$1.Sender(this, rheaSender, options);
                sender.actionInitiated++;
                let onSendable;
                let onClose;
                let waitTimer;
                // listeners provided by the user in the options object should be added
                // to our (rhea-promise) object.
                if (options) {
                    if (options.onError) {
                        sender.on(container.SenderEvents.senderError, options.onError);
                    }
                    if (options.onClose) {
                        sender.on(container.SenderEvents.senderClose, options.onClose);
                    }
                    if (options.onAccepted) {
                        sender.on(container.SenderEvents.accepted, options.onAccepted);
                    }
                    if (options.onRejected) {
                        sender.on(container.SenderEvents.rejected, options.onRejected);
                    }
                    if (options.onReleased) {
                        sender.on(container.SenderEvents.released, options.onReleased);
                    }
                    if (options.onModified) {
                        sender.on(container.SenderEvents.modified, options.onModified);
                    }
                }
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    sender.actionInitiated--;
                    rheaSender.removeListener(container.SenderEvents.senderOpen, onSendable);
                    rheaSender.removeListener(container.SenderEvents.senderClose, onClose);
                };
                onSendable = (context) => {
                    removeListeners();
                    log$2.sender("[%s] Resolving the promise with amqp sender '%s'.", this.connection.id, sender.name);
                    return resolve(sender);
                };
                onClose = (context) => {
                    removeListeners();
                    log$2.error("[%s] Error occurred while creating a sender over amqp connection: %O.", this.connection.id, context.sender.error);
                    return reject(context.sender.error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to create the amqp sender ${sender.name} due to ` +
                        `operation timeout.`;
                    log$2.error("[%s] %s", this.connection.id, msg);
                    return reject(new operationTimeoutError.OperationTimeoutError(msg));
                };
                // listeners that we add for completing the operation are added directly to rhea's objects.
                rheaSender.once(container.SenderEvents.sendable, onSendable);
                rheaSender.once(container.SenderEvents.senderClose, onClose);
                waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
            });
        }
        /**
         * Adds event listeners for the possible events that can occur on the session object and
         * re-emits the same event back with the received arguments from rhea's event emitter.
         * @private
         * @returns {void} void
         */
        _initializeEventListeners() {
            for (const eventName in container.SessionEvents) {
                this._session.on(container.SessionEvents[eventName], (context) => {
                    const params = {
                        rheaContext: context,
                        emitter: this,
                        eventName: container.SessionEvents[eventName],
                        emitterType: "session",
                        connectionId: this.connection.id
                    };
                    utils$1.emitEvent(params);
                });
            }
            // Add event handlers for *_error and *_close events that can be propogated to the session
            // object, if they are not handled at their level. * denotes - Sender and Receiver.
            // Sender
            this._session.on(container.SenderEvents.senderError, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SenderEvents.senderError,
                    emitterType: "session",
                    connectionId: this.connection.id
                };
                utils$1.emitEvent(params);
            });
            this._session.on(container.SenderEvents.senderClose, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SenderEvents.senderClose,
                    emitterType: "session",
                    connectionId: this.connection.id
                };
                utils$1.emitEvent(params);
            });
            // Receiver
            this._session.on(container.ReceiverEvents.receiverError, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.ReceiverEvents.receiverError,
                    emitterType: "session",
                    connectionId: this.connection.id
                };
                utils$1.emitEvent(params);
            });
            this._session.on(container.ReceiverEvents.receiverClose, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.ReceiverEvents.receiverClose,
                    emitterType: "session",
                    connectionId: this.connection.id
                };
                utils$1.emitEvent(params);
            });
            if (typeof this._session.eventNames === "function") {
                log$2.eventHandler("[%s] rhea-promise 'session' object is listening for events: %o " +
                    "emitted by rhea's 'session' object.", this.connection.id, this._session.eventNames());
            }
        }
    }
    exports.Session = Session;

    });

    unwrapExports(session$1);
    var session_1 = session$1.Session;

    var container$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });




    /**
     * An AMQP container from which outgoing connections can be made and/or
     * to which incoming connections can be accepted.
     * @class Container
     */
    class Container extends events.EventEmitter {
        constructor(options) {
            if (!options)
                options = {};
            super();
            if (options.createdInstance) {
                this._container = options.createdInstance;
                delete options.createdInstance;
            }
            else {
                this._container = container.create_container(options);
            }
            this.options = this._container.options;
        }
        get id() {
            return this._container.id;
        }
        get filter() {
            return this._container.filter;
        }
        get types() {
            return this._container.types;
        }
        get message() {
            return this._container.message;
        }
        get sasl() {
            return this._container.sasl;
        }
        get saslServerMechanisms() {
            return this._container.sasl_server_mechanisms;
        }
        createConnection(options) {
            const rheaConnection = this._container.create_connection(options);
            return new connection$1.Connection({ rheaConnection: rheaConnection, container: this });
        }
        connect(options) {
            return tslib_es6.__awaiter(this, void 0, void 0, function* () {
                return this.createConnection(options).open();
            });
        }
        listen(options) {
            return this._container.listen(options);
        }
        generateUUid() {
            return this._container.generate_uuid();
        }
        stringToUuid(uuidString) {
            return this._container.string_to_uuid(uuidString);
        }
        uuidToString(buffer) {
            return this._container.uuid_to_string(buffer);
        }
        websocketAccept(socket, options) {
            return this._container.websocket_accept(socket, options);
        }
        websocketConnect(impl) {
            return this._container.websocket_connect(impl);
        }
        static create(options) {
            return new Container(options);
        }
        static copyFromContainerInstance(instance) {
            return new Container({ createdInstance: instance });
        }
    }
    exports.Container = Container;

    });

    unwrapExports(container$1);
    var container_1 = container$1.Container;

    var constants = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Describes the default operation timeout in seconds. Value: `60`.
     */
    exports.defaultOperationTimeoutInSeconds = 60;

    });

    unwrapExports(constants);
    var constants_1 = constants.defaultOperationTimeoutInSeconds;

    var connection$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });









    // Determines whether the given object is a CreatedRheConnectionOptions object.
    function isCreatedRheaConnectionOptions(obj) {
        return (obj && typeof obj.container === "object" && typeof obj.rheaConnection === "object");
    }
    /**
     * Descibes the AQMP Connection.
     * @class Connection
     */
    class Connection extends entity.Entity {
        /**
         * Creates an instance of the Connection object.
         * @constructor
         * @param {Connection} _connection The connection object from rhea library.
         */
        constructor(options) {
            super();
            if (!options)
                options = {};
            if (options.operationTimeoutInSeconds == undefined) {
                options.operationTimeoutInSeconds = constants.defaultOperationTimeoutInSeconds;
            }
            if (isCreatedRheaConnectionOptions(options)) {
                this._connection = options.rheaConnection;
                this.container = options.container;
            }
            else {
                const connectionOptions = options;
                if (connectionOptions.webSocketOptions) {
                    const ws = container.websocket_connect(connectionOptions.webSocketOptions.webSocket);
                    connectionOptions.connection_details = ws(connectionOptions.webSocketOptions.url, connectionOptions.webSocketOptions.protocol, connectionOptions.webSocketOptions.options);
                }
                this._connection = container.create_connection(connectionOptions);
                this.container = container$1.Container.copyFromContainerInstance(this._connection.container);
            }
            this.options = this._connection.options;
            this.options.operationTimeoutInSeconds = options.operationTimeoutInSeconds;
            this._initializeEventListeners();
        }
        /**
         * @property {string} id Returns the connection id.
         * @readonly
         */
        get id() {
            return this._connection.options.id;
        }
        /**
         * @property {Dictionary<any> | undefined} [properties] Provides the connection properties.
         * @readonly
         */
        get properties() {
            return this._connection.properties;
        }
        /**
         * @property {number | undefined} [maxFrameSize] Provides the max frame size.
         * @readonly
         */
        get maxFrameSize() {
            return this._connection.max_frame_size;
        }
        /**
         * @property {number | undefined} [idleTimeout] Provides the idle timeout for the connection.
         * @readonly
         */
        get idleTimeout() {
            return this._connection.idle_time_out;
        }
        /**
         * @property {number | undefined} [channelMax] Provides the maximum number of channels supported.
         * @readonly
         */
        get channelMax() {
            return this._connection.channel_max;
        }
        /**
         * @property {AmqpError | Error | undefined} [error] Provides the last error that occurred on the
         * connection.
         */
        get error() {
            return this._connection.error;
        }
        /**
         * Removes the provided session from the internal map in rhea.
         * Also removes all the event handlers added in the rhea-promise library on the provided session.
         * @param {Session} session The session to be removed.
         */
        removeSession(session) {
            return session.remove();
        }
        /**
         * Creates a new amqp connection.
         * @return {Promise<Connection>} Promise<Connection>
         * - **Resolves** the promise with the Connection object when rhea emits the "connection_open" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "connection_close" event
         * while trying to establish an amqp connection.
         */
        open() {
            return new Promise((resolve, reject) => {
                if (!this.isOpen()) {
                    let onOpen;
                    let onClose;
                    let waitTimer;
                    const removeListeners = () => {
                        clearTimeout(waitTimer);
                        this.actionInitiated--;
                        this._connection.removeListener(container.ConnectionEvents.connectionOpen, onOpen);
                        this._connection.removeListener(container.ConnectionEvents.connectionClose, onClose);
                        this._connection.removeListener(container.ConnectionEvents.disconnected, onClose);
                    };
                    onOpen = (context) => {
                        removeListeners();
                        log$2.connection("[%s] Resolving the promise with amqp connection.", this.id);
                        return resolve(this);
                    };
                    onClose = (context) => {
                        removeListeners();
                        const err = context.error || context.connection.error || Error('Failed to connect');
                        log$2.error("[%s] Error occurred while establishing amqp connection: %O", this.id, err);
                        return reject(err);
                    };
                    const actionAfterTimeout = () => {
                        removeListeners();
                        const msg = `Unable to open the amqp connection "${this.id}" due to operation timeout.`;
                        log$2.error("[%s] %s", this.id, msg);
                        return reject(new Error(msg));
                    };
                    // listeners that we add for completing the operation are added directly to rhea's objects.
                    this._connection.once(container.ConnectionEvents.connectionOpen, onOpen);
                    this._connection.once(container.ConnectionEvents.connectionClose, onClose);
                    this._connection.once(container.ConnectionEvents.disconnected, onClose);
                    waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
                    log$2.connection("[%s] Trying to create a new amqp connection.", this.id);
                    this._connection.connect();
                    this.actionInitiated++;
                }
                else {
                    return resolve(this);
                }
            });
        }
        /**
         * Closes the amqp connection.
         * @return {Promise<void>} Promise<void>
         * - **Resolves** the promise when rhea emits the "connection_close" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "connection_error" event while
         * trying to close an amqp connection.
         */
        close() {
            return new Promise((resolve, reject) => {
                log$2.error("[%s] The connection is open ? -> %s", this.id, this.isOpen());
                if (this.isOpen()) {
                    let onClose;
                    let onError;
                    let waitTimer;
                    const removeListeners = () => {
                        clearTimeout(waitTimer);
                        this.actionInitiated--;
                        this._connection.removeListener(container.ConnectionEvents.connectionError, onError);
                        this._connection.removeListener(container.ConnectionEvents.connectionClose, onClose);
                    };
                    onClose = (context) => {
                        removeListeners();
                        log$2.connection("[%s] Resolving the promise as the connection has been successfully closed.", this.id);
                        return resolve();
                    };
                    onError = (context) => {
                        removeListeners();
                        log$2.error("[%s] Error occurred while closing amqp connection: %O.", this.id, context.connection.error);
                        return reject(context.connection.error);
                    };
                    const actionAfterTimeout = () => {
                        removeListeners();
                        const msg = `Unable to close the amqp connection "${this.id}" due to operation timeout.`;
                        log$2.error("[%s] %s", this.id, msg);
                        return reject(new Error(msg));
                    };
                    // listeners that we add for completing the operation are added directly to rhea's objects.
                    this._connection.once(container.ConnectionEvents.connectionClose, onClose);
                    this._connection.once(container.ConnectionEvents.connectionError, onError);
                    waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
                    this._connection.close();
                    this.actionInitiated++;
                }
                else {
                    return resolve();
                }
            });
        }
        /**
         * Determines whether the connection is open.
         * @returns {boolean} result `true` - is open; `false` otherwise.
         */
        isOpen() {
            let result = false;
            if (this._connection && this._connection.is_open && this._connection.is_open()) {
                result = true;
            }
            return result;
        }
        /**
         * Clears all the amqp sessions from the internal map maintained in rhea. This does not remove any
         * of the event handlers added in the rhea-promise library. To clear such event handlers, either
         * call remove() or close() on each session
         */
        removeAllSessions() {
            if (this._connection) {
                this._connection.remove_all_sessions();
            }
        }
        /**
         * Determines whether the remote end of the connection is open.
         * @returns {boolean} result `true` - is open; `false` otherwise.
         */
        isRemoteOpen() {
            return this._connection.is_remote_open();
        }
        /**
         * Gets the connection error if present.
         * @returns {ConnectionError | undefined} ConnectionError | undefined
         */
        getError() {
            return this._connection.get_error();
        }
        /**
         * Gets the peer certificate if present.
         * @returns {PeerCertificate | undefined} PeerCertificate | undefined
         */
        getPeerCertificate() {
            return this._connection.get_peer_certificate();
        }
        /**
         * Gets the tls socket if present.
         * @returns {Socket | undefined} Socket | undefined
         */
        getTlsSocket() {
            return this._connection.get_tls_socket();
        }
        /**
         * Determines whether the close from the peer is a response to a locally initiated close request
         * for the connection.
         * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
         */
        wasCloseInitiated() {
            return this._connection.is_closed();
        }
        /**
         * Creates an amqp session on the provided amqp connection.
         * @return {Promise<Session>} Promise<Session>
         * - **Resolves** the promise with the Session object when rhea emits the "session_open" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "session_close" event while
         * trying to create an amqp session.
         */
        createSession() {
            return new Promise((resolve, reject) => {
                const rheaSession = this._connection.create_session();
                const session = new session$1.Session(this, rheaSession);
                session.actionInitiated++;
                let onOpen;
                let onClose;
                let waitTimer;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    session.actionInitiated--;
                    rheaSession.removeListener(container.SessionEvents.sessionOpen, onOpen);
                    rheaSession.removeListener(container.SessionEvents.sessionClose, onClose);
                };
                onOpen = (context) => {
                    removeListeners();
                    log$2.session("[%s] Resolving the promise with amqp session.", this.id);
                    return resolve(session);
                };
                onClose = (context) => {
                    removeListeners();
                    log$2.error("[%s] Error occurred while establishing a session over amqp connection: %O.", this.id, context.session.error);
                    return reject(context.session.error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to create the amqp session due to operation timeout.`;
                    log$2.error("[%s] %s", this.id, msg);
                    return reject(new operationTimeoutError.OperationTimeoutError(msg));
                };
                // listeners that we add for completing the operation are added directly to rhea's objects.
                rheaSession.once(container.SessionEvents.sessionOpen, onOpen);
                rheaSession.once(container.SessionEvents.sessionClose, onClose);
                log$2.session("[%s] Calling amqp session.begin().", this.id);
                waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
                rheaSession.begin();
            });
        }
        /**
         * Creates an amqp sender link. It either uses the provided session or creates a new one.
         * @param {SenderOptionsWithSession} options Optional parameters to create a sender link.
         * @return {Promise<Sender>} Promise<Sender>.
         */
        createSender(options) {
            return tslib_es6.__awaiter(this, void 0, void 0, function* () {
                if (options && options.session && options.session.createSender) {
                    return options.session.createSender(options);
                }
                const session = yield this.createSession();
                return session.createSender(options);
            });
        }
        /**
         * Creates an amqp receiver link. It either uses the provided session or creates a new one.
         * @param {ReceiverOptionsWithSession} options Optional parameters to create a receiver link.
         * @return {Promise<Receiver>} Promise<Receiver>.
         */
        createReceiver(options) {
            return tslib_es6.__awaiter(this, void 0, void 0, function* () {
                if (options && options.session && options.session.createReceiver) {
                    return options.session.createReceiver(options);
                }
                const session = yield this.createSession();
                return session.createReceiver(options);
            });
        }
        /**
         * Creates an amqp sender-receiver link. It either uses the provided session or creates a new one.
         * This method creates a sender-receiver link on the same session. It is useful for management
         * style operations where one may want to send a request and await for response.
         * @param {SenderOptions} senderOptions Parameters to create a sender.
         * @param {ReceiverOptions} receiverOptions Parameters to create a receiver.
         * @param {Session} [session] The optional session on which the sender and receiver links will be
         * created.
         * @return {Promise<ReqResLink>} Promise<ReqResLink>
         */
        createRequestResponseLink(senderOptions, receiverOptions, providedSession) {
            return tslib_es6.__awaiter(this, void 0, void 0, function* () {
                if (!senderOptions) {
                    throw new Error(`Please provide sender options.`);
                }
                if (!receiverOptions) {
                    throw new Error(`Please provide receiver options.`);
                }
                const session = providedSession || (yield this.createSession());
                const [sender, receiver] = yield Promise.all([
                    session.createSender(senderOptions),
                    session.createReceiver(receiverOptions)
                ]);
                log$2.connection("[%s] Successfully created the sender and receiver links on the same session.", this.id);
                return {
                    session: session,
                    sender: sender,
                    receiver: receiver
                };
            });
        }
        /**
         * Adds event listeners for the possible events that can occur on the connection object and
         * re-emits the same event back with the received arguments from rhea's event emitter.
         * @private
         * @returns {void} void
         */
        _initializeEventListeners() {
            for (const eventName in container.ConnectionEvents) {
                this._connection.on(container.ConnectionEvents[eventName], (context) => {
                    const params = {
                        rheaContext: context,
                        emitter: this,
                        eventName: container.ConnectionEvents[eventName],
                        emitterType: "connection",
                        connectionId: this.id
                    };
                    utils$1.emitEvent(params);
                });
            }
            // Add event handlers for *_error and *_close events that can be propogated to the connection
            // object, if they are not handled at their level. * denotes - Sender, Receiver, Session
            // Sender
            this._connection.on(container.SenderEvents.senderError, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SenderEvents.senderError,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils$1.emitEvent(params);
            });
            this._connection.on(container.SenderEvents.senderClose, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SenderEvents.senderClose,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils$1.emitEvent(params);
            });
            // Receiver
            this._connection.on(container.ReceiverEvents.receiverError, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.ReceiverEvents.receiverError,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils$1.emitEvent(params);
            });
            this._connection.on(container.ReceiverEvents.receiverClose, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.ReceiverEvents.receiverClose,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils$1.emitEvent(params);
            });
            // Session
            this._connection.on(container.SessionEvents.sessionError, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SessionEvents.sessionError,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils$1.emitEvent(params);
            });
            this._connection.on(container.SessionEvents.sessionClose, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SessionEvents.sessionClose,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils$1.emitEvent(params);
            });
            if (typeof this._connection.eventNames === "function") {
                log$2.eventHandler("[%s] rhea-promise 'connection' object is listening for events: %o " +
                    "emitted by rhea's 'connection' object.", this.id, this._connection.eventNames());
            }
        }
    }
    exports.Connection = Connection;

    });

    unwrapExports(connection$1);
    var connection_1 = connection$1.Connection;

    var eventContext = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });




    var EventContext;
    (function (EventContext) {
        /**
         * Translates rhea's EventContext into rhea-promise EventContext
         * @param rheaContext The received context from rhea's event emitter
         * @param emitter The rhea-promise equivalent object that is supposed emit the same event
         * @param eventName The name of the event for which the context will be translated
         *
         * @returns EventContext The translated EventContext.
         */
        function translate(rheaContext, emitter, eventName) {
            const connectionId = (rheaContext.connection && rheaContext.connection.options) ? rheaContext.connection.options.id : "";
            log$2.contextTranslator("[%s] Translating the context for event: '%s'.", connectionId, eventName);
            // initialize the result
            const result = Object.assign({ _context: rheaContext }, rheaContext);
            const connection = emitter instanceof connection$1.Connection
                ? emitter
                : emitter.connection;
            // set rhea-promise connection and container
            result.connection = connection;
            result.container = connection.container;
            // set rhea-promise session, sender/receiver.
            if (emitter instanceof link$3.Link) {
                result.session = emitter.session;
                if (emitter.type === link$3.LinkType.receiver && rheaContext.receiver) {
                    result.receiver = emitter;
                }
                else if (emitter.type === link$3.LinkType.sender && rheaContext.sender) {
                    result.sender = emitter;
                }
            }
            else if (emitter instanceof session$1.Session) {
                result.session = emitter;
            }
            return result;
        }
        EventContext.translate = translate;
    })(EventContext = exports.EventContext || (exports.EventContext = {}));

    });

    unwrapExports(eventContext);
    var eventContext_1 = eventContext.EventContext;

    var lib = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    exports.types = container.types;
    exports.message = container.message;
    exports.filter = container.filter;
    exports.uuid_to_string = container.uuid_to_string;
    exports.generate_uuid = container.generate_uuid;
    exports.string_to_uuid = container.string_to_uuid;
    exports.ReceiverEvents = container.ReceiverEvents;
    exports.SenderEvents = container.SenderEvents;
    exports.ConnectionEvents = container.ConnectionEvents;
    exports.SessionEvents = container.SessionEvents;
    exports.Typed = container.Typed;

    exports.EventContext = eventContext.EventContext;

    exports.Container = container$1.Container;

    exports.Connection = connection$1.Connection;

    exports.Session = session$1.Session;

    exports.Receiver = receiver$1.Receiver;

    exports.Sender = sender$1.Sender;

    exports.AmqpResponseStatusCode = utils$1.AmqpResponseStatusCode;
    exports.isAmqpError = utils$1.isAmqpError;
    exports.delay = utils$1.delay;
    exports.messageHeader = utils$1.messageHeader;
    exports.messageProperties = utils$1.messageProperties;
    exports.parseConnectionString = utils$1.parseConnectionString;

    });

    unwrapExports(lib);
    var lib_1 = lib.types;
    var lib_2 = lib.message;
    var lib_3 = lib.filter;
    var lib_4 = lib.uuid_to_string;
    var lib_5 = lib.generate_uuid;
    var lib_6 = lib.string_to_uuid;
    var lib_7 = lib.ReceiverEvents;
    var lib_8 = lib.SenderEvents;
    var lib_9 = lib.ConnectionEvents;
    var lib_10 = lib.SessionEvents;
    var lib_11 = lib.Typed;
    var lib_12 = lib.EventContext;
    var lib_13 = lib.Container;
    var lib_14 = lib.Connection;
    var lib_15 = lib.Session;
    var lib_16 = lib.Receiver;
    var lib_17 = lib.Sender;
    var lib_18 = lib.AmqpResponseStatusCode;
    var lib_19 = lib.isAmqpError;
    var lib_20 = lib.delay;
    var lib_21 = lib.messageHeader;
    var lib_22 = lib.messageProperties;
    var lib_23 = lib.parseConnectionString;

    var AsyncLock = function (opts) {
    	opts = opts || {};

    	this.Promise = opts.Promise || Promise;

    	// format: {key : [fn, fn]}
    	// queues[key] = null indicates no job running for key
    	this.queues = {};

    	// domain of current running func {key : fn}
    	this.domains = {};

    	// lock is reentrant for same domain
    	this.domainReentrant = opts.domainReentrant || false;

    	this.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT;
    	this.maxPending = opts.maxPending || AsyncLock.DEFAULT_MAX_PENDING;
    };

    AsyncLock.DEFAULT_TIMEOUT = 0; //Never
    AsyncLock.DEFAULT_MAX_PENDING = 1000;

    /**
     * Acquire Locks
     *
     * @param {String|Array} key 	resource key or keys to lock
     * @param {function} fn 	async function
     * @param {function} cb 	callback function, otherwise will return a promise
     * @param {Object} opts 	options
     */
    AsyncLock.prototype.acquire = function (key, fn, cb, opts) {
    	if (Array.isArray(key)) {
    		return this._acquireBatch(key, fn, cb, opts);
    	}

    	if (typeof (fn) !== 'function') {
    		throw new Error('You must pass a function to execute');
    	}

    	// faux-deferred promise using new Promise() (as Promise.defer is deprecated)
    	var deferredResolve = null;
    	var deferredReject = null;
    	var deferred = null;

    	if (typeof (cb) !== 'function') {
    		opts = cb;
    		cb = null;

    		// will return a promise
    		deferred =  new this.Promise(function(resolve, reject) {
    			deferredResolve = resolve;
    			deferredReject = reject;
    		});
    	}

    	opts = opts || {};

    	var resolved = false;
    	var timer = null;
    	var self = this;

    	var done = function (locked, err, ret) {
    		if (locked) {
    			if (self.queues[key].length === 0) {
    				delete self.queues[key];
    			}
    			delete self.domains[key];
    		}

    		if (!resolved) {
    			if (!deferred) {
    				if (typeof (cb) === 'function') {
    					cb(err, ret);
    				}
    			}
    			else {
    				//promise mode
    				if (err) {
    					deferredReject(err);
    				}
    				else {
    					deferredResolve(ret);
    				}
    			}
    			resolved = true;
    		}

    		if (locked) {
    			//run next func
    			if (!!self.queues[key] && self.queues[key].length > 0) {
    				self.queues[key].shift()();
    			}
    		}
    	};

    	var exec = function (locked) {
    		if (resolved) { // may due to timed out
    			return done(locked);
    		}

    		if (timer) {
    			clearTimeout(timer);
    			timer = null;
    		}

    		if (locked) {
    			self.domains[key] = browser.domain;
    		}

    		// Callback mode
    		if (fn.length === 1) {
    			var called = false;
    			fn(function (err, ret) {
    				if (!called) {
    					called = true;
    					done(locked, err, ret);
    				}
    			});
    		}
    		else {
    			// Promise mode
    			self._promiseTry(function () {
    				return fn();
    			})
    			.then(function(ret){
    				done(locked, undefined, ret);
    			}, function(error){
    				done(locked, error);
    			});
    		}
    	};
    	if (!!browser.domain) {
    		exec = browser.domain.bind(exec);
    	}

    	if (!self.queues[key]) {
    		self.queues[key] = [];
    		exec(true);
    	}
    	else if (self.domainReentrant && !!browser.domain && browser.domain === self.domains[key]) {
    		// If code is in the same domain of current running task, run it directly
    		// Since lock is re-enterable
    		exec(false);
    	}
    	else if (self.queues[key].length >= self.maxPending) {
    		done(false, new Error('Too much pending tasks'));
    	}
    	else {
    		var taskFn = function () {
    			exec(true);
    		};
    		if (opts.skipQueue) {
    			self.queues[key].unshift(taskFn);
    		} else {
    			self.queues[key].push(taskFn);
    		}

    		var timeout = opts.timeout || self.timeout;
    		if (timeout) {
    			timer = setTimeout(function () {
    				timer = null;
    				done(false, new Error('async-lock timed out'));
    			}, timeout);
    		}
    	}

    	if (deferred) {
    		return deferred;
    	}
    };

    /*
     * Below is how this function works:
     *
     * Equivalent code:
     * self.acquire(key1, function(cb){
     *     self.acquire(key2, function(cb){
     *         self.acquire(key3, fn, cb);
     *     }, cb);
     * }, cb);
     *
     * Equivalent code:
     * var fn3 = getFn(key3, fn);
     * var fn2 = getFn(key2, fn3);
     * var fn1 = getFn(key1, fn2);
     * fn1(cb);
     */
    AsyncLock.prototype._acquireBatch = function (keys, fn, cb, opts) {
    	if (typeof (cb) !== 'function') {
    		opts = cb;
    		cb = null;
    	}

    	var self = this;
    	var getFn = function (key, fn) {
    		return function (cb) {
    			self.acquire(key, fn, cb, opts);
    		};
    	};

    	var fnx = fn;
    	keys.reverse().forEach(function (key) {
    		fnx = getFn(key, fnx);
    	});

    	if (typeof (cb) === 'function') {
    		fnx(cb);
    	}
    	else {
    		return new this.Promise(function (resolve, reject) {
    			// check for promise mode in case keys is empty array
    			if (fnx.length === 1) {
    				fnx(function (err, ret) {
    					if (err) {
    						reject(err);
    					}
    					else {
    						resolve(ret);
    					}
    				});
    			} else {
    				resolve(fnx());
    			}
    		});
    	}
    };

    /*
     *	Whether there is any running or pending asyncFunc
     *
     *	@param {String} key
     */
    AsyncLock.prototype.isBusy = function (key) {
    	if (!key) {
    		return Object.keys(this.queues).length > 0;
    	}
    	else {
    		return !!this.queues[key];
    	}
    };

    /**
     * Promise.try() implementation to become independent of Q-specific methods
     */
    AsyncLock.prototype._promiseTry = function(fn) {
    	try {
    		return this.Promise.resolve(fn());
    	} catch (e) {
    		return this.Promise.reject(e);
    	}
    };

    var lib$1 = AsyncLock;

    var asyncLock = lib$1;

    /**
     * A constant that indicates whether the environment is node.js or browser based.
     */
    const isNode = !!browser &&
        !!browser.version &&
        !!browser.versions &&
        !!browser.versions.node;
    /**
     * Parses the connection string and returns an object of type T.
     *
     * Connection strings have the following syntax:
     *
     * ConnectionString ::= Part { ";" Part } [ ";" ] [ WhiteSpace ]
     * Part             ::= [ PartLiteral [ "=" PartLiteral ] ]
     * PartLiteral      ::= [ WhiteSpace ] Literal [ WhiteSpace ]
     * Literal          ::= ? any sequence of characters except ; or = or WhiteSpace ?
     * WhiteSpace       ::= ? all whitespace characters including \r and \n ?
     *
     * @param {string} connectionString The connection string to be parsed.
     * @returns {ParsedOutput<T>} ParsedOutput<T>.
     */
    function parseConnectionString(connectionString) {
        const output = {};
        const parts = connectionString.trim().split(";");
        for (let part of parts) {
            part = part.trim();
            if (part === "") {
                // parts can be empty
                continue;
            }
            const splitIndex = part.indexOf("=");
            if (splitIndex === -1) {
                throw new Error("Connection string malformed: each part of the connection string must have an `=` assignment.");
            }
            const key = part.substring(0, splitIndex).trim();
            if (key === "") {
                throw new Error("Connection string malformed: missing key for assignment");
            }
            const value = part.substring(splitIndex + 1).trim();
            output[key] = value;
        }
        return output;
    }
    /**
     * @constant {AsyncLock} defaultLock The async lock instance with default settings.
     */
    const defaultLock = new asyncLock({ maxPending: 10000 });
    /**
     * A wrapper for setTimeout that resolves a promise after t milliseconds.
     * @param {number} t - The number of milliseconds to be delayed.
     * @param {T} value - The value to be resolved with after a timeout of t milliseconds.
     * @returns {Promise<T>} - Resolved promise
     */
    function delay(t, value) {
        return new Promise(resolve => setTimeout(() => resolve(value), t));
    }
    /**
     * Generates a random number between the given interval
     * @param {number} min Min number of the range (inclusive).
     * @param {number} max Max number of the range (inclusive).
     */
    function randomNumberFromInterval(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Maps the conditions to the numeric AMQP Response status codes.
     * @enum {ConditionStatusMapper}
     */
    var ConditionStatusMapper;
    (function (ConditionStatusMapper) {
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:timeout"] = 408] = "com.microsoft:timeout";
        ConditionStatusMapper[ConditionStatusMapper["amqp:not-found"] = 404] = "amqp:not-found";
        ConditionStatusMapper[ConditionStatusMapper["amqp:not-implemented"] = 501] = "amqp:not-implemented";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-already-exists"] = 409] = "com.microsoft:entity-already-exists";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:message-lock-lost"] = 410] = "com.microsoft:message-lock-lost";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-lock-lost"] = 410] = "com.microsoft:session-lock-lost";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:no-matching-subscription"] = 500] = "com.microsoft:no-matching-subscription";
        ConditionStatusMapper[ConditionStatusMapper["amqp:link:message-size-exceeded"] = 403] = "amqp:link:message-size-exceeded";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:server-busy"] = 503] = "com.microsoft:server-busy";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-error"] = 400] = "com.microsoft:argument-error";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-out-of-range"] = 400] = "com.microsoft:argument-out-of-range";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:store-lock-lost"] = 410] = "com.microsoft:store-lock-lost";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-cannot-be-locked"] = 410] = "com.microsoft:session-cannot-be-locked";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:partition-not-owned"] = 410] = "com.microsoft:partition-not-owned";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-disabled"] = 400] = "com.microsoft:entity-disabled";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:publisher-revoked"] = 401] = "com.microsoft:publisher-revoked";
        ConditionStatusMapper[ConditionStatusMapper["amqp:link:stolen"] = 410] = "amqp:link:stolen";
        ConditionStatusMapper[ConditionStatusMapper["amqp:not-allowed"] = 400] = "amqp:not-allowed";
        ConditionStatusMapper[ConditionStatusMapper["amqp:unauthorized-access"] = 401] = "amqp:unauthorized-access";
        ConditionStatusMapper[ConditionStatusMapper["amqp:resource-limit-exceeded"] = 403] = "amqp:resource-limit-exceeded";
    })(ConditionStatusMapper || (ConditionStatusMapper = {}));
    /**
     * Maps the amqp error conditions to the Error names.
     * @enum {ConditionErrorNameMapper}
     */
    var ConditionErrorNameMapper;
    (function (ConditionErrorNameMapper) {
        /**
         * Error is thrown when the address is already in use.
         */
        ConditionErrorNameMapper["com.microsoft:address-already-in-use"] = "AddressAlreadyInUseError";
        /**
         * Error is thrown when the store lock is lost.
         */
        ConditionErrorNameMapper["com.microsoft:store-lock-lost"] = "StoreLockLostError";
        /**
         * Error is thrown when a matching subscription is not found.
         */
        ConditionErrorNameMapper["com.microsoft:no-matching-subscription"] = "NoMatchingSubscriptionError";
        /**
         * Error is thrown when an attempt is made to access a parition that is not owned by the
         * requesting entity.
         */
        ConditionErrorNameMapper["com.microsoft:partition-not-owned"] = "PartitionNotOwnedError";
        /**
         * Error is thrown when access to publisher has been revoked.
         */
        ConditionErrorNameMapper["com.microsoft:publisher-revoked"] = "PublisherRevokedError";
        /**
         * Error is thrown when an attempt is made to create an entity that already exists.
         */
        ConditionErrorNameMapper["com.microsoft:entity-already-exists"] = "MessagingEntityAlreadyExistsError";
        /**
         * Error is thrown when trying to access/connect to a disabled messaging entity.
         */
        ConditionErrorNameMapper["com.microsoft:entity-disabled"] = "MessagingEntityDisabledError";
        /**
         * Error is thrown when the lock on the message is lost.
         */
        ConditionErrorNameMapper["com.microsoft:message-lock-lost"] = "MessageLockLostError";
        /**
         * Error is thrown when the lock on the Azure ServiceBus session is lost.
         */
        ConditionErrorNameMapper["com.microsoft:session-lock-lost"] = "SessionLockLostError";
        /**
         * Error is thrown when the Azure ServiceBus session cannot be locked.
         */
        ConditionErrorNameMapper["com.microsoft:session-cannot-be-locked"] = "SessionCannotBeLockedError";
        /**
         * Error is thrown when an internal server error occured. You may have found a bug?
         */
        ConditionErrorNameMapper["amqp:internal-error"] = "InternalServerError";
        /**
         * Error for signaling general communication errors related to messaging operations.
         */
        ConditionErrorNameMapper["amqp:not-found"] = "ServiceCommunicationError";
        /**
         * Error is thrown when the message is not found.
         */
        ConditionErrorNameMapper["com.microsoft:message-not-found"] = "MessageNotFoundError";
        /**
         * Error is thrown when relay is not found.
         */
        ConditionErrorNameMapper["com.microsoft:relay-not-found"] = "RelayNotFoundError";
        /**
         * Error is thrown when a feature is not implemented yet but the placeholder is present.
         */
        ConditionErrorNameMapper["amqp:not-implemented"] = "NotImplementedError";
        /**
         * Error is thrown when an operation is attempted but is not allowed.
         */
        ConditionErrorNameMapper["amqp:not-allowed"] = "InvalidOperationError";
        /**
         * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
         * Quotas are reset periodically, this operation will have to wait until then.
         * The messaging entity has reached its maximum allowable size.
         * This can happen if the maximum number of receivers (which is 5) has already
         * been opened on a per-consumer group level.
         */
        ConditionErrorNameMapper["amqp:resource-limit-exceeded"] = "QuotaExceededError";
        /**
         * Error is thrown when the connection parameters are wrong and the server refused the connection.
         */
        ConditionErrorNameMapper["amqp:unauthorized-access"] = "UnauthorizedError";
        /**
         * Error is thrown when the connection parameters are wrong and the server refused the connection.
         */
        ConditionErrorNameMapper["com.microsoft:auth-failed"] = "UnauthorizedError";
        /**
         * Error is thrown when the service is unavailable. The operation should be retried.
         */
        ConditionErrorNameMapper["com.microsoft:timeout"] = "ServiceUnavailableError";
        /**
         * Error is thrown when no new messages are received for the specified time.
         */
        ConditionErrorNameMapper["com.microsoft:message-wait-timeout"] = "MessageWaitTimeout";
        /**
         * Error is thrown when timeout happens for the said operation.
         */
        ConditionErrorNameMapper["amqp:operation-timeout"] = "OperationTimeoutError";
        /**
         * Error is thrown when an argument has a value that is out of the admissible range.
         */
        ConditionErrorNameMapper["com.microsoft:argument-out-of-range"] = "ArgumentOutOfRangeError";
        /**
         * Error is thrown when a condition that should have been met in order to execute an operation was not.
         */
        ConditionErrorNameMapper["amqp:precondition-failed"] = "PreconditionFailedError";
        /**
         * Error is thrown when a condition that should have been met in order to execute an operation was not.
         */
        ConditionErrorNameMapper["com.microsoft:precondition-failed"] = "PreconditionFailedError";
        /**
         * Error is thrown when data could not be decoded.
         */
        ConditionErrorNameMapper["amqp:decode-error"] = "DecodeError";
        /**
         * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
         */
        ConditionErrorNameMapper["amqp:invalid-field"] = "InvalidFieldError";
        /**
         * Error is thrown when the client attempted to work with a server entity to which it
         * has no access because another client is working with it.
         */
        ConditionErrorNameMapper["amqp:resource-locked"] = "ResourceLockedError";
        /**
         * Error is thrown when a server entity the client is working with has been deleted.
         */
        ConditionErrorNameMapper["amqp:resource-deleted"] = "ResourceDeletedError";
        /**
         * Error is thrown when the peer sent a frame that is not permitted in the current state.
         */
        ConditionErrorNameMapper["amqp:illegal-state"] = "IllegalStateError";
        /**
         * Error is thrown when the peer cannot send a frame because the smallest encoding of
         * the performative with the currently valid values would be too large to fit within
         * a frame of the agreed maximum frame size.
         */
        ConditionErrorNameMapper["amqp:frame-size-too-small"] = "FrameSizeTooSmallError";
        /**
         * Error is thrown when an operator intervened to detach for some reason.
         */
        ConditionErrorNameMapper["amqp:link:detach-forced"] = "DetachForcedError";
        /**
         * Error is thrown when the peer sent more message transfers than currently allowed on the link.
         */
        ConditionErrorNameMapper["amqp:link:transfer-limit-exceeded"] = "TransferLimitExceededError";
        /**
         * Error is thrown when the message sent is too large: the maximum size is 256Kb.
         */
        ConditionErrorNameMapper["amqp:link:message-size-exceeded"] = "MessageTooLargeError";
        /**
         * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
         */
        ConditionErrorNameMapper["amqp:link:redirect"] = "LinkRedirectError";
        /**
         * Error is thrown when two or more instances connect to the same partition
         * with different epoch values.
         */
        ConditionErrorNameMapper["amqp:link:stolen"] = "ReceiverDisconnectedError";
        /**
         * Error is thrown when the peer violated incoming window for the session.
         */
        ConditionErrorNameMapper["amqp:session:window-violation"] = "SessionWindowViolationError";
        /**
         * Error is thrown when input was received for a link that was detached with an error.
         */
        ConditionErrorNameMapper["amqp:session:errant-link"] = "ErrantLinkError";
        /**
         * Error is thrown when an attach was received using a handle that is already in use for an attached link.
         */
        ConditionErrorNameMapper["amqp:session:handle-in-use"] = "HandleInUseError";
        /**
         * Error is thrown when a frame (other than attach) was received referencing a handle which is not
         * currently in use of an attached link.
         */
        ConditionErrorNameMapper["amqp:session:unattached-handle"] = "UnattachedHandleError";
        /**
         * Error is thrown when an operator intervened to close the connection for some reason.
         */
        ConditionErrorNameMapper["amqp:connection:forced"] = "ConnectionForcedError";
        /**
         * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
         */
        ConditionErrorNameMapper["amqp:connection:framing-error"] = "FramingError";
        /**
         * Error is thrown when the container is no longer available on the current connection.
         */
        ConditionErrorNameMapper["amqp:connection:redirect"] = "ConnectionRedirectError";
        /**
         * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
         */
        ConditionErrorNameMapper["com.microsoft:server-busy"] = "ServerBusyError";
        /**
         * Error is thrown when an incorrect argument was received.
         */
        ConditionErrorNameMapper["com.microsoft:argument-error"] = "ArgumentError";
        /**
         * Error is thrown when server cancels the operation due to an internal issue.
         */
        ConditionErrorNameMapper["com.microsoft:operation-cancelled"] = "OperationCancelledError";
        /**
         * Error is thrown when the client sender does not have enough link credits to send the message.
         */
        ConditionErrorNameMapper["client.sender:not-enough-link-credit"] = "SenderBusyError";
        /**
         * Error is thrown when a low level system error is thrown by node.js.
         * {@link https://nodejs.org/dist/latest-v8.x/docs/api/all.html#errors_class_system_error}
         */
        ConditionErrorNameMapper["system:error"] = "SystemError";
    })(ConditionErrorNameMapper || (ConditionErrorNameMapper = {}));
    /**
     * Maps the Error names to the amqp error conditions.
     * @enum {ErrorNameConditionMapper}
     */
    var ErrorNameConditionMapper;
    (function (ErrorNameConditionMapper) {
        /**
         * Error is thrown when the address is already in use.
         */
        ErrorNameConditionMapper["AddressAlreadyInUseError"] = "com.microsoft:address-already-in-use";
        /**
         * Error is thrown when the store lock is lost.
         */
        ErrorNameConditionMapper["StoreLockLostError"] = "com.microsoft:store-lock-lost";
        /**
         * Error is thrown when a matching subscription is not found.
         */
        ErrorNameConditionMapper["NoMatchingSubscriptionError"] = "com.microsoft:no-matching-subscription";
        /**
         * Error is thrown when an attempt is made to access a parition that is not owned by the
         * requesting entity.
         */
        ErrorNameConditionMapper["PartitionNotOwnedError"] = "com.microsoft:partition-not-owned";
        /**
         * Error is thrown when access to publisher has been revoked.
         */
        ErrorNameConditionMapper["PublisherRevokedError"] = "com.microsoft:publisher-revoked";
        /**
         * Error is thrown when an attempt is made to create an entity that already exists.
         */
        ErrorNameConditionMapper["MessagingEntityAlreadyExistsError"] = "com.microsoft:entity-already-exists";
        /**
         * Error is thrown when trying to access/connect to a disabled messaging entity.
         */
        ErrorNameConditionMapper["MessagingEntityDisabledError"] = "com.microsoft:entity-disabled";
        /**
         * Error is thrown when the lock on the message is lost.
         */
        ErrorNameConditionMapper["MessageLockLostError"] = "com.microsoft:message-lock-lost";
        /**
         * Error is thrown when the lock on the Azure ServiceBus session is lost.
         */
        ErrorNameConditionMapper["SessionLockLostError"] = "com.microsoft:session-lock-lost";
        /**
         * Error is thrown when the Azure ServiceBus session cannot be locked.
         */
        ErrorNameConditionMapper["SessionCannotBeLockedError"] = "com.microsoft:session-cannot-be-locked";
        /**
         * Error is thrown when an internal server error occured. You may have found a bug?
         */
        ErrorNameConditionMapper["InternalServerError"] = "amqp:internal-error";
        /**
         * Error for signaling general communication errors related to messaging operations.
         */
        ErrorNameConditionMapper["ServiceCommunicationError"] = "amqp:not-found";
        /**
         * Error is thrown when message is not found.
         */
        ErrorNameConditionMapper["MessageNotFoundError"] = "com.microsoft:message-not-found";
        /**
         * Error is thrown when relay is not found.
         */
        ErrorNameConditionMapper["RelayNotFoundError"] = "com.microsoft:relay-not-found";
        /**
         * Error is thrown when a feature is not implemented yet but the placeholder is present.
         */
        ErrorNameConditionMapper["NotImplementedError"] = "amqp:not-implemented";
        /**
         * Error is thrown when an operation is attempted but is not allowed.
         */
        ErrorNameConditionMapper["InvalidOperationError"] = "amqp:not-allowed";
        /**
         * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
         * Quotas are reset periodically, this operation will have to wait until then.
         * The messaging entity has reached its maximum allowable size.
         * This can happen if the maximum number of receivers (which is 5) has already
         * been opened on a per-consumer group level.
         */
        ErrorNameConditionMapper["QuotaExceededError"] = "amqp:resource-limit-exceeded";
        /**
         * Error is thrown when the connection parameters are wrong and the server refused the connection.
         */
        ErrorNameConditionMapper["UnauthorizedError"] = "amqp:unauthorized-access";
        /**
         * Error is thrown when the service is unavailable. The operation should be retried.
         */
        ErrorNameConditionMapper["ServiceUnavailableError"] = "com.microsoft:timeout";
        /**
         * Error is thrown when no new messages are received for the specified time.
         */
        ErrorNameConditionMapper["MessageWaitTimeout"] = "com.microsoft:message-wait-timeout";
        /**
         * Error is thrown when timeout happens for the said operation.
         */
        ErrorNameConditionMapper["OperationTimeoutError"] = "amqp:operation-timeout";
        /**
         * Error is thrown when an argument has a value that is out of the admissible range.
         */
        ErrorNameConditionMapper["ArgumentOutOfRangeError"] = "com.microsoft:argument-out-of-range";
        /**
         * Error is thrown when a condition that should have been met in order to execute an operation was not.
         */
        ErrorNameConditionMapper["PreconditionFailedError"] = "amqp:precondition-failed";
        /**
         * Error is thrown when data could not be decoded.
         */
        ErrorNameConditionMapper["DecodeError"] = "amqp:decode-error";
        /**
         * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
         */
        ErrorNameConditionMapper["InvalidFieldError"] = "amqp:invalid-field";
        /**
         * Error is thrown when the client attempted to work with a server entity to which it
         * has no access because another client is working with it.
         */
        ErrorNameConditionMapper["ResourceLockedError"] = "amqp:resource-locked";
        /**
         * Error is thrown when a server entity the client is working with has been deleted.
         */
        ErrorNameConditionMapper["ResourceDeletedError"] = "amqp:resource-deleted";
        /**
         * Error is thrown when the peer sent a frame that is not permitted in the current state.
         */
        ErrorNameConditionMapper["IllegalStateError"] = "amqp:illegal-state";
        /**
         * Error is thrown when the peer cannot send a frame because the smallest encoding of
         * the performative with the currently valid values would be too large to fit within
         * a frame of the agreed maximum frame size.
         */
        ErrorNameConditionMapper["FrameSizeTooSmallError"] = "amqp:frame-size-too-small";
        /**
         * Error is thrown when an operator intervened to detach for some reason.
         */
        ErrorNameConditionMapper["DetachForcedError"] = "amqp:link:detach-forced";
        /**
         * Error is thrown when the peer sent more message transfers than currently allowed on the link.
         */
        ErrorNameConditionMapper["TransferLimitExceededError"] = "amqp:link:transfer-limit-exceeded";
        /**
         * Error is thrown when the message sent is too large: the maximum size is 256Kb.
         */
        ErrorNameConditionMapper["MessageTooLargeError"] = "amqp:link:message-size-exceeded";
        /**
         * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
         */
        ErrorNameConditionMapper["LinkRedirectError"] = "amqp:link:redirect";
        /**
         * Error is thrown when two or more instances connect to the same partition
         * with different epoch values.
         */
        ErrorNameConditionMapper["ReceiverDisconnectedError"] = "amqp:link:stolen";
        /**
         * Error is thrown when the peer violated incoming window for the session.
         */
        ErrorNameConditionMapper["SessionWindowViolationError"] = "amqp:session:window-violation";
        /**
         * Error is thrown when input was received for a link that was detached with an error.
         */
        ErrorNameConditionMapper["ErrantLinkError"] = "amqp:session:errant-link";
        /**
         * Error is thrown when an attach was received using a handle that is already in use for an attached link.
         */
        ErrorNameConditionMapper["HandleInUseError"] = "amqp:session:handle-in-use";
        /**
         * Error is thrown when a frame (other than attach) was received referencing a handle which is not
         * currently in use of an attached link.
         */
        ErrorNameConditionMapper["UnattachedHandleError"] = "amqp:session:unattached-handle";
        /**
         * Error is thrown when an operator intervened to close the connection for some reason.
         */
        ErrorNameConditionMapper["ConnectionForcedError"] = "amqp:connection:forced";
        /**
         * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
         */
        ErrorNameConditionMapper["FramingError"] = "amqp:connection:framing-error";
        /**
         * Error is thrown when the container is no longer available on the current connection.
         */
        ErrorNameConditionMapper["ConnectionRedirectError"] = "amqp:connection:redirect";
        /**
         * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
         */
        ErrorNameConditionMapper["ServerBusyError"] = "com.microsoft:server-busy";
        /**
         * Error is thrown when an incorrect argument was received.
         */
        ErrorNameConditionMapper["ArgumentError"] = "com.microsoft:argument-error";
        /**
         * Error is thrown when server cancels the operation due to an internal issue.
         */
        ErrorNameConditionMapper["OperationCancelledError"] = "com.microsoft:operation-cancelled";
        /**
         * Error is thrown when the client sender does not have enough link credits to send the message.
         */
        ErrorNameConditionMapper["SenderBusyError"] = "client.sender:not-enough-link-credit";
        /**
         * Error is thrown when a low level system error is thrown by node.js.
         * {@link https://nodejs.org/api/errors.html#errors_class_systemerror}
         */
        ErrorNameConditionMapper["SystemError"] = "system:error";
    })(ErrorNameConditionMapper || (ErrorNameConditionMapper = {}));
    /**
     * Describes the base class for Messaging Error.
     * @class {MessagingError}
     * @extends Error
     */
    class MessagingError extends Error {
        /**
         * @param {string} message The error message that provides more information about the error.
         */
        constructor(message) {
            super(message);
            /**
             * @property {string} name The error name. Default value: "MessagingError".
             */
            this.name = "MessagingError";
            /**
             * @property {boolean} translated Has the error been translated. Default: true.
             */
            this.translated = true;
            /**
             *
             * @property {boolean} retryable Describes whether the error is retryable. Default: true.
             */
            this.retryable = true;
        }
    }
    /**
     * Provides a list of retryable AMQP errors.
     * "InternalServerError", "ServerBusyError", "ServiceUnavailableError", "OperationCancelledError",
     * "SenderBusyError", "MessagingError", "DetachForcedError", "ConnectionForcedError",
     * "TransferLimitExceededError"
     */
    const retryableErrors = [
        "InternalServerError",
        "ServerBusyError",
        "ServiceUnavailableError",
        "OperationCancelledError",
        "SenderBusyError",
        "MessagingError",
        "DetachForcedError",
        "ConnectionForcedError",
        "TransferLimitExceededError"
    ];
    /**
     * Maps some SytemErrors to amqp error conditions
     * @enum SystemErrorConditionMapper
     */
    var SystemErrorConditionMapper;
    (function (SystemErrorConditionMapper) {
        SystemErrorConditionMapper["ENOTFOUND"] = "amqp:not-found";
        SystemErrorConditionMapper["EBUSY"] = "com.microsoft:server-busy";
        SystemErrorConditionMapper["ECONNREFUSED"] = "amqp:connection:forced";
        SystemErrorConditionMapper["ETIMEDOUT"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["ECONNRESET"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["ENETDOWN"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["EHOSTDOWN"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["ENETRESET"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["ENETUNREACH"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["ENONET"] = "com.microsoft:timeout";
    })(SystemErrorConditionMapper || (SystemErrorConditionMapper = {}));
    function isSystemError(err) {
        let result = false;
        if (err.code &&
            typeof err.code === "string" &&
            (err.syscall && typeof err.syscall === "string") &&
            (err.errno && (typeof err.errno === "string" || typeof err.errno === "number"))) {
            result = true;
        }
        return result;
    }
    /**
     * @internal
     * Since browser doesnt differentiate between the various kinds of service communication errors,
     * this utility is used to look at the error target to identify such category of errors.
     * For more information refer to - https://html.spec.whatwg.org/multipage/comms.html#feedback-from-the-protocol
     * @param err object that may contain error information
     */
    function isBrowserWebsocketError(err) {
        let result = false;
        if (!isNode &&
            window &&
            err.type === "error" &&
            err.target instanceof window.WebSocket) {
            result = true;
        }
        return result;
    }
    /**
     * Translates the AQMP error received at the protocol layer or a generic Error into a MessagingError.
     *
     * @param {AmqpError} err The amqp error that was received.
     * @returns {MessagingError} MessagingError object.
     */
    function translate(err) {
        if (err.translated) {
            // already translated
            return err;
        }
        let error = err;
        // Built-in errors like TypeError and RangeError should not be retryable as these indicate issues
        // with user input and not an issue with the Messaging process.
        if (err instanceof TypeError || err instanceof RangeError) {
            error.retryable = false;
            return error;
        }
        if (lib_19(err)) {
            // translate
            const condition = err.condition;
            const description = err.description;
            error = new MessagingError(description);
            if (err.stack)
                error.stack = err.stack;
            error.info = err.info;
            error.condition = condition;
            if (condition) {
                error.name = ConditionErrorNameMapper[condition];
            }
            if (!error.name)
                error.name = "MessagingError";
            if (description &&
                (description.includes("status-code: 404") ||
                    description.match(/The messaging entity .* could not be found.*/i) !== null)) {
                error.name = "MessagingEntityNotFoundError";
            }
            if (retryableErrors.indexOf(error.name) === -1) {
                // not found
                error.retryable = false;
            }
        }
        else if (isSystemError(err)) {
            // translate
            const condition = err.code;
            const description = err.message;
            error = new MessagingError(description);
            if (err.stack)
                error.stack = err.stack;
            if (condition) {
                const amqpErrorCondition = SystemErrorConditionMapper[condition];
                error.name = ConditionErrorNameMapper[amqpErrorCondition];
            }
            if (!error.name)
                error.name = "SystemError";
            if (retryableErrors.indexOf(error.name) === -1) {
                // not found
                error.retryable = false;
            }
        }
        else if (isBrowserWebsocketError(err)) {
            // Translate browser communication errors during opening handshake to generic SeviceCommunicationError
            error = new MessagingError("Websocket connection failed.");
            error.name = ConditionErrorNameMapper[ErrorNameConditionMapper.ServiceCommunicationError];
            error.retryable = false;
        }
        else {
            // Translate a generic error into MessagingError.
            error = new MessagingError(err.message);
            error.stack = err.stack;
        }
        return error;
    }
    //# sourceMappingURL=errors.js.map

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @ignore
     * log statements for cbs
     */
    const cbs = browser$2("azure:amqp-common:cbs");
    /**
     * @ignore
     * log statements for error
     */
    const error$1 = browser$2("azure:amqp-common:error");
    /**
     * @ignore
     * log statements for datatransformer
     */
    const transformer = browser$2("azure:amqp-common:datatransformer");
    /**
     * @ignore
     * log statements for messageHeader
     */
    const msgHeader = browser$2("azure:amqp-common:messageHeader");
    /**
     * @ignore
     * log statements for messageProperties
     */
    const msgProperties = browser$2("azure:amqp-common:messageProperties");
    /**
     * @ignore
     * log statements for retry
     */
    const retry = browser$2("azure:amqp-common:retry");
    /**
     * @ignore
     * log statements for reqreslink
     */
    const reqres = browser$2("azure:amqp-common:reqreslink");

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    /**
     * Checks whether a network connection is detected.
     * @ignore
     * @internal
     */
    function checkNetworkConnection() {
        return Promise.resolve(window.navigator.onLine);
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Determines whether the object is a Delivery object.
     * @ignore
     */
    function isDelivery(obj) {
        let result = false;
        if (obj &&
            typeof obj.id === "number" &&
            typeof obj.settled === "boolean" &&
            typeof obj.remote_settled === "boolean" &&
            typeof obj.format === "number") {
            result = true;
        }
        return result;
    }
    /**
     * Describes the retry operation type.
     * @enum RetryOperationType
     */
    var RetryOperationType;
    (function (RetryOperationType) {
        RetryOperationType["cbsAuth"] = "cbsAuth";
        RetryOperationType["connection"] = "connection";
        RetryOperationType["management"] = "management";
        RetryOperationType["receiverLink"] = "receiverLink";
        RetryOperationType["senderLink"] = "senderLink";
        RetryOperationType["sendMessage"] = "sendMessage";
        RetryOperationType["session"] = "session";
    })(RetryOperationType || (RetryOperationType = {}));
    /**
     * Validates the retry config.
     * @ignore
     */
    function validateRetryConfig(config) {
        if (!config.operation) {
            throw new TypeError("Missing 'operation' in retry configuration");
        }
        if (!config.connectionId) {
            throw new TypeError("Missing 'connectionId' in retry configuration");
        }
        if (!config.operationType) {
            throw new TypeError("Missing 'operationType' in retry configuration");
        }
    }
    /**
     * It will attempt to linearly retry an operation specified number of times with a specified
     * delay in between each retry. The retries will only happen if the error is retryable.
     *
     * @param {RetryConfig<T>} config Parameters to configure retry operation.
     *
     * @return {Promise<T>} Promise<T>.
     */
    function retry$1(config) {
        return __awaiter(this, void 0, void 0, function* () {
            validateRetryConfig(config);
            if (config.times == undefined)
                config.times = defaultRetryAttempts;
            if (config.delayInSeconds == undefined) {
                config.delayInSeconds = defaultDelayBetweenRetriesInSeconds;
            }
            let lastError;
            let result;
            let success = false;
            for (let i = 0; i < config.times; i++) {
                const j = i + 1;
                retry("[%s] Retry for '%s', attempt number: %d", config.connectionId, config.operationType, j);
                try {
                    result = yield config.operation();
                    success = true;
                    retry("[%s] Success for '%s', after attempt number: %d.", config.connectionId, config.operationType, j);
                    if (result && !isDelivery(result)) {
                        retry("[%s] Success result for '%s': %O", config.connectionId, config.operationType, result);
                    }
                    break;
                }
                catch (err) {
                    if (!err.translated) {
                        err = translate(err);
                    }
                    if (!err.retryable && err.name === "ServiceCommunicationError" && config.connectionHost) {
                        const isConnected = yield checkNetworkConnection(config.connectionHost);
                        if (!isConnected) {
                            err.name = "ConnectionLostError";
                            err.retryable = true;
                        }
                    }
                    lastError = err;
                    error$1("[%s] Error occured for '%s' in attempt number %d: %O", config.connectionId, config.operationType, j, err);
                    if (lastError && lastError.retryable) {
                        error$1("[%s] Sleeping for %d seconds for '%s'.", config.connectionId, config.delayInSeconds, config.operationType);
                        yield delay(config.delayInSeconds * 1000);
                        continue;
                    }
                    else {
                        break;
                    }
                }
            }
            if (success) {
                return result;
            }
            else {
                throw lastError;
            }
        });
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes an amqp request(sender)-response(receiver) link that is created over an amqp session.
     * @class RequestResponseLink
     */
    class RequestResponseLink {
        /**
         * @constructor
         * @param {Session} session The amqp session.
         * @param {Sender} sender The amqp sender link.
         * @param {Receiver} receiver The amqp receiver link.
         */
        constructor(session, sender, receiver) {
            this.session = session;
            this.sender = sender;
            this.receiver = receiver;
            this.session = session;
            this.sender = sender;
            this.receiver = receiver;
        }
        /**
         * Provides the underlying amqp connection object.
         * @returns {Connection} Connection.
         */
        get connection() {
            return this.session.connection;
        }
        /**
         * Indicates whether the session and the sender and receiver links are all open or closed.
         * @returns {boolean} boolean - `true` - `open`, `false` - `closed`.
         */
        isOpen() {
            return (this.session.isOpen() && this.sender.isOpen() && this.receiver.isOpen());
        }
        /**
         * Sends the given request message and returns the received response. If the operation is not
         * completed in the provided timeout in seconds `default: 10`, then the request will be retried
         * linearly for the provided number of times `default: 3` with the provided delay in seconds
         * `default: 15` between each attempt.
         *
         * @param {Message} request The AMQP (request) message.
         * @param {SendRequestOptions} [options] Options that can be provided while sending a request.
         * @returns {Promise<Message>} Promise<Message> The AMQP (response) message.
         */
        sendRequest(request, options) {
            if (!options)
                options = {};
            if (!options.timeoutInSeconds) {
                options.timeoutInSeconds = defaultOperationTimeoutInSeconds;
            }
            let count = 0;
            const sendRequestPromise = () => new Promise((resolve, reject) => {
                let waitTimer;
                let timeOver = false;
                count++;
                if (count !== 1) {
                    // Generate a new message_id every time after the first attempt
                    request.message_id = lib_5();
                }
                else if (!request.message_id) {
                    // Set the message_id in the first attempt only if it is not set
                    request.message_id = lib_5();
                }
                // Handle different variations of property names in responses emitted by EventHubs and ServiceBus.
                const getCodeDescriptionAndError = (props) => {
                    if (!props)
                        props = {};
                    return {
                        statusCode: (props[statusCode] ||
                            props.statusCode),
                        statusDescription: (props[statusDescription] ||
                            props.statusDescription),
                        errorCondition: (props[errorCondition] ||
                            props.errorCondition)
                    };
                };
                const messageCallback = (context) => {
                    // remove the event listener as this will be registered next time when someone makes a request.
                    this.receiver.removeListener(lib_7.message, messageCallback);
                    const info = getCodeDescriptionAndError(context.message.application_properties);
                    const responseCorrelationId = context.message.correlation_id;
                    reqres("[%s] %s response: ", this.connection.id, request.to || "$management", context.message);
                    if (info.statusCode > 199 && info.statusCode < 300) {
                        if (request.message_id === responseCorrelationId ||
                            request.correlation_id === responseCorrelationId) {
                            if (!timeOver) {
                                clearTimeout(waitTimer);
                            }
                            reqres("[%s] request-messageId | '%s' == '%s' | response-correlationId.", this.connection.id, request.message_id, responseCorrelationId);
                            return resolve(context.message);
                        }
                        else {
                            error$1("[%s] request-messageId | '%s' != '%s' | response-correlationId. " +
                                "Hence dropping this response and waiting for the next one.", this.connection.id, request.message_id, responseCorrelationId);
                        }
                    }
                    else {
                        const condition = info.errorCondition ||
                            ConditionStatusMapper[info.statusCode] ||
                            "amqp:internal-error";
                        const e = {
                            condition: condition,
                            description: info.statusDescription
                        };
                        const error = translate(e);
                        error$1(error);
                        return reject(error);
                    }
                };
                const actionAfterTimeout = () => {
                    timeOver = true;
                    this.receiver.removeListener(lib_7.message, messageCallback);
                    const address = this.receiver.address || "address";
                    const desc = `The request with message_id "${request.message_id}" to "${address}" ` +
                        `endpoint timed out. Please try again later.`;
                    const e = {
                        condition: ConditionStatusMapper[408],
                        description: desc
                    };
                    return reject(translate(e));
                };
                this.receiver.on(lib_7.message, messageCallback);
                waitTimer = setTimeout(actionAfterTimeout, options.timeoutInSeconds * 1000);
                reqres("[%s] %s request sent: %O", this.connection.id, request.to || "$managment", request);
                this.sender.send(request);
            });
            const config = {
                operation: sendRequestPromise,
                connectionId: this.connection.id,
                operationType: request.to && request.to === cbsEndpoint
                    ? RetryOperationType.cbsAuth
                    : RetryOperationType.management,
                delayInSeconds: options.delayInSeconds,
                times: options.times
            };
            return retry$1(config);
        }
        /**
         * Closes the sender, receiver link and the underlying session.
         * @returns {Promise<void>} Promise<void>
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.sender.close();
                yield this.receiver.close();
                yield this.session.close();
            });
        }
        /**
         * Removes the sender, receiver link and it's underlying session.
         * @returns {void} void
         */
        remove() {
            this.sender.remove();
            this.receiver.remove();
            this.session.remove();
        }
        /**
         * Creates an amqp request/response link.
         *
         * @param {Connection} connection The amqp connection.
         * @param {SenderOptions} senderOptions Options that must be provided to create the sender link.
         * @param {ReceiverOptions} receiverOptions Options that must be provided to create the receiver link.
         * @returns {Promise<RequestResponseLink>} Promise<RequestResponseLink>
         */
        static create(connection, senderOptions, receiverOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const session = yield connection.createSession();
                const sender = yield session.createSender(senderOptions);
                const receiver = yield session.createReceiver(receiverOptions);
                reqres("[%s] Successfully created the sender and receiver links on the same session.", connection.id);
                return new RequestResponseLink(session, sender, receiver);
            });
        }
    }

    /*!
     * Determine if an object is a Buffer
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */

    var isBuffer = function isBuffer (obj) {
      return obj != null && obj.constructor != null &&
        typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    };

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * The default data transformer that will be used by the Azure SDK.
     */
    class DefaultDataTransformer {
        /**
         * A function that takes the body property from an EventData object
         * and returns an encoded body (some form of AMQP type).
         *
         * @param {*} body The AMQP message body
         * @return {DataSection} encodedBody - The encoded AMQP message body as an AMQP Data type
         * (data section in rhea terms). Section object with following properties:
         * - typecode: 117 (0x75)
         * - content: The given AMQP message body as a Buffer.
         * - multiple: true | undefined.
         */
        encode(body) {
            let result;
            transformer("[encode] The given message body that needs to be encoded is: ", body);
            if (isBuffer(body)) {
                result = lib_2.data_section(body);
            }
            else {
                // string, undefined, null, boolean, array, object, number should end up here
                // coercing undefined to null as that will ensure that null value will be given to the
                // customer on receive.
                if (body === undefined)
                    body = null; // tslint:disable-line
                try {
                    const bodyStr = JSON.stringify(body);
                    result = lib_2.data_section(buffer_1.from(bodyStr, "utf8"));
                }
                catch (err) {
                    const msg = `An error occurred while executing JSON.stringify() on the given body ` +
                        body +
                        `${err ? err.stack : JSON.stringify(err)}`;
                    error$1("[encode] " + msg);
                    throw new Error(msg);
                }
            }
            transformer("[encode] The encoded message body is: %O.", result);
            return result;
        }
        /**
         * @property {Function} [decode] A function that takes the body property from an AMQP message
         * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.
         * If it cannot decode the body then it returns the body
         * as-is.
         * @param {DataSection} body The AMQP message body
         * @return {*} decoded body or the given body as-is.
         */
        decode(body) {
            let processedBody = body;
            try {
                transformer("[decode] Received message body for decoding is: %O", body);
                if (body.content && isBuffer(body.content)) {
                    // This indicates that we are getting the AMQP described type. Let us try decoding it.
                    processedBody = body.content;
                }
                try {
                    // Trying to stringify and JSON.parse() anything else will fail flat and we shall return
                    // the original type back
                    const bodyStr = processedBody.toString("utf8");
                    processedBody = JSON.parse(bodyStr);
                }
                catch (err) {
                    error$1("[decode] An error occurred while trying JSON.parse() on the received body. " +
                        "The error is %O", err);
                }
            }
            catch (err) {
                error$1("[decode] An error occurred while decoding the received message body. The error is: %O", err);
            }
            transformer("[decode] The decoded message body is: %O", processedBody);
            return processedBody;
        }
    }
    //# sourceMappingURL=dataTransformer.js.map

    // Copyright (c) Microsoft Corporation. All rights reserved.
    (function (TokenType) {
        /**
         * The "jwt" token type. Used with AADTokenProvider.
         */
        TokenType["CbsTokenTypeJwt"] = "jwt";
        /**
         * The sas token type. Used with SasTokenProvider.
         */
        TokenType["CbsTokenTypeSas"] = "servicebus.windows.net:sastoken";
    })(exports.TokenType || (exports.TokenType = {}));

    var sha = createCommonjsModule(function (module, exports) {
    (function(Y){function C(c,a,b){var e=0,h=[],n=0,g,l,d,f,m,q,u,r,I=!1,v=[],w=[],t,y=!1,z=!1,x=-1;b=b||{};g=b.encoding||"UTF8";t=b.numRounds||1;if(t!==parseInt(t,10)||1>t)throw Error("numRounds must a integer >= 1");if("SHA-1"===c)m=512,q=K,u=Z,f=160,r=function(a){return a.slice()};else if(0===c.lastIndexOf("SHA-",0))if(q=function(a,b){return L(a,b,c)},u=function(a,b,h,e){var k,f;if("SHA-224"===c||"SHA-256"===c)k=(b+65>>>9<<4)+15,f=16;else if("SHA-384"===c||"SHA-512"===c)k=(b+129>>>10<<
    5)+31,f=32;else throw Error("Unexpected error in SHA-2 implementation");for(;a.length<=k;)a.push(0);a[b>>>5]|=128<<24-b%32;b=b+h;a[k]=b&4294967295;a[k-1]=b/4294967296|0;h=a.length;for(b=0;b<h;b+=f)e=L(a.slice(b,b+f),e,c);if("SHA-224"===c)a=[e[0],e[1],e[2],e[3],e[4],e[5],e[6]];else if("SHA-256"===c)a=e;else if("SHA-384"===c)a=[e[0].a,e[0].b,e[1].a,e[1].b,e[2].a,e[2].b,e[3].a,e[3].b,e[4].a,e[4].b,e[5].a,e[5].b];else if("SHA-512"===c)a=[e[0].a,e[0].b,e[1].a,e[1].b,e[2].a,e[2].b,e[3].a,e[3].b,e[4].a,
    e[4].b,e[5].a,e[5].b,e[6].a,e[6].b,e[7].a,e[7].b];else throw Error("Unexpected error in SHA-2 implementation");return a},r=function(a){return a.slice()},"SHA-224"===c)m=512,f=224;else if("SHA-256"===c)m=512,f=256;else if("SHA-384"===c)m=1024,f=384;else if("SHA-512"===c)m=1024,f=512;else throw Error("Chosen SHA variant is not supported");else if(0===c.lastIndexOf("SHA3-",0)||0===c.lastIndexOf("SHAKE",0)){var F=6;q=D;r=function(a){var c=[],e;for(e=0;5>e;e+=1)c[e]=a[e].slice();return c};x=1;if("SHA3-224"===
    c)m=1152,f=224;else if("SHA3-256"===c)m=1088,f=256;else if("SHA3-384"===c)m=832,f=384;else if("SHA3-512"===c)m=576,f=512;else if("SHAKE128"===c)m=1344,f=-1,F=31,z=!0;else if("SHAKE256"===c)m=1088,f=-1,F=31,z=!0;else throw Error("Chosen SHA variant is not supported");u=function(a,c,e,b,h){e=m;var k=F,f,g=[],n=e>>>5,l=0,d=c>>>5;for(f=0;f<d&&c>=e;f+=n)b=D(a.slice(f,f+n),b),c-=e;a=a.slice(f);for(c%=e;a.length<n;)a.push(0);f=c>>>3;a[f>>2]^=k<<f%4*8;a[n-1]^=2147483648;for(b=D(a,b);32*g.length<h;){a=b[l%
    5][l/5|0];g.push(a.b);if(32*g.length>=h)break;g.push(a.a);l+=1;0===64*l%e&&D(null,b);}return g};}else throw Error("Chosen SHA variant is not supported");d=M(a,g,x);l=A(c);this.setHMACKey=function(a,b,h){var k;if(!0===I)throw Error("HMAC key already set");if(!0===y)throw Error("Cannot set HMAC key after calling update");if(!0===z)throw Error("SHAKE is not supported for HMAC");g=(h||{}).encoding||"UTF8";b=M(b,g,x)(a);a=b.binLen;b=b.value;k=m>>>3;h=k/4-1;if(k<a/8){for(b=u(b,a,0,A(c),f);b.length<=h;)b.push(0);
    b[h]&=4294967040;}else if(k>a/8){for(;b.length<=h;)b.push(0);b[h]&=4294967040;}for(a=0;a<=h;a+=1)v[a]=b[a]^909522486,w[a]=b[a]^1549556828;l=q(v,l);e=m;I=!0;};this.update=function(a){var c,b,k,f=0,g=m>>>5;c=d(a,h,n);a=c.binLen;b=c.value;c=a>>>5;for(k=0;k<c;k+=g)f+m<=a&&(l=q(b.slice(k,k+g),l),f+=m);e+=f;h=b.slice(f>>>5);n=a%m;y=!0;};this.getHash=function(a,b){var k,g,d,m;if(!0===I)throw Error("Cannot call getHash after setting HMAC key");d=N(b);if(!0===z){if(-1===d.shakeLen)throw Error("shakeLen must be specified in options");
    f=d.shakeLen;}switch(a){case "HEX":k=function(a){return O(a,f,x,d)};break;case "B64":k=function(a){return P(a,f,x,d)};break;case "BYTES":k=function(a){return Q(a,f,x)};break;case "ARRAYBUFFER":try{g=new ArrayBuffer(0);}catch(p){throw Error("ARRAYBUFFER not supported by this environment");}k=function(a){return R(a,f,x)};break;default:throw Error("format must be HEX, B64, BYTES, or ARRAYBUFFER");}m=u(h.slice(),n,e,r(l),f);for(g=1;g<t;g+=1)!0===z&&0!==f%32&&(m[m.length-1]&=16777215>>>24-f%32),m=u(m,f,
    0,A(c),f);return k(m)};this.getHMAC=function(a,b){var k,g,d,p;if(!1===I)throw Error("Cannot call getHMAC without first setting HMAC key");d=N(b);switch(a){case "HEX":k=function(a){return O(a,f,x,d)};break;case "B64":k=function(a){return P(a,f,x,d)};break;case "BYTES":k=function(a){return Q(a,f,x)};break;case "ARRAYBUFFER":try{k=new ArrayBuffer(0);}catch(v){throw Error("ARRAYBUFFER not supported by this environment");}k=function(a){return R(a,f,x)};break;default:throw Error("outputFormat must be HEX, B64, BYTES, or ARRAYBUFFER");
    }g=u(h.slice(),n,e,r(l),f);p=q(w,A(c));p=u(g,f,m,p,f);return k(p)};}function b(c,a){this.a=c;this.b=a;}function O(c,a,b,e){var h="";a/=8;var n,g,d;d=-1===b?3:0;for(n=0;n<a;n+=1)g=c[n>>>2]>>>8*(d+n%4*b),h+="0123456789abcdef".charAt(g>>>4&15)+"0123456789abcdef".charAt(g&15);return e.outputUpper?h.toUpperCase():h}function P(c,a,b,e){var h="",n=a/8,g,d,p,f;f=-1===b?3:0;for(g=0;g<n;g+=3)for(d=g+1<n?c[g+1>>>2]:0,p=g+2<n?c[g+2>>>2]:0,p=(c[g>>>2]>>>8*(f+g%4*b)&255)<<16|(d>>>8*(f+(g+1)%4*b)&255)<<8|p>>>8*(f+
    (g+2)%4*b)&255,d=0;4>d;d+=1)8*g+6*d<=a?h+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(p>>>6*(3-d)&63):h+=e.b64Pad;return h}function Q(c,a,b){var e="";a/=8;var h,d,g;g=-1===b?3:0;for(h=0;h<a;h+=1)d=c[h>>>2]>>>8*(g+h%4*b)&255,e+=String.fromCharCode(d);return e}function R(c,a,b){a/=8;var e,h=new ArrayBuffer(a),d,g;g=new Uint8Array(h);d=-1===b?3:0;for(e=0;e<a;e+=1)g[e]=c[e>>>2]>>>8*(d+e%4*b)&255;return h}function N(c){var a={outputUpper:!1,b64Pad:"=",shakeLen:-1};c=c||{};
    a.outputUpper=c.outputUpper||!1;!0===c.hasOwnProperty("b64Pad")&&(a.b64Pad=c.b64Pad);if(!0===c.hasOwnProperty("shakeLen")){if(0!==c.shakeLen%8)throw Error("shakeLen must be a multiple of 8");a.shakeLen=c.shakeLen;}if("boolean"!==typeof a.outputUpper)throw Error("Invalid outputUpper formatting option");if("string"!==typeof a.b64Pad)throw Error("Invalid b64Pad formatting option");return a}function M(c,a,b){switch(a){case "UTF8":case "UTF16BE":case "UTF16LE":break;default:throw Error("encoding must be UTF8, UTF16BE, or UTF16LE");
    }switch(c){case "HEX":c=function(a,c,d){var g=a.length,l,p,f,m,q,u;if(0!==g%2)throw Error("String of HEX type must be in byte increments");c=c||[0];d=d||0;q=d>>>3;u=-1===b?3:0;for(l=0;l<g;l+=2){p=parseInt(a.substr(l,2),16);if(isNaN(p))throw Error("String of HEX type contains invalid characters");m=(l>>>1)+q;for(f=m>>>2;c.length<=f;)c.push(0);c[f]|=p<<8*(u+m%4*b);}return {value:c,binLen:4*g+d}};break;case "TEXT":c=function(c,h,d){var g,l,p=0,f,m,q,u,r,t;h=h||[0];d=d||0;q=d>>>3;if("UTF8"===a)for(t=-1===
    b?3:0,f=0;f<c.length;f+=1)for(g=c.charCodeAt(f),l=[],128>g?l.push(g):2048>g?(l.push(192|g>>>6),l.push(128|g&63)):55296>g||57344<=g?l.push(224|g>>>12,128|g>>>6&63,128|g&63):(f+=1,g=65536+((g&1023)<<10|c.charCodeAt(f)&1023),l.push(240|g>>>18,128|g>>>12&63,128|g>>>6&63,128|g&63)),m=0;m<l.length;m+=1){r=p+q;for(u=r>>>2;h.length<=u;)h.push(0);h[u]|=l[m]<<8*(t+r%4*b);p+=1;}else if("UTF16BE"===a||"UTF16LE"===a)for(t=-1===b?2:0,l="UTF16LE"===a&&1!==b||"UTF16LE"!==a&&1===b,f=0;f<c.length;f+=1){g=c.charCodeAt(f);
    !0===l&&(m=g&255,g=m<<8|g>>>8);r=p+q;for(u=r>>>2;h.length<=u;)h.push(0);h[u]|=g<<8*(t+r%4*b);p+=2;}return {value:h,binLen:8*p+d}};break;case "B64":c=function(a,c,d){var g=0,l,p,f,m,q,u,r,t;if(-1===a.search(/^[a-zA-Z0-9=+\/]+$/))throw Error("Invalid character in base-64 string");p=a.indexOf("=");a=a.replace(/\=/g,"");if(-1!==p&&p<a.length)throw Error("Invalid '=' found in base-64 string");c=c||[0];d=d||0;u=d>>>3;t=-1===b?3:0;for(p=0;p<a.length;p+=4){q=a.substr(p,4);for(f=m=0;f<q.length;f+=1)l="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(q[f]),
    m|=l<<18-6*f;for(f=0;f<q.length-1;f+=1){r=g+u;for(l=r>>>2;c.length<=l;)c.push(0);c[l]|=(m>>>16-8*f&255)<<8*(t+r%4*b);g+=1;}}return {value:c,binLen:8*g+d}};break;case "BYTES":c=function(a,c,d){var g,l,p,f,m,q;c=c||[0];d=d||0;p=d>>>3;q=-1===b?3:0;for(l=0;l<a.length;l+=1)g=a.charCodeAt(l),m=l+p,f=m>>>2,c.length<=f&&c.push(0),c[f]|=g<<8*(q+m%4*b);return {value:c,binLen:8*a.length+d}};break;case "ARRAYBUFFER":try{c=new ArrayBuffer(0);}catch(e){throw Error("ARRAYBUFFER not supported by this environment");}c=
    function(a,c,d){var g,l,p,f,m,q;c=c||[0];d=d||0;l=d>>>3;m=-1===b?3:0;q=new Uint8Array(a);for(g=0;g<a.byteLength;g+=1)f=g+l,p=f>>>2,c.length<=p&&c.push(0),c[p]|=q[g]<<8*(m+f%4*b);return {value:c,binLen:8*a.byteLength+d}};break;default:throw Error("format must be HEX, TEXT, B64, BYTES, or ARRAYBUFFER");}return c}function y(c,a){return c<<a|c>>>32-a}function S(c,a){return 32<a?(a-=32,new b(c.b<<a|c.a>>>32-a,c.a<<a|c.b>>>32-a)):0!==a?new b(c.a<<a|c.b>>>32-a,c.b<<a|c.a>>>32-a):c}function w(c,a){return c>>>
    a|c<<32-a}function t(c,a){var k=null,k=new b(c.a,c.b);return k=32>=a?new b(k.a>>>a|k.b<<32-a&4294967295,k.b>>>a|k.a<<32-a&4294967295):new b(k.b>>>a-32|k.a<<64-a&4294967295,k.a>>>a-32|k.b<<64-a&4294967295)}function T(c,a){var k=null;return k=32>=a?new b(c.a>>>a,c.b>>>a|c.a<<32-a&4294967295):new b(0,c.a>>>a-32)}function aa(c,a,b){return c&a^~c&b}function ba(c,a,k){return new b(c.a&a.a^~c.a&k.a,c.b&a.b^~c.b&k.b)}function U(c,a,b){return c&a^c&b^a&b}function ca(c,a,k){return new b(c.a&a.a^c.a&k.a^a.a&
    k.a,c.b&a.b^c.b&k.b^a.b&k.b)}function da(c){return w(c,2)^w(c,13)^w(c,22)}function ea(c){var a=t(c,28),k=t(c,34);c=t(c,39);return new b(a.a^k.a^c.a,a.b^k.b^c.b)}function fa(c){return w(c,6)^w(c,11)^w(c,25)}function ga(c){var a=t(c,14),k=t(c,18);c=t(c,41);return new b(a.a^k.a^c.a,a.b^k.b^c.b)}function ha(c){return w(c,7)^w(c,18)^c>>>3}function ia(c){var a=t(c,1),k=t(c,8);c=T(c,7);return new b(a.a^k.a^c.a,a.b^k.b^c.b)}function ja(c){return w(c,17)^w(c,19)^c>>>10}function ka(c){var a=t(c,19),k=t(c,61);
    c=T(c,6);return new b(a.a^k.a^c.a,a.b^k.b^c.b)}function G(c,a){var b=(c&65535)+(a&65535);return ((c>>>16)+(a>>>16)+(b>>>16)&65535)<<16|b&65535}function la(c,a,b,e){var h=(c&65535)+(a&65535)+(b&65535)+(e&65535);return ((c>>>16)+(a>>>16)+(b>>>16)+(e>>>16)+(h>>>16)&65535)<<16|h&65535}function H(c,a,b,e,h){var d=(c&65535)+(a&65535)+(b&65535)+(e&65535)+(h&65535);return ((c>>>16)+(a>>>16)+(b>>>16)+(e>>>16)+(h>>>16)+(d>>>16)&65535)<<16|d&65535}function ma(c,a){var d,e,h;d=(c.b&65535)+(a.b&65535);e=(c.b>>>16)+
    (a.b>>>16)+(d>>>16);h=(e&65535)<<16|d&65535;d=(c.a&65535)+(a.a&65535)+(e>>>16);e=(c.a>>>16)+(a.a>>>16)+(d>>>16);return new b((e&65535)<<16|d&65535,h)}function na(c,a,d,e){var h,n,g;h=(c.b&65535)+(a.b&65535)+(d.b&65535)+(e.b&65535);n=(c.b>>>16)+(a.b>>>16)+(d.b>>>16)+(e.b>>>16)+(h>>>16);g=(n&65535)<<16|h&65535;h=(c.a&65535)+(a.a&65535)+(d.a&65535)+(e.a&65535)+(n>>>16);n=(c.a>>>16)+(a.a>>>16)+(d.a>>>16)+(e.a>>>16)+(h>>>16);return new b((n&65535)<<16|h&65535,g)}function oa(c,a,d,e,h){var n,g,l;n=(c.b&
    65535)+(a.b&65535)+(d.b&65535)+(e.b&65535)+(h.b&65535);g=(c.b>>>16)+(a.b>>>16)+(d.b>>>16)+(e.b>>>16)+(h.b>>>16)+(n>>>16);l=(g&65535)<<16|n&65535;n=(c.a&65535)+(a.a&65535)+(d.a&65535)+(e.a&65535)+(h.a&65535)+(g>>>16);g=(c.a>>>16)+(a.a>>>16)+(d.a>>>16)+(e.a>>>16)+(h.a>>>16)+(n>>>16);return new b((g&65535)<<16|n&65535,l)}function B(c,a){return new b(c.a^a.a,c.b^a.b)}function A(c){var a=[],d;if("SHA-1"===c)a=[1732584193,4023233417,2562383102,271733878,3285377520];else if(0===c.lastIndexOf("SHA-",0))switch(a=
    [3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428],d=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],c){case "SHA-224":break;case "SHA-256":a=d;break;case "SHA-384":a=[new b(3418070365,a[0]),new b(1654270250,a[1]),new b(2438529370,a[2]),new b(355462360,a[3]),new b(1731405415,a[4]),new b(41048885895,a[5]),new b(3675008525,a[6]),new b(1203062813,a[7])];break;case "SHA-512":a=[new b(d[0],4089235720),new b(d[1],2227873595),
    new b(d[2],4271175723),new b(d[3],1595750129),new b(d[4],2917565137),new b(d[5],725511199),new b(d[6],4215389547),new b(d[7],327033209)];break;default:throw Error("Unknown SHA variant");}else if(0===c.lastIndexOf("SHA3-",0)||0===c.lastIndexOf("SHAKE",0))for(c=0;5>c;c+=1)a[c]=[new b(0,0),new b(0,0),new b(0,0),new b(0,0),new b(0,0)];else throw Error("No SHA variants supported");return a}function K(c,a){var b=[],e,d,n,g,l,p,f;e=a[0];d=a[1];n=a[2];g=a[3];l=a[4];for(f=0;80>f;f+=1)b[f]=16>f?c[f]:y(b[f-
    3]^b[f-8]^b[f-14]^b[f-16],1),p=20>f?H(y(e,5),d&n^~d&g,l,1518500249,b[f]):40>f?H(y(e,5),d^n^g,l,1859775393,b[f]):60>f?H(y(e,5),U(d,n,g),l,2400959708,b[f]):H(y(e,5),d^n^g,l,3395469782,b[f]),l=g,g=n,n=y(d,30),d=e,e=p;a[0]=G(e,a[0]);a[1]=G(d,a[1]);a[2]=G(n,a[2]);a[3]=G(g,a[3]);a[4]=G(l,a[4]);return a}function Z(c,a,b,e){var d;for(d=(a+65>>>9<<4)+15;c.length<=d;)c.push(0);c[a>>>5]|=128<<24-a%32;a+=b;c[d]=a&4294967295;c[d-1]=a/4294967296|0;a=c.length;for(d=0;d<a;d+=16)e=K(c.slice(d,d+16),e);return e}function L(c,
    a,k){var e,h,n,g,l,p,f,m,q,u,r,t,v,w,y,A,z,x,F,B,C,D,E=[],J;if("SHA-224"===k||"SHA-256"===k)u=64,t=1,D=Number,v=G,w=la,y=H,A=ha,z=ja,x=da,F=fa,C=U,B=aa,J=d;else if("SHA-384"===k||"SHA-512"===k)u=80,t=2,D=b,v=ma,w=na,y=oa,A=ia,z=ka,x=ea,F=ga,C=ca,B=ba,J=V;else throw Error("Unexpected error in SHA-2 implementation");k=a[0];e=a[1];h=a[2];n=a[3];g=a[4];l=a[5];p=a[6];f=a[7];for(r=0;r<u;r+=1)16>r?(q=r*t,m=c.length<=q?0:c[q],q=c.length<=q+1?0:c[q+1],E[r]=new D(m,q)):E[r]=w(z(E[r-2]),E[r-7],A(E[r-15]),E[r-
    16]),m=y(f,F(g),B(g,l,p),J[r],E[r]),q=v(x(k),C(k,e,h)),f=p,p=l,l=g,g=v(n,m),n=h,h=e,e=k,k=v(m,q);a[0]=v(k,a[0]);a[1]=v(e,a[1]);a[2]=v(h,a[2]);a[3]=v(n,a[3]);a[4]=v(g,a[4]);a[5]=v(l,a[5]);a[6]=v(p,a[6]);a[7]=v(f,a[7]);return a}function D(c,a){var d,e,h,n,g=[],l=[];if(null!==c)for(e=0;e<c.length;e+=2)a[(e>>>1)%5][(e>>>1)/5|0]=B(a[(e>>>1)%5][(e>>>1)/5|0],new b(c[e+1],c[e]));for(d=0;24>d;d+=1){n=A("SHA3-");for(e=0;5>e;e+=1){h=a[e][0];var p=a[e][1],f=a[e][2],m=a[e][3],q=a[e][4];g[e]=new b(h.a^p.a^f.a^
    m.a^q.a,h.b^p.b^f.b^m.b^q.b);}for(e=0;5>e;e+=1)l[e]=B(g[(e+4)%5],S(g[(e+1)%5],1));for(e=0;5>e;e+=1)for(h=0;5>h;h+=1)a[e][h]=B(a[e][h],l[e]);for(e=0;5>e;e+=1)for(h=0;5>h;h+=1)n[h][(2*e+3*h)%5]=S(a[e][h],W[e][h]);for(e=0;5>e;e+=1)for(h=0;5>h;h+=1)a[e][h]=B(n[e][h],new b(~n[(e+1)%5][h].a&n[(e+2)%5][h].a,~n[(e+1)%5][h].b&n[(e+2)%5][h].b));a[0][0]=B(a[0][0],X[d]);}return a}var d,V,W,X;d=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,
    1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,
    2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];V=[new b(d[0],3609767458),new b(d[1],602891725),new b(d[2],3964484399),new b(d[3],2173295548),new b(d[4],4081628472),new b(d[5],3053834265),new b(d[6],2937671579),new b(d[7],3664609560),new b(d[8],2734883394),new b(d[9],1164996542),new b(d[10],1323610764),new b(d[11],3590304994),new b(d[12],4068182383),new b(d[13],991336113),new b(d[14],633803317),new b(d[15],3479774868),new b(d[16],2666613458),new b(d[17],944711139),new b(d[18],2341262773),
    new b(d[19],2007800933),new b(d[20],1495990901),new b(d[21],1856431235),new b(d[22],3175218132),new b(d[23],2198950837),new b(d[24],3999719339),new b(d[25],766784016),new b(d[26],2566594879),new b(d[27],3203337956),new b(d[28],1034457026),new b(d[29],2466948901),new b(d[30],3758326383),new b(d[31],168717936),new b(d[32],1188179964),new b(d[33],1546045734),new b(d[34],1522805485),new b(d[35],2643833823),new b(d[36],2343527390),new b(d[37],1014477480),new b(d[38],1206759142),new b(d[39],344077627),
    new b(d[40],1290863460),new b(d[41],3158454273),new b(d[42],3505952657),new b(d[43],106217008),new b(d[44],3606008344),new b(d[45],1432725776),new b(d[46],1467031594),new b(d[47],851169720),new b(d[48],3100823752),new b(d[49],1363258195),new b(d[50],3750685593),new b(d[51],3785050280),new b(d[52],3318307427),new b(d[53],3812723403),new b(d[54],2003034995),new b(d[55],3602036899),new b(d[56],1575990012),new b(d[57],1125592928),new b(d[58],2716904306),new b(d[59],442776044),new b(d[60],593698344),new b(d[61],
    3733110249),new b(d[62],2999351573),new b(d[63],3815920427),new b(3391569614,3928383900),new b(3515267271,566280711),new b(3940187606,3454069534),new b(4118630271,4000239992),new b(116418474,1914138554),new b(174292421,2731055270),new b(289380356,3203993006),new b(460393269,320620315),new b(685471733,587496836),new b(852142971,1086792851),new b(1017036298,365543100),new b(1126000580,2618297676),new b(1288033470,3409855158),new b(1501505948,4234509866),new b(1607167915,987167468),new b(1816402316,
    1246189591)];X=[new b(0,1),new b(0,32898),new b(2147483648,32906),new b(2147483648,2147516416),new b(0,32907),new b(0,2147483649),new b(2147483648,2147516545),new b(2147483648,32777),new b(0,138),new b(0,136),new b(0,2147516425),new b(0,2147483658),new b(0,2147516555),new b(2147483648,139),new b(2147483648,32905),new b(2147483648,32771),new b(2147483648,32770),new b(2147483648,128),new b(0,32778),new b(2147483648,2147483658),new b(2147483648,2147516545),new b(2147483648,32896),new b(0,2147483649),
    new b(2147483648,2147516424)];W=[[0,36,3,41,18],[1,44,10,45,2],[62,6,43,15,61],[28,55,25,21,56],[27,20,39,8,14]];(module.exports&&(module.exports=C),exports=C);})();
    });

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @class SasTokenProvider
     * Defines the SasTokenProvider.
     */
    class SasTokenProvider {
        /**
         * Initializes a new instance of SasTokenProvider
         * @constructor
         * @param {string} namespace - The namespace of the EventHub/ServiceBus instance.
         * @param {string} keyName - The name of the EventHub/ServiceBus key.
         * @param {string} key - The secret value associated with the above EventHub/ServiceBus key
         */
        constructor(namespace, keyName, key, tokenValidTimeInSeconds, tokenRenewalMarginInSeconds) {
            this.namespace = namespace;
            this.keyName = keyName;
            this.key = key;
            this.tokenValidTimeInSeconds = tokenValidTimeInSeconds || 3600;
            this.tokenRenewalMarginInSeconds = tokenRenewalMarginInSeconds || 900;
            if (this.tokenValidTimeInSeconds <= this.tokenRenewalMarginInSeconds) {
                throw new Error("tokenRenewalMarginInSeconds must be less than tokenValidTimeInSeconds");
            }
        }
        /**
         * Gets the sas token for the specified audience
         * @param {string} [audience] - The audience for which the token is desired. If not
         * provided then the Endpoint from the connection string will be applied.
         */
        getToken(audience) {
            return __awaiter(this, void 0, void 0, function* () {
                return this._createToken(Math.floor(Date.now() / 1000) + this.tokenValidTimeInSeconds, audience);
            });
        }
        /**
         * @protected
         * Creates the sas token based on the provided information
         * @param {string | number} expiry - The time period in unix time after which the token will expire.
         * @param {string} [audience] - The audience for which the token is desired. If not
         * provided then the Endpoint from the connection string will be applied.
         * @param {string | Buffer} [hashInput] The input to be provided to hmac to create the hash.
         */
        _createToken(expiry, audience, hashInput) {
            if (!audience)
                audience = this.namespace;
            audience = encodeURIComponent(audience);
            const keyName = encodeURIComponent(this.keyName);
            const stringToSign = audience + "\n" + expiry;
            hashInput = hashInput || this.key;
            let shaObj;
            if (isBuffer(hashInput)) {
                shaObj = new sha("SHA-256", "ARRAYBUFFER");
                shaObj.setHMACKey(hashInput, "ARRAYBUFFER");
                shaObj.update(buffer_1.from(stringToSign));
            }
            else {
                shaObj = new sha("SHA-256", "TEXT");
                shaObj.setHMACKey(hashInput, "TEXT");
                shaObj.update(stringToSign);
            }
            const sig = encodeURIComponent(shaObj.getHMAC("B64"));
            return {
                token: `SharedAccessSignature sr=${audience}&sig=${sig}&se=${expiry}&skn=${keyName}`,
                tokenType: exports.TokenType.CbsTokenTypeSas,
                expiry: expiry
            };
        }
        /**
         * Creates a token provider from the EventHub/ServiceBus connection string;
         * @param {string} connectionString - The EventHub/ServiceBus connection string
         */
        static fromConnectionString(connectionString) {
            const parsed = parseConnectionString(connectionString);
            return new SasTokenProvider(parsed.Endpoint, parsed.SharedAccessKeyName, parsed.SharedAccessKey);
        }
    }
    //# sourceMappingURL=sas.js.map

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes the ConnectionConfig module
     * @module ConnectionConfig
     */
    var ConnectionConfig;
    (function (ConnectionConfig) {
        /**
         * Creates the connection config.
         * @param {string} connectionString - The connection string for a given service like
         * EventHub/ServiceBus.
         * @param {string} [path]           - The name/path of the entity (hub name) to which the
         * connection needs to happen. This will override the EntityPath in the connectionString
         * if present.
         * @returns {ConnectionConfig} ConnectionConfig
         */
        function create(connectionString, path) {
            connectionString = String(connectionString);
            const parsedCS = parseConnectionString(connectionString);
            if (!parsedCS.Endpoint) {
                throw new TypeError("Missing Endpoint in Connection String.");
            }
            if (!parsedCS.Endpoint.endsWith("/"))
                parsedCS.Endpoint += "/";
            const result = {
                connectionString: connectionString,
                endpoint: parsedCS.Endpoint,
                host: parsedCS && parsedCS.Endpoint
                    ? (parsedCS.Endpoint.match("sb://([^/]*)") || [])[1]
                    : "",
                sharedAccessKeyName: parsedCS.SharedAccessKeyName,
                sharedAccessKey: parsedCS.SharedAccessKey
            };
            if (path || parsedCS.EntityPath) {
                result.entityPath = path || parsedCS.EntityPath;
            }
            return result;
        }
        ConnectionConfig.create = create;
        /**
         * Validates the properties of connection config.
         * @param {ConnectionConfig} config The connection config to be validated.
         * @returns {void} void
         */
        function validate(config, options) {
            if (!options)
                options = {};
            if (!config) {
                throw new TypeError("Missing configuration");
            }
            if (!config.endpoint) {
                throw new TypeError("Missing 'endpoint' in configuration");
            }
            config.endpoint = String(config.endpoint);
            if (!config.host) {
                throw new TypeError("Missing 'host' in configuration");
            }
            config.host = String(config.host);
            if (options.isEntityPathRequired && !config.entityPath) {
                throw new TypeError("Missing 'entityPath' in configuration");
            }
            config.entityPath = String(config.entityPath);
            if (!config.sharedAccessKeyName) {
                throw new TypeError("Missing 'sharedAccessKeyName' in configuration");
            }
            config.sharedAccessKeyName = String(config.sharedAccessKeyName);
            if (!config.sharedAccessKey) {
                throw new TypeError("Missing 'sharedAccessKey' in configuration");
            }
            config.sharedAccessKey = String(config.sharedAccessKey);
        }
        ConnectionConfig.validate = validate;
    })(ConnectionConfig || (ConnectionConfig = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes the connection config object that is created after parsing an EventHub connection
     * string. It also provides some convenience methods for getting the address and audience for
     * different entities.
     * @module EventHubConnectionConfig
     */
    var EventHubConnectionConfig;
    (function (EventHubConnectionConfig) {
        /**
         * Creates the connection config.
         * @param {string} connectionString - The connection string for a given service like
         * EventHub/ServiceBus.
         * @param {string} [path]           - The name/path of the entity (hub name) to which the
         * connection needs to happen. This will override the EntityPath in the connectionString
         * if present.
         * @returns {EventHubConnectionConfig} EventHubConnectionConfig
         */
        function create(connectionString, path) {
            const config = ConnectionConfig.create(connectionString, path);
            if (!config.entityPath) {
                throw new TypeError(`Either provide "path" or the "connectionString": "${connectionString}", ` +
                    `must contain EntityPath="<path-to-the-entity>".`);
            }
            return createFromConnectionConfig(config);
        }
        EventHubConnectionConfig.create = create;
        /**
         * Creates an EventHubConnectionConfig from the provided base ConnectionConfig.
         * @param config The base connection config from which the EventHubConnectionConfig needs to be
         * created.
         * @returns EventHubConnectionConfig
         */
        function createFromConnectionConfig(config) {
            ConnectionConfig.validate(config, { isEntityPathRequired: true });
            config.getManagementAudience = () => {
                return `${config.endpoint}${config.entityPath}/$management`;
            };
            config.getManagementAddress = () => {
                return `${config.entityPath}/$management`;
            };
            config.getSenderAudience = (partitionId) => {
                if (partitionId != undefined) {
                    return `${config.endpoint}${config.entityPath}/Partitions/${partitionId}`;
                }
                else {
                    return `${config.endpoint}${config.entityPath}`;
                }
            };
            config.getSenderAddress = (partitionId) => {
                if (partitionId != undefined) {
                    return `${config.entityPath}/Partitions/${partitionId}`;
                }
                else {
                    return `${config.entityPath}`;
                }
            };
            config.getReceiverAudience = (partitionId, consumergroup) => {
                if (!consumergroup)
                    consumergroup = "$default";
                return (`${config.endpoint}${config.entityPath}/ConsumerGroups/${consumergroup}/` + `Partitions/${partitionId}`);
            };
            config.getReceiverAddress = (partitionId, consumergroup) => {
                if (!consumergroup)
                    consumergroup = "$default";
                return `${config.entityPath}/ConsumerGroups/${consumergroup}/Partitions/${partitionId}`;
            };
            return config;
        }
        EventHubConnectionConfig.createFromConnectionConfig = createFromConnectionConfig;
        /**
         * Validates the properties of connection config.
         * @param {ConnectionConfig} config The connection config to be validated.
         * @returns {void} void
         */
        function validate(config) {
            return ConnectionConfig.validate(config, { isEntityPathRequired: true });
        }
        EventHubConnectionConfig.validate = validate;
    })(EventHubConnectionConfig || (EventHubConnectionConfig = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @module IotHubConnectionConfig
     * @ignore
     */
    var IotHubConnectionConfig;
    (function (IotHubConnectionConfig) {
        /**
         * Creates the connection config.
         * @ignore
         * @param {string} connectionString - The event hub connection string
         * @param {string} [path]           - The name/path of the entity (hub name) to which the connection needs to happen
         */
        function create(connectionString, path) {
            connectionString = String(connectionString);
            const parsedCS = parseConnectionString(connectionString);
            if (!path) {
                path = "messages/events";
            }
            const result = {
                connectionString: connectionString,
                hostName: parsedCS.HostName,
                host: parsedCS && parsedCS.HostName ? parsedCS.HostName.split(".")[0] : "",
                entityPath: path,
                sharedAccessKeyName: parsedCS.SharedAccessKeyName,
                sharedAccessKey: parsedCS.SharedAccessKey,
                deviceId: parsedCS.DeviceId
            };
            return result;
        }
        IotHubConnectionConfig.create = create;
        /**
         * Validates the properties of connection config.
         * @ignore
         * @param {ConnectionConfig} config The connection config to be validated.
         */
        function validate(config) {
            if (!config) {
                throw new TypeError("Missing configuration");
            }
            if (!config.hostName) {
                throw new TypeError("Missing 'hostName' in configuration");
            }
            config.hostName = String(config.hostName);
            if (!config.entityPath) {
                throw new TypeError("Missing 'entityPath' in configuration");
            }
            config.entityPath = String(config.entityPath);
            if (!config.sharedAccessKeyName) {
                throw new TypeError("Missing 'sharedAccessKeyName' in configuration");
            }
            config.sharedAccessKeyName = String(config.sharedAccessKeyName);
            if (!config.sharedAccessKey) {
                throw new TypeError("Missing 'sharedAccessKey' in configuration");
            }
            config.sharedAccessKey = String(config.sharedAccessKey);
            if (config.deviceId) {
                config.deviceId = String(config.deviceId);
            }
        }
        IotHubConnectionConfig.validate = validate;
        /**
         * Convert iothub connection config to eventhub connection config.
         * @ignore
         * @param {IotHubConnectionConfig} iotHubConfig
         */
        function convertToEventHubConnectionConfig(iotHubConfig) {
            validate(iotHubConfig);
            const config = {
                sharedAccessKey: iotHubConfig.sharedAccessKey,
                sharedAccessKeyName: iotHubConfig.sharedAccessKeyName,
                entityPath: iotHubConfig.entityPath,
                host: iotHubConfig.hostName,
                endpoint: `sb://${iotHubConfig.hostName}/`,
                connectionString: iotHubConfig.connectionString
            };
            return EventHubConnectionConfig.createFromConnectionConfig(config);
        }
        IotHubConnectionConfig.convertToEventHubConnectionConfig = convertToEventHubConnectionConfig;
    })(IotHubConnectionConfig || (IotHubConnectionConfig = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @class CbsClient
     * Describes the EventHub/ServiceBus Cbs client that talks to the $cbs endopint over AMQP connection.
     */
    class CbsClient {
        /**
         * @constructor
         * @param {Connection} connection The AMQP conection.
         * @param {string} connectionLock A unique string (usually a guid) per connection.
         */
        constructor(connection, connectionLock) {
            /**
             * @property {string} endpoint CBS endpoint - "$cbs"
             */
            this.endpoint = cbsEndpoint;
            /**
             * @property {string} replyTo CBS replyTo - The reciever link name that the service should reply to.
             */
            this.replyTo = `${cbsReplyTo}-${lib_5()}`;
            /**
             * @property {string} cbsLock The unqiue lock name per $cbs session per connection that is used to
             * acquire the lock for establishing a cbs session if one does not exist for an aqmp connection.
             */
            this.cbsLock = `${negotiateCbsKey}-${lib_5()}`;
            this.connection = connection;
            this.connectionLock = connectionLock;
        }
        /**
         * Creates a singleton instance of the CBS session if it hasn't been initialized previously on
         * the given connection.
         * @returns {Promise<void>} Promise<void>.
         */
        init() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Acquire the lock and establish an amqp connection if it does not exist.
                    if (!this.connection.isOpen()) {
                        cbs("The CBS client is trying to establish an AMQP connection.");
                        yield defaultLock.acquire(this.connectionLock, () => {
                            return this.connection.open();
                        });
                    }
                    if (!this._isCbsSenderReceiverLinkOpen()) {
                        const rxOpt = {
                            source: {
                                address: this.endpoint
                            },
                            name: this.replyTo,
                            onSessionError: (context) => {
                                const id = context.connection.options.id;
                                const ehError = translate(context.session.error);
                                error$1("[%s] An error occurred on the session for request/response links " +
                                    "for $cbs: %O", id, ehError);
                            }
                        };
                        const srOpt = { target: { address: this.endpoint } };
                        cbs("[%s] Creating sender/receiver links on a session for $cbs endpoint.", this.connection.id);
                        this._cbsSenderReceiverLink = yield RequestResponseLink.create(this.connection, srOpt, rxOpt);
                        this._cbsSenderReceiverLink.sender.on(lib_8.senderError, (context) => {
                            const id = context.connection.options.id;
                            const ehError = translate(context.sender.error);
                            error$1("[%s] An error occurred on the cbs sender link.. %O", id, ehError);
                        });
                        this._cbsSenderReceiverLink.receiver.on(lib_7.receiverError, (context) => {
                            const id = context.connection.options.id;
                            const ehError = translate(context.receiver.error);
                            error$1("[%s] An error occurred on the cbs receiver link.. %O", id, ehError);
                        });
                        cbs("[%s] Successfully created the cbs sender '%s' and receiver '%s' " +
                            "links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
                    }
                    else {
                        cbs("[%s] CBS session is already present. Reusing the cbs sender '%s' " +
                            "and receiver '%s' links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
                    }
                }
                catch (err) {
                    err = translate(err);
                    error$1("[%s] An error occured while establishing the cbs links: %O", this.connection.id, err);
                    throw err;
                }
            });
        }
        /**
         * Negotiates the CBS claim with the EventHub/ServiceBus Service.
         * @param {string} audience The entity token audience for which the token is requested in one
         * of the following forms:
         *
         * - **ServiceBus**
         *    - **Sender**
         *        - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
         *        - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
         *
         *    - **Receiver**
         *         - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
         *         - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
         *
         *    - **ManagementClient**
         *         - `"sb://<your-namespace>.servicebus.windows.net/<queue-name>/$management"`.
         *         - `"sb://<your-namespace>.servicebus.windows.net/<topic-name>/$management"`.
         *
         * - **EventHubs**
         *     - **Sender**
         *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>"`
         *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>"`.
         *
         *     - **Receiver**
         *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`.
         *
         *     - **ManagementClient**
         *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management"`.
         * @param {TokenInfo} tokenObject The token object that needs to be sent in the put-token request.
         * @return {Promise<any>} Returns a Promise that resolves when $cbs authentication is successful
         * and rejects when an error occurs during $cbs authentication.
         */
        negotiateClaim(audience, tokenObject) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const request = {
                        body: tokenObject.token,
                        message_id: lib_5(),
                        reply_to: this.replyTo,
                        to: this.endpoint,
                        application_properties: {
                            operation: operationPutToken,
                            name: audience,
                            type: tokenObject.tokenType
                        }
                    };
                    const responseMessage = yield this._cbsSenderReceiverLink.sendRequest(request);
                    cbs("[%s] The CBS response is: %O", this.connection.id, responseMessage);
                    return this._fromAmqpMessageResponse(responseMessage);
                }
                catch (err) {
                    error$1("[%s] An error occurred while negotiating the cbs claim: %O", this.connection.id, err);
                    throw err;
                }
            });
        }
        /**
         * Closes the AMQP cbs session to the EventHub/ServiceBus for this client,
         * returning a promise that will be resolved when disconnection is completed.
         * @return {Promise<void>}
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    if (this._isCbsSenderReceiverLinkOpen()) {
                        const cbsLink = this._cbsSenderReceiverLink;
                        this._cbsSenderReceiverLink = undefined;
                        yield cbsLink.close();
                        cbs("[%s] Successfully closed the cbs session.", this.connection.id);
                    }
                }
                catch (err) {
                    const msg = `An error occurred while closing the cbs link: ${err.stack ||
                    JSON.stringify(err)}.`;
                    error$1("[%s] %s", this.connection.id, msg);
                    throw new Error(msg);
                }
            });
        }
        /**
         * Removes the AMQP cbs session to the EventHub/ServiceBus for this client,
         * @returns {void} void
         */
        remove() {
            try {
                if (this._cbsSenderReceiverLink) {
                    const cbsLink = this._cbsSenderReceiverLink;
                    this._cbsSenderReceiverLink = undefined;
                    cbsLink.remove();
                    cbs("[%s] Successfully removed the cbs session.", this.connection.id);
                }
            }
            catch (err) {
                const msg = `An error occurred while removing the cbs link: ${err.stack ||
                JSON.stringify(err)}.`;
                error$1("[%s] %s", this.connection.id, msg);
                throw new Error(msg);
            }
        }
        /**
         * Indicates whether the cbs sender receiver link is open or closed.
         * @private
         * @return {boolean} `true` open, `false` closed.
         */
        _isCbsSenderReceiverLinkOpen() {
            return (this._cbsSenderReceiverLink && this._cbsSenderReceiverLink.isOpen());
        }
        _fromAmqpMessageResponse(msg) {
            const cbsResponse = {
                correlationId: msg.correlation_id,
                statusCode: msg.application_properties
                    ? msg.application_properties["status-code"]
                    : "",
                satusDescription: msg.application_properties
                    ? msg.application_properties["status-description"]
                    : ""
            };
            cbs("[%s] The deserialized CBS response is: %o", this.connection.id, cbsResponse);
            return cbsResponse;
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes the operations that can be performed on the message header.
     * @module MessageHeader
     */
    var MessageHeader;
    (function (MessageHeader) {
        /**
         * Converts MessageHeader to AmqpMessageHeader.
         *
         * @param {MessageHeader} props Message header.
         * @returns {AmqpMessageHeader} AmqpMessageHeader
         */
        function toAmqpMessageHeader(props) {
            const amqpHeader = {};
            if (props.deliveryCount != undefined) {
                amqpHeader.delivery_count = props.deliveryCount;
            }
            if (props.durable != undefined)
                amqpHeader.durable = props.durable;
            if (props.firstAcquirer != undefined) {
                amqpHeader.first_acquirer = props.firstAcquirer;
            }
            if (props.priority != undefined) {
                amqpHeader.priority = props.priority;
            }
            if (props.ttl != undefined) {
                amqpHeader.ttl = props.ttl;
            }
            msgHeader("To AmqpMessageHeader: %O", amqpHeader);
            return amqpHeader;
        }
        MessageHeader.toAmqpMessageHeader = toAmqpMessageHeader;
        /**
         * Converts AmqpMessageHeader to MessageHeader.
         *
         * @param {AmqpMessageHeader} props Amqp Message Header
         * @returns {MessageHeader} MessageHeader.
         */
        function fromAmqpMessageHeader(props) {
            const msgHeader$1 = {};
            if (props.delivery_count != undefined) {
                msgHeader$1.deliveryCount = props.delivery_count;
            }
            if (props.durable != undefined) {
                msgHeader$1.durable = props.durable;
            }
            if (props.first_acquirer != undefined) {
                msgHeader$1.firstAcquirer = props.first_acquirer;
            }
            if (props.priority != undefined) {
                msgHeader$1.priority = props.priority;
            }
            if (props.ttl != undefined) {
                msgHeader$1.ttl = props.ttl;
            }
            msgHeader("From AmqpMessageHeader: %O", msgHeader$1);
            return msgHeader$1;
        }
        MessageHeader.fromAmqpMessageHeader = fromAmqpMessageHeader;
    })(MessageHeader || (MessageHeader = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes the operations that can be performed on the amqp message properties.
     * @module MessageProperties
     */
    var MessageProperties;
    (function (MessageProperties) {
        /**
         * Converts MessageProperties to AmqpMessageProperties.
         * @param {MessageProperties} props Message properties.
         * @returns {AmqpMessageProperties} AmqpMessageProperties.
         */
        function toAmqpMessageProperties(props) {
            const amqpProperties = {};
            if (props.absoluteExpiryTime != undefined) {
                amqpProperties.absolute_expiry_time = props.absoluteExpiryTime;
            }
            if (props.contentEncoding != undefined) {
                amqpProperties.content_encoding = props.contentEncoding;
            }
            if (props.contentType != undefined) {
                amqpProperties.content_type = props.contentType;
            }
            if (props.correlationId != undefined) {
                amqpProperties.correlation_id = props.correlationId;
            }
            if (props.creationTime != undefined) {
                amqpProperties.creation_time = props.creationTime;
            }
            if (props.groupId != undefined) {
                amqpProperties.group_id = props.groupId;
            }
            if (props.groupSequence != undefined) {
                amqpProperties.group_sequence = props.groupSequence;
            }
            if (props.messageId != undefined) {
                amqpProperties.message_id = props.messageId;
            }
            if (props.replyTo != undefined) {
                amqpProperties.reply_to = props.replyTo;
            }
            if (props.replyToGroupId != undefined) {
                amqpProperties.reply_to_group_id = props.replyToGroupId;
            }
            if (props.subject != undefined) {
                amqpProperties.subject = props.subject;
            }
            if (props.to != undefined) {
                amqpProperties.to = props.to;
            }
            if (props.userId != undefined) {
                amqpProperties.user_id = props.userId;
            }
            msgProperties("To AmqpMessageProperties: %O", amqpProperties);
            return amqpProperties;
        }
        MessageProperties.toAmqpMessageProperties = toAmqpMessageProperties;
        /**
         * Converts AmqpMessageProperties to MessageProperties.
         * @param {AmqpMessageProperties} props Amqp message properties.
         * @returns {MessageProperties} MessageProperties.
         */
        function fromAmqpMessageProperties(props) {
            const msgProperties$1 = {};
            if (props.absolute_expiry_time != undefined) {
                msgProperties$1.absoluteExpiryTime = props.absolute_expiry_time;
            }
            if (props.content_encoding != undefined) {
                msgProperties$1.contentEncoding = props.content_encoding;
            }
            if (props.content_type != undefined) {
                msgProperties$1.contentType = props.content_type;
            }
            if (props.correlation_id != undefined) {
                msgProperties$1.correlationId = props.correlation_id;
            }
            if (props.creation_time != undefined) {
                msgProperties$1.creationTime = props.creation_time;
            }
            if (props.group_id != undefined) {
                msgProperties$1.groupId = props.group_id;
            }
            if (props.group_sequence != undefined) {
                msgProperties$1.groupSequence = props.group_sequence;
            }
            if (props.message_id != undefined) {
                msgProperties$1.messageId = props.message_id;
            }
            if (props.reply_to != undefined) {
                msgProperties$1.replyTo = props.reply_to;
            }
            if (props.reply_to_group_id != undefined) {
                msgProperties$1.replyToGroupId = props.reply_to_group_id;
            }
            if (props.subject != undefined) {
                msgProperties$1.subject = props.subject;
            }
            if (props.to != undefined) {
                msgProperties$1.to = props.to;
            }
            if (props.user_id != undefined) {
                msgProperties$1.userId = props.user_id;
            }
            msgProperties("From AmqpMessageProperties: %O", msgProperties$1);
            return msgProperties$1;
        }
        MessageProperties.fromAmqpMessageProperties = fromAmqpMessageProperties;
    })(MessageProperties || (MessageProperties = {}));

    var ConnectionContextBase;
    (function (ConnectionContextBase) {
        /**
         * Creates the base connection context.
         * @param {CreateConnectionContextBaseParameters} parameters Parameters to be provided to create
         * the base connection context.
         */
        function create(parameters) {
            ConnectionConfig.validate(parameters.config, {
                isEntityPathRequired: parameters.isEntityPathRequired || false
            });
            const userAgent = parameters.connectionProperties.userAgent;
            if (userAgent.length > maxUserAgentLength) {
                throw new Error(`The user-agent string cannot be more than ${maxUserAgentLength} characters in length.` +
                    `The given user-agent string is: ${userAgent} with length: ${userAgent.length}`);
            }
            const connectionOptions = {
                transport: TLS,
                host: parameters.config.host,
                hostname: parameters.config.host,
                username: parameters.config.sharedAccessKeyName,
                port: 5671,
                reconnect: false,
                properties: {
                    product: parameters.connectionProperties.product,
                    version: parameters.connectionProperties.version,
                    "user-agent": userAgent,
                    platform: `(${arch()}-${type()}-${release()})`,
                    framework: `Node/${browser.version}`
                },
                operationTimeoutInSeconds: parameters.operationTimeoutInSeconds,
                idle_time_out: defaultConnectionIdleTimeoutInMs
            };
            if (parameters.config.webSocket ||
                (!isNode && typeof window !== "undefined" && window.WebSocket)) {
                const socket = parameters.config.webSocket || window.WebSocket;
                const host = parameters.config.host;
                const endpoint = parameters.config.webSocketEndpointPath || "";
                const socketOptions = parameters.config.webSocketConstructorOptions || {};
                connectionOptions.webSocketOptions = {
                    webSocket: socket,
                    url: `wss://${host}:443/${endpoint}`,
                    protocol: ["AMQPWSB10"],
                    options: socketOptions
                };
            }
            const connection = new lib_14(connectionOptions);
            const connectionLock = `${establishConnection}-${lib_5()}`;
            const connectionContextBase = {
                wasConnectionCloseCalled: false,
                connectionLock: connectionLock,
                negotiateClaimLock: `${negotiateClaim}-${lib_5()}`,
                connection: connection,
                connectionId: connection.id,
                cbsSession: new CbsClient(connection, connectionLock),
                config: parameters.config,
                tokenProvider: parameters.tokenProvider ||
                    new SasTokenProvider(parameters.config.endpoint, parameters.config.sharedAccessKeyName, parameters.config.sharedAccessKey),
                dataTransformer: parameters.dataTransformer || new DefaultDataTransformer()
            };
            return connectionContextBase;
        }
        ConnectionContextBase.create = create;
    })(ConnectionContextBase || (ConnectionContextBase = {}));

    /**
     * @internal
     */
    var ConnectionContext;
    (function (ConnectionContext) {
        /**
         * @property {string} userAgent The user agent string for the ServiceBus client.
         * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk
         */
        ConnectionContext.userAgent = `azsdk-js-azureservicebus/${packageJsonInfo.version} (NODE-VERSION ${browser.version}; ${type()} ${release()})`;
        function create(config, tokenProvider, options) {
            if (!options)
                options = {};
            const parameters = {
                config: config,
                tokenProvider: tokenProvider,
                dataTransformer: options.dataTransformer,
                isEntityPathRequired: false,
                connectionProperties: {
                    product: "MSJSClient",
                    userAgent: ConnectionContext.userAgent,
                    version: packageJsonInfo.version
                }
            };
            // Let us create the base context and then add ServiceBus specific ConnectionContext properties.
            const connectionContext = ConnectionContextBase.create(parameters);
            connectionContext.clientContexts = {};
            // Define listeners to be added to the connection object for
            // "connection_open" and "connection_error" events.
            const onConnectionOpen = (context) => {
                connectionContext.wasConnectionCloseCalled = false;
                connectionCtxt("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
            };
            const disconnected = (context) => __awaiter(this, void 0, void 0, function* () {
                const connectionError = context.connection && context.connection.error ? context.connection.error : undefined;
                if (connectionError) {
                    error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, connectionError);
                }
                const contextError = context.error;
                if (contextError) {
                    error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, contextError);
                }
                const state = {
                    wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                    numClients: Object.keys(connectionContext.clientContexts).length
                };
                // Clear internal map maintained by rhea to avoid reconnecting of old links once the
                // connection is back up.
                connectionContext.connection.removeAllSessions();
                // Close the cbs session to ensure all the event handlers are released.
                yield connectionContext.cbsSession.close();
                // Close the management sessions to ensure all the event handlers are released.
                for (const id of Object.keys(connectionContext.clientContexts)) {
                    const clientContext = connectionContext.clientContexts[id];
                    if (clientContext.managementClient) {
                        yield clientContext.managementClient.close();
                    }
                }
                // The connection should always be brought back up if the sdk did not call connection.close()
                // and there was atleast one sender/receiver link on the connection before it went down.
                error("[%s] state: %O", connectionContext.connectionId, state);
                if (!state.wasConnectionCloseCalled && state.numClients) {
                    error("[%s] connection.close() was not called from the sdk and there were some " +
                        "clients. We should reconnect.", connectionContext.connection.id);
                    yield delay(connectionReconnectDelay);
                    // reconnect clients if any
                    for (const id of Object.keys(connectionContext.clientContexts)) {
                        const clientContext = connectionContext.clientContexts[id];
                        error("[%s] calling detached on client '%s'.", connectionContext.connection.id, clientContext.clientId);
                        clientContext.onDetached(connectionError || contextError).catch((err) => {
                            error("[%s] An error occurred while reconnecting the sender '%s': %O.", connectionContext.connection.id, clientContext.clientId, err);
                        });
                    }
                }
            });
            const protocolError = (context) => __awaiter(this, void 0, void 0, function* () {
                if (context.connection && context.connection.error) {
                    error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
                }
                if (context.error) {
                    error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.error);
                }
            });
            const error$1 = (context) => __awaiter(this, void 0, void 0, function* () {
                if (context.connection && context.connection.error) {
                    error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
                }
                if (context.error) {
                    error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.error);
                }
            });
            // Add listeners on the connection object.
            connectionContext.connection.on(lib_9.connectionOpen, onConnectionOpen);
            connectionContext.connection.on(lib_9.disconnected, disconnected);
            connectionContext.connection.on(lib_9.protocolError, protocolError);
            connectionContext.connection.on(lib_9.error, error$1);
            connectionCtxt("[%s] Created connection context successfully.", connectionContext.connectionId);
            return connectionContext;
        }
        ConnectionContext.create = create;
    })(ConnectionContext || (ConnectionContext = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    /**
     * @internal
     */
    var ClientType;
    (function (ClientType) {
        ClientType["QueueClient"] = "QueueClient";
        ClientType["TopicClient"] = "TopicClient";
        ClientType["SubscriptionClient"] = "SubscriptionClient";
    })(ClientType || (ClientType = {}));

    var long_1 = Long;

    /**
     * wasm optimizations, to do native i64 multiplication and divide
     */
    var wasm = null;

    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
      ])), {}).exports;
    } catch (e) {
      // no wasm support :(
    }

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @constructor
     */
    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", { value: true });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = (0 <= value && value < 256)) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
                UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = (-128 <= value && value < 128)) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
                INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value))
            return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0)
                return UZERO;
            if (value >= TWO_PWR_64_DBL)
                return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL)
                return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
                return MAX_VALUE;
        }
        if (value < 0)
            return fromNumber(-value, unsigned).neg();
        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0)
            throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned,
            unsigned = false;
        } else {
            unsigned = !! unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('interior hyphen');
        else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromValue(val, unsigned) {
        if (typeof val === 'number')
            return fromNumber(val, unsigned);
        if (typeof val === 'string')
            return fromString(val, unsigned);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
    }

    /**
     * Converts the specified value to a Long using the appropriate from* function for its type.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long}
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000|0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else
                return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
     * @returns {boolean}
     */
    LongPrototype.eqz = LongPrototype.isZero;

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.ne = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.le = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend))
            addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);

        // use wasm support if present
        if (wasm) {
            var low = wasm.mul(this.low,
                               this.high,
                               multiplier.low,
                               multiplier.high);
            return fromBits(low, wasm.get_high(), this.unsigned);
        }

        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');

        // use wasm support if present
        if (wasm) {
            // guard against signed division overflow: the largest
            // negative number / -1 would be 1 larger than the largest
            // positive number, due to two's complement.
            if (!this.unsigned &&
                this.high === -0x80000000 &&
                divisor.low === -1 && divisor.high === -1) {
                // be consistent with non-wasm code path
                return this;
            }
            var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
                this.low,
                this.high,
                divisor.low,
                divisor.high
            );
            return fromBits(low, wasm.get_high(), this.unsigned);
        }

        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE))
                    return ONE;
                else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shr(1);
                    approx = halfThis.div(divisor).shl(1);
                    if (approx.eq(ZERO)) {
                        return divisor.isNegative() ? ONE : NEG_ONE;
                    } else {
                        rem = this.sub(divisor.mul(approx));
                        res = approx.add(rem.div(divisor));
                        return res;
                    }
                }
            } else if (divisor.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
                approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);

        // use wasm support if present
        if (wasm) {
            var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
                this.low,
                this.high,
                divisor.low,
                divisor.high
            );
            return fromBits(low, wasm.get_high(), this.unsigned);
        }

        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.rem = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };

    /**
     * Converts this Long to its byte representation.
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {!Array.<number>} Byte representation
     */
    LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    };

    /**
     * Converts this Long to its little endian byte representation.
     * @returns {!Array.<number>} Little endian byte representation
     */
    LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high,
            lo = this.low;
        return [
            lo        & 0xff,
            lo >>>  8 & 0xff,
            lo >>> 16 & 0xff,
            lo >>> 24       ,
            hi        & 0xff,
            hi >>>  8 & 0xff,
            hi >>> 16 & 0xff,
            hi >>> 24
        ];
    };

    /**
     * Converts this Long to its big endian byte representation.
     * @returns {!Array.<number>} Big endian byte representation
     */
    LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high,
            lo = this.low;
        return [
            hi >>> 24       ,
            hi >>> 16 & 0xff,
            hi >>>  8 & 0xff,
            hi        & 0xff,
            lo >>> 24       ,
            lo >>> 16 & 0xff,
            lo >>>  8 & 0xff,
            lo        & 0xff
        ];
    };

    /**
     * Creates a Long from its byte representation.
     * @param {!Array.<number>} bytes Byte representation
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {Long} The corresponding Long value
     */
    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    };

    /**
     * Creates a Long from its little endian byte representation.
     * @param {!Array.<number>} bytes Little endian byte representation
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {Long} The corresponding Long value
     */
    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long(
            bytes[0]       |
            bytes[1] <<  8 |
            bytes[2] << 16 |
            bytes[3] << 24,
            bytes[4]       |
            bytes[5] <<  8 |
            bytes[6] << 16 |
            bytes[7] << 24,
            unsigned
        );
    };

    /**
     * Creates a Long from its big endian byte representation.
     * @param {!Array.<number>} bytes Big endian byte representation
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {Long} The corresponding Long value
     */
    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long(
            bytes[4] << 24 |
            bytes[5] << 16 |
            bytes[6] <<  8 |
            bytes[7],
            bytes[0] << 24 |
            bytes[1] << 16 |
            bytes[2] <<  8 |
            bytes[3],
            unsigned
        );
    };

    /**
     * @internal
     * Provides a uniue name by appending a string guid to the given string in the following format:
     * `{name}-{uuid}`.
     * @param name The nme of the entity
     */
    function getUniqueName(name) {
        return `${name}-${lib_5()}`;
    }
    /**
     * @internal
     * If you try to turn a Guid into a Buffer in .NET, the bytes of the first three groups get
     * flipped within the group, but the last two groups don't get flipped, so we end up with a
     * different byte order. This is the order of bytes needed to make Service Bus recognize the token.
     *
     * @param lockToken The lock token whose bytes need to be reorded.
     * @returns Buffer - Buffer representing reordered bytes.
     */
    function reorderLockToken(lockTokenBytes) {
        if (!lockTokenBytes || !buffer_1.isBuffer(lockTokenBytes)) {
            return lockTokenBytes;
        }
        return buffer_1.from([
            lockTokenBytes[3],
            lockTokenBytes[2],
            lockTokenBytes[1],
            lockTokenBytes[0],
            lockTokenBytes[5],
            lockTokenBytes[4],
            lockTokenBytes[7],
            lockTokenBytes[6],
            lockTokenBytes[8],
            lockTokenBytes[9],
            lockTokenBytes[10],
            lockTokenBytes[11],
            lockTokenBytes[12],
            lockTokenBytes[13],
            lockTokenBytes[14],
            lockTokenBytes[15]
        ]);
    }
    /**
     * @internal
     * Provides the time in milliseconds after which the lock renewal should occur.
     * @param lockedUntilUtc - The time until which the message is locked.
     */
    function calculateRenewAfterDuration(lockedUntilUtc) {
        const now = Date.now();
        const lockedUntil = lockedUntilUtc.getTime();
        const remainingTime = lockedUntil - now;
        utils("Locked until utc  : %d", lockedUntil);
        utils("Current time is   : %d", now);
        utils("Remaining time is : %d", remainingTime);
        if (remainingTime < 1000) {
            return 0;
        }
        const buffer = Math.min(remainingTime / 2, 10000); // 10 seconds
        const renewAfter = remainingTime - buffer;
        utils("Renew after       : %d", renewAfter);
        return renewAfter;
    }
    /**
     * @internal
     * Converts the .net ticks to a JS Date object.
     *
     * - The epoch for the DateTimeOffset type is `0000-01-01`, while the epoch for JS Dates is
     * `1970-01-01`.
     * - The DateTimeOffset ticks value for the date `1970-01-01` is `621355968000000000`.
     *   - Hence, to convert it to the JS epoch; we `subtract` the delta from the given value.
     * - Ticks in DateTimeOffset is `1/10000000` second, while ticks in JS Date is `1/1000` second.
     *   - Thus, we `divide` the value by `10000` to convert it to JS Date ticks.
     *
     * @param buf Input as a Buffer
     * @returns Date The JS Date object.
     */
    function convertTicksToDate(buf) {
        const epochMicroDiff = 621355968000000000;
        const longValue = long_1.fromBytesBE(buf);
        const timeInMS = longValue
            .sub(epochMicroDiff)
            .div(10000)
            .toNumber();
        const result = new Date(timeInMS);
        utils("The converted date is: %s", result.toString());
        return result;
    }
    /**
     * @internal
     * Returns the number of logical processors in the system.
     */
    function getProcessorCount() {
        {
            return navigator.hardwareConcurrency || 1;
        }
    }
    /**
     * @internal
     * Converts any given input to a Buffer.
     * @param input The input that needs to be converted to a Buffer.
     */
    function toBuffer(input) {
        let result;
        utils("[utils.toBuffer] The given message body that needs to be converted to buffer is: ", input);
        if (isBuffer(input)) {
            result = input;
        }
        else {
            // string, undefined, null, boolean, array, object, number should end up here
            // coercing undefined to null as that will ensure that null value will be given to the
            // customer on receive.
            if (input === undefined)
                input = null;
            try {
                const inputStr = JSON.stringify(input);
                result = buffer_1.from(inputStr, "utf8");
            }
            catch (err) {
                const msg = `An error occurred while executing JSON.stringify() on the given input ` +
                    input +
                    `${err instanceof Error ? err.stack : JSON.stringify(err)}`;
                error("[utils.toBuffer] " + msg);
                throw err instanceof Error ? err : new Error(msg);
            }
        }
        utils("[utils.toBuffer] The converted buffer is: %O.", result);
        return result;
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @internal
     * Logs and throws Error if the current AMQP connection is closed.
     * @param context The ConnectionContext associated with the current AMQP connection.
     */
    function throwErrorIfConnectionClosed(context) {
        if (context && context.wasConnectionCloseCalled) {
            const errorMessage = "The underlying AMQP connection is closed.";
            const error$1 = new Error(errorMessage);
            error(`[${context.connectionId}] %O`, error$1);
            throw error$1;
        }
    }
    /**
     * @internal
     * Logs and throws error if the underlying AMQP connection or if the client is closed
     * @param context The ConnectionContext associated with the current AMQP connection.
     * @param entityPath Entity Path of the client which denotes the name of the Queue/Topic/Subscription
     * @param isClientClosed Boolean denoting if the client is closed or not
     */
    function throwErrorIfClientOrConnectionClosed(context, entityPath, isClientClosed) {
        throwErrorIfConnectionClosed(context);
        if (context && isClientClosed) {
            const errorMessage = getClientClosedErrorMsg(entityPath);
            const error$1 = new Error(errorMessage);
            error(`[${context.connectionId}] %O`, error$1);
            throw error$1;
        }
    }
    /**
     * @internal
     * Gets the error message when an open sender exists, but a new one is asked for on the same client
     * @param clientType 'QueueClient' or 'TopicClient'
     * @param entityPath  Value of the `entityPath` property on the client which denotes its name
     */
    function getOpenSenderErrorMsg(clientType, entityPath) {
        return (`An open sender already exists on the ${clientType} for "${entityPath}". ` +
            `Please close it and try again or use a new ${clientType} instance.`);
    }
    /**
     * @internal
     * Gets the error message when an open receiver exists, but a new one is asked for on the same client
     * @param clientType 'QueueClient' or 'SubscriptionClient'
     * @param entityPath  Value of the `entityPath` property on the client which denotes its name
     * @param sessionId If using session receiver, then the id of the session
     */
    function getOpenReceiverErrorMsg(clientType, entityPath, sessionId) {
        if (!sessionId) {
            return (`An open receiver already exists on the ${clientType} for "${entityPath}". ` +
                `Please close it and try again or use a new ${clientType} instance.`);
        }
        return (`An open receiver already exists for the session "${sessionId}" on the ${clientType} for ` +
            `"${entityPath}". Please close it and try again or use a new ${clientType} instance.`);
    }
    /**
     * @internal
     * Gets the error message when a client is used when its already closed
     * @param entityPath Value of the `entityPath` property on the client which denotes its name
     */
    function getClientClosedErrorMsg(entityPath) {
        return (`The client for "${entityPath}" has been closed and can no longer be used. ` +
            `Please create a new client using an instance of ServiceBusClient.`);
    }
    /**
     * @internal
     * Gets the error message when a sender is used when its already closed
     * @param entityPath Value of the `entityPath` property on the client which denotes its name
     * @param clientType One of "QueueClient", "TopicClient" or "SubscriptionClient", used for logging
     * @param isClientClosed Denotes if the close() was called on the client that created the sender
     */
    function getSenderClosedErrorMsg(entityPath, clientType, isClientClosed) {
        if (isClientClosed) {
            return (`The client for "${entityPath}" has been closed. The sender created by it can no longer be used. ` +
                `Please create a new client using an instance of ServiceBusClient.`);
        }
        return (`The sender for "${entityPath}" has been closed and can no longer be used. ` +
            `Please create a new sender using the "createSender" function on the ${clientType}.`);
    }
    /**
     * @internal
     * Gets the error message when a receiver is used when its already closed
     * @param entityPath Value of the `entityPath` property on the client which denotes its name
     * @param clientType One of "QueueClient", "TopicClient" or "SubscriptionClient", used for logging
     * @param isClientClosed Denotes if the close() was called on the client that created the sender
     * @param sessionId If using session receiver, then the id of the session
     */
    function getReceiverClosedErrorMsg(entityPath, clientType, isClientClosed, sessionId) {
        if (isClientClosed) {
            return (`The client for "${entityPath}" has been closed. The receiver created by it can no longer be used. ` +
                `Please create a new client using an instance of ServiceBusClient.`);
        }
        if (sessionId == undefined) {
            return (`The receiver for "${entityPath}" has been closed and can no longer be used. ` +
                `Please create a new receiver using the "createReceiver" function on the ${clientType}.`);
        }
        return (`The receiver for session "${sessionId}" in "${entityPath}" has been closed and can no ` +
            `longer be used. Please create a new receiver using the "createReceiver" function.`);
    }
    /**
     * @internal
     * @param entityPath Value of the `entityPath` property on the client which denotes its name
     * @param sessionId If using session receiver, then the id of the session
     */
    function getAlreadyReceivingErrorMsg(entityPath, sessionId) {
        if (sessionId == undefined) {
            return `The receiver for "${entityPath}" is already receiving messages.`;
        }
        return `The receiver for session "${sessionId}" for "${entityPath}" is already receiving messages.`;
    }
    /**
     * @internal
     * Logs and Throws TypeError if given parameter is undefined or null
     * @param connectionId Id of the underlying AMQP connection used for logging
     * @param parameterName Name of the parameter to check
     * @param parameterValue Value of the parameter to check
     */
    function throwTypeErrorIfParameterMissing(connectionId, parameterName, parameterValue) {
        if (parameterValue === undefined || parameterValue === null) {
            const error$1 = new TypeError(`Missing parameter "${parameterName}"`);
            error(`[${connectionId}] %O`, error$1);
            throw error$1;
        }
    }
    /**
     * @internal
     * Logs and Throws TypeError if given parameter is not of expected type
     * @param connectionId Id of the underlying AMQP connection used for logging
     * @param parameterName Name of the parameter to type check
     * @param parameterValue Value of the parameter to type check
     * @param expectedType Expected type of the parameter
     */
    function throwTypeErrorIfParameterTypeMismatch(connectionId, parameterName, parameterValue, expectedType) {
        if (typeof parameterValue !== expectedType) {
            const error$1 = new TypeError(`The parameter "${parameterName}" should be of type "${expectedType}"`);
            error(`[${connectionId}] %O`, error$1);
            throw error$1;
        }
    }
    /**
     * @internal
     * Logs and Throws TypeError if given parameter is not of type `Long`
     * @param connectionId Id of the underlying AMQP connection used for logging
     * @param parameterName Name of the parameter to type check
     * @param parameterValue Value of the parameter to type check
     */
    function throwTypeErrorIfParameterNotLong(connectionId, parameterName, parameterValue) {
        if (long_1.isLong(parameterValue)) {
            return;
        }
        const error$1 = new TypeError(`The parameter "${parameterName}" should be of type "Long"`);
        error(`[${connectionId}] %O`, error$1);
        throw error$1;
    }
    /**
     * @internal
     * Logs and Throws TypeError if given parameter is not an array of type `Long`
     * @param connectionId Id of the underlying AMQP connection used for logging
     * @param parameterName Name of the parameter to type check
     * @param parameterValue Value of the parameter to type check
     */
    function throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue) {
        if (parameterValue.every((item) => long_1.isLong(item))) {
            return;
        }
        const error$1 = new TypeError(`The parameter "${parameterName}" should be an array of type "Long"`);
        error(`[${connectionId}] %O`, error$1);
        throw error$1;
    }
    /**
     * @internal
     * Logs and Throws TypeError if given parameter is an empty string
     * @param connectionId Id of the underlying AMQP connection used for logging
     * @param parameterName Name of the parameter to type check
     * @param parameterValue Value of the parameter to type check
     */
    function throwTypeErrorIfParameterIsEmptyString(connectionId, parameterName, parameterValue) {
        if (parameterValue !== "") {
            return;
        }
        const error$1 = new TypeError(`Empty string not allowed in parameter "${parameterName}"`);
        error(`[${connectionId}] %O`, error$1);
        throw error$1;
    }
    /**
     * @internal
     * Gets error message for when an operation is not supported in ReceiveAndDelete mode
     * @param failedToDo A string to add to the placeholder in the error message. Denotes the action
     * that is not supported in ReceiveAndDelete mode
     */
    function getErrorMessageNotSupportedInReceiveAndDeleteMode(failedToDo) {
        return `Failed to ${failedToDo} as the operation is only supported in 'PeekLock' recieve mode.`;
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    (function (ReceiveMode) {
        /**
         * Once a message is received in this mode, the receiver has a lock on the message for a
         * particular duration. If the message is not settled by this time, it lands back on Service Bus
         * to be fetched by the next receive operation.
         * @type {Number}
         */
        ReceiveMode[ReceiveMode["peekLock"] = 1] = "peekLock";
        /**
         * Messages received in this mode get automatically removed from Service Bus.
         * @type {Number}
         */
        ReceiveMode[ReceiveMode["receiveAndDelete"] = 2] = "receiveAndDelete";
    })(exports.ReceiveMode || (exports.ReceiveMode = {}));
    /**
     * @internal
     */
    var DispositionType;
    (function (DispositionType) {
        DispositionType["complete"] = "complete";
        DispositionType["deadletter"] = "deadletter";
        DispositionType["abandon"] = "abandon";
        DispositionType["defer"] = "defer";
    })(DispositionType || (DispositionType = {}));
    /**
     * @internal
     */
    var DispositionStatus;
    (function (DispositionStatus) {
        DispositionStatus["completed"] = "completed";
        DispositionStatus["defered"] = "defered";
        DispositionStatus["suspended"] = "suspended";
        DispositionStatus["abandoned"] = "abandoned";
        DispositionStatus["renewed"] = "renewed";
    })(DispositionStatus || (DispositionStatus = {}));
    /**
     * @internal
     * Gets the error message for when a property on given message is not of expected type
     */
    function getMessagePropertyTypeMismatchError(msg) {
        if (msg.contentType != null && typeof msg.contentType !== "string") {
            return new TypeError("The property 'contentType' on the message must be of type 'string'");
        }
        if (msg.label != null && typeof msg.label !== "string") {
            return new TypeError("The property 'label' on the message must be of type 'string'");
        }
        if (msg.to != null && typeof msg.to !== "string") {
            return new TypeError("The property 'to' on the message must be of type 'string'");
        }
        if (msg.replyTo != null && typeof msg.replyTo !== "string") {
            return new TypeError("The property 'replyTo' on the message must be of type 'string'");
        }
        if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== "string") {
            return new TypeError("The property 'replyToSessionId' on the message must be of type 'string'");
        }
        if (msg.timeToLive != null && typeof msg.timeToLive !== "number") {
            return new TypeError("The property 'timeToLive' on the message must be of type 'number'");
        }
        if (msg.sessionId != null && typeof msg.sessionId !== "string") {
            return new TypeError("The property 'sessionId' on the message must be of type 'string'");
        }
        if (msg.messageId != null &&
            typeof msg.messageId !== "string" &&
            typeof msg.messageId !== "number" &&
            !buffer_1.isBuffer(msg.messageId)) {
            return new TypeError("The property 'messageId' on the message must be of type string, number or Buffer");
        }
        if (msg.correlationId != null &&
            typeof msg.correlationId !== "string" &&
            typeof msg.correlationId !== "number" &&
            !buffer_1.isBuffer(msg.correlationId)) {
            return new TypeError("The property 'correlationId' on the message must be of type string, number or Buffer");
        }
        return;
    }
    /**
     * @internal
     * Converts given SendableMessageInfo to AmqpMessage
     */
    function toAmqpMessage(msg) {
        const amqpMsg = {
            body: msg.body,
            message_annotations: {}
        };
        if (msg.userProperties != null) {
            amqpMsg.application_properties = msg.userProperties;
        }
        if (msg.contentType != null) {
            amqpMsg.content_type = msg.contentType;
        }
        if (msg.sessionId != null) {
            if (msg.sessionId.length > maxSessionIdLength) {
                throw new Error("Length of 'sessionId' property on the message cannot be greater than 128 characters.");
            }
            amqpMsg.group_id = msg.sessionId;
        }
        if (msg.replyTo != null) {
            amqpMsg.reply_to = msg.replyTo;
        }
        if (msg.to != null) {
            amqpMsg.to = msg.to;
        }
        if (msg.label != null) {
            amqpMsg.subject = msg.label;
        }
        if (msg.messageId != null) {
            if (typeof msg.messageId === "string" && msg.messageId.length > maxMessageIdLength) {
                throw new Error("Length of 'messageId' property on the message cannot be greater than 128 characters.");
            }
            amqpMsg.message_id = msg.messageId;
        }
        if (msg.correlationId != null) {
            amqpMsg.correlation_id = msg.correlationId;
        }
        if (msg.replyToSessionId != null) {
            amqpMsg.reply_to_group_id = msg.replyToSessionId;
        }
        if (msg.timeToLive != null && msg.timeToLive !== maxDurationValue) {
            amqpMsg.ttl = msg.timeToLive;
            amqpMsg.creation_time = Date.now();
            if (maxAbsoluteExpiryTime - amqpMsg.creation_time > amqpMsg.ttl) {
                amqpMsg.absolute_expiry_time = amqpMsg.creation_time + amqpMsg.ttl;
            }
            else {
                amqpMsg.absolute_expiry_time = maxAbsoluteExpiryTime;
            }
        }
        if (msg.partitionKey != null) {
            if (msg.partitionKey.length > maxPartitionKeyLength) {
                throw new Error("Length of 'partitionKey' property on the message cannot be greater than 128 characters.");
            }
            amqpMsg.message_annotations[partitionKey] = msg.partitionKey;
        }
        if (msg.viaPartitionKey != null) {
            if (msg.viaPartitionKey.length > maxPartitionKeyLength) {
                throw new Error("Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters.");
            }
            amqpMsg.message_annotations[viaPartitionKey] = msg.viaPartitionKey;
        }
        if (msg.scheduledEnqueueTimeUtc != null) {
            amqpMsg.message_annotations[scheduledEnqueueTime] = msg.scheduledEnqueueTimeUtc;
        }
        message("SBMessage to AmqpMessage: %O", amqpMsg);
        return amqpMsg;
    }
    /**
     * @ignore
     * Converts given AmqpMessage to ReceivedMessageInfo
     */
    function fromAmqpMessage(msg, delivery, shouldReorderLockToken) {
        if (!msg) {
            msg = {
                body: undefined
            };
        }
        const sbmsg = {
            body: msg.body
        };
        if (msg.application_properties != null) {
            sbmsg.userProperties = msg.application_properties;
        }
        if (msg.content_type != null) {
            sbmsg.contentType = msg.content_type;
        }
        if (msg.group_id != null) {
            sbmsg.sessionId = msg.group_id;
        }
        if (msg.reply_to != null) {
            sbmsg.replyTo = msg.reply_to;
        }
        if (msg.to != null) {
            sbmsg.to = msg.to;
        }
        if (msg.ttl != null) {
            sbmsg.timeToLive = msg.ttl;
        }
        if (msg.subject != null) {
            sbmsg.label = msg.subject;
        }
        if (msg.message_id != null) {
            sbmsg.messageId = msg.message_id;
        }
        if (msg.correlation_id != null) {
            sbmsg.correlationId = msg.correlation_id;
        }
        if (msg.reply_to_group_id != null) {
            sbmsg.replyToSessionId = msg.reply_to_group_id;
        }
        if (msg.message_annotations != null) {
            if (msg.message_annotations[partitionKey] != null) {
                sbmsg.partitionKey = msg.message_annotations[partitionKey];
            }
            if (msg.message_annotations[viaPartitionKey] != null) {
                sbmsg.viaPartitionKey = msg.message_annotations[viaPartitionKey];
            }
            if (msg.message_annotations[scheduledEnqueueTime] != null) {
                sbmsg.scheduledEnqueueTimeUtc = msg.message_annotations[scheduledEnqueueTime];
            }
        }
        const props = {};
        if (msg.message_annotations != null) {
            if (msg.message_annotations[deadLetterSource] != null) {
                props.deadLetterSource = msg.message_annotations[deadLetterSource];
            }
            if (msg.message_annotations[enqueueSequenceNumber] != null) {
                props.enqueuedSequenceNumber = msg.message_annotations[enqueueSequenceNumber];
            }
            if (msg.message_annotations[sequenceNumber] != null) {
                if (buffer_1.isBuffer(msg.message_annotations[sequenceNumber])) {
                    props.sequenceNumber = long_1.fromBytesBE(msg.message_annotations[sequenceNumber]);
                }
                else {
                    props.sequenceNumber = long_1.fromNumber(msg.message_annotations[sequenceNumber]);
                }
            }
            if (msg.message_annotations[enqueuedTime] != null) {
                props.enqueuedTimeUtc = new Date(msg.message_annotations[enqueuedTime]);
            }
            if (msg.message_annotations[lockedUntil] != null) {
                props.lockedUntilUtc = new Date(msg.message_annotations[lockedUntil]);
            }
        }
        if (msg.ttl != null && msg.ttl >= maxDurationValue - props.enqueuedTimeUtc.getTime()) {
            props.expiresAtUtc = new Date(maxDurationValue);
        }
        else {
            props.expiresAtUtc = new Date(props.enqueuedTimeUtc.getTime() + msg.ttl);
        }
        const rcvdsbmsg = Object.assign(Object.assign({ _amqpMessage: msg, _delivery: delivery, deliveryCount: msg.delivery_count, lockToken: delivery && delivery.tag && delivery.tag.length !== 0
                ? lib_4(shouldReorderLockToken === true
                    ? reorderLockToken(typeof delivery.tag === "string" ? buffer_1.from(delivery.tag) : delivery.tag)
                    : typeof delivery.tag === "string"
                        ? buffer_1.from(delivery.tag)
                        : delivery.tag)
                : undefined }, sbmsg), props);
        message("AmqpMessage to ReceivedSBMessage: %O", rcvdsbmsg);
        return rcvdsbmsg;
    }
    /**
     * Describes the message received from Service Bus.
     * @class ServiceBusMessage
     */
    class ServiceBusMessage {
        /**
         * @internal
         */
        constructor(context, msg, delivery, shouldReorderLockToken) {
            Object.assign(this, fromAmqpMessage(msg, delivery, shouldReorderLockToken));
            this._context = context;
            if (msg.body) {
                this.body = this._context.namespace.dataTransformer.decode(msg.body);
            }
            this._amqpMessage = msg;
            this.delivery = delivery;
        }
        /**
         * @property Boolean denoting if the message has already been settled.
         * @readonly
         */
        get isSettled() {
            return this.delivery.remote_settled;
        }
        /**
         * Removes the message from Service Bus.
         *
         * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
         * if the AMQP link with which the message was received is no longer alive. This can
         * happen either because the lock on the session expired or the receiver was explicitly closed by
         * the user or the AMQP link got closed by the library due to network loss or service error.
         * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
         * if the lock on the message has expired or the AMQP link with which the message was received is
         * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
         * AMQP link got closed by the library due to network loss or service error.
         * @throws Error if the message is already settled. To avoid this error check the `isSettled`
         * property on the message if you are not sure whether the message is settled.
         * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
         * are pre-settled. To avoid this error, update your code to not settle a message which is received
         * in this mode.
         * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
         * the message in time. The message may or may not have been settled successfully.
         *
         * @returns Promise<void>.
         */
        complete() {
            return __awaiter(this, void 0, void 0, function* () {
                message("[%s] Completing the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
                if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                    yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.completed, {
                        sessionId: this.sessionId
                    });
                    // Remove the message from the internal map of deferred messages
                    this._context.requestResponseLockedMessages.delete(this.lockToken);
                    return;
                }
                const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
                this.throwIfMessageCannotBeSettled(receiver, DispositionType.complete);
                return receiver.settleMessage(this, DispositionType.complete);
            });
        }
        /**
         * The lock held on the message by the receiver is let go, making the message available again in
         * Service Bus for another receive operation.
         *
         * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
         * if the AMQP link with which the message was received is no longer alive. This can
         * happen either because the lock on the session expired or the receiver was explicitly closed by
         * the user or the AMQP link got closed by the library due to network loss or service error.
         * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
         * if the lock on the message has expired or the AMQP link with which the message was received is
         * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
         * AMQP link got closed by the library due to network loss or service error.
         * @throws Error if the message is already settled. To avoid this error check the `isSettled`
         * property on the message if you are not sure whether the message is settled.
         * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
         * are pre-settled. To avoid this error, update your code to not settle a message which is received
         * in this mode.
         * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
         * the message in time. The message may or may not have been settled successfully.
         *
         * @param propertiesToModify The properties of the message to modify while abandoning the message.
         *
         * @return Promise<void>.
         */
        abandon(propertiesToModify) {
            return __awaiter(this, void 0, void 0, function* () {
                // TODO: Figure out a mechanism to convert specified properties to message_annotations.
                message("[%s] Abandoning the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
                if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                    yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.abandoned, { propertiesToModify: propertiesToModify, sessionId: this.sessionId });
                    // Remove the message from the internal map of deferred messages
                    this._context.requestResponseLockedMessages.delete(this.lockToken);
                    return;
                }
                const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
                this.throwIfMessageCannotBeSettled(receiver, DispositionType.abandon);
                return receiver.settleMessage(this, DispositionType.abandon, {
                    propertiesToModify: propertiesToModify
                });
            });
        }
        /**
         * Defers the processing of the message. Save the `sequenceNumber` of the message, in order to
         * receive it message again in the future using the `receiveDeferredMessage` method.
         *
         * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
         * if the AMQP link with which the message was received is no longer alive. This can
         * happen either because the lock on the session expired or the receiver was explicitly closed by
         * the user or the AMQP link got closed by the library due to network loss or service error.
         * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
         * if the lock on the message has expired or the AMQP link with which the message was received is
         * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
         * AMQP link got closed by the library due to network loss or service error.
         * @throws Error if the message is already settled. To avoid this error check the `isSettled`
         * property on the message if you are not sure whether the message is settled.
         * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
         * are pre-settled. To avoid this error, update your code to not settle a message which is received
         * in this mode.
         * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
         * the message in time. The message may or may not have been settled successfully.
         *
         * @param propertiesToModify The properties of the message to modify while deferring the message
         *
         * @returns Promise<void>
         */
        defer(propertiesToModify) {
            return __awaiter(this, void 0, void 0, function* () {
                message("[%s] Deferring the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
                if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                    yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.defered, { propertiesToModify: propertiesToModify, sessionId: this.sessionId });
                    // Remove the message from the internal map of deferred messages
                    this._context.requestResponseLockedMessages.delete(this.lockToken);
                    return;
                }
                const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
                this.throwIfMessageCannotBeSettled(receiver, DispositionType.defer);
                return receiver.settleMessage(this, DispositionType.defer, {
                    propertiesToModify: propertiesToModify
                });
            });
        }
        /**
         * Moves the message to the deadletter sub-queue. To receive a deadletted message, create a new
         * QueueClient/SubscriptionClient using the path for the deadletter sub-queue.
         *
         * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
         * if the AMQP link with which the message was received is no longer alive. This can
         * happen either because the lock on the session expired or the receiver was explicitly closed by
         * the user or the AMQP link got closed by the library due to network loss or service error.
         * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
         * if the lock on the message has expired or the AMQP link with which the message was received is
         * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
         * AMQP link got closed by the library due to network loss or service error.
         * @throws Error if the message is already settled. To avoid this error check the `isSettled`
         * property on the message if you are not sure whether the message is settled.
         * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
         * are pre-settled. To avoid this error, update your code to not settle a message which is received
         * in this mode.
         * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
         * the message in time. The message may or may not have been settled successfully.
         *
         * @param options The DeadLetter options that can be provided while
         * rejecting the message.
         *
         * @returns Promise<void>
         */
        deadLetter(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const error = {
                    condition: deadLetterName
                };
                if (options) {
                    error.info = {
                        DeadLetterReason: options.deadletterReason,
                        DeadLetterErrorDescription: options.deadLetterErrorDescription
                    };
                }
                message("[%s] Deadlettering the message with id '%s'.", this._context.namespace.connectionId, this.messageId);
                if (this._context.requestResponseLockedMessages.has(this.lockToken)) {
                    yield this._context.managementClient.updateDispositionStatus(this.lockToken, DispositionStatus.suspended, {
                        deadLetterReason: error.condition,
                        deadLetterDescription: error.description,
                        sessionId: this.sessionId
                    });
                    // Remove the message from the internal map of deferred messages
                    this._context.requestResponseLockedMessages.delete(this.lockToken);
                    return;
                }
                const receiver = this._context.getReceiver(this.delivery.link.name, this.sessionId);
                this.throwIfMessageCannotBeSettled(receiver, DispositionType.deadletter);
                return receiver.settleMessage(this, DispositionType.deadletter, {
                    error: error
                });
            });
        }
        /**
         * Creates a clone of the current message to allow it to be re-sent to the queue
         * @returns ServiceBusMessage
         */
        clone() {
            // We are returning a SendableMessageInfo object because that object can then be sent to Service Bus
            const clone = {
                body: this.body,
                contentType: this.contentType,
                correlationId: this.correlationId,
                label: this.label,
                messageId: this.messageId,
                partitionKey: this.partitionKey,
                replyTo: this.replyTo,
                replyToSessionId: this.replyToSessionId,
                scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,
                sessionId: this.sessionId,
                timeToLive: this.timeToLive,
                to: this.to,
                userProperties: this.userProperties,
                viaPartitionKey: this.viaPartitionKey
            };
            return clone;
        }
        /**
         * @private
         * Logs and Throws an error if the given message cannot be settled.
         * @param receiver Receiver to be used to settle this message
         * @param operation Settle operation: complete, abandon, defer or deadLetter
         */
        throwIfMessageCannotBeSettled(receiver, operation) {
            let error$1;
            if (receiver && receiver.receiveMode !== exports.ReceiveMode.peekLock) {
                error$1 = new Error(getErrorMessageNotSupportedInReceiveAndDeleteMode(`${operation} the message`));
            }
            else if (this.delivery.remote_settled) {
                error$1 = new Error(`Failed to ${operation} the message as this message is already settled.`);
            }
            else if (!receiver || !receiver.isOpen()) {
                const errorMessage = `Failed to ${operation} the message as the AMQP link with which the message was ` +
                    `received is no longer alive.`;
                if (this.sessionId != undefined) {
                    error$1 = translate({
                        description: errorMessage,
                        condition: ErrorNameConditionMapper.SessionLockLostError
                    });
                }
                else {
                    error$1 = translate({
                        description: errorMessage,
                        condition: ErrorNameConditionMapper.MessageLockLostError
                    });
                }
            }
            if (!error$1) {
                return;
            }
            error("[%s] An error occured when settling a message with id '%s'. " +
                "This message was received using the receiver %s which %s currently open: %O", this._context.namespace.connectionId, this.messageId, this.delivery.link.name, this.delivery.link.is_open() ? "is" : "is not", error$1);
            throw error$1;
        }
    }
    //# sourceMappingURL=serviceBusMessage.js.map

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @internal
     * Describes the base class for entities like MessageSender, MessageReceiver and Management client.
     * @class ClientEntity
     */
    class LinkEntity {
        /**
         * Creates a new ClientEntity instance.
         * @constructor
         * @param {ClientEntityContext} context The connection context.
         * @param {LinkEntityOptions} [options] Options that can be provided while creating the LinkEntity.
         */
        constructor(name, context, options) {
            /**
             * @property {boolean} isConnecting Indicates whether the link is in the process of connecting
             * (establishing) itself. Default value: `false`.
             */
            this.isConnecting = false;
            if (!options)
                options = {};
            this._context = context;
            this.address = options.address || "";
            this.audience = options.audience || "";
            this.name = getUniqueName(name);
        }
        /**
         * Negotiates the cbs claim for the ClientEntity.
         * @protected
         * @param {boolean} [setTokenRenewal] Set the token renewal timer. Default false.
         * @return {Promise<void>} Promise<void>
         */
        _negotiateClaim(setTokenRenewal) {
            return __awaiter(this, void 0, void 0, function* () {
                // Acquire the lock and establish a cbs session if it does not exist on the connection.
                // Although node.js is single threaded, we need a locking mechanism to ensure that a
                // race condition does not happen while creating a shared resource (in this case the
                // cbs session, since we want to have exactly 1 cbs session per connection).
                link("[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: " +
                    "'%s' with address: '%s'.", this._context.namespace.connectionId, this._context.namespace.cbsSession.cbsLock, this._type, this.name, this.address);
                yield defaultLock.acquire(this._context.namespace.cbsSession.cbsLock, () => {
                    return this._context.namespace.cbsSession.init();
                });
                const tokenObject = yield this._context.namespace.tokenProvider.getToken(this.audience);
                link("[%s] %s: calling negotiateClaim for audience '%s'.", this._context.namespace.connectionId, this._type, this.audience);
                // Acquire the lock to negotiate the CBS claim.
                link("[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.", this._context.namespace.connectionId, this._context.namespace.negotiateClaimLock, this._type, this.name, this.address);
                yield defaultLock.acquire(this._context.namespace.negotiateClaimLock, () => {
                    return this._context.namespace.cbsSession.negotiateClaim(this.audience, tokenObject);
                });
                link("[%s] Negotiated claim for %s '%s' with with address: %s", this._context.namespace.connectionId, this._type, this.name, this.address);
                if (setTokenRenewal) {
                    yield this._ensureTokenRenewal();
                }
            });
        }
        /**
         * Ensures that the token is renewed within the predefined renewal margin.
         * @protected
         * @returns {void}
         */
        _ensureTokenRenewal() {
            return __awaiter(this, void 0, void 0, function* () {
                const tokenValidTimeInSeconds = this._context.namespace.tokenProvider.tokenValidTimeInSeconds;
                const tokenRenewalMarginInSeconds = this._context.namespace.tokenProvider
                    .tokenRenewalMarginInSeconds;
                const nextRenewalTimeout = (tokenValidTimeInSeconds - tokenRenewalMarginInSeconds) * 1000;
                this._tokenRenewalTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield this._negotiateClaim(true);
                    }
                    catch (err) {
                        // TODO: May be add some retries over here before emitting the error.
                        error("[%s] %s '%s' with address %s, an error occurred while renewing the token: %O", this._context.namespace.connectionId, this._type, this.name, this.address, err);
                    }
                }), nextRenewalTimeout);
                link("[%s] %s '%s' with address %s, has next token renewal in %d seconds @(%s).", this._context.namespace.connectionId, this._type, this.name, this.address, nextRenewalTimeout / 1000, new Date(Date.now() + nextRenewalTimeout).toString());
            });
        }
        /**
         * Closes the Sender|Receiver link and it's underlying session and also removes it from the
         * internal map.
         *
         * @param {Sender | Receiver} [link] The Sender or Receiver link that needs to be closed and
         * removed.
         */
        _closeLink(link$1) {
            return __awaiter(this, void 0, void 0, function* () {
                clearTimeout(this._tokenRenewalTimer);
                if (link$1) {
                    try {
                        // This should take care of closing the link and it's underlying session. This should also
                        // remove them from the internal map.
                        yield link$1.close();
                        link("[%s] %s '%s' with address '%s' closed.", this._context.namespace.connectionId, this._type, this.name, this.address);
                    }
                    catch (err) {
                        error("[%s] An error occurred while closing the %s '%s': %O", this._context.namespace.connectionId, this._type, this.name, this.address, err);
                    }
                }
            });
        }
        /**
         * Provides the current type of the ClientEntity.
         * @return {string} The entity type.
         */
        get _type() {
            let result = "LinkEntity";
            if (this.constructor && this.constructor.name) {
                result = this.constructor.name;
            }
            return result;
        }
    }
    //# sourceMappingURL=linkEntity.js.map

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @internal
     * Describes the MessageSender that will send messages to ServiceBus.
     * @class MessageSender
     */
    class MessageSender extends LinkEntity {
        /**
         * Creates a new MessageSender instance.
         * @constructor
         * @param {ClientEntityContext} context The client entity context.
         */
        constructor(context) {
            super(context.entityPath, context, {
                address: context.entityPath,
                audience: `${context.namespace.config.endpoint}${context.entityPath}`
            });
            /**
             * @property {string} senderLock The unqiue lock name per connection that is used to acquire the
             * lock for establishing a sender link by an entity on that connection.
             * @readonly
             */
            this.senderLock = `sender-${lib_5()}`;
            this._onAmqpError = (context) => {
                const senderError = context.sender && context.sender.error;
                if (senderError) {
                    const err = translate(senderError);
                    error("[%s] An error occurred for sender '%s': %O.", this._context.namespace.connectionId, this.name, err);
                }
            };
            this._onSessionError = (context) => {
                const sessionError = context.session && context.session.error;
                if (sessionError) {
                    const err = translate(sessionError);
                    error("[%s] An error occurred on the session of sender '%s': %O.", this._context.namespace.connectionId, this.name, err);
                }
            };
            this._onAmqpClose = (context) => __awaiter(this, void 0, void 0, function* () {
                const sender = this._sender || context.sender;
                const senderError = context.sender && context.sender.error;
                if (senderError) {
                    error("[%s] 'sender_close' event occurred for sender '%s' with address '%s'. " +
                        "The associated error is: %O", this._context.namespace.connectionId, this.name, this.address, senderError);
                }
                if (sender && !sender.isItselfClosed()) {
                    if (!this.isConnecting) {
                        error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                            "and the sdk did not initiate this. The sender is not reconnecting. Hence, calling " +
                            "detached from the _onAmqpClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                        yield this.onDetached(senderError);
                    }
                    else {
                        error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                            "and the sdk did not initate this. Moreover the sender is already re-connecting. " +
                            "Hence not calling detached from the _onAmqpClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                    }
                }
                else {
                    error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                        "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                        "() handler.", this._context.namespace.connectionId, this.name, this.address);
                }
            });
            this._onSessionClose = (context) => __awaiter(this, void 0, void 0, function* () {
                const sender = this._sender || context.sender;
                const sessionError = context.session && context.session.error;
                if (sessionError) {
                    error("[%s] 'session_close' event occurred for sender '%s' with address '%s'. " +
                        "The associated error is: %O", this._context.namespace.connectionId, this.name, this.address, sessionError);
                }
                if (sender && !sender.isSessionItselfClosed()) {
                    if (!this.isConnecting) {
                        error("[%s] 'session_close' event occurred on the session of sender '%s' with " +
                            "address '%s' and the sdk did not initiate this. Hence calling detached from the " +
                            "_onSessionClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                        yield this.onDetached(sessionError);
                    }
                    else {
                        error("[%s] 'session_close' event occurred on the session of sender '%s' with " +
                            "address '%s' and the sdk did not initiate this. Moreover the sender is already " +
                            "re-connecting. Hence not calling detached from the _onSessionClose() handler.", this._context.namespace.connectionId, this.name, this.address);
                    }
                }
                else {
                    error("[%s] 'session_close' event occurred on the session of sender '%s' with address " +
                        "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                        "() handler.", this._context.namespace.connectionId, this.name, this.address);
                }
            });
        }
        _deleteFromCache() {
            this._sender = undefined;
            delete this._context.sender;
            error("[%s] Deleted the sender '%s' with address '%s' from the client cache.", this._context.namespace.connectionId, this.name, this.address);
        }
        _createSenderOptions(options) {
            if (options.newName)
                this.name = getUniqueName(this._context.entityPath);
            const srOptions = {
                name: this.name,
                target: {
                    address: this.address
                },
                onError: this._onAmqpError,
                onClose: this._onAmqpClose,
                onSessionError: this._onSessionError,
                onSessionClose: this._onSessionClose
            };
            sender("Creating sender with options: %O", srOptions);
            return srOptions;
        }
        /**
         * Tries to send the message to ServiceBus if there is enough credit to send them
         * and the circular buffer has available space to settle the message after sending them.
         *
         * We have implemented a synchronous send over here in the sense that we shall be waiting
         * for the message to be accepted or rejected and accordingly resolve or reject the promise.
         *
         * @param encodedMessage The encoded message to be sent to ServiceBus.
         * @param sendBatch Boolean indicating whether the encoded message represents a batch of messages or not
         * @return {Promise<Delivery>} Promise<Delivery>
         */
        _trySend(encodedMessage, sendBatch) {
            const sendEventPromise = () => new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let waitTimer;
                sender("[%s] Sender '%s', credit: %d available: %d", this._context.namespace.connectionId, this.name, this._sender.credit, this._sender.session.outgoing.available());
                if (!this._sender.sendable()) {
                    sender("[%s] Sender '%s', waiting for 1 second for sender to become sendable", this._context.namespace.connectionId, this.name);
                    yield delay(1000);
                    sender("[%s] Sender '%s' after waiting for a second, credit: %d available: %d", this._context.namespace.connectionId, this.name, this._sender.credit, this._sender.session.outgoing.available());
                }
                if (this._sender.sendable()) {
                    let onRejected;
                    let onReleased;
                    let onModified;
                    let onAccepted;
                    const removeListeners = () => {
                        clearTimeout(waitTimer);
                        // When `removeListeners` is called on timeout, the sender might be closed and cleared
                        // So, check if it exists, before removing listeners from it.
                        if (this._sender) {
                            this._sender.removeListener(lib_8.rejected, onRejected);
                            this._sender.removeListener(lib_8.accepted, onAccepted);
                            this._sender.removeListener(lib_8.released, onReleased);
                            this._sender.removeListener(lib_8.modified, onModified);
                        }
                    };
                    onAccepted = (context) => {
                        // Since we will be adding listener for accepted and rejected event every time
                        // we send a message, we need to remove listener for both the events.
                        // This will ensure duplicate listeners are not added for the same event.
                        removeListeners();
                        sender("[%s] Sender '%s', got event accepted.", this._context.namespace.connectionId, this.name);
                        resolve();
                    };
                    onRejected = (context) => {
                        removeListeners();
                        error("[%s] Sender '%s', got event rejected.", this._context.namespace.connectionId, this.name);
                        const err = translate(context.delivery.remote_state.error);
                        reject(err);
                    };
                    onReleased = (context) => {
                        removeListeners();
                        error("[%s] Sender '%s', got event released.", this._context.namespace.connectionId, this.name);
                        let err;
                        if (context.delivery.remote_state.error) {
                            err = translate(context.delivery.remote_state.error);
                        }
                        else {
                            err = new Error(`[${this._context.namespace.connectionId}]Sender '${this.name}', ` +
                                `received a release disposition.Hence we are rejecting the promise.`);
                        }
                        reject(err);
                    };
                    onModified = (context) => {
                        removeListeners();
                        error("[%s] Sender '%s', got event modified.", this._context.namespace.connectionId, this.name);
                        let err;
                        if (context.delivery.remote_state.error) {
                            err = translate(context.delivery.remote_state.error);
                        }
                        else {
                            err = new Error(`[${this._context.namespace.connectionId}]Sender "${this.name}", ` +
                                `received a modified disposition.Hence we are rejecting the promise.`);
                        }
                        reject(err);
                    };
                    const actionAfterTimeout = () => {
                        removeListeners();
                        const desc = `[${this._context.namespace.connectionId}] Sender "${this.name}" ` +
                            `with address "${this.address}", was not able to send the message right now, due ` +
                            `to operation timeout.`;
                        error(desc);
                        const e = {
                            condition: ErrorNameConditionMapper.ServiceUnavailableError,
                            description: desc
                        };
                        return reject(translate(e));
                    };
                    this._sender.on(lib_8.accepted, onAccepted);
                    this._sender.on(lib_8.rejected, onRejected);
                    this._sender.on(lib_8.modified, onModified);
                    this._sender.on(lib_8.released, onReleased);
                    waitTimer = setTimeout(actionAfterTimeout, defaultOperationTimeoutInSeconds * 1000);
                    try {
                        const delivery = this._sender.send(encodedMessage, undefined, sendBatch ? 0x80013700 : 0);
                        sender("[%s] Sender '%s', sent message with delivery id: %d", this._context.namespace.connectionId, this.name, delivery.id);
                    }
                    catch (error) {
                        removeListeners();
                        return reject(error);
                    }
                }
                else {
                    // let us retry to send the message after some time.
                    const msg = `[${this._context.namespace.connectionId}] Sender "${this.name}", ` +
                        `cannot send the message right now. Please try later.`;
                    error(msg);
                    const amqpError = {
                        condition: ErrorNameConditionMapper.SenderBusyError,
                        description: msg
                    };
                    reject(translate(amqpError));
                }
            }));
            const jitterInSeconds = randomNumberFromInterval(1, 4);
            const config = {
                operation: sendEventPromise,
                connectionId: this._context.namespace.connectionId,
                operationType: RetryOperationType.sendMessage,
                times: defaultRetryAttempts,
                delayInSeconds: defaultDelayBetweenOperationRetriesInSeconds + jitterInSeconds
            };
            return retry$1(config);
        }
        /**
         * Initializes the sender session on the connection.
         */
        _init(options) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // isOpen isConnecting  Should establish
                    // true     false          No
                    // true     true           No
                    // false    true           No
                    // false    false          Yes
                    if (!this.isOpen()) {
                        error("[%s] The sender '%s' with address '%s' is not open and is not currently " +
                            "establishing itself. Hence let's try to connect.", this._context.namespace.connectionId, this.name, this.address);
                        this.isConnecting = true;
                        yield this._negotiateClaim();
                        error("[%s] Trying to create sender '%s'...", this._context.namespace.connectionId, this.name);
                        if (!options) {
                            options = this._createSenderOptions({});
                        }
                        this._sender = yield this._context.namespace.connection.createSender(options);
                        this.isConnecting = false;
                        error("[%s] Sender '%s' with address '%s' has established itself.", this._context.namespace.connectionId, this.name, this.address);
                        this._sender.setMaxListeners(1000);
                        error("[%s] Promise to create the sender resolved. Created sender with name: %s", this._context.namespace.connectionId, this.name);
                        error("[%s] Sender '%s' created with sender options: %O", this._context.namespace.connectionId, this.name, options);
                        // It is possible for someone to close the sender and then start it again.
                        // Thus make sure that the sender is present in the client cache.
                        if (!this._sender)
                            this._context.sender = this;
                        yield this._ensureTokenRenewal();
                    }
                }
                catch (err) {
                    err = translate(err);
                    error("[%s] An error occurred while creating the sender %s", this._context.namespace.connectionId, this.name, err);
                    throw err;
                }
            });
        }
        /**
         * Will reconnect the sender link if necessary.
         * @param {AmqpError | Error} [senderError] The sender error if any.
         * @returns {Promise<void>} Promise<void>.
         */
        onDetached(senderError) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const wasCloseInitiated = this._sender && this._sender.isItselfClosed();
                    // Clears the token renewal timer. Closes the link and its session if they are open.
                    // Removes the link and its session if they are present in rhea's cache.
                    yield this._closeLink(this._sender);
                    // We should attempt to reopen only when the sender(sdk) did not initiate the close
                    let shouldReopen = false;
                    if (senderError && !wasCloseInitiated) {
                        const translatedError = translate(senderError);
                        if (translatedError.retryable) {
                            shouldReopen = true;
                            error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                                "was an accompanying error an it is retryable. This is a candidate for re-establishing " +
                                "the sender link.", this._context.namespace.connectionId, this.name, this.address);
                        }
                        else {
                            error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                                "was an accompanying error and it is NOT retryable. Hence NOT re-establishing " +
                                "the sender link.", this._context.namespace.connectionId, this.name, this.address);
                        }
                    }
                    else if (!wasCloseInitiated) {
                        shouldReopen = true;
                        error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                            "was no accompanying error as well. This is a candidate for re-establishing " +
                            "the sender link.", this._context.namespace.connectionId, this.name, this.address);
                    }
                    else {
                        const state = {
                            wasCloseInitiated: wasCloseInitiated,
                            senderError: senderError,
                            _sender: this._sender
                        };
                        error("[%s] Something went wrong. State of sender '%s' with address '%s' is: %O", this._context.namespace.connectionId, this.name, this.address, state);
                    }
                    if (shouldReopen) {
                        yield defaultLock.acquire(this.senderLock, () => {
                            const options = this._createSenderOptions({
                                newName: true
                            });
                            // shall retry forever at an interval of 15 seconds if the error is a retryable error
                            // else bail out when the error is not retryable or the oepration succeeds.
                            const config = {
                                operation: () => this._init(options),
                                connectionId: this._context.namespace.connectionId,
                                operationType: RetryOperationType.senderLink,
                                times: defaultConnectionRetryAttempts,
                                connectionHost: this._context.namespace.config.host,
                                delayInSeconds: 15
                            };
                            return retry$1(config);
                        });
                    }
                }
                catch (err) {
                    error("[%s] An error occurred while processing detached() of Sender '%s' with address " +
                        "'%s': %O", this._context.namespace.connectionId, this.name, this.address, err);
                }
            });
        }
        /**
         * Deletes the sender fromt the context. Clears the token renewal timer. Closes the sender link.
         * @return {Promise<void>} Promise<void>
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._sender) {
                    sender("[%s] Closing the Sender for the entity '%s'.", this._context.namespace.connectionId, this._context.entityPath);
                    const senderLink = this._sender;
                    this._deleteFromCache();
                    yield this._closeLink(senderLink);
                }
            });
        }
        /**
         * Determines whether the AMQP sender link is open. If open then returns true else returns false.
         * @return {boolean} boolean
         */
        isOpen() {
            const result = this._sender && this._sender.isOpen();
            error("[%s] Sender '%s' with address '%s' is open? -> %s", this._context.namespace.connectionId, this.name, this.address, result);
            return result;
        }
        /**
         * Sends the given message, with the given options on this link
         *
         * @param {SendableMessageInfo} data Message to send.  Will be sent as UTF8-encoded JSON string.
         * @returns {Promise<void>}
         */
        send(data) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                try {
                    if (!this.isOpen()) {
                        sender("Acquiring lock %s for initializing the session, sender and " +
                            "possibly the connection.", this.senderLock);
                        yield defaultLock.acquire(this.senderLock, () => {
                            return this._init();
                        });
                    }
                    const amqpMessage = toAmqpMessage(data);
                    amqpMessage.body = this._context.namespace.dataTransformer.encode(data.body);
                    let encodedMessage;
                    try {
                        encodedMessage = lib_2.encode(amqpMessage);
                    }
                    catch (error) {
                        if (error instanceof TypeError || error.name === "TypeError") {
                            // `RheaMessageUtil.encode` can fail if message properties are of invalid type
                            // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too
                            // Errors in such cases do not have user friendy message or call stack
                            // So use `getMessagePropertyTypeMismatchError` to get a better error message
                            throw getMessagePropertyTypeMismatchError(data) || error;
                        }
                        throw error;
                    }
                    sender("[%s] Sender '%s', trying to send message: %O", this._context.namespace.connectionId, this.name, data);
                    return yield this._trySend(encodedMessage);
                }
                catch (err) {
                    error("[%s] Sender '%s': An error occurred while sending the message: %O\nError: %O", this._context.namespace.connectionId, this.name, data, err);
                    throw err;
                }
            });
        }
        /**
         * Send a batch of Message to the ServiceBus in a single AMQP message. The "message_annotations",
         * "application_properties" and "properties" of the first message will be set as that
         * of the envelope (batch message).
         * @param {Array<Message>} inputMessages  An array of Message objects to be sent in a
         * Batch message.
         * @return {Promise<void>}
         */
        sendBatch(inputMessages) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                try {
                    if (!Array.isArray(inputMessages)) {
                        inputMessages = [inputMessages];
                    }
                    if (!this.isOpen()) {
                        sender("Acquiring lock %s for initializing the session, sender and " +
                            "possibly the connection.", this.senderLock);
                        yield defaultLock.acquire(this.senderLock, () => {
                            return this._init();
                        });
                    }
                    sender("[%s] Sender '%s', trying to send Message[]: %O", this._context.namespace.connectionId, this.name, inputMessages);
                    const amqpMessages = [];
                    const encodedMessages = [];
                    // Convert Message to AmqpMessage.
                    for (let i = 0; i < inputMessages.length; i++) {
                        const amqpMessage = toAmqpMessage(inputMessages[i]);
                        amqpMessage.body = this._context.namespace.dataTransformer.encode(inputMessages[i].body);
                        amqpMessages[i] = amqpMessage;
                        try {
                            encodedMessages[i] = lib_2.encode(amqpMessage);
                        }
                        catch (error) {
                            if (error instanceof TypeError || error.name === "TypeError") {
                                throw getMessagePropertyTypeMismatchError(inputMessages[i]) || error;
                            }
                            throw error;
                        }
                    }
                    // Convert every encoded message to amqp data section
                    const batchMessage = {
                        body: lib_2.data_sections(encodedMessages)
                    };
                    // Set message_annotations, application_properties and properties of the first message as
                    // that of the envelope (batch message).
                    if (amqpMessages[0].message_annotations) {
                        batchMessage.message_annotations = amqpMessages[0].message_annotations;
                    }
                    if (amqpMessages[0].application_properties) {
                        batchMessage.application_properties = amqpMessages[0].application_properties;
                    }
                    for (const prop of lib_22) {
                        if (amqpMessages[0][prop]) {
                            batchMessage[prop] = amqpMessages[0][prop];
                        }
                    }
                    // Finally encode the envelope (batch message).
                    const encodedBatchMessage = lib_2.encode(batchMessage);
                    sender("[%s]Sender '%s', sending encoded batch message.", this._context.namespace.connectionId, this.name, encodedBatchMessage);
                    return yield this._trySend(encodedBatchMessage, true);
                }
                catch (err) {
                    error("[%s] Sender '%s': An error occurred while sending the messages: %O\nError: %O", this._context.namespace.connectionId, this.name, inputMessages, err);
                    throw err;
                }
            });
        }
        /**
         * Creates a new sender to the specifiec ServiceBus entity, and optionally to a given
         * partition if it is not present in the context or returns the one present in the context.
         * @static
         * @returns {Promise<MessageSender>}
         */
        static create(context) {
            throwErrorIfConnectionClosed(context.namespace);
            if (!context.sender) {
                context.sender = new MessageSender(context);
            }
            return context.sender;
        }
    }
    //# sourceMappingURL=messageSender.js.map

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * The Sender class can be used to send messages, schedule messages to be sent at a later time
     * and cancel such scheduled messages.
     * Use the `createSender` function on the QueueClient or TopicClient to instantiate a Sender.
     * The Sender class is an abstraction over the underlying AMQP sender link.
     * @class Sender
     */
    class Sender$1 {
        /**
         * @internal
         * @throws Error if the underlying connection is closed.
         */
        constructor(context) {
            /**
             * @property Denotes if close() was called on this sender
             */
            this._isClosed = false;
            throwErrorIfConnectionClosed(context.namespace);
            this._context = context;
        }
        _throwIfSenderOrConnectionClosed() {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (this.isClosed) {
                const errorMessage = getSenderClosedErrorMsg(this._context.entityPath, this._context.clientType, this._context.isClosed);
                const error$1 = new Error(errorMessage);
                error(`[${this._context.namespace.connectionId}] %O`, error$1);
                throw error$1;
            }
        }
        /**
         * @property Returns `true` if either the sender or the client that created it has been closed
         * @readonly
         */
        get isClosed() {
            return this._isClosed || this._context.isClosed;
        }
        /**
         * Sends the given message after creating an AMQP Sender link if it doesnt already exists.
         *
         * To send a message to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`
         * and/or `partitionKey` properties respectively on the message.
         *
         * @param message - Message to send.
         * @returns Promise<void>
         * @throws Error if the underlying connection, client or sender is closed.
         * @throws MessagingError if the service returns an error while sending messages to the service.
         */
        send(message) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfSenderOrConnectionClosed();
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "message", message);
                const sender = MessageSender.create(this._context);
                return sender.send(message);
            });
        }
        /**
         * Sends the given messages in a single batch i.e. in a single AMQP message after creating an AMQP
         * Sender link if it doesnt already exists.
         *
         * - To send messages to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`
         * and/or `partitionKey` properties respectively on the messages.
         * - When doing so, all
         * messages in the batch should have the same `sessionId` (if using sessions) and the same
         * `parititionKey` (if using paritions).
         *
         * @param messages - An array of SendableMessageInfo objects to be sent in a Batch message.
         * @return Promise<void>
         * @throws Error if the underlying connection, client or sender is closed.
         * @throws MessagingError if the service returns an error while sending messages to the service.
         */
        sendBatch(messages) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfSenderOrConnectionClosed();
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "messages", messages);
                if (!Array.isArray(messages)) {
                    messages = [messages];
                }
                const sender = MessageSender.create(this._context);
                return sender.sendBatch(messages);
            });
        }
        /**
         * Schedules given message to appear on Service Bus Queue/Subscription at a later time.
         *
         * Please note that you need to explicitly encode the message body if you intend to receive the message using a tool or library other than this library.
         * For example:
         *  1. Import DefaultDataTransformer and instantiate.
         *      ```js
         *        const dt = new DefaultDataTransformer();
         *      ```
         *  2. Use the `encode` method on the transformer to encode the message body before calling the scheduleMessage() method
         *      ```js
         *        message.body = dt.encode(message.body);
         *      ```
         *
         * @param scheduledEnqueueTimeUtc - The UTC time at which the message should be enqueued.
         * @param message - The message that needs to be scheduled.
         * @returns Promise<Long> - The sequence number of the message that was scheduled.
         * You will need the sequence number if you intend to cancel the scheduling of the message.
         * Save the `Long` type as-is in your application without converting to number. Since JavaScript
         * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.
         * @throws Error if the underlying connection, client or sender is closed.
         * @throws MessagingError if the service returns an error while scheduling a message.
         */
        scheduleMessage(scheduledEnqueueTimeUtc, message) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfSenderOrConnectionClosed();
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "scheduledEnqueueTimeUtc", scheduledEnqueueTimeUtc);
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "message", message);
                const messages = [message];
                const result = yield this._context.managementClient.scheduleMessages(scheduledEnqueueTimeUtc, messages);
                return result[0];
            });
        }
        /**
         * Schedules given messages to appear on Service Bus Queue/Subscription at a later time.
         *
         * Please note that you need to explicitly encode the message body if you intend to receive the message using a tool or library other than this library.
         * For example:
         *  1. Import DefaultDataTransformer and instantiate.
         *      ```js
         *        const dt = new DefaultDataTransformer();
         *      ```
         *  2. Use the `encode` method on the transformer to encode the message body before calling the scheduleMessage() method
         *      ```js
         *        message.body = dt.encode(message.body);
         *      ```
         *
         * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
         * @param messages - Array of Messages that need to be scheduled.
         * @returns Promise<Long[]> - The sequence numbers of messages that were scheduled.
         * You will need the sequence number if you intend to cancel the scheduling of the messages.
         * Save the `Long` type as-is in your application without converting to number. Since JavaScript
         * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.
         * @throws Error if the underlying connection, client or sender is closed.
         * @throws MessagingError if the service returns an error while scheduling messages.
         */
        scheduleMessages(scheduledEnqueueTimeUtc, messages) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfSenderOrConnectionClosed();
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "scheduledEnqueueTimeUtc", scheduledEnqueueTimeUtc);
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "messages", messages);
                if (!Array.isArray(messages)) {
                    messages = [messages];
                }
                return this._context.managementClient.scheduleMessages(scheduledEnqueueTimeUtc, messages);
            });
        }
        /**
         * Cancels a message that was scheduled to appear on a ServiceBus Queue/Subscription.
         * @param sequenceNumber - The sequence number of the message to be cancelled.
         * @returns Promise<void>
         * @throws Error if the underlying connection, client or sender is closed.
         * @throws MessagingError if the service returns an error while canceling a scheduled message.
         */
        cancelScheduledMessage(sequenceNumber) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfSenderOrConnectionClosed();
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
                throwTypeErrorIfParameterNotLong(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
                return this._context.managementClient.cancelScheduledMessages([sequenceNumber]);
            });
        }
        /**
         * Cancels multiple messages that were scheduled to appear on a ServiceBus Queue/Subscription.
         * @param sequenceNumbers - An Array of sequence numbers of the messages to be cancelled.
         * @returns Promise<void>
         * @throws Error if the underlying connection, client or sender is closed.
         * @throws MessagingError if the service returns an error while canceling scheduled messages.
         */
        cancelScheduledMessages(sequenceNumbers) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfSenderOrConnectionClosed();
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
                if (!Array.isArray(sequenceNumbers)) {
                    sequenceNumbers = [sequenceNumbers];
                }
                throwTypeErrorIfParameterNotLongArray(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
                return this._context.managementClient.cancelScheduledMessages(sequenceNumbers);
            });
        }
        /**
         * Closes the underlying AMQP sender link.
         * Once closed, the sender cannot be used for any further operations.
         * Use the `createSender` function on the QueueClient or TopicClient to instantiate a new Sender
         *
         * @returns {Promise<void>}
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    this._isClosed = true;
                    if (this._context.namespace.connection &&
                        this._context.namespace.connection.isOpen() &&
                        this._context.sender) {
                        yield this._context.sender.close();
                    }
                }
                catch (err) {
                    error("[%s] An error occurred while closing the Sender for %s: %O", this._context.namespace.connectionId, this._context.entityPath, err);
                    throw err;
                }
            });
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @internal
     */
    var ReceiverType;
    (function (ReceiverType) {
        ReceiverType["batching"] = "batching";
        ReceiverType["streaming"] = "streaming";
    })(ReceiverType || (ReceiverType = {}));
    /**
     * @internal
     * Describes the MessageReceiver that will receive messages from ServiceBus.
     * @class MessageReceiver
     */
    class MessageReceiver extends LinkEntity {
        constructor(context, receiverType, options) {
            super(context.entityPath, context, {
                address: context.entityPath,
                audience: `${context.namespace.config.endpoint}${context.entityPath}`
            });
            /**
             * @property {number} [maxConcurrentCalls] The maximum number of messages that should be
             * processed concurrently while in streaming mode. Once this limit has been reached, more
             * messages will not be received until the user's message handler has completed processing current message.
             * Default: 1
             */
            this.maxConcurrentCalls = 1;
            /**
             * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that
             * are being actively disposed. It acts as a store for correlating the responses received for
             * active dispositions.
             */
            this._deliveryDispositionMap = new Map();
            /**
             * @property {Map<string, Function>} _messageRenewLockTimers Maintains a map of messages for which
             * the lock is automatically renewed.
             * @protected
             */
            this._messageRenewLockTimers = new Map();
            if (!options)
                options = {};
            this.wasCloseInitiated = false;
            this.receiverType = receiverType;
            this.receiveMode = options.receiveMode || exports.ReceiveMode.peekLock;
            if (typeof options.maxConcurrentCalls === "number" && options.maxConcurrentCalls > 0) {
                this.maxConcurrentCalls = options.maxConcurrentCalls;
            }
            this.resetTimerOnNewMessageReceived = () => {
                /** */
            };
            // If explicitly set to false then autoComplete is false else true (default).
            this.autoComplete = options.autoComplete === false ? options.autoComplete : true;
            this.maxAutoRenewDurationInSeconds =
                options.maxMessageAutoRenewLockDurationInSeconds != null
                    ? options.maxMessageAutoRenewLockDurationInSeconds
                    : 300;
            this.autoRenewLock =
                this.maxAutoRenewDurationInSeconds > 0 && this.receiveMode === exports.ReceiveMode.peekLock;
            this._clearMessageLockRenewTimer = (messageId) => {
                if (this._messageRenewLockTimers.has(messageId)) {
                    clearTimeout(this._messageRenewLockTimers.get(messageId));
                    receiver("[%s] Cleared the message renew lock timer for message with id '%s'.", this._context.namespace.connectionId, messageId);
                    this._messageRenewLockTimers.delete(messageId);
                }
            };
            this._clearAllMessageLockRenewTimers = () => {
                receiver("[%s] Clearing message renew lock timers for all the active messages.", this._context.namespace.connectionId);
                for (const messageId of this._messageRenewLockTimers.keys()) {
                    this._clearMessageLockRenewTimer(messageId);
                }
            };
            // setting all the handlers
            this._onSettled = (context) => {
                const connectionId = this._context.namespace.connectionId;
                const delivery = context.delivery;
                if (delivery) {
                    const id = delivery.id;
                    const state = delivery.remote_state;
                    const settled = delivery.remote_settled;
                    receiver("[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been " + "received.", connectionId, id, settled, state && state.error ? state.error : state);
                    if (settled && this._deliveryDispositionMap.has(id)) {
                        const promise = this._deliveryDispositionMap.get(id);
                        clearTimeout(promise.timer);
                        receiver("[%s] Found the delivery with id %d in the map and cleared the timer.", connectionId, id);
                        const deleteResult = this._deliveryDispositionMap.delete(id);
                        receiver("[%s] Successfully deleted the delivery with id %d from the map.", connectionId, id, deleteResult);
                        if (state && state.error && (state.error.condition || state.error.description)) {
                            const error = translate(state.error);
                            return promise.reject(error);
                        }
                        return promise.resolve();
                    }
                }
            };
            this._onAmqpMessage = (context) => __awaiter(this, void 0, void 0, function* () {
                // If the receiver got closed in PeekLock mode, avoid processing the message as we
                // cannot settle the message.
                if (this.receiveMode === exports.ReceiveMode.peekLock &&
                    (!this._receiver || !this._receiver.isOpen())) {
                    error("[%s] Not calling the user's message handler for the current message " +
                        "as the receiver '%s' is closed", this._context.namespace.connectionId, this.name);
                    return;
                }
                this.resetTimerOnNewMessageReceived();
                const connectionId = this._context.namespace.connectionId;
                const bMessage = new ServiceBusMessage(this._context, context.message, context.delivery, true);
                if (this.autoRenewLock && bMessage.lockToken) {
                    const lockToken = bMessage.lockToken;
                    // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.
                    // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInSeconds
                    // - We should be able to clear the renewal timer when the user's message handler
                    // is done (whether it succeeds or fails).
                    // Setting the messageId with undefined value in the _messageRenewockTimers Map because we
                    // track state by checking the presence of messageId in the map. It is removed from the map
                    // when an attempt is made to settle the message (either by the user or by the sdk) OR
                    // when the execution of user's message handler completes.
                    this._messageRenewLockTimers.set(bMessage.messageId, undefined);
                    receiver("[%s] message with id '%s' is locked until %s.", connectionId, bMessage.messageId, bMessage.lockedUntilUtc.toString());
                    const totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;
                    receiver("[%s] Total autolockrenew duration for message with id '%s' is: ", connectionId, bMessage.messageId, new Date(totalAutoLockRenewDuration).toString());
                    const autoRenewLockTask = () => {
                        if (new Date(totalAutoLockRenewDuration) > bMessage.lockedUntilUtc &&
                            Date.now() < totalAutoLockRenewDuration) {
                            if (this._messageRenewLockTimers.has(bMessage.messageId)) {
                                // TODO: We can run into problems with clock skew between the client and the server.
                                // It would be better to calculate the duration based on the "lockDuration" property
                                // of the queue. However, we do not have the management plane of the client ready for
                                // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.
                                const amount = calculateRenewAfterDuration(bMessage.lockedUntilUtc);
                                receiver("[%s] Sleeping for %d milliseconds while renewing the lock for " +
                                    "message with id '%s' is: ", connectionId, amount, bMessage.messageId);
                                // Setting the value of the messageId to the actual timer. This will be cleared when
                                // an attempt is made to settle the message (either by the user or by the sdk) OR
                                // when the execution of user's message handler completes.
                                this._messageRenewLockTimers.set(bMessage.messageId, setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                                    try {
                                        receiver("[%s] Attempting to renew the lock for message with id '%s'.", connectionId, bMessage.messageId);
                                        bMessage.lockedUntilUtc = yield this._context.managementClient.renewLock(lockToken);
                                        receiver("[%s] Successfully renewed the lock for message with id '%s'.", connectionId, bMessage.messageId);
                                        receiver("[%s] Calling the autorenewlock task again for message with " + "id '%s'.", connectionId, bMessage.messageId);
                                        autoRenewLockTask();
                                    }
                                    catch (err) {
                                        error("[%s] An error occured while auto renewing the message lock '%s' " +
                                            "for message with id '%s': %O.", connectionId, bMessage.lockToken, bMessage.messageId, err);
                                        // Let the user know that there was an error renewing the message lock.
                                        this._onError(err);
                                    }
                                }), amount));
                            }
                            else {
                                receiver("[%s] Looks like the message lock renew timer has already been " +
                                    "cleared for message with id '%s'.", connectionId, bMessage.messageId);
                            }
                        }
                        else {
                            receiver("[%s] Current time %s exceeds the total autolockrenew duration %s for " +
                                "message with messageId '%s'. Hence we will stop the autoLockRenewTask.", connectionId, new Date(Date.now()).toString(), new Date(totalAutoLockRenewDuration).toString(), bMessage.messageId);
                            this._clearMessageLockRenewTimer(bMessage.messageId);
                        }
                    };
                    // start
                    autoRenewLockTask();
                }
                try {
                    yield this._onMessage(bMessage);
                    this._clearMessageLockRenewTimer(bMessage.messageId);
                }
                catch (err) {
                    // This ensures we call users' error handler when users' message handler throws.
                    if (!lib_19(err)) {
                        error("[%s] An error occurred while running user's message handler for the message " +
                            "with id '%s' on the receiver '%s': %O", connectionId, bMessage.messageId, this.name, err);
                        this._onError(err);
                    }
                    // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,
                    // doing this here. Otherwise, this should be done in finally.
                    this._clearMessageLockRenewTimer(bMessage.messageId);
                    const error$1 = translate(err);
                    // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                    if (!bMessage.delivery.remote_settled &&
                        error$1.name !== ConditionErrorNameMapper["com.microsoft:message-lock-lost"] &&
                        this.receiveMode === exports.ReceiveMode.peekLock &&
                        this.isOpen() // only try to abandon the messages if the connection is still open
                    ) {
                        try {
                            error("[%s] Abandoning the message with id '%s' on the receiver '%s' since " +
                                "an error occured: %O.", connectionId, bMessage.messageId, this.name, error$1);
                            yield bMessage.abandon();
                        }
                        catch (abandonError) {
                            const translatedError = translate(abandonError);
                            error("[%s] An error occurred while abandoning the message with id '%s' on the " +
                                "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                            this._onError(translatedError);
                        }
                    }
                    return;
                }
                finally {
                    if (this._receiver) {
                        this._receiver.addCredit(1);
                    }
                }
                // If we've made it this far, then user's message handler completed fine. Let us try
                // completing the message.
                if (this.autoComplete &&
                    this.receiveMode === exports.ReceiveMode.peekLock &&
                    !bMessage.delivery.remote_settled) {
                    try {
                        log[this.receiverType]("[%s] Auto completing the message with id '%s' on " + "the receiver '%s'.", connectionId, bMessage.messageId, this.name);
                        yield bMessage.complete();
                    }
                    catch (completeError) {
                        const translatedError = translate(completeError);
                        error("[%s] An error occurred while completing the message with id '%s' on the " +
                            "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                        this._onError(translatedError);
                    }
                }
            });
            this._onAmqpError = (context) => {
                const connectionId = this._context.namespace.connectionId;
                const receiver = this._receiver || context.receiver;
                const receiverError = context.receiver && context.receiver.error;
                if (receiverError) {
                    const sbError = translate(receiverError);
                    error("[%s] An error occurred for Receiver '%s': %O.", connectionId, this.name, sbError);
                    if (!sbError.retryable) {
                        if (receiver && !receiver.isItselfClosed()) {
                            error("[%s] Since the user did not close the receiver and the error is not " +
                                "retryable, we let the user know about it by calling the user's error handler.", connectionId);
                            this._onError(sbError);
                        }
                        else {
                            error("[%s] The received error is not retryable. However, the receiver was " +
                                "closed by the user. Hence not notifying the user's error handler.", connectionId);
                        }
                    }
                    else {
                        error("[%s] Since received error is retryable, we will NOT notify the user's " +
                            "error handler.", connectionId);
                    }
                }
                if (this._newMessageReceivedTimer) {
                    clearTimeout(this._newMessageReceivedTimer);
                }
            };
            this._onSessionError = (context) => {
                const connectionId = this._context.namespace.connectionId;
                const receiver = this._receiver || context.receiver;
                const sessionError = context.session && context.session.error;
                if (sessionError) {
                    const sbError = translate(sessionError);
                    error("[%s] An error occurred on the session for Receiver '%s': %O.", connectionId, this.name, sbError);
                    if (receiver && !receiver.isSessionItselfClosed() && !sbError.retryable) {
                        error("[%s] Since the user did not close the receiver and the session error is not " +
                            "retryable, we let the user know about it by calling the user's error handler.", connectionId);
                        this._onError(sbError);
                    }
                }
                if (this._newMessageReceivedTimer) {
                    clearTimeout(this._newMessageReceivedTimer);
                }
            };
            this._onAmqpClose = (context) => __awaiter(this, void 0, void 0, function* () {
                const connectionId = this._context.namespace.connectionId;
                const receiverError = context.receiver && context.receiver.error;
                const receiver = this._receiver || context.receiver;
                if (receiverError) {
                    error("[%s] 'receiver_close' event occurred for receiver '%s' with address '%s'. " +
                        "The associated error is: %O", connectionId, this.name, this.address, receiverError);
                }
                this._clearAllMessageLockRenewTimers();
                if (receiver && !receiver.isItselfClosed()) {
                    if (!this.isConnecting) {
                        error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                            "and the sdk did not initiate this. The receiver is not reconnecting. Hence, calling " +
                            "detached from the _onAmqpClose() handler.", connectionId, this.name, this.address);
                        yield this.onDetached(receiverError);
                    }
                    else {
                        error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                            "and the sdk did not initate this. Moreover the receiver is already re-connecting. " +
                            "Hence not calling detached from the _onAmqpClose() handler.", connectionId, this.name, this.address);
                    }
                }
                else {
                    error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                        "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                        "() handler.", connectionId, this.name, this.address);
                }
            });
            this._onSessionClose = (context) => __awaiter(this, void 0, void 0, function* () {
                const connectionId = this._context.namespace.connectionId;
                const receiver = this._receiver || context.receiver;
                const sessionError = context.session && context.session.error;
                if (sessionError) {
                    error("[%s] 'session_close' event occurred for receiver '%s' with address '%s'. " +
                        "The associated error is: %O", connectionId, this.name, this.address, sessionError);
                }
                this._clearAllMessageLockRenewTimers();
                if (receiver && !receiver.isSessionItselfClosed()) {
                    if (!this.isConnecting) {
                        error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                            "address '%s' and the sdk did not initiate this. Hence calling detached from the " +
                            "_onSessionClose() handler.", connectionId, this.name, this.address);
                        yield this.onDetached(sessionError);
                    }
                    else {
                        error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                            "address '%s' and the sdk did not initiate this. Moreover the receiver is already " +
                            "re-connecting. Hence not calling detached from the _onSessionClose() handler.", connectionId, this.name, this.address);
                    }
                }
                else {
                    error("[%s] 'session_close' event occurred on the session of receiver '%s' with address " +
                        "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                        "() handler.", connectionId, this.name, this.address);
                }
            });
        }
        /**
         * Creates the options that need to be specified while creating an AMQP receiver link.
         */
        _createReceiverOptions(useNewName, options) {
            if (!options) {
                options = {
                    onMessage: (context) => this._onAmqpMessage(context).catch(() => {
                        /* */
                    }),
                    onClose: (context) => this._onAmqpClose(context).catch(() => {
                        /* */
                    }),
                    onSessionClose: (context) => this._onSessionClose(context).catch(() => {
                        /* */
                    }),
                    onError: this._onAmqpError,
                    onSessionError: this._onSessionError,
                    onSettled: this._onSettled
                };
            }
            const rcvrOptions = Object.assign({ name: useNewName ? getUniqueName(this._context.entityPath) : this.name, autoaccept: this.receiveMode === exports.ReceiveMode.receiveAndDelete ? true : false, 
                // receiveAndDelete -> first(0), peekLock -> second (1)
                rcv_settle_mode: this.receiveMode === exports.ReceiveMode.receiveAndDelete ? 0 : 1, 
                // receiveAndDelete -> settled (1), peekLock -> unsettled (0)
                snd_settle_mode: this.receiveMode === exports.ReceiveMode.receiveAndDelete ? 1 : 0, source: {
                    address: this.address
                }, credit_window: 0 }, options);
            return rcvrOptions;
        }
        /**
         * Creates a new AMQP receiver under a new AMQP session.
         * @protected
         *
         * @returns {Promise<void>} Promise<void>.
         */
        _init(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const connectionId = this._context.namespace.connectionId;
                try {
                    if (!this.isOpen() && !this.isConnecting) {
                        error("[%s] The receiver '%s' with address '%s' is not open and is not currently " +
                            "establishing itself. Hence let's try to connect.", connectionId, this.name, this.address);
                        if (options && options.name) {
                            this.name = options.name;
                        }
                        this.isConnecting = true;
                        yield this._negotiateClaim();
                        if (!options) {
                            options = this._createReceiverOptions();
                        }
                        error("[%s] Trying to create receiver '%s' with options %O", connectionId, this.name, options);
                        this._receiver = yield this._context.namespace.connection.createReceiver(options);
                        this.isConnecting = false;
                        error("[%s] Receiver '%s' with address '%s' has established itself.", connectionId, this.name, this.address);
                        log[this.receiverType]("Promise to create the receiver resolved. " + "Created receiver with name: ", this.name);
                        log[this.receiverType]("[%s] Receiver '%s' created with receiver options: %O", connectionId, this.name, options);
                        // It is possible for someone to close the receiver and then start it again.
                        // Thus make sure that the receiver is present in the client cache.
                        if (this.receiverType === ReceiverType.streaming && !this._context.streamingReceiver) {
                            this._context.streamingReceiver = this;
                        }
                        else if (this.receiverType === ReceiverType.batching && !this._context.batchingReceiver) {
                            this._context.batchingReceiver = this;
                        }
                        yield this._ensureTokenRenewal();
                    }
                    else {
                        error("[%s] The receiver '%s' with address '%s' is open -> %s and is connecting " +
                            "-> %s. Hence not reconnecting.", connectionId, this.name, this.address, this.isOpen(), this.isConnecting);
                    }
                }
                catch (err) {
                    this.isConnecting = false;
                    err = translate(err);
                    error("[%s] An error occured while creating the receiver '%s': %O", this._context.namespace.connectionId, this.name, err);
                    throw err;
                }
            });
        }
        _deleteFromCache() {
            this._receiver = undefined;
            if (this.receiverType === ReceiverType.streaming) {
                this._context.streamingReceiver = undefined;
            }
            else if (this.receiverType === ReceiverType.batching) {
                this._context.batchingReceiver = undefined;
            }
            error("[%s] Deleted the receiver '%s' from the client cache.", this._context.namespace.connectionId, this.name);
        }
        /**
         * Will reconnect the receiver link if necessary.
         * @param {AmqpError | Error} [receiverError] The receiver error if any.
         * @returns {Promise<void>} Promise<void>.
         */
        onDetached(receiverError) {
            return __awaiter(this, void 0, void 0, function* () {
                const connectionId = this._context.namespace.connectionId;
                try {
                    // Local 'wasCloseInitiated' serves same purpose as {this.wasCloseInitiated}
                    // but the condition is inferred based on state of receiver in context of network disconnect scenario
                    const wasCloseInitiated = this._receiver && this._receiver.isItselfClosed();
                    // Clears the token renewal timer. Closes the link and its session if they are open.
                    // Removes the link and its session if they are present in rhea's cache.
                    yield this._closeLink(this._receiver);
                    if (this.receiverType === ReceiverType.batching) {
                        error("[%s] Receiver '%s' with address '%s' is a Batching Receiver, so we will not be " +
                            "re-establishing the receiver link.", connectionId, this.name, this.address);
                        return;
                    }
                    // We should attempt to reopen only when the receiver(sdk) did not initiate the close
                    let shouldReopen = false;
                    if (receiverError && !wasCloseInitiated) {
                        const translatedError = translate(receiverError);
                        if (translatedError.retryable) {
                            shouldReopen = true;
                            error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                                "was an accompanying error and it is retryable. This is a candidate for re-establishing " +
                                "the receiver link.", connectionId, this.name, this.address);
                        }
                        else {
                            error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                                "was an accompanying error and it is NOT retryable. Hence NOT re-establishing " +
                                "the receiver link.", connectionId, this.name, this.address);
                        }
                    }
                    else if (!wasCloseInitiated) {
                        shouldReopen = true;
                        error("[%s] close() method of Receiver '%s' with address '%s' was not called. " +
                            "There was no accompanying error as well. This is a candidate for re-establishing " +
                            "the receiver link.", connectionId, this.name, this.address);
                    }
                    else {
                        const state = {
                            wasCloseInitiated: wasCloseInitiated,
                            receiverError: receiverError,
                            _receiver: this._receiver
                        };
                        error("[%s] Something went wrong. State of Receiver '%s' with address '%s' is: %O", connectionId, this.name, this.address, state);
                    }
                    if (shouldReopen) {
                        // provide a new name to the link while re-connecting it. This ensures that
                        // the service does not send an error stating that the link is still open.
                        const options = this._createReceiverOptions(true);
                        // shall retry forever at an interval of 15 seconds if the error is a retryable error
                        // else bail out when the error is not retryable or the oepration succeeds.
                        const config = {
                            operation: () => this._init(options).then(() => __awaiter(this, void 0, void 0, function* () {
                                if (this.wasCloseInitiated) {
                                    error("[%s] close() method of Receiver '%s' with address '%s' was called. " +
                                        "by the time the receiver finished getting created. Hence, disallowing messages from being received. ", connectionId, this.name, this.address);
                                    yield this.close();
                                }
                                else {
                                    if (this._receiver && this.receiverType === ReceiverType.streaming) {
                                        this._receiver.addCredit(this.maxConcurrentCalls);
                                    }
                                }
                                return;
                            })),
                            connectionId: connectionId,
                            operationType: RetryOperationType.receiverLink,
                            times: defaultConnectionRetryAttempts,
                            connectionHost: this._context.namespace.config.host,
                            delayInSeconds: 15
                        };
                        if (!this.wasCloseInitiated) {
                            yield retry$1(config);
                        }
                    }
                }
                catch (err) {
                    error("[%s] An error occurred while processing detached() of Receiver '%s': %O ", connectionId, this.name, this.address, err);
                    if (typeof this._onError === "function") {
                        error("[%s] Unable to automatically reconnect Receiver '%s' with address '%s'.", connectionId, this.name, this.address);
                        try {
                            this._onError(err);
                        }
                        catch (err) {
                            error("[%s] User-code error in error handler called after disconnect: %O", connectionId, err);
                        }
                    }
                }
            });
        }
        /**
         * Closes the underlying AMQP receiver.
         * @return {Promise<void>} Promise<void>.
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                this.wasCloseInitiated = true;
                receiver("[%s] Closing the [%s]Receiver for entity '%s'.", this._context.namespace.connectionId, this.receiverType, this._context.entityPath);
                if (this._newMessageReceivedTimer)
                    clearTimeout(this._newMessageReceivedTimer);
                this._clearAllMessageLockRenewTimers();
                if (this._receiver) {
                    const receiverLink = this._receiver;
                    this._deleteFromCache();
                    yield this._closeLink(receiverLink);
                }
            });
        }
        /**
         * Settles the message with the specified disposition.
         * @param message The ServiceBus Message that needs to be settled.
         * @param operation The disposition type.
         * @param options Optional parameters that can be provided while disposing the message.
         */
        settleMessage(message, operation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((resolve, reject) => {
                    if (!options)
                        options = {};
                    if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {
                        return reject(new Error(`operation: '${operation}' is not a valid operation.`));
                    }
                    this._clearMessageLockRenewTimer(message.messageId);
                    const delivery = message.delivery;
                    const timer = setTimeout(() => {
                        this._deliveryDispositionMap.delete(delivery.id);
                        receiver("[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. " +
                            "Hence rejecting the promise with timeout error.", this._context.namespace.connectionId, delivery.id, defaultOperationTimeoutInSeconds * 1000);
                        const e = {
                            condition: ErrorNameConditionMapper.ServiceUnavailableError,
                            description: "Operation to settle the message has timed out. The disposition of the " +
                                "message may or may not be successful"
                        };
                        return reject(translate(e));
                    }, defaultOperationTimeoutInSeconds * 1000);
                    this._deliveryDispositionMap.set(delivery.id, {
                        resolve: resolve,
                        reject: reject,
                        timer: timer
                    });
                    if (operation === DispositionType.complete) {
                        delivery.accept();
                    }
                    else if (operation === DispositionType.abandon) {
                        const params = {
                            undeliverable_here: false
                        };
                        if (options.propertiesToModify)
                            params.message_annotations = options.propertiesToModify;
                        delivery.modified(params);
                    }
                    else if (operation === DispositionType.defer) {
                        const params = {
                            undeliverable_here: true
                        };
                        if (options.propertiesToModify)
                            params.message_annotations = options.propertiesToModify;
                        delivery.modified(params);
                    }
                    else if (operation === DispositionType.deadletter) {
                        delivery.reject(options.error || {});
                    }
                });
            });
        }
        /**
         * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
         * @return {boolean} boolean
         */
        isOpen() {
            const result = this._receiver && this._receiver.isOpen();
            error("[%s] Receiver '%s' with address '%s' is open? -> %s", this._context.namespace.connectionId, this.name, this.address, result);
            return result;
        }
    }
    //# sourceMappingURL=messageReceiver.js.map

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @internal
     * Describes the streaming receiver where the user can receive the message
     * by providing handler functions.
     * @class StreamingReceiver
     * @extends MessageReceiver
     */
    class StreamingReceiver extends MessageReceiver {
        /**
         * Instantiate a new Streaming receiver for receiving messages with handlers.
         *
         * @constructor
         * @param {ClientEntityContext} context                      The client entity context.
         * @param {ReceiveOptions} [options]                         Options for how you'd like to connect.
         */
        constructor(context, options) {
            super(context, ReceiverType.streaming, options);
            this.resetTimerOnNewMessageReceived = () => {
                if (this._newMessageReceivedTimer)
                    clearTimeout(this._newMessageReceivedTimer);
                if (this.newMessageWaitTimeoutInSeconds) {
                    this._newMessageReceivedTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        const msg = `StreamingReceiver '${this.name}' did not receive any messages in ` +
                            `the last ${this.newMessageWaitTimeoutInSeconds} seconds. ` +
                            `Hence ending this receive operation.`;
                        error("[%s] %s", this._context.namespace.connectionId, msg);
                        yield this.close();
                    }), this.newMessageWaitTimeoutInSeconds * 1000);
                }
            };
        }
        /**
         * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.
         *
         * @param {OnMessage} onMessage The message handler to receive servicebus messages.
         * @param {OnError} onError The error handler to receive an error that occurs while receivin messages.
         */
        receive(onMessage, onError) {
            throwErrorIfConnectionClosed(this._context.namespace);
            this._onMessage = onMessage;
            this._onError = onError;
            if (this._receiver) {
                this._receiver.addCredit(this.maxConcurrentCalls);
            }
        }
        /**
         * Creates a streaming receiver.
         * @static
         *
         * @param {ClientEntityContext} context    The connection context.
         * @param {ReceiveOptions} [options]     Receive options.
         * @return {Promise<StreamingReceiver>} A promise that resolves with an instance of StreamingReceiver.
         */
        static create(context, options) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(context.namespace);
                if (!options)
                    options = {};
                if (options.autoComplete == null)
                    options.autoComplete = true;
                const sReceiver = new StreamingReceiver(context, options);
                yield sReceiver._init();
                context.streamingReceiver = sReceiver;
                return sReceiver;
            });
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes the batching receiver where the user can receive a specified number of messages for
     * a predefined time.
     * @internal
     * @class BatchingReceiver
     * @extends MessageReceiver
     */
    class BatchingReceiver extends MessageReceiver {
        /**
         * Instantiate a new BatchingReceiver.
         *
         * @constructor
         * @param {ClientEntityContext} context The client entity context.
         * @param {ReceiveOptions} [options]  Options for how you'd like to connect.
         */
        constructor(context, options) {
            super(context, ReceiverType.batching, options);
            /**
             * @property {boolean} isReceivingMessages Indicates whether the link is actively receiving
             * messages. Default: false.
             */
            this.isReceivingMessages = false;
            /**
             * @property {AmqpError | Error | undefined} detachedError Error that occured when receiver
             * got detached. Not applicable when onReceiveError is called.
             *  Default: undefined.
             */
            this.detachedError = undefined;
            this._finalActionHandler = undefined;
            this.newMessageWaitTimeoutInSeconds = 1;
        }
        /**
         * Clear the token renewal timer and set the `detachedError` property.
         * @param {AmqpError | Error} [receiverError] The receiver error if any.
         * @returns {Promise<void>} Promise<void>.
         */
        onDetached(receiverError) {
            return __awaiter(this, void 0, void 0, function* () {
                // Clears the token renewal timer. Closes the link and its session if they are open.
                yield this._closeLink(this._receiver);
                this.detachedError = receiverError;
                if (this.isReceivingMessages && typeof this._finalActionHandler === "function") {
                    this._finalActionHandler();
                }
            });
        }
        /**
         * Receives a batch of messages from a ServiceBus Queue/Topic.
         * @param maxMessageCount The maximum number of messages to receive.
         * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.
         * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.
         * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
         * - **Default**: `60` seconds.
         * @returns {Promise<ServiceBusMessage[]>} A promise that resolves with an array of Message objects.
         */
        receive(maxMessageCount, maxWaitTimeInSeconds) {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (maxWaitTimeInSeconds == null) {
                maxWaitTimeInSeconds = defaultOperationTimeoutInSeconds;
            }
            const brokeredMessages = [];
            this.isReceivingMessages = true;
            return new Promise((resolve, reject) => {
                let totalWaitTimer;
                const onSessionError = (context) => {
                    this.isReceivingMessages = false;
                    const receiver = this._receiver || context.receiver;
                    receiver.removeListener(lib_7.receiverError, onReceiveError);
                    receiver.removeListener(lib_7.message, onReceiveMessage);
                    receiver.removeListener(lib_7.receiverDrained, onReceiveDrain);
                    receiver.session.removeListener(lib_10.sessionError, onSessionError);
                    const sessionError = context.session && context.session.error;
                    let error$1 = new MessagingError("An error occurred while receiving messages.");
                    if (sessionError) {
                        error$1 = translate(sessionError);
                        error("[%s] 'session_close' event occurred for Receiver '%s' received an error:\n%O", this._context.namespace.connectionId, this.name, error$1);
                    }
                    if (totalWaitTimer) {
                        clearTimeout(totalWaitTimer);
                    }
                    if (this._newMessageReceivedTimer) {
                        clearTimeout(this._newMessageReceivedTimer);
                    }
                    reject(error$1);
                };
                // Final action to be performed after maxMessageCount is reached or the maxWaitTime is over.
                const finalAction = (this._finalActionHandler = () => {
                    // clear finalActionHandler so that it can't be called multiple times.
                    this._finalActionHandler = undefined;
                    if (this._newMessageReceivedTimer) {
                        clearTimeout(this._newMessageReceivedTimer);
                    }
                    if (totalWaitTimer) {
                        clearTimeout(totalWaitTimer);
                    }
                    // Removing listeners, so that the next receiveMessages() call can set them again.
                    if (this._receiver) {
                        this._receiver.removeListener(lib_7.receiverError, onReceiveError);
                        this._receiver.removeListener(lib_7.message, onReceiveMessage);
                        this._receiver.session.removeListener(lib_10.sessionError, onSessionError);
                    }
                    // When receiveMode is in receiveAndDelete mode, we should return those messages to the user
                    // because they have already been removed from service bus and are safe to handle.
                    // If there haven't been any received messages, then it's safe to reject the promise
                    // so that the user knows there was an underlying issue that prevented receiving messages.
                    if (this.detachedError &&
                        (this.receiveMode !== exports.ReceiveMode.receiveAndDelete || brokeredMessages.length === 0)) {
                        if (this._receiver) {
                            this._receiver.removeListener(lib_7.receiverDrained, onReceiveDrain);
                        }
                        this.isReceivingMessages = false;
                        const err = translate(this.detachedError);
                        return reject(err);
                    }
                    // If the receiver has been detached, there is no need to drain.
                    if (this._receiver && this._receiver.credit > 0 && !this.detachedError) {
                        batching("[%s] Receiver '%s': Draining leftover credits(%d).", this._context.namespace.connectionId, this.name, this._receiver.credit);
                        // Setting drain must be accompanied by a flow call (aliased to addCredit in this case).
                        this._receiver.drain = true;
                        this._receiver.addCredit(1);
                    }
                    else {
                        if (this._receiver) {
                            this._receiver.removeListener(lib_7.receiverDrained, onReceiveDrain);
                        }
                        this.isReceivingMessages = false;
                        batching("[%s] Receiver '%s': Resolving receiveMessages() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                        resolve(brokeredMessages);
                    }
                });
                // Action to be performed on the "message" event.
                const onReceiveMessage = (context) => __awaiter(this, void 0, void 0, function* () {
                    this.resetTimerOnNewMessageReceived();
                    try {
                        const data = new ServiceBusMessage(this._context, context.message, context.delivery, true);
                        if (brokeredMessages.length < maxMessageCount) {
                            brokeredMessages.push(data);
                        }
                    }
                    catch (err) {
                        const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));
                        error("[%s] Receiver '%s' received an error while converting AmqpMessage to ServiceBusMessage:\n%O", this._context.namespace.connectionId, this.name, errObj);
                        reject(errObj);
                    }
                    if (brokeredMessages.length === maxMessageCount) {
                        finalAction();
                    }
                });
                const onSessionClose = (context) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        this.isReceivingMessages = false;
                        const sessionError = context.session && context.session.error;
                        if (sessionError) {
                            error("[%s] 'session_close' event occurred for receiver '%s'. The associated error is: %O", this._context.namespace.connectionId, this.name, sessionError);
                        }
                    }
                    catch (err) {
                        error("[%s] Receiver '%s' error in onSessionClose handler:\n%O", this._context.namespace.connectionId, this.name, translate(err));
                    }
                });
                // Action to be performed on the "receiver_drained" event.
                const onReceiveDrain = () => {
                    if (this._receiver) {
                        this._receiver.removeListener(lib_7.receiverDrained, onReceiveDrain);
                        this._receiver.drain = false;
                    }
                    this.isReceivingMessages = false;
                    batching("[%s] Receiver '%s' drained. Resolving receiveMessages() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                    resolve(brokeredMessages);
                };
                const onReceiveClose = (context) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        this.isReceivingMessages = false;
                        const receiverError = context.receiver && context.receiver.error;
                        if (receiverError) {
                            error("[%s] 'receiver_close' event occurred. The associated error is: %O", this._context.namespace.connectionId, receiverError);
                        }
                    }
                    catch (err) {
                        error("[%s] Receiver '%s' error in onClose handler:\n%O", this._context.namespace.connectionId, this.name, translate(err));
                    }
                });
                // Action to be taken when an error is received.
                const onReceiveError = (context) => {
                    this.isReceivingMessages = false;
                    const receiver = this._receiver || context.receiver;
                    receiver.removeListener(lib_7.receiverError, onReceiveError);
                    receiver.removeListener(lib_7.message, onReceiveMessage);
                    receiver.removeListener(lib_7.receiverDrained, onReceiveDrain);
                    receiver.session.removeListener(lib_10.sessionError, onSessionError);
                    const receiverError = context.receiver && context.receiver.error;
                    let error$1 = new MessagingError("An error occurred while receiving messages.");
                    if (receiverError) {
                        error$1 = translate(receiverError);
                        error("[%s] Receiver '%s' received an error:\n%O", this._context.namespace.connectionId, this.name, error$1);
                    }
                    if (totalWaitTimer) {
                        clearTimeout(totalWaitTimer);
                    }
                    if (this._newMessageReceivedTimer) {
                        clearTimeout(this._newMessageReceivedTimer);
                    }
                    reject(error$1);
                };
                // Use new message wait timer only in peekLock mode
                if (this.receiveMode === exports.ReceiveMode.peekLock) {
                    /**
                     * Resets the timer when a new message is received. If no messages were received for
                     * `newMessageWaitTimeoutInSeconds`, the messages received till now are returned. The
                     * receiver link stays open for the next receive call, but doesnt receive messages until then.
                     */
                    this.resetTimerOnNewMessageReceived = () => {
                        if (this._newMessageReceivedTimer)
                            clearTimeout(this._newMessageReceivedTimer);
                        if (this.newMessageWaitTimeoutInSeconds) {
                            this._newMessageReceivedTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                                const msg = `BatchingReceiver '${this.name}' did not receive any messages in the last ` +
                                    `${this.newMessageWaitTimeoutInSeconds} seconds. ` +
                                    `Hence ending this batch receive operation.`;
                                error("[%s] %s", this._context.namespace.connectionId, msg);
                                finalAction();
                            }), this.newMessageWaitTimeoutInSeconds * 1000);
                        }
                    };
                }
                // Action to be performed after the max wait time is over.
                const actionAfterWaitTimeout = () => {
                    batching("[%s] Batching Receiver '%s'  max wait time in seconds %d over.", this._context.namespace.connectionId, this.name, maxWaitTimeInSeconds);
                    return finalAction();
                };
                const onSettled = (context) => {
                    const connectionId = this._context.namespace.connectionId;
                    const delivery = context.delivery;
                    if (delivery) {
                        const id = delivery.id;
                        const state = delivery.remote_state;
                        const settled = delivery.remote_settled;
                        receiver("[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been " +
                            "received.", connectionId, id, settled, state && state.error ? state.error : state);
                        if (settled && this._deliveryDispositionMap.has(id)) {
                            const promise = this._deliveryDispositionMap.get(id);
                            clearTimeout(promise.timer);
                            receiver("[%s] Found the delivery with id %d in the map and cleared the timer.", connectionId, id);
                            const deleteResult = this._deliveryDispositionMap.delete(id);
                            receiver("[%s] Successfully deleted the delivery with id %d from the map.", connectionId, id, deleteResult);
                            if (state && state.error && (state.error.condition || state.error.description)) {
                                const error = translate(state.error);
                                return promise.reject(error);
                            }
                            return promise.resolve();
                        }
                    }
                };
                const addCreditAndSetTimer = (reuse) => {
                    batching("[%s] Receiver '%s', adding credit for receiving %d messages.", this._context.namespace.connectionId, this.name, maxMessageCount);
                    // By adding credit here, we let the service know that at max we can handle `maxMessageCount`
                    // number of messages concurrently. We will return the user an array of messages that can
                    // be of size upto maxMessageCount. Then the user needs to accordingly dispose
                    // (complete/abandon/defer/deadletter) the messages from the array.
                    this._receiver.addCredit(maxMessageCount);
                    let msg = "[%s] Setting the wait timer for %d seconds for receiver '%s'.";
                    if (reuse)
                        msg += " Receiver link already present, hence reusing it.";
                    batching(msg, this._context.namespace.connectionId, maxWaitTimeInSeconds, this.name);
                    totalWaitTimer = setTimeout(actionAfterWaitTimeout, maxWaitTimeInSeconds * 1000);
                    // TODO: Disabling this for now. We would want to give the user a decent chance to receive
                    // the first message and only timeout faster if successive messages from there onwards are
                    // not received quickly. However, it may be possible that there are no pending messages
                    // currently on the queue. In that case waiting for idleTimeoutInSeconds would be
                    // unnecessary.
                    // There is a management plane API to get runtimeInfo of the Queue which provides
                    // information about active messages on the Queue and it's sub Queues. However, this adds
                    // a little complexity. If the first message was delayed due to network latency then there
                    // are bright chances that the management plane api would receive the same fate.
                    // It would be better to weigh all the options before making a decision.
                    // resetTimerOnNewMessageReceived();
                };
                if (!this.isOpen()) {
                    // clear detachedError since we are reconnecting.
                    this.detachedError = undefined;
                    batching("[%s] Receiver '%s', setting max concurrent calls to 0.", this._context.namespace.connectionId, this.name);
                    // while creating the receiver link for batching receiver the max concurrent calls
                    // i.e. the credit_window on the link is set to zero. After the link is created
                    // successfully, we add credit which is the maxMessageCount specified by the user.
                    this.maxConcurrentCalls = 0;
                    const rcvrOptions = this._createReceiverOptions(false, {
                        onMessage: onReceiveMessage,
                        onError: onReceiveError,
                        onSessionError: onSessionError,
                        onSettled: onSettled,
                        onClose: onReceiveClose,
                        onSessionClose: onSessionClose
                    });
                    this._init(rcvrOptions)
                        .then(() => {
                        this._receiver.on(lib_7.receiverDrained, onReceiveDrain);
                        addCreditAndSetTimer();
                        return;
                    })
                        .catch(reject);
                }
                else {
                    addCreditAndSetTimer(true);
                    this._receiver.on(lib_7.message, onReceiveMessage);
                    this._receiver.on(lib_7.receiverError, onReceiveError);
                    this._receiver.on(lib_7.receiverDrained, onReceiveDrain);
                    this._receiver.session.on(lib_10.sessionError, onSessionError);
                }
            });
        }
        /**
         * Creates a batching receiver.
         * @static
         *
         * @param {ClientEntityContext} context    The connection context.
         * @param {ReceiveOptions} [options]     Receive options.
         */
        static create(context, options) {
            throwErrorIfConnectionClosed(context.namespace);
            const bReceiver = new BatchingReceiver(context, options);
            context.batchingReceiver = bReceiver;
            return bReceiver;
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Enum to denote who is calling the session receiver
     * @internal
     */
    var SessionCallee;
    (function (SessionCallee) {
        SessionCallee["standalone"] = "standalone";
        SessionCallee["sessionManager"] = "sessionManager";
    })(SessionCallee || (SessionCallee = {}));
    /**
     * @internal
     * Describes the receiver for a Message Session.
     */
    class MessageSession extends LinkEntity {
        constructor(context, options) {
            super(context.entityPath, context, {
                address: context.entityPath,
                audience: `${context.namespace.config.endpoint}${context.entityPath}`
            });
            /**
             * @property {number} [maxConcurrentCalls] The maximum number of messages that should be
             * processed concurrently in a session while in streaming mode. Once this limit has been reached,
             * more messages will not be received until the user's message handler has completed processing current message.
             * - **Default**: `1` (message in a session at a time).
             */
            this.maxConcurrentCalls = 1;
            /**
             * @property {Map<number, Promise<any>>} _deliveryDispositionMap Maintains a map of deliveries that
             * are being actively disposed. It acts as a store for correlating the responses received for
             * active dispositions.
             */
            this._deliveryDispositionMap = new Map();
            this._context.isSessionEnabled = true;
            this.isReceivingMessages = false;
            if (!options)
                options = { sessionId: undefined };
            this.autoComplete = false;
            this.sessionId = options.sessionId;
            this.receiveMode = options.receiveMode || exports.ReceiveMode.peekLock;
            this.callee = options.callee || SessionCallee.standalone;
            this.maxAutoRenewDurationInSeconds =
                options.maxSessionAutoRenewLockDurationInSeconds != null
                    ? options.maxSessionAutoRenewLockDurationInSeconds
                    : 300;
            this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;
            this.autoRenewLock =
                this.maxAutoRenewDurationInSeconds > 0 && this.receiveMode === exports.ReceiveMode.peekLock;
            // setting all the handlers
            this._onSettled = (context) => {
                const connectionId = this._context.namespace.connectionId;
                const delivery = context.delivery;
                if (delivery) {
                    const id = delivery.id;
                    const state = delivery.remote_state;
                    const settled = delivery.remote_settled;
                    receiver("[%s] Delivery with id %d, remote_settled: %s, remote_state: %o has been " + "received.", connectionId, id, settled, state && state.error ? state.error : state);
                    if (settled && this._deliveryDispositionMap.has(id)) {
                        const promise = this._deliveryDispositionMap.get(id);
                        clearTimeout(promise.timer);
                        receiver("[%s] Found the delivery with id %d in the map and cleared the timer.", connectionId, id);
                        const deleteResult = this._deliveryDispositionMap.delete(id);
                        receiver("[%s] Successfully deleted the delivery with id %d from the map.", connectionId, id, deleteResult);
                        if (state && state.error && (state.error.condition || state.error.description)) {
                            const error = translate(state.error);
                            return promise.reject(error);
                        }
                        return promise.resolve();
                    }
                }
            };
            this._notifyError = (error$1) => {
                if (this._onError) {
                    this._onError(error$1);
                    error("[%s] Notified the user's error handler about the error received by the " +
                        "Receiver '%s'.", this._context.namespace.connectionId, this.name);
                }
            };
            this._onAmqpError = (context) => {
                const connectionId = this._context.namespace.connectionId;
                const receiverError = context.receiver && context.receiver.error;
                if (receiverError) {
                    const sbError = translate(receiverError);
                    if (sbError.name === "SessionLockLostError") {
                        this._context.expiredMessageSessions[this.sessionId] = true;
                        sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;
                    }
                    error("[%s] An error occurred for Receiver '%s': %O.", connectionId, this.name, sbError);
                    this._notifyError(sbError);
                }
            };
            this._onSessionError = (context) => {
                const connectionId = this._context.namespace.connectionId;
                const sessionError = context.session && context.session.error;
                if (sessionError) {
                    const sbError = translate(sessionError);
                    error("[%s] An error occurred on the session for Receiver '%s': %O.", connectionId, this.name, sbError);
                    this._notifyError(sbError);
                }
            };
            this._onAmqpClose = (context) => __awaiter(this, void 0, void 0, function* () {
                const connectionId = this._context.namespace.connectionId;
                const receiverError = context.receiver && context.receiver.error;
                const receiver = this._receiver || context.receiver;
                let isClosedDueToExpiry = false;
                if (receiverError) {
                    const sbError = translate(receiverError);
                    if (sbError.name === "SessionLockLostError") {
                        isClosedDueToExpiry = true;
                    }
                    error("[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. " +
                        "The associated error is: %O", connectionId, this.name, this.sessionId, sbError);
                    // no need to notify the user's error handler since rhea guarantees that receiver_error
                    // will always be emitted before receiver_close.
                }
                if (receiver && !receiver.isItselfClosed()) {
                    error("[%s] 'receiver_close' event occurred on the receiver '%s' for sessionId '%s' " +
                        "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", connectionId, this.name, this.sessionId);
                    try {
                        yield this.close(isClosedDueToExpiry);
                    }
                    catch (err) {
                        error("[%s] An error occurred while closing the receiver '%s' for sessionId '%s': %O.", connectionId, this.name, this.sessionId, err);
                    }
                }
                else {
                    error("[%s] 'receiver_close' event occurred on the receiver '%s' for sessionId '%s' " +
                        "because the sdk initiated it. Hence no need to gracefully close the receiver", connectionId, this.name, this.sessionId);
                }
            });
            this._onSessionClose = (context) => __awaiter(this, void 0, void 0, function* () {
                const connectionId = this._context.namespace.connectionId;
                const receiver = this._receiver || context.receiver;
                const sessionError = context.session && context.session.error;
                if (sessionError) {
                    const sbError = translate(sessionError);
                    error("[%s] 'session_close' event occurred for receiver '%s' for sessionId '%s'. " +
                        "The associated error is: %O", connectionId, this.name, this.sessionId, sbError);
                    // no need to notify the user's error handler since rhea guarantees that session_error
                    // will always be emitted before session_close.
                }
                if (receiver && !receiver.isSessionItselfClosed()) {
                    error("[%s] 'session_close' event occurred on the receiver '%s' for sessionId '%s' " +
                        "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", connectionId, this.name, this.sessionId);
                    try {
                        yield this.close();
                    }
                    catch (err) {
                        error("[%s] An error occurred while closing the receiver '%s' for sessionId '%s': %O.", connectionId, this.name, this.sessionId, err);
                    }
                }
                else {
                    error("[%s] 'session_close' event occurred on the receiver '%s' for sessionId '%s' " +
                        "because the sdk initiated it. Hence no need to gracefully close the receiver", connectionId, this.name, this.sessionId);
                }
            });
        }
        /**
         * Ensures that the session lock is renewed before it expires. The lock will not be renewed for
         * more than the configured totalAutoLockRenewDuration.
         */
        _ensureSessionLockRenewal() {
            if (this.autoRenewLock &&
                new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc &&
                Date.now() < this._totalAutoLockRenewDuration &&
                this.isOpen()) {
                const connectionId = this._context.namespace.connectionId;
                const nextRenewalTimeout = calculateRenewAfterDuration(this.sessionLockedUntilUtc);
                this._sessionLockRenewalTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    try {
                        messageSession("[%s] Attempting to renew the session lock for MessageSession '%s' " +
                            "with name '%s'.", connectionId, this.sessionId, this.name);
                        this.sessionLockedUntilUtc = yield this._context.managementClient.renewSessionLock(this.sessionId, {
                            delayInSeconds: 0,
                            timeoutInSeconds: 10,
                            times: 4
                        });
                        receiver("[%s] Successfully renewed the session lock for MessageSession '%s' " +
                            "with name '%s'.", connectionId, this.sessionId, this.name);
                        receiver("[%s] Calling _ensureSessionLockRenewal() again for MessageSession '%s'.", connectionId, this.sessionId);
                        this._ensureSessionLockRenewal();
                    }
                    catch (err) {
                        error("[%s] An error occurred while renewing the session lock for MessageSession " +
                            "'%s' with name '%s': %O", this._context.namespace.connectionId, this.sessionId, this.name, err);
                    }
                }), nextRenewalTimeout);
                messageSession("[%s] MessageSession '%s' with name '%s', has next session lock renewal " +
                    "in %d seconds @(%s).", this._context.namespace.connectionId, this.sessionId, this.name, nextRenewalTimeout / 1000, new Date(Date.now() + nextRenewalTimeout).toString());
            }
        }
        /**
         * Deletes the MessageSession from the internal cache.
         */
        _deleteFromCache() {
            this._receiver = undefined;
            delete this._context.messageSessions[this.sessionId];
            error("[%s] Deleted the receiver '%s' with sessionId '%s' from the client cache.", this._context.namespace.connectionId, this.name, this.sessionId);
        }
        /**
         * Creates a new AMQP receiver under a new AMQP session.
         */
        _init() {
            return __awaiter(this, void 0, void 0, function* () {
                const connectionId = this._context.namespace.connectionId;
                try {
                    if (!this.isOpen() && !this.isConnecting) {
                        error("[%s] The receiver '%s' with address '%s' is not open and is not currently " +
                            "establishing itself. Hence let's try to connect.", connectionId, this.name, this.address);
                        this.isConnecting = true;
                        yield this._negotiateClaim();
                        const options = this._createMessageSessionOptions();
                        error("[%s] Trying to create receiver '%s' with options %O", connectionId, this.name, options);
                        this._receiver = yield this._context.namespace.connection.createReceiver(options);
                        this.isConnecting = false;
                        const receivedSessionId = this._receiver.source &&
                            this._receiver.source.filter &&
                            this._receiver.source.filter[sessionFilterName];
                        let errorMessage = "";
                        // SB allows a sessionId with empty string value :)
                        if (receivedSessionId == null) {
                            errorMessage =
                                `Received an incorrect sessionId '${receivedSessionId}' while creating ` +
                                    `the receiver '${this.name}'.`;
                        }
                        if (this.sessionId != null && receivedSessionId !== this.sessionId) {
                            errorMessage =
                                `Received sessionId '${receivedSessionId}' does not match the provided ` +
                                    `sessionId '${this.sessionId}' while creating the receiver '${this.name}'.`;
                        }
                        if (errorMessage) {
                            const error$1 = translate({
                                description: errorMessage,
                                condition: ErrorNameConditionMapper.SessionCannotBeLockedError
                            });
                            error("[%s] %O", this._context.namespace.connectionId, error$1);
                            throw error$1;
                        }
                        if (this.sessionId == null)
                            this.sessionId = receivedSessionId;
                        this.sessionLockedUntilUtc = convertTicksToDate(this._receiver.properties["com.microsoft:locked-until-utc"]);
                        messageSession("[%s] Session with id '%s' is locked until: '%s'.", connectionId, this.sessionId, this.sessionLockedUntilUtc.toISOString());
                        error("[%s] Receiver '%s' for sessionId '%s' has established itself.", connectionId, this.name, this.sessionId);
                        messageSession("Promise to create the receiver resolved. " + "Created receiver with name: ", this.name);
                        messageSession("[%s] Receiver '%s' created with receiver options: %O", connectionId, this.name, options);
                        if (!this._context.messageSessions[this.sessionId]) {
                            this._context.messageSessions[this.sessionId] = this;
                        }
                        this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInSeconds * 1000;
                        yield this._ensureTokenRenewal();
                        yield this._ensureSessionLockRenewal();
                    }
                    else {
                        error("[%s] The receiver '%s' for sessionId '%s' is open -> %s and is connecting " +
                            "-> %s. Hence not reconnecting.", connectionId, this.name, this.sessionId, this.isOpen(), this.isConnecting);
                    }
                }
                catch (err) {
                    this.isConnecting = false;
                    const errObj = translate(err);
                    error("[%s] An error occured while creating the receiver '%s': %O", this._context.namespace.connectionId, this.name, errObj);
                    throw errObj;
                }
            });
        }
        /**
         * Creates the options that need to be specified while creating an AMQP receiver link.
         */
        _createMessageSessionOptions() {
            const rcvrOptions = {
                name: this.name,
                autoaccept: false,
                // receiveAndDelete -> first(0), peekLock -> second (1)
                rcv_settle_mode: this.receiveMode === exports.ReceiveMode.receiveAndDelete ? 0 : 1,
                // receiveAndDelete -> settled (1), peekLock -> unsettled (0)
                snd_settle_mode: this.receiveMode === exports.ReceiveMode.receiveAndDelete ? 1 : 0,
                source: {
                    address: this.address,
                    filter: {}
                },
                credit_window: 0,
                onClose: (context) => this._onAmqpClose(context).catch(() => {
                    /* */
                }),
                onSessionClose: (context) => this._onSessionClose(context).catch(() => {
                    /* */
                }),
                onError: this._onAmqpError,
                onSessionError: this._onSessionError,
                onSettled: this._onSettled
            };
            rcvrOptions.source.filter[sessionFilterName] = this.sessionId;
            return rcvrOptions;
        }
        /**
         * Closes the underlying AMQP receiver link.
         * @param isClosedDueToExpiry Flag that denotes if close is invoked due to session expiring.
         * This is so that the internal map of expired sessions doesn't get cleared when session is
         * closed due to expiry.
         */
        close(isClosedDueToExpiry) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    messageSession("[%s] Closing the MessageSession '%s' for queue '%s'.", this._context.namespace.connectionId, this.sessionId, this.name);
                    this.isReceivingMessages = false;
                    if (this._newMessageReceivedTimer)
                        clearTimeout(this._newMessageReceivedTimer);
                    if (this._sessionLockRenewalTimer)
                        clearTimeout(this._sessionLockRenewalTimer);
                    messageSession("[%s] Cleared the timers for 'no new message received' task and " +
                        "'session lock renewal' task.", this._context.namespace.connectionId);
                    if (!isClosedDueToExpiry) {
                        delete this._context.expiredMessageSessions[this.sessionId];
                    }
                    if (this._receiver) {
                        const receiverLink = this._receiver;
                        this._deleteFromCache();
                        yield this._closeLink(receiverLink);
                    }
                }
                catch (err) {
                    error("[%s] An error occurred while closing the message session with id '%s': %O.", this._context.namespace.connectionId, this.sessionId, err);
                }
            });
        }
        /**
         * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
         */
        isOpen() {
            const result = this._receiver && this._receiver.isOpen();
            messageSession("[%s] Receiver '%s' for sessionId '%s' is open? -> %s", this._context.namespace.connectionId, this.name, this.sessionId, result);
            return result;
        }
        /**
         * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
         * from a Queue/Subscription.
         * To stop receiving messages, call `close()` on the SessionReceiver or set the property
         * `newMessageWaitTimeoutInSeconds` in the options to provide a timeout.
         *
         * @param onMessage - Handler for processing each incoming message.
         * @param onError - Handler for any error that occurs while receiving or processing messages.
         * @param options - Options to control whether messages should be automatically completed. You can
         * also provide a timeout in seconds to denote the amount of time to wait for a new message
         * before closing the receiver.
         *
         * @returns void
         */
        receive(onMessage, onError, options) {
            if (!options)
                options = {};
            this.isReceivingMessages = true;
            if (typeof options.maxConcurrentCalls === "number" && options.maxConcurrentCalls > 0) {
                this.maxConcurrentCalls = options.maxConcurrentCalls;
            }
            // If explicitly set to false then autoComplete is false else true (default).
            this.autoComplete = options.autoComplete === false ? options.autoComplete : true;
            this._onMessage = onMessage;
            this._onError = onError;
            const connectionId = this._context.namespace.connectionId;
            /**
             * Resets the timer when a new message is received for Session Manager.
             * It will close the receiver gracefully, if no
             * messages were received for the configured newMessageWaitTimeoutInSeconds
             */
            const resetTimerOnNewMessageReceived = () => {
                if (this._newMessageReceivedTimer)
                    clearTimeout(this._newMessageReceivedTimer);
                if (this.newMessageWaitTimeoutInSeconds) {
                    this._newMessageReceivedTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        const msg = `MessageSession '${this.sessionId}' with name '${this.name}' did not receive ` +
                            `any messages in the last ${this.newMessageWaitTimeoutInSeconds} seconds. Hence closing it.`;
                        error("[%s] %s", this._context.namespace.connectionId, msg);
                        if (this.callee === SessionCallee.sessionManager) {
                            // The session manager will not forward this error to user.
                            // Instead, this is taken as a indicator to create a new session client for the next session.
                            const error = translate({
                                condition: "com.microsoft:message-wait-timeout",
                                description: msg
                            });
                            this._notifyError(translate(error));
                        }
                        yield this.close();
                    }), this.newMessageWaitTimeoutInSeconds * 1000);
                }
            };
            if (this._receiver && this._receiver.isOpen()) {
                const onSessionMessage = (context) => __awaiter(this, void 0, void 0, function* () {
                    // If the receiver got closed in PeekLock mode, avoid processing the message as we
                    // cannot settle the message.
                    if (this.receiveMode === exports.ReceiveMode.peekLock &&
                        (!this._receiver || !this._receiver.isOpen())) {
                        error("[%s] Not calling the user's message handler for the current message " +
                            "as the receiver '%s' is closed", connectionId, this.name);
                        return;
                    }
                    resetTimerOnNewMessageReceived();
                    const bMessage = new ServiceBusMessage(this._context, context.message, context.delivery, true);
                    try {
                        yield this._onMessage(bMessage);
                    }
                    catch (err) {
                        // This ensures we call users' error handler when users' message handler throws.
                        if (!lib_19(err)) {
                            error("[%s] An error occurred while running user's message handler for the message " +
                                "with id '%s' on the receiver '%s': %O", connectionId, bMessage.messageId, this.name, err);
                            this._onError(err);
                        }
                        const error$1 = translate(err);
                        // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                        if (!bMessage.delivery.remote_settled &&
                            this.receiveMode === exports.ReceiveMode.peekLock &&
                            this.isOpen() // only try to abandon the messages if the connection is still open
                        ) {
                            try {
                                error("[%s] Abandoning the message with id '%s' on the receiver '%s' since " +
                                    "an error occured: %O.", connectionId, bMessage.messageId, this.name, error$1);
                                yield bMessage.abandon();
                            }
                            catch (abandonError) {
                                const translatedError = translate(abandonError);
                                error("[%s] An error occurred while abandoning the message with id '%s' on the " +
                                    "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                                this._notifyError(translatedError);
                            }
                        }
                        return;
                    }
                    finally {
                        if (this._receiver) {
                            this._receiver.addCredit(1);
                        }
                    }
                    // If we've made it this far, then user's message handler completed fine. Let us try
                    // completing the message.
                    if (this.autoComplete &&
                        this.receiveMode === exports.ReceiveMode.peekLock &&
                        !bMessage.delivery.remote_settled) {
                        try {
                            messageSession("[%s] Auto completing the message with id '%s' on " + "the receiver '%s'.", connectionId, bMessage.messageId, this.name);
                            yield bMessage.complete();
                        }
                        catch (completeError) {
                            const translatedError = translate(completeError);
                            error("[%s] An error occurred while completing the message with id '%s' on the " +
                                "receiver '%s': %O.", connectionId, bMessage.messageId, this.name, translatedError);
                            this._notifyError(translatedError);
                        }
                    }
                });
                // setting the "message" event listener.
                this._receiver.on(lib_7.message, onSessionMessage);
                // adding credit
                this._receiver.addCredit(this.maxConcurrentCalls);
            }
            else {
                this.isReceivingMessages = false;
                const msg = `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` +
                    `has either not been created or is not open.`;
                error("[%s] %s", this._context.namespace.connectionId, msg);
                this._notifyError(new Error(msg));
            }
        }
        /**
         * Returns a batch of messages based on given count and timeout over an AMQP receiver link
         * from a Queue/Subscription.
         *
         * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
         * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.
         * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
         * - **Default**: `60` seconds.
         * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
         */
        receiveMessages(maxMessageCount, maxWaitTimeInSeconds) {
            return __awaiter(this, void 0, void 0, function* () {
                if (maxWaitTimeInSeconds == null) {
                    maxWaitTimeInSeconds = defaultOperationTimeoutInSeconds;
                }
                const brokeredMessages = [];
                this.isReceivingMessages = true;
                return new Promise((resolve, reject) => {
                    let totalWaitTimer;
                    const setnewMessageWaitTimeoutInSeconds = (value) => {
                        this.newMessageWaitTimeoutInSeconds = value;
                    };
                    setnewMessageWaitTimeoutInSeconds(1);
                    // Action to be performed on the "receiver_drained" event.
                    const onReceiveDrain = () => {
                        this._receiver.removeListener(lib_7.receiverDrained, onReceiveDrain);
                        this._receiver.drain = false;
                        this.isReceivingMessages = false;
                        messageSession("[%s] Receiver '%s' drained. Resolving receiveMessages() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                        resolve(brokeredMessages);
                    };
                    // Action to be performed after the max wait time is over.
                    const actionAfterWaitTimeout = () => {
                        batching("[%s] Batching Receiver '%s'  max wait time in seconds %d over.", this._context.namespace.connectionId, this.name, maxWaitTimeInSeconds);
                        return finalAction();
                    };
                    // Action to be performed on the "message" event.
                    const onReceiveMessage = (context) => __awaiter(this, void 0, void 0, function* () {
                        resetTimerOnNewMessageReceived();
                        try {
                            const data = new ServiceBusMessage(this._context, context.message, context.delivery, true);
                            if (brokeredMessages.length < maxMessageCount) {
                                brokeredMessages.push(data);
                            }
                        }
                        catch (err) {
                            // Removing listeners, so that the next receiveMessages() call can set them again.
                            if (this._receiver) {
                                this._receiver.removeListener(lib_7.message, onReceiveMessage);
                                this._receiver.removeListener(lib_7.receiverDrained, onReceiveDrain);
                            }
                            error("[%s] Receiver '%s' received an error while converting AmqpMessage to ServiceBusMessage:\n%O", this._context.namespace.connectionId, this.name, err);
                            reject(err instanceof Error ? err : new Error(JSON.stringify(err)));
                        }
                        if (brokeredMessages.length === maxMessageCount) {
                            finalAction();
                        }
                    });
                    this._onError = (error) => {
                        this.isReceivingMessages = false;
                        // Resetting the newMessageWaitTimeoutInSeconds to undefined since we are done receiving
                        // a batch of messages.
                        setnewMessageWaitTimeoutInSeconds();
                        if (totalWaitTimer) {
                            clearTimeout(totalWaitTimer);
                        }
                        // Removing listeners, so that the next receiveMessages() call can set them again.
                        if (this._receiver) {
                            this._receiver.removeListener(lib_7.message, onReceiveMessage);
                            this._receiver.removeListener(lib_7.receiverDrained, onReceiveDrain);
                        }
                        reject(error);
                    };
                    // Final action to be performed after maxMessageCount is reached or the maxWaitTime is over.
                    const finalAction = () => {
                        if (this._newMessageReceivedTimer) {
                            clearTimeout(this._newMessageReceivedTimer);
                        }
                        if (totalWaitTimer) {
                            clearTimeout(totalWaitTimer);
                        }
                        // Unsetting the newMessageWaitTimeoutInSeconds to undefined since we are done receiving
                        // a batch of messages.
                        setnewMessageWaitTimeoutInSeconds();
                        // Removing listeners, so that the next receiveMessages() call can set them again.
                        if (this._receiver) {
                            this._receiver.removeListener(lib_7.message, onReceiveMessage);
                        }
                        if (this._receiver && this._receiver.credit > 0) {
                            messageSession("[%s] Receiver '%s': Draining leftover credits(%d).", this._context.namespace.connectionId, this.name, this._receiver.credit);
                            // Setting drain must be accompanied by a flow call (aliased to addCredit in this case).
                            this._receiver.drain = true;
                            this._receiver.addCredit(1);
                        }
                        else {
                            if (this._receiver) {
                                this._receiver.removeListener(lib_7.receiverDrained, onReceiveDrain);
                            }
                            this.isReceivingMessages = false;
                            messageSession("[%s] Receiver '%s': Resolving receiveMessages() with %d messages.", this._context.namespace.connectionId, this.name, brokeredMessages.length);
                            resolve(brokeredMessages);
                        }
                    };
                    /**
                     * Resets the timer when a new message is received. If no messages were received for
                     * `newMessageWaitTimeoutInSeconds`, the messages received till now are returned. The
                     * receiver link stays open for the next receive call, but doesnt receive messages until then.
                     * The new message wait timer mechanism is used only in `peekLock` mode.
                     */
                    const resetTimerOnNewMessageReceived = this.receiveMode === exports.ReceiveMode.peekLock
                        ? () => {
                            if (this._newMessageReceivedTimer)
                                clearTimeout(this._newMessageReceivedTimer);
                            if (this.newMessageWaitTimeoutInSeconds) {
                                this._newMessageReceivedTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                                    const msg = `MessageSession '${this.sessionId}' with name '${this.name}' did not receive ` +
                                        `any messages in the last ${this.newMessageWaitTimeoutInSeconds} seconds. Hence closing it.`;
                                    error("[%s] %s", this._context.namespace.connectionId, msg);
                                    finalAction();
                                    if (this.callee === SessionCallee.sessionManager) {
                                        yield this.close();
                                    }
                                }), this.newMessageWaitTimeoutInSeconds * 1000);
                            }
                        }
                        : () => { };
                    const addCreditAndSetTimer = (reuse) => {
                        batching("[%s] Receiver '%s', adding credit for receiving %d messages.", this._context.namespace.connectionId, this.name, maxMessageCount);
                        // By adding credit here, we let the service know that at max we can handle `maxMessageCount`
                        // number of messages concurrently. We will return the user an array of messages that can
                        // be of size upto maxMessageCount. Then the user needs to accordingly dispose
                        // (complete,/abandon/defer/deadletter) the messages from the array.
                        this._receiver.addCredit(maxMessageCount);
                        let msg = "[%s] Setting the wait timer for %d seconds for receiver '%s'.";
                        if (reuse)
                            msg += " Receiver link already present, hence reusing it.";
                        batching(msg, this._context.namespace.connectionId, maxWaitTimeInSeconds, this.name);
                        totalWaitTimer = setTimeout(actionAfterWaitTimeout, maxWaitTimeInSeconds * 1000);
                    };
                    if (this.isOpen()) {
                        this._receiver.on(lib_7.message, onReceiveMessage);
                        this._receiver.on(lib_7.receiverDrained, onReceiveDrain);
                        addCreditAndSetTimer(true);
                    }
                    else {
                        const msg = `MessageSession "${this.name}" with sessionId "${this.sessionId}", ` +
                            `is already closed. Hence cannot receive messages in a batch.`;
                        error("[%s] %s", this._context.namespace.connectionId, msg);
                        reject(new Error(msg));
                    }
                });
            });
        }
        /**
         * Settles the message with the specified disposition.
         * @param message The ServiceBus Message that needs to be settled.
         * @param operation The disposition type.
         * @param options Optional parameters that can be provided while disposing the message.
         */
        settleMessage(message, operation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((resolve, reject) => {
                    if (!options)
                        options = {};
                    if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {
                        return reject(new Error(`operation: '${operation}' is not a valid operation.`));
                    }
                    const delivery = message.delivery;
                    const timer = setTimeout(() => {
                        this._deliveryDispositionMap.delete(delivery.id);
                        receiver("[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. " +
                            "Hence rejecting the promise with timeout error", this._context.namespace.connectionId, delivery.id, defaultOperationTimeoutInSeconds * 1000);
                        const e = {
                            condition: ErrorNameConditionMapper.ServiceUnavailableError,
                            description: "Operation to settle the message has timed out. The disposition of the " +
                                "message may or may not be successful"
                        };
                        return reject(translate(e));
                    }, defaultOperationTimeoutInSeconds * 1000);
                    this._deliveryDispositionMap.set(delivery.id, {
                        resolve: resolve,
                        reject: reject,
                        timer: timer
                    });
                    if (operation === DispositionType.complete) {
                        delivery.accept();
                    }
                    else if (operation === DispositionType.abandon) {
                        const params = {
                            undeliverable_here: false
                        };
                        if (options.propertiesToModify)
                            params.message_annotations = options.propertiesToModify;
                        delivery.modified(params);
                    }
                    else if (operation === DispositionType.defer) {
                        const params = {
                            undeliverable_here: true
                        };
                        if (options.propertiesToModify)
                            params.message_annotations = options.propertiesToModify;
                        delivery.modified(params);
                    }
                    else if (operation === DispositionType.deadletter) {
                        delivery.reject(options.error || {});
                    }
                });
            });
        }
        /**
         * Creates a new instance of the MessageSession based on the provided parameters.
         * @param context The client entity context
         * @param options Options that can be provided while creating the MessageSession.
         */
        static create(context, options) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(context.namespace);
                const messageSession = new MessageSession(context, options);
                yield messageSession._init();
                return messageSession;
            });
        }
    }
    //# sourceMappingURL=messageSession.js.map

    /**
     * The Receiver class can be used to receive messages in a batch or by registering handlers.
     * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate a Receiver.
     * The Receiver class is an abstraction over the underlying AMQP receiver link.
     * @class Receiver
     */
    class Receiver$1 {
        /**
         * @internal
         * @throws Error if the underlying connection is closed.
         */
        constructor(context, receiveMode) {
            /**
             * @property {boolean} [_isClosed] Denotes if close() was called on this receiver
             */
            this._isClosed = false;
            throwErrorIfConnectionClosed(context.namespace);
            this._context = context;
            this._receiveMode =
                receiveMode === exports.ReceiveMode.receiveAndDelete ? receiveMode : exports.ReceiveMode.peekLock;
        }
        _throwIfAlreadyReceiving() {
            if (this.isReceivingMessages()) {
                const errorMessage = getAlreadyReceivingErrorMsg(this._context.entityPath);
                const error$1 = new Error(errorMessage);
                error(`[${this._context.namespace.connectionId}] %O`, error$1);
                throw error$1;
            }
        }
        _throwIfReceiverOrConnectionClosed() {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (this.isClosed) {
                const errorMessage = getReceiverClosedErrorMsg(this._context.entityPath, this._context.clientType, this._context.isClosed);
                const error$1 = new Error(errorMessage);
                error(`[${this._context.namespace.connectionId}] %O`, error$1);
                throw error$1;
            }
        }
        /**
         * @property Denotes receiveMode of this receiver.
         * @readonly
         */
        get receiveMode() {
            return this._receiveMode;
        }
        /**
         * @property Returns `true` if the receiver is closed. This can happen either because the receiver
         * itself has been closed or the client that created it has been closed.
         * @readonly
         */
        get isClosed() {
            return this._isClosed || this._context.isClosed;
        }
        /**
         * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
         * from a Queue/Subscription.
         * To stop receiving messages, call `close()` on the Receiver.
         *
         * Throws an error if there is another receive operation in progress on the same receiver. If you
         * are not sure whether there is another receive operation running, check the `isReceivingMessages`
         * property on the receiver.
         *
         * @param onMessage - Handler for processing each incoming message.
         * @param onError - Handler for any error that occurs while receiving or processing messages.
         * @param options - Options to control if messages should be automatically completed, and/or have
         * their locks automatically renewed. You can control the maximum number of messages that should
         * be concurrently processed. You can also provide a timeout in seconds to denote the
         * amount of time to wait for a new message before closing the receiver.
         *
         * @returns void
         * @throws Error if the underlying connection or receiver is closed.
         * @throws Error if current receiver is already in state of receiving messages.
         * @throws MessagingError if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
         */
        registerMessageHandler(onMessage, onError, options) {
            this._throwIfReceiverOrConnectionClosed();
            this._throwIfAlreadyReceiving();
            const connId = this._context.namespace.connectionId;
            throwTypeErrorIfParameterMissing(connId, "onMessage", onMessage);
            throwTypeErrorIfParameterMissing(connId, "onError", onError);
            if (typeof onMessage !== "function") {
                throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
            }
            if (typeof onError !== "function") {
                throw new TypeError("The parameter 'onError' must be of type 'function'.");
            }
            StreamingReceiver.create(this._context, Object.assign(Object.assign({}, options), { receiveMode: this._receiveMode }))
                .then((sReceiver) => __awaiter(this, void 0, void 0, function* () {
                if (!sReceiver) {
                    return;
                }
                if (!this.isClosed) {
                    sReceiver.receive(onMessage, onError);
                }
                else {
                    yield sReceiver.close();
                }
                return;
            }))
                .catch((err) => {
                onError(err);
            });
        }
        /**
         * Returns a promise that resolves to an array of messages based on given count and timeout over
         * an AMQP receiver link from a Queue/Subscription.
         *
         * Throws an error if there is another receive operation in progress on the same receiver. If you
         * are not sure whether there is another receive operation running, check the `isReceivingMessages`
         * property on the receiver.
         *
         * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
         * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.
         * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
         * - **Default**: `60` seconds.
         * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
         * @throws Error if the underlying connection, client or receiver is closed.
         * @throws Error if current receiver is already in state of receiving messages.
         * @throws MessagingError if the service returns an error while receiving messages.
         */
        receiveMessages(maxMessageCount, maxWaitTimeInSeconds) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                this._throwIfAlreadyReceiving();
                if (!this._context.batchingReceiver || !this._context.batchingReceiver.isOpen()) {
                    const options = {
                        maxConcurrentCalls: 0,
                        receiveMode: this._receiveMode
                    };
                    this._context.batchingReceiver = BatchingReceiver.create(this._context, options);
                }
                return this._context.batchingReceiver.receive(maxMessageCount, maxWaitTimeInSeconds);
            });
        }
        /**
         * Gets an async iterator over messages from the receiver.
         *
         * Throws an error if there is another receive operation in progress on the same receiver. If you
         * are not sure whether there is another receive operation running, check the `isReceivingMessages`
         * property on the receiver.
         *
         * If the iterator is not able to fetch a new message in over a minute, `undefined` will be returned.
         * @throws Error if the underlying connection, client or receiver is closed.
         * @throws Error if current receiver is already in state of receiving messages.
         * @throws MessagingError if the service returns an error while receiving messages.
         */
        getMessageIterator() {
            return __asyncGenerator(this, arguments, function* getMessageIterator_1() {
                while (true) {
                    const currentBatch = yield __await(this.receiveMessages(1));
                    yield yield __await(currentBatch[0]);
                }
            });
        }
        /**
         * Renews the lock on the message for the duration as specified during the Queue/Subscription
         * creation.
         * - Check the `lockedUntilUtc` property on the message for the time when the lock expires.
         * - If a message is not settled (using either `complete()`, `defer()` or `deadletter()`,
         * before its lock expires, then the message lands back in the Queue/Subscription for the next
         * receive operation.
         *
         * @param lockTokenOrMessage - The `lockToken` property of the message or the message itself.
         * @returns Promise<Date> - New lock token expiry date and time in UTC format.
         * @throws Error if the underlying connection, client or receiver is closed.
         * @throws MessagingError if the service returns an error while renewing message lock.
         */
        renewMessageLock(lockTokenOrMessage) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                if (this._receiveMode !== exports.ReceiveMode.peekLock) {
                    throw new Error(getErrorMessageNotSupportedInReceiveAndDeleteMode("renew the message lock"));
                }
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "lockTokenOrMessage", lockTokenOrMessage);
                const lockToken = lockTokenOrMessage instanceof ServiceBusMessage
                    ? String(lockTokenOrMessage.lockToken)
                    : String(lockTokenOrMessage);
                const lockedUntilUtc = yield this._context.managementClient.renewLock(lockToken);
                return lockedUntilUtc;
            });
        }
        /**
         * Returns a promise that resolves to a deferred message identified by the given `sequenceNumber`.
         * @param sequenceNumber The sequence number of the message that needs to be received.
         * @returns Promise<ServiceBusMessage | undefined>
         * - Returns `Message` identified by sequence number.
         * - Returns `undefined` if no such message is found.
         * @throws Error if the underlying connection, client or receiver is closed.
         * @throws MessagingError if the service returns an error while receiving deferred message.
         */
        receiveDeferredMessage(sequenceNumber) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
                throwTypeErrorIfParameterNotLong(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
                const messages = yield this._context.managementClient.receiveDeferredMessages([sequenceNumber], this._receiveMode);
                return messages[0];
            });
        }
        /**
         * Returns a promise that resolves to an array of deferred messages identified by given `sequenceNumbers`.
         * @param sequenceNumbers An array of sequence numbers for the messages that need to be received.
         * @returns Promise<ServiceBusMessage[]>
         * - Returns a list of messages identified by the given sequenceNumbers.
         * - Returns an empty list if no messages are found.
         * @throws Error if the underlying connection, client or receiver is closed.
         * @throws MessagingError if the service returns an error while receiving deferred messages.
         */
        receiveDeferredMessages(sequenceNumbers) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
                if (!Array.isArray(sequenceNumbers)) {
                    sequenceNumbers = [sequenceNumbers];
                }
                throwTypeErrorIfParameterNotLongArray(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
                return this._context.managementClient.receiveDeferredMessages(sequenceNumbers, this._receiveMode);
            });
        }
        /**
         * Closes the underlying AMQP receiver link.
         * Once closed, the receiver cannot be used for any further operations.
         * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate
         * a new Receiver
         *
         * @returns {Promise<void>}
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    this._isClosed = true;
                    if (this._context.namespace.connection && this._context.namespace.connection.isOpen()) {
                        // Close the streaming receiver.
                        if (this._context.streamingReceiver) {
                            yield this._context.streamingReceiver.close();
                        }
                        // Close the batching receiver.
                        if (this._context.batchingReceiver) {
                            yield this._context.batchingReceiver.close();
                        }
                        // Make sure that we clear the map of deferred messages
                        this._context.requestResponseLockedMessages.clear();
                    }
                }
                catch (err) {
                    error("[%s] An error occurred while closing the Receiver for %s: %O", this._context.namespace.connectionId, this._context.entityPath, err);
                    throw err;
                }
            });
        }
        /**
         * Indicates whether the receiver is currently receiving messages or not.
         * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
         */
        isReceivingMessages() {
            if (this._context.streamingReceiver && this._context.streamingReceiver.isOpen()) {
                return true;
            }
            if (this._context.batchingReceiver &&
                this._context.batchingReceiver.isOpen() &&
                this._context.batchingReceiver.isReceivingMessages) {
                return true;
            }
            return false;
        }
    }
    /**
     * The SessionReceiver class can be used to receive messages from a session enabled Queue or
     * Subscription in a batch or by registering handlers.
     * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate a
     * SessionReceiver.
     * The SessionReceiver class is an abstraction over the underlying AMQP receiver link.
     * @class SessionReceiver
     */
    class SessionReceiver {
        /**
         * @internal
         * @throws Error if the underlying connection is closed.
         * @throws Error if an open receiver is already existing for given sessionId.
         */
        constructor(context, receiveMode, sessionOptions) {
            /**
             * @property {boolean} [_isClosed] Denotes if close() was called on this receiver
             */
            this._isClosed = false;
            throwErrorIfConnectionClosed(context.namespace);
            this._context = context;
            this._receiveMode =
                receiveMode === exports.ReceiveMode.receiveAndDelete ? receiveMode : exports.ReceiveMode.peekLock;
            this._sessionOptions = sessionOptions;
            if (sessionOptions.sessionId) {
                sessionOptions.sessionId = String(sessionOptions.sessionId);
                // Check if receiver for given session already exists
                if (this._context.messageSessions[sessionOptions.sessionId] &&
                    this._context.messageSessions[sessionOptions.sessionId].isOpen()) {
                    const errorMessage = getOpenReceiverErrorMsg(this._context.clientType, this._context.entityPath, sessionOptions.sessionId);
                    const error$1 = new Error(errorMessage);
                    error(`[${this._context.namespace.connectionId}] %O`, error$1);
                    throw error$1;
                }
            }
        }
        _throwIfReceiverOrConnectionClosed() {
            throwErrorIfConnectionClosed(this._context.namespace);
            if (this.isClosed) {
                const errorMessage = getReceiverClosedErrorMsg(this._context.entityPath, this._context.clientType, this._context.isClosed, this.sessionId);
                const error$1 = new Error(errorMessage);
                error(`[${this._context.namespace.connectionId}] %O`, error$1);
                throw error$1;
            }
        }
        _createMessageSessionIfDoesntExist() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._messageSession) {
                    return;
                }
                this._context.isSessionEnabled = true;
                this._messageSession = yield MessageSession.create(this._context, {
                    sessionId: this._sessionOptions.sessionId,
                    maxSessionAutoRenewLockDurationInSeconds: this._sessionOptions
                        .maxSessionAutoRenewLockDurationInSeconds,
                    receiveMode: this._receiveMode
                });
                // By this point, we should have a valid sessionId on the messageSession
                // If not, the receiver cannot be used, so throw error.
                if (this._messageSession.sessionId == null) {
                    const error$1 = new Error("Something went wrong. Cannot lock a session.");
                    error(`[${this._context.namespace.connectionId}] %O`, error$1);
                    throw error$1;
                }
                this._sessionId = this._messageSession.sessionId;
                delete this._context.expiredMessageSessions[this._messageSession.sessionId];
            });
        }
        _throwIfAlreadyReceiving() {
            if (this.isReceivingMessages()) {
                const errorMessage = getAlreadyReceivingErrorMsg(this._context.entityPath, this.sessionId);
                const error$1 = new Error(errorMessage);
                error(`[${this._context.namespace.connectionId}] %O`, error$1);
                throw error$1;
            }
        }
        /**
         * @property Denotes receiveMode of this receiver.
         * @readonly
         */
        get receiveMode() {
            return this._receiveMode;
        }
        /**
         * @property Returns `true` if the receiver is closed. This can happen either because the receiver
         * itself has been closed or the client that created it has been closed.
         * @readonly
         */
        get isClosed() {
            return (this._isClosed || (this.sessionId ? !this._context.messageSessions[this.sessionId] : false));
        }
        /**
         * @property The id of the session from which this receiver will receive messages.
         * Will return undefined until a AMQP receiver link has been successfully set up for the session.
         * @readonly
         */
        get sessionId() {
            return this._sessionId;
        }
        /**
         * @property The time in UTC until which the session is locked.
         * Everytime `renewSessionLock()` is called, this time gets updated to current time plus the lock
         * duration as specified during the Queue/Subscription creation.
         *
         * Will return undefined until a AMQP receiver link has been successfully set up for the session.
         *
         * @readonly
         */
        get sessionLockedUntilUtc() {
            return this._messageSession ? this._messageSession.sessionLockedUntilUtc : undefined;
        }
        /**
         * Renews the lock on the session for the duration as specified during the Queue/Subscription
         * creation.
         * - Check the `sessionLockedUntilUtc` property on the SessionReceiver for the time when the lock expires.
         * - When the lock on the session expires
         *     - No more messages can be received using this receiver
         *     - If a message is not settled (using either `complete()`, `defer()` or `deadletter()`,
         *   before the session lock expires, then the message lands back in the Queue/Subscription for the next
         *   receive operation.
         *
         * @returns Promise<Date> - New lock token expiry date and time in UTC format.
         * @throws Error if the underlying connection or receiver is closed.
         * @throws MessagingError if the service returns an error while renewing session lock.
         */
        renewSessionLock() {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                yield this._createMessageSessionIfDoesntExist();
                this._messageSession.sessionLockedUntilUtc = yield this._context.managementClient.renewSessionLock(this.sessionId);
                return this._messageSession.sessionLockedUntilUtc;
            });
        }
        /**
         * Sets the state on the Session. For more on session states, see
         * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions#message-session-state Session State}
         * @param state The state that needs to be set.
         * @throws Error if the underlying connection or receiver is closed.
         * @throws MessagingError if the service returns an error while setting the session state.
         */
        setState(state) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                yield this._createMessageSessionIfDoesntExist();
                return this._context.managementClient.setSessionState(this.sessionId, state);
            });
        }
        /**
         * Gets the state of the Session. For more on session states, see
         * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions#message-session-state Session State}
         * @returns Promise<any> The state of that session
         * @throws Error if the underlying connection or receiver is closed.
         * @throws MessagingError if the service returns an error while retrieving session state.
         */
        getState() {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                yield this._createMessageSessionIfDoesntExist();
                return this._context.managementClient.getSessionState(this.sessionId);
            });
        }
        /**
         * Fetches the next batch of active messages (including deferred but not deadlettered messages) in
         * the current session.
         * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the
         * subsequent message.
         * - Unlike a `received` message, `peeked` message is a read-only version of the message.
         * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
         *
         * @param maxMessageCount The maximum number of messages to peek. Default value `1`.
         * @returns Promise<ReceivedMessageInfo[]>
         * @throws Error if the underlying connection or receiver is closed.
         * @throws MessagingError if the service returns an error while peeking for messages.
         */
        peek(maxMessageCount) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                yield this._createMessageSessionIfDoesntExist();
                return this._context.managementClient.peekMessagesBySession(this.sessionId, maxMessageCount);
            });
        }
        /**
         * Peeks the desired number of active messages (including deferred but not deadlettered messages)
         * from the specified sequence number in the current session.
         * - Unlike a `received` message, `peeked` message is a read-only version of the message.
         * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
         *
         * @param fromSequenceNumber The sequence number from where to read the message.
         * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
         * @returns Promise<ReceivedSBMessage[]>
         * @throws Error if the underlying connection or receiver is closed.
         * @throws MessagingError if the service returns an error while peeking for messages.
         */
        peekBySequenceNumber(fromSequenceNumber, maxMessageCount) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                yield this._createMessageSessionIfDoesntExist();
                return this._context.managementClient.peekBySequenceNumber(fromSequenceNumber, maxMessageCount, this.sessionId);
            });
        }
        /**
         * Returns a promise that resolves to a deferred message identified by the given `sequenceNumber`.
         * @param sequenceNumber The sequence number of the message that needs to be received.
         * @returns Promise<ServiceBusMessage | undefined>
         * - Returns `Message` identified by sequence number.
         * - Returns `undefined` if no such message is found.
         * @throws Error if the underlying connection or receiver is closed.
         * @throws MessagingError if the service returns an error while receiving deferred message.
         */
        receiveDeferredMessage(sequenceNumber) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
                throwTypeErrorIfParameterNotLong(this._context.namespace.connectionId, "sequenceNumber", sequenceNumber);
                yield this._createMessageSessionIfDoesntExist();
                const messages = yield this._context.managementClient.receiveDeferredMessages([sequenceNumber], this._receiveMode, this.sessionId);
                return messages[0];
            });
        }
        /**
         * Returns a promise that resolves to an array of deferred messages identified by given `sequenceNumbers`.
         * @param sequenceNumbers An array of sequence numbers for the messages that need to be received.
         * @returns Promise<ServiceBusMessage[]>
         * - Returns a list of messages identified by the given sequenceNumbers.
         * - Returns an empty list if no messages are found.
         * @throws Error if the underlying connection or receiver is closed.
         * @throws MessagingError if the service returns an error while receiving deferred messages.
         */
        receiveDeferredMessages(sequenceNumbers) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
                if (!Array.isArray(sequenceNumbers)) {
                    sequenceNumbers = [sequenceNumbers];
                }
                throwTypeErrorIfParameterNotLongArray(this._context.namespace.connectionId, "sequenceNumbers", sequenceNumbers);
                yield this._createMessageSessionIfDoesntExist();
                return this._context.managementClient.receiveDeferredMessages(sequenceNumbers, this._receiveMode, this.sessionId);
            });
        }
        /**
         * Returns a promise that resolves to an array of messages based on given count and timeout over
         * an AMQP receiver link from a Queue/Subscription.
         *
         * Throws an error if there is another receive operation in progress on the same receiver. If you
         * are not sure whether there is another receive operation running, check the `isReceivingMessages`
         * property on the receiver.
         *
         * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
         * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.
         * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
         * - **Default**: `60` seconds.
         * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
         * @throws Error if the underlying connection or receiver is closed.
         * @throws Error if the receiver is already in state of receiving messages.
         * @throws MessagingError if the service returns an error while receiving messages.
         */
        receiveMessages(maxMessageCount, maxWaitTimeInSeconds) {
            return __awaiter(this, void 0, void 0, function* () {
                this._throwIfReceiverOrConnectionClosed();
                this._throwIfAlreadyReceiving();
                yield this._createMessageSessionIfDoesntExist();
                return this._messageSession.receiveMessages(maxMessageCount, maxWaitTimeInSeconds);
            });
        }
        /**
         * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
         * from a Queue/Subscription.
         * To stop receiving messages, call `close()` on the SessionReceiver.
         *
         * Throws an error if there is another receive operation in progress on the same receiver. If you
         * are not sure whether there is another receive operation running, check the `isReceivingMessages`
         * property on the receiver.
         *
         * @param onMessage - Handler for processing each incoming message.
         * @param onError - Handler for any error that occurs while receiving or processing messages.
         * @param options - Options to control whether messages should be automatically completed
         * or if the lock on the session should be automatically renewed. You can control the
         * maximum number of messages that should be concurrently processed. You can
         * also provide a timeout in seconds to denote the amount of time to wait for a new message
         * before closing the receiver.
         *
         * @returns void
         * @throws Error if the underlying connection or receiver is closed.
         * @throws Error if the receiver is already in state of receiving messages.
         * @throws MessagingErrormif the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
         */
        registerMessageHandler(onMessage, onError, options) {
            this._throwIfReceiverOrConnectionClosed();
            this._throwIfAlreadyReceiving();
            const connId = this._context.namespace.connectionId;
            throwTypeErrorIfParameterMissing(connId, "onMessage", onMessage);
            throwTypeErrorIfParameterMissing(connId, "onError", onError);
            if (typeof onMessage !== "function") {
                throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
            }
            if (typeof onError !== "function") {
                throw new TypeError("The parameter 'onError' must be of type 'function'.");
            }
            this._createMessageSessionIfDoesntExist()
                .then(() => __awaiter(this, void 0, void 0, function* () {
                if (!this._messageSession) {
                    return;
                }
                if (!this._isClosed) {
                    this._messageSession.receive(onMessage, onError, options);
                }
                else {
                    yield this._messageSession.close();
                }
                return;
            }))
                .catch((err) => {
                onError(err);
            });
        }
        /**
         * Gets an async iterator over messages from the receiver.
         *
         * Throws an error if there is another receive operation in progress on the same receiver. If you
         * are not sure whether there is another receive operation running, check the `isReceivingMessages`
         * property on the receiver.
         *
         * If the iterator is not able to fetch a new message in over a minute, `undefined` will be returned
         * @throws Error if the underlying connection or receiver is closed.
         * @throws Error if the receiver is already in state of receiving messages.
         * @throws MessagingError if the service returns an error while receiving messages.
         */
        getMessageIterator() {
            return __asyncGenerator(this, arguments, function* getMessageIterator_2() {
                while (true) {
                    const currentBatch = yield __await(this.receiveMessages(1));
                    yield yield __await(currentBatch[0]);
                }
            });
        }
        /**
         * Closes the underlying AMQP receiver link.
         * Once closed, the receiver cannot be used for any further operations.
         * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate
         * a new Receiver
         *
         * @returns {Promise<void>}
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    if (this._messageSession) {
                        yield this._messageSession.close();
                        this._messageSession = undefined;
                    }
                }
                catch (err) {
                    error("[%s] An error occurred while closing the SessionReceiver for session %s in %s: %O", this._context.namespace.connectionId, this.sessionId, this._context.entityPath, err);
                    throw err;
                }
                finally {
                    this._isClosed = true;
                }
            });
        }
        /**
         * Indicates whether the receiver is currently receiving messages or not.
         * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
         */
        isReceivingMessages() {
            return this._messageSession ? this._messageSession.isReceivingMessages : false;
        }
    }
    //# sourceMappingURL=receiver.js.map

    // Copyright (c) Microsoft Corporation. All rights reserved.
    const correlationProperties = [
        "correlationId",
        "messageId",
        "to",
        "replyTo",
        "label",
        "sessionId",
        "replyToSessionId",
        "contentType",
        "userProperties"
    ];
    /**
     * @internal
     * @class ManagementClient
     * Descibes the ServiceBus Management Client that talks
     * to the $management endpoint over AMQP connection.
     */
    class ManagementClient extends LinkEntity {
        /**
         * @constructor
         * Instantiates the management client.
         * @param {ClientEntityContext} context The client entity context.
         * @param {ManagementClientOptions} [options] Options to be provided for creating the
         * "$management" client.
         */
        constructor(context, options) {
            super(`${context.entityPath}/$management`, context, {
                address: options && options.address ? options.address : management,
                audience: options && options.audience
                    ? options.audience
                    : `${context.namespace.config.endpoint}${context.entityPath}/$management`
            });
            this.managementLock = `${managementRequestKey}-${lib_5()}`;
            /**
             * @property {string} replyTo The reply to Guid for the management client.
             */
            this.replyTo = lib_5();
            /**
             * @property _lastPeekedSequenceNumber Provides the sequence number of the last peeked message.
             * @private
             */
            this._lastPeekedSequenceNumber = long_1.ZERO;
            this._context = context;
            this.entityPath = context.namespace.config.entityPath;
        }
        _init() {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                try {
                    if (!this._isMgmtRequestResponseLinkOpen()) {
                        yield this._negotiateClaim();
                        const rxopt = {
                            source: { address: this.address },
                            name: this.replyTo,
                            target: { address: this.replyTo },
                            onSessionError: (context) => {
                                const id = context.connection.options.id;
                                const ehError = translate(context.session.error);
                                error("[%s] An error occurred on the session for request/response links for " +
                                    "$management: %O", id, ehError);
                            }
                        };
                        const sropt = { target: { address: this.address } };
                        mgmt("[%s] Creating sender/receiver links on a session for $management endpoint with " +
                            "srOpts: %o, receiverOpts: %O.", this._context.namespace.connectionId, sropt, rxopt);
                        this._mgmtReqResLink = yield RequestResponseLink.create(this._context.namespace.connection, sropt, rxopt);
                        this._mgmtReqResLink.sender.on(lib_8.senderError, (context) => {
                            const id = context.connection.options.id;
                            const ehError = translate(context.sender.error);
                            error("[%s] An error occurred on the $management sender link.. %O", id, ehError);
                        });
                        this._mgmtReqResLink.receiver.on(lib_7.receiverError, (context) => {
                            const id = context.connection.options.id;
                            const ehError = translate(context.receiver.error);
                            error("[%s] An error occurred on the $management receiver link.. %O", id, ehError);
                        });
                        mgmt("[%s] Created sender '%s' and receiver '%s' links for $management endpoint.", this._context.namespace.connectionId, this._mgmtReqResLink.sender.name, this._mgmtReqResLink.receiver.name);
                        yield this._ensureTokenRenewal();
                    }
                }
                catch (err) {
                    err = translate(err);
                    error("[%s] An error occured while establishing the $management links: %O", this._context.namespace.connectionId, err);
                    throw err;
                }
            });
        }
        _isMgmtRequestResponseLinkOpen() {
            return this._mgmtReqResLink && this._mgmtReqResLink.isOpen();
        }
        /**
         * Given array of typed values, returns the element in given index
         */
        _safelyGetTypedValueFromArray(data, index) {
            return Array.isArray(data) && data.length > index && data[index]
                ? data[index].value
                : undefined;
        }
        /**
         * Helper function to retrieve active receiver name, if it exists.
         * @param clientEntityContext The `ClientEntityContext` associated with given Service Bus entity client
         * @param sessionId `sessionId` if applicable
         */
        _getAssociatedReceiverName(clientEntityContext, sessionId) {
            if (sessionId != undefined) {
                if (clientEntityContext.messageSessions[sessionId]) {
                    return clientEntityContext.messageSessions[sessionId].name;
                }
            }
            if (clientEntityContext.batchingReceiver) {
                return clientEntityContext.batchingReceiver.name;
            }
            if (clientEntityContext.streamingReceiver) {
                return clientEntityContext.streamingReceiver.name;
            }
            return;
        }
        /**
         * Closes the AMQP management session to the ServiceBus namespace for this client,
         * returning a promise that will be resolved when disconnection is completed.
         * @return Promise<void>
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    if (this._isMgmtRequestResponseLinkOpen()) {
                        const mgmtLink = this._mgmtReqResLink;
                        this._mgmtReqResLink = undefined;
                        clearTimeout(this._tokenRenewalTimer);
                        yield mgmtLink.close();
                        mgmt("Successfully closed the management session.");
                    }
                }
                catch (err) {
                    error("[%s] An error occurred while closing the management session: %O.", this._context.namespace.connectionId, err);
                    throw err;
                }
            });
        }
        /**
         * Fetches the next batch of active messages. The first call to `peek()` fetches the first
         * active message for this client. Each subsequent call fetches the subsequent message in the
         * entity.
         *
         * Unlike a `received` message, `peeked` message will not have lock token associated with it,
         * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. This method will
         * also fetch even Deferred messages (but not Deadlettered message).
         * @param {number} [messageCount] The number of messages to retrieve. Default value `1`.
         * @returns Promise<ReceivedSBMessage[]>
         */
        peek(messageCount) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount);
            });
        }
        /**
         * Fetches the next batch of active messages in the current MessageSession. The first call to
         * `peek()` fetches the first active message for this client. Each subsequent call fetches the
         * subsequent message in the entity.
         *
         * Unlike a `received` message, `peeked` message will not have lock token associated with it,
         * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`.  This method will
         * also fetch even Deferred messages (but not Deadlettered message).
         * @param {string} sessionId The sessionId from which messages need to be peeked.
         * @param {number} [messageCount] The number of messages to retrieve. Default value `1`.
         * @returns Promise<ReceivedMessageInfo[]>
         */
        peekMessagesBySession(sessionId, messageCount) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, sessionId);
            });
        }
        /**
         * Peeks the desired number of messages from the specified sequence number.
         * @param {Long} fromSequenceNumber The sequence number from where to read the message.
         * @param {number} messageCount The number of messages to retrieve. Default value `1`.
         * @param {string} sessionId The sessionId from which messages need to be peeked.
         * @returns Promise<ReceivedMessageInfo[]>
         */
        peekBySequenceNumber(fromSequenceNumber$1, maxMessageCount, sessionId) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                const connId = this._context.namespace.connectionId;
                // Checks for fromSequenceNumber
                throwTypeErrorIfParameterMissing(connId, "fromSequenceNumber", fromSequenceNumber$1);
                throwTypeErrorIfParameterNotLong(connId, "fromSequenceNumber", fromSequenceNumber$1);
                // Checks for maxMessageCount
                if (maxMessageCount !== undefined) {
                    throwTypeErrorIfParameterTypeMismatch(connId, "maxMessageCount", maxMessageCount, "number");
                    if (maxMessageCount <= 0) {
                        return [];
                    }
                }
                else {
                    maxMessageCount = 1;
                }
                const messageList = [];
                try {
                    const messageBody = {};
                    messageBody[fromSequenceNumber] = lib_1.wrap_long(buffer_1.from(fromSequenceNumber$1.toBytesBE()));
                    messageBody[messageCount] = lib_1.wrap_int(maxMessageCount);
                    if (sessionId != undefined) {
                        messageBody[sessionIdMapKey] = sessionId;
                    }
                    const request = {
                        body: messageBody,
                        message_id: lib_5(),
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.peekMessage
                        }
                    };
                    const associatedLinkName$1 = this._getAssociatedReceiverName(this._context, sessionId);
                    if (associatedLinkName$1) {
                        request.application_properties[associatedLinkName] = associatedLinkName$1;
                    }
                    request.application_properties[trackingId] = lib_5();
                    mgmt("[%s] Peek by sequence number request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    const result = yield this._mgmtReqResLink.sendRequest(request);
                    if (result.application_properties.statusCode !== 204) {
                        const messages = result.body.messages;
                        for (const msg of messages) {
                            const decodedMessage = lib_2.decode(msg.message);
                            const message = fromAmqpMessage(decodedMessage);
                            message.body = this._context.namespace.dataTransformer.decode(message.body);
                            messageList.push(message);
                            this._lastPeekedSequenceNumber = message.sequenceNumber;
                        }
                    }
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the request to peek messages to " +
                        "$management endpoint: %O", error$1);
                    // statusCode == 404 then do not throw
                    if (error$1.name !== ConditionErrorNameMapper["com.microsoft:message-not-found"]) {
                        throw error$1;
                    }
                }
                return messageList;
            });
        }
        /**
         * Renews the lock on the message. The lock will be renewed based on the setting specified on
         * the queue.
         *
         * When a message is received in `PeekLock` mode, the message is locked on the server for this
         * receiver instance for a duration as specified during the Queue/Subscription creation
         * (LockDuration). If processing of the message requires longer than this duration, the
         * lock needs to be renewed. For each renewal, it resets the time the message is locked by the
         * LockDuration set on the Entity.
         *
         * @param {string} lockToken Lock token of the message
         * @param {SendRequestOptions} [options] Options that can be set while sending the request.
         * @returns {Promise<Date>} Promise<Date> New lock token expiry date and time in UTC format.
         */
        renewLock(lockToken, options) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                if (!options)
                    options = {};
                if (options.delayInSeconds == null)
                    options.delayInSeconds = 1;
                if (options.timeoutInSeconds == null)
                    options.timeoutInSeconds = 5;
                if (options.times == null)
                    options.times = 5;
                try {
                    const messageBody = {};
                    messageBody[lockTokens] = lib_1.wrap_array([lib_6(lockToken)], 0x98, undefined);
                    const request = {
                        body: messageBody,
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.renewLock
                        }
                    };
                    request.application_properties[trackingId] = lib_5();
                    const associatedLinkName$1 = this._getAssociatedReceiverName(this._context);
                    if (associatedLinkName$1) {
                        request.application_properties[associatedLinkName] = associatedLinkName$1;
                    }
                    mgmt("[%s] Renew message Lock request: %O.", this._context.namespace.connectionId, request);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    const result = yield this._mgmtReqResLink.sendRequest(request, options);
                    const lockedUntilUtc = new Date(result.body.expirations[0]);
                    return lockedUntilUtc;
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
        /**
         * Schedules an array of messages to appear on Service Bus at a later time.
         *
         * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
         * @param messages - An array of messages that needs to be scheduled.
         * @returns Promise<number> The sequence numbers of messages that were scheduled.
         */
        scheduleMessages(scheduledEnqueueTimeUtc, messages) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                const messageBody = [];
                for (let i = 0; i < messages.length; i++) {
                    const item = messages[i];
                    if (!item.messageId)
                        item.messageId = lib_5();
                    item.scheduledEnqueueTimeUtc = scheduledEnqueueTimeUtc;
                    const amqpMessage = toAmqpMessage(item);
                    try {
                        const entry = {
                            message: lib_2.encode(amqpMessage),
                            "message-id": item.messageId
                        };
                        if (item.sessionId) {
                            entry[sessionIdMapKey] = item.sessionId;
                        }
                        if (item.partitionKey) {
                            entry["partition-key"] = item.partitionKey;
                        }
                        if (item.viaPartitionKey) {
                            entry["via-partition-key"] = item.viaPartitionKey;
                        }
                        const wrappedEntry = lib_1.wrap_map(entry);
                        messageBody.push(wrappedEntry);
                    }
                    catch (err) {
                        let error$1;
                        if (err instanceof TypeError || err.name === "TypeError") {
                            // `RheaMessageUtil.encode` can fail if message properties are of invalid type
                            // rhea throws errors with name `TypeError` but not an instance of `TypeError`, so catch them too
                            // Errors in such cases do not have user friendy message or call stack
                            // So use `getMessagePropertyTypeMismatchError` to get a better error message
                            error$1 = translate(getMessagePropertyTypeMismatchError(item) || err);
                        }
                        else {
                            error$1 = translate(err);
                        }
                        error("An error occurred while encoding the item at position %d in the messages array" + ": %O", i, error$1);
                        throw error$1;
                    }
                }
                try {
                    const request = {
                        body: { messages: messageBody },
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.scheduleMessage
                        }
                    };
                    if (this._context.sender) {
                        request.application_properties[associatedLinkName] = this._context.sender.name;
                    }
                    request.application_properties[trackingId] = lib_5();
                    mgmt("[%s] Schedule messages request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    const result = yield this._mgmtReqResLink.sendRequest(request);
                    const sequenceNumbers$1 = result.body[sequenceNumbers];
                    const sequenceNumbersAsLong = [];
                    for (let i = 0; i < sequenceNumbers$1.length; i++) {
                        if (typeof sequenceNumbers$1[i] === "number") {
                            sequenceNumbersAsLong.push(long_1.fromNumber(sequenceNumbers$1[i]));
                        }
                        else {
                            sequenceNumbersAsLong.push(long_1.fromBytesBE(sequenceNumbers$1[i]));
                        }
                    }
                    return sequenceNumbersAsLong;
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the request to schedule messages to " +
                        "$management endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
        /**
         * Cancels an array of messages that were scheduled.
         * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.
         * @returns Promise<void>
         */
        cancelScheduledMessages(sequenceNumbers$1) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                const messageBody = {};
                messageBody[sequenceNumbers] = [];
                for (let i = 0; i < sequenceNumbers$1.length; i++) {
                    const sequenceNumber = sequenceNumbers$1[i];
                    try {
                        messageBody[sequenceNumbers].push(buffer_1.from(sequenceNumber.toBytesBE()));
                    }
                    catch (err) {
                        const error$1 = translate(err);
                        error("An error occurred while encoding the item at position %d in the " +
                            "sequenceNumbers array: %O", i, error$1);
                        throw error$1;
                    }
                }
                try {
                    messageBody[sequenceNumbers] = lib_1.wrap_array(messageBody[sequenceNumbers], 0x81, undefined);
                    const request = {
                        body: messageBody,
                        message_id: lib_5(),
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.cancelScheduledMessage
                        }
                    };
                    if (this._context.sender) {
                        request.application_properties[associatedLinkName] = this._context.sender.name;
                    }
                    request.application_properties[trackingId] = lib_5();
                    mgmt("[%s] Cancel scheduled messages request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    yield this._mgmtReqResLink.sendRequest(request);
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the request to cancel the scheduled message to " +
                        "$management endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
        /**
         * Receives a list of deferred messages identified by `sequenceNumbers`.
         * @param sequenceNumbers A list containing the sequence numbers to receive.
         * @param receiveMode The mode in which the receiver was created.
         * @returns Promise<ServiceBusMessage[]>
         * - Returns a list of messages identified by the given sequenceNumbers.
         * - Returns an empty list if no messages are found.
         * - Throws an error if the messages have not been deferred.
         */
        receiveDeferredMessages(sequenceNumbers$1, receiveMode, sessionId) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                const messageList = [];
                const messageBody = {};
                messageBody[sequenceNumbers] = [];
                for (let i = 0; i < sequenceNumbers$1.length; i++) {
                    const sequenceNumber = sequenceNumbers$1[i];
                    try {
                        messageBody[sequenceNumbers].push(buffer_1.from(sequenceNumber.toBytesBE()));
                    }
                    catch (err) {
                        const error$1 = translate(err);
                        error("An error occurred while encoding the item at position %d in the " +
                            "sequenceNumbers array: %O", i, error$1);
                        throw error$1;
                    }
                }
                try {
                    messageBody[sequenceNumbers] = lib_1.wrap_array(messageBody[sequenceNumbers], 0x81, undefined);
                    const receiverSettleMode$1 = receiveMode === exports.ReceiveMode.receiveAndDelete ? 0 : 1;
                    messageBody[receiverSettleMode] = lib_1.wrap_uint(receiverSettleMode$1);
                    if (sessionId != null) {
                        messageBody[sessionIdMapKey] = sessionId;
                    }
                    const request = {
                        body: messageBody,
                        message_id: lib_5(),
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.receiveBySequenceNumber
                        }
                    };
                    const associatedLinkName$1 = this._getAssociatedReceiverName(this._context, sessionId);
                    if (associatedLinkName$1) {
                        request.application_properties[associatedLinkName] = associatedLinkName$1;
                    }
                    request.application_properties[trackingId] = lib_5();
                    mgmt("[%s] Receive deferred messages request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    const result = yield this._mgmtReqResLink.sendRequest(request);
                    const messages = result.body.messages;
                    for (const msg of messages) {
                        const decodedMessage = lib_2.decode(msg.message);
                        const message = new ServiceBusMessage(this._context, decodedMessage, { tag: msg["lock-token"] }, false);
                        if (message.lockToken && message.lockedUntilUtc) {
                            this._context.requestResponseLockedMessages.set(message.lockToken, message.lockedUntilUtc);
                        }
                        messageList.push(message);
                    }
                    return messageList;
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the request to receive deferred messages to " +
                        "$management endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
        /**
         * Updates the disposition status of deferred messages.
         *
         * @param lockTokens Message lock tokens to update disposition status.
         * @param dispositionStatus The disposition status to be set
         * @param options Optional parameters that can be provided while updating the disposition status.
         *
         * @returns Promise<void>
         */
        updateDispositionStatus(lockToken, dispositionStatus$1, options) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                if (!options)
                    options = {};
                try {
                    const messageBody = {};
                    const lockTokenBuffer = [];
                    lockTokenBuffer.push(lib_6(lockToken));
                    messageBody[lockTokens] = lib_1.wrap_array(lockTokenBuffer, 0x98, undefined);
                    messageBody[dispositionStatus] = dispositionStatus$1;
                    if (options.deadLetterDescription != null) {
                        messageBody[deadLetterDescription] = options.deadLetterDescription;
                    }
                    if (options.deadLetterReason != null) {
                        messageBody[deadLetterReason] = options.deadLetterReason;
                    }
                    if (options.propertiesToModify != null) {
                        messageBody[propertiesToModify] = options.propertiesToModify;
                    }
                    if (options.sessionId != null) {
                        messageBody[sessionIdMapKey] = options.sessionId;
                    }
                    const request = {
                        body: messageBody,
                        message_id: lib_5(),
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.updateDisposition
                        }
                    };
                    const associatedLinkName$1 = this._getAssociatedReceiverName(this._context, options.sessionId);
                    if (associatedLinkName$1) {
                        request.application_properties[associatedLinkName] = associatedLinkName$1;
                    }
                    request.application_properties[trackingId] = lib_5();
                    mgmt("[%s] Update disposition status request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    yield this._mgmtReqResLink.sendRequest(request);
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the request to update disposition status to " +
                        "$management endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
        /**
         * Renews the lock for the specified session.
         * @param sessionId Id of the session for which the lock needs to be renewed
         * @param options Options that can be set while sending the request.
         * @returns Promise<Date> New lock token expiry date and time in UTC format.
         */
        renewSessionLock(sessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                if (!options)
                    options = {};
                if (options.delayInSeconds == null)
                    options.delayInSeconds = 1;
                if (options.timeoutInSeconds == null)
                    options.timeoutInSeconds = 5;
                if (options.times == null)
                    options.times = 5;
                try {
                    const messageBody = {};
                    messageBody[sessionIdMapKey] = sessionId;
                    const request = {
                        body: messageBody,
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.renewSessionLock
                        }
                    };
                    request.application_properties[trackingId] = lib_5();
                    const associatedLinkName$1 = this._getAssociatedReceiverName(this._context, sessionId);
                    if (associatedLinkName$1) {
                        request.application_properties[associatedLinkName] = associatedLinkName$1;
                    }
                    mgmt("[%s] Renew Session Lock request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    const result = yield this._mgmtReqResLink.sendRequest(request, options);
                    const lockedUntilUtc = new Date(result.body.expiration);
                    mgmt("[%s] Lock for session '%s' will expire at %s.", this._context.namespace.connectionId, sessionId, lockedUntilUtc.toString());
                    return lockedUntilUtc;
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
        /**
         * Sets the state of the specified session.
         * @param sessionId The session for which the state needs to be set
         * @param state The state that needs to be set.
         * @returns Promise<void>
         */
        setSessionState(sessionId, state) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                try {
                    const messageBody = {};
                    messageBody[sessionIdMapKey] = sessionId;
                    messageBody["session-state"] = toBuffer(state);
                    const request = {
                        body: messageBody,
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.setSessionState
                        }
                    };
                    const associatedLinkName$1 = this._getAssociatedReceiverName(this._context, sessionId);
                    if (associatedLinkName$1) {
                        request.application_properties[associatedLinkName] = associatedLinkName$1;
                    }
                    request.application_properties[trackingId] = lib_5();
                    mgmt("[%s] Set Session state request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    yield this._mgmtReqResLink.sendRequest(request);
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
        /**
         * Gets the state of the specified session.
         * @param sessionId The session for which the state needs to be retrieved.
         * @returns Promise<any> The state of that session
         */
        getSessionState(sessionId) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                try {
                    const messageBody = {};
                    messageBody[sessionIdMapKey] = sessionId;
                    const request = {
                        body: messageBody,
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.getSessionState
                        }
                    };
                    const associatedLinkName$1 = this._getAssociatedReceiverName(this._context, sessionId);
                    if (associatedLinkName$1) {
                        request.application_properties[associatedLinkName] = associatedLinkName$1;
                    }
                    request.application_properties[trackingId] = lib_5();
                    mgmt("[%s] Get session state request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    const result = yield this._mgmtReqResLink.sendRequest(request);
                    return result.body["session-state"]
                        ? this._context.namespace.dataTransformer.decode(result.body["session-state"])
                        : result.body["session-state"];
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
        /**
         * Lists the sessions on the ServiceBus Queue/Topic.
         * @param lastUpdateTime Filter to include only sessions updated after a given time.
         * @param skip The number of sessions to skip
         * @param top Maximum numer of sessions.
         * @returns Promise<string[]> A list of session ids.
         */
        listMessageSessions(skip, top, lastUpdatedTime) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                const defaultLastUpdatedTimeForListingSessions = 259200000; // 3 * 24 * 3600 * 1000
                if (typeof skip !== "number") {
                    throw new Error("'skip' is a required parameter and must be of type 'number'.");
                }
                if (typeof top !== "number") {
                    throw new Error("'top' is a required parameter and must be of type 'number'.");
                }
                if (lastUpdatedTime && !(lastUpdatedTime instanceof Date)) {
                    throw new Error("'lastUpdatedTime' must be of type 'Date'.");
                }
                if (!lastUpdatedTime) {
                    lastUpdatedTime = new Date(Date.now() - defaultLastUpdatedTimeForListingSessions);
                }
                try {
                    const messageBody = {};
                    messageBody["last-updated-time"] = lastUpdatedTime;
                    messageBody["skip"] = lib_1.wrap_int(skip);
                    messageBody["top"] = lib_1.wrap_int(top);
                    const request = {
                        body: messageBody,
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.enumerateSessions
                        }
                    };
                    request.application_properties[trackingId] = lib_5();
                    mgmt("[%s] List sessions request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    const response = yield this._mgmtReqResLink.sendRequest(request);
                    return (response && response.body && response.body["sessions-ids"]) || [];
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the renew lock request to $management " + "endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
        /**
         * Get all the rules on the Subscription.
         * @returns Promise<RuleDescription[]> A list of rules.
         */
        getRules() {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                try {
                    const request = {
                        body: {
                            top: lib_1.wrap_int(max32BitNumber),
                            skip: lib_1.wrap_int(0)
                        },
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.enumerateRules
                        }
                    };
                    request.application_properties[trackingId] = lib_5();
                    mgmt("[%s] Get rules request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    const response = yield this._mgmtReqResLink.sendRequest(request);
                    if (response.application_properties.statusCode === 204 ||
                        !response.body ||
                        !Array.isArray(response.body.rules)) {
                        return [];
                    }
                    // Reference: https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-amqp-request-response#response-11
                    const result = response.body.rules || [];
                    const rules = [];
                    result.forEach((x) => {
                        const ruleDescriptor = x["rule-description"];
                        // We use the first three elements of the `ruleDescriptor.value` to get filter, action, name
                        if (!ruleDescriptor ||
                            !ruleDescriptor.descriptor ||
                            ruleDescriptor.descriptor.value !== descriptorCodes.ruleDescriptionList ||
                            !Array.isArray(ruleDescriptor.value) ||
                            ruleDescriptor.value.length < 3) {
                            return;
                        }
                        const filtersRawData = ruleDescriptor.value[0];
                        const actionsRawData = ruleDescriptor.value[1];
                        const rule = {
                            name: ruleDescriptor.value[2].value
                        };
                        switch (filtersRawData.descriptor.value) {
                            case descriptorCodes.trueFilterList:
                                rule.filter = "1=1";
                                break;
                            case descriptorCodes.falseFilterList:
                                rule.filter = "1=0";
                                break;
                            case descriptorCodes.sqlFilterList:
                                rule.filter = this._safelyGetTypedValueFromArray(filtersRawData.value, 0);
                                break;
                            case descriptorCodes.correlationFilterList:
                                rule.filter = {
                                    correlationId: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),
                                    messageId: this._safelyGetTypedValueFromArray(filtersRawData.value, 1),
                                    to: this._safelyGetTypedValueFromArray(filtersRawData.value, 2),
                                    replyTo: this._safelyGetTypedValueFromArray(filtersRawData.value, 3),
                                    label: this._safelyGetTypedValueFromArray(filtersRawData.value, 4),
                                    sessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 5),
                                    replyToSessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 6),
                                    contentType: this._safelyGetTypedValueFromArray(filtersRawData.value, 7),
                                    userProperties: this._safelyGetTypedValueFromArray(filtersRawData.value, 8)
                                };
                                break;
                            default:
                                mgmt(`Found unexpected descriptor code for the filter: ${filtersRawData.descriptor.value}`);
                                break;
                        }
                        if (actionsRawData.descriptor.value === descriptorCodes.sqlRuleActionList &&
                            Array.isArray(actionsRawData.value) &&
                            actionsRawData.value.length) {
                            rule.action = this._safelyGetTypedValueFromArray(actionsRawData.value, 0);
                        }
                        rules.push(rule);
                    });
                    return rules;
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the get rules request to $management " + "endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
        /**
         * Removes the rule on the Subscription identified by the given rule name.
         * @param ruleName
         */
        removeRule(ruleName) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "ruleName", ruleName);
                ruleName = String(ruleName);
                throwTypeErrorIfParameterIsEmptyString(this._context.namespace.connectionId, "ruleName", ruleName);
                try {
                    const request = {
                        body: {
                            "rule-name": lib_1.wrap_string(ruleName)
                        },
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.removeRule
                        }
                    };
                    request.application_properties[trackingId] = lib_5();
                    mgmt("[%s] Remove Rule request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    yield this._mgmtReqResLink.sendRequest(request);
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the remove rule request to $management " + "endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
        /**
         * Adds a rule on the subscription as defined by the given rule name, filter and action
         * @param ruleName Name of the rule
         * @param filter A Boolean, SQL expression or a Correlation filter
         * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression
         */
        addRule(ruleName, filter, sqlRuleActionExpression) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfConnectionClosed(this._context.namespace);
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "ruleName", ruleName);
                ruleName = String(ruleName);
                throwTypeErrorIfParameterIsEmptyString(this._context.namespace.connectionId, "ruleName", ruleName);
                throwTypeErrorIfParameterMissing(this._context.namespace.connectionId, "filter", filter);
                if (typeof filter !== "boolean" &&
                    typeof filter !== "string" &&
                    !correlationProperties.some((validProperty) => filter.hasOwnProperty(validProperty))) {
                    throw new TypeError(`The parameter "filter" should be either a boolean, string or implement the CorrelationFilter interface.`);
                }
                try {
                    const ruleDescription = {};
                    switch (typeof filter) {
                        case "boolean":
                            ruleDescription["sql-filter"] = {
                                expression: filter ? "1=1" : "1=0"
                            };
                            break;
                        case "string":
                            ruleDescription["sql-filter"] = {
                                expression: filter
                            };
                            break;
                        default:
                            ruleDescription["correlation-filter"] = {
                                "correlation-id": filter.correlationId,
                                "message-id": filter.messageId,
                                to: filter.to,
                                "reply-to": filter.replyTo,
                                label: filter.label,
                                "session-id": filter.sessionId,
                                "reply-to-session-id": filter.replyToSessionId,
                                "content-type": filter.contentType,
                                properties: filter.userProperties
                            };
                            break;
                    }
                    if (sqlRuleActionExpression !== undefined) {
                        ruleDescription["sql-rule-action"] = {
                            expression: String(sqlRuleActionExpression)
                        };
                    }
                    const request = {
                        body: {
                            "rule-name": lib_1.wrap_string(ruleName),
                            "rule-description": lib_1.wrap_map(ruleDescription)
                        },
                        reply_to: this.replyTo,
                        application_properties: {
                            operation: operations.addRule
                        }
                    };
                    request.application_properties[trackingId] = lib_5();
                    mgmt("[%s] Add Rule request body: %O.", this._context.namespace.connectionId, request.body);
                    mgmt("[%s] Acquiring lock to get the management req res link.", this._context.namespace.connectionId);
                    yield defaultLock.acquire(this.managementLock, () => {
                        return this._init();
                    });
                    yield this._mgmtReqResLink.sendRequest(request);
                }
                catch (err) {
                    const error$1 = translate(err);
                    error("An error occurred while sending the Add rule request to $management " + "endpoint: %O", error$1);
                    throw error$1;
                }
            });
        }
    }
    //# sourceMappingURL=managementClient.js.map

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes a map that ensures, deleting a an entry from the map is concurrency safe.
     * @internal
     * @class ConcurrentExpiringMap<TKey>
     */
    class ConcurrentExpiringMap {
        constructor(options) {
            this._map = new Map();
            this._cleanupScheduled = false;
            this._lockId = lib_5();
            this._lockStore = new asyncLock({ maxPending: 1000000 });
            if (!options)
                options = {};
            this._delayBetweenCleanupInSeconds = options.delayBetweenCleanupInSeconds || 30;
        }
        _scheduleCleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._cleanupScheduled || this._map.size === 0) {
                    return;
                }
                yield this._lockStore.acquire(this._lockId, () => {
                    this._cleanupScheduled = true;
                    this._collectExpiredEntries().catch((err) => {
                        error("An error occurred while collecting expired entries: %O", err);
                    });
                });
            });
        }
        _collectExpiredEntries() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._map.size === 0) {
                    return;
                }
                yield delay(this._delayBetweenCleanupInSeconds);
                this._cleanupScheduled = false;
                for (const key of this._map.keys()) {
                    if (Date.now() > this._map.get(key).getTime()) {
                        this._map.delete(key);
                        map("Deleted the key '%s' from the map.", key);
                    }
                }
                this._scheduleCleanup().catch((err) => {
                    error("An error occurred while scheduling the cleanup, after " + "collecting expired entries: %O", err);
                });
            });
        }
        /**
         * Sets the key and it's expiration time as the value in the map.
         * @param key The key to be set.
         * @param expiration Expiration time for the key.
         * @returns void
         */
        set(key, expiration) {
            this._map.set(key, expiration);
            this._scheduleCleanup().catch((err) => {
                error("An error occurred while scheduling the cleanup, after " + "setting the key: '%s': %O", key, err);
            });
        }
        /**
         * Determines whether the key is present in the map.
         * @param key The key whose presence in the map needs to be checked.
         * @returns boolean
         */
        has(key) {
            const value = this._map.get(key);
            const result = value && value.getTime() > Date.now();
            map("Key '%s' is present in the map? -> %s", key, result);
            return result;
        }
        /**
         * Removes an entry from the the map if present
         * @param key The key which needs to be removed from the map.
         * @returns True if the key was found and removed from the map, False otherwise
         */
        delete(key) {
            map("Deleting key '%s' from the map", key);
            return this._map.delete(key);
        }
        /**
         * Clears all the entries from the underlying map.
         */
        clear() {
            map("Clearing the map of all the entries");
            this._map.clear();
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    /**
     * @internal
     * A simple Semaphore
     * @class Semaphore
     */
    class Semaphore {
        constructor(limit) {
            this._queue = [];
            this._used = 0;
            if (typeof limit !== "number") {
                throw new TypeError(`Expected limit to be a number, got ${typeof limit}`);
            }
            if (limit < 1) {
                throw new Error("limit cannot be less than 1");
            }
            this.limit = limit;
        }
        /**
         * Acquires a lock from the semaphore, returns a Promise that resolves when the caller holds
         * a lock.
         */
        acquire() {
            if (this._used < this.limit) {
                this._used += 1;
                return Promise.resolve();
            }
            return new Promise((resolve) => {
                this._queue.push(resolve);
            });
        }
        /**
         * Releases a lock back to the semaphore.
         */
        release() {
            if (this._queue.length) {
                const item = this._queue.shift();
                if (item) {
                    item();
                }
            }
            else {
                this._used -= 1;
            }
        }
        /**
         * Aquires a lock from the semaphore and then execute the fn. If the fn returns a Promise,
         * wait for that promise to settle and then release the lock back to the semaphore.
         * @param fn The function that needs to be executed in the ciritical region.
         * @returns A Promise that will settle with the return value of fn.
         */
        use(fn) {
            return this.acquire()
                .then(fn)
                .then((val) => {
                this.release();
                return val;
            })
                .catch((err) => {
                this.release();
                throw err;
            });
        }
        /**
         * Provides the number of locks currently held.
         */
        currentLockCount() {
            return this._used;
        }
        /**
         * Provides the number of tasks waiting to acquire a lock.
         */
        awaitedTaskCount() {
            return this._queue.length;
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @internal
     * Enum to denote the entity type calling the session manager
     */
    var SessionEntityType;
    (function (SessionEntityType) {
        SessionEntityType["queue"] = "Queue";
        SessionEntityType["subscription"] = "Subscription";
    })(SessionEntityType || (SessionEntityType = {}));
    /**
     * @internal
     */
    class SessionManager {
        constructor(context) {
            this._isManagingSessions = false;
            this._isCancelRequested = false;
            this._context = context;
            this.maxConcurrentSessions = 2000;
        }
        /**
         * @property {number} maxConcurrentSessions The maximum number of sessions that the user wants to
         * handle concurrently.
         * - **Default**: `2000`.
         */
        set maxConcurrentSessions(value) {
            if (value <= 0) {
                throw new Error("'maxConcurrentSessions must be greater than 0.");
            }
            this._maxConcurrentSessions = value;
            this.maxConcurrentAcceptSessionRequests = value;
        }
        get maxConcurrenSessions() {
            return this._maxConcurrentSessions;
        }
        /**
         * @property {number} _maxConcurrentAcceptSessionRequests The maximum number of acceptSession
         * requests that can be made concurrently at any given time.
         */
        set maxConcurrentAcceptSessionRequests(value) {
            this._maxConcurrentAcceptSessionRequests = Math.min(value, getProcessorCount());
        }
        get maxConcurrentAcceptSessionRequests() {
            return this._maxConcurrentAcceptSessionRequests;
        }
        /**
         * Accept a new session and start receiving messages.
         * @param onMessage Handler for receiving messages from a session enabled entity.
         * @param onError Handler for receiving errors.
         * @param options Optional parameters for handling sessions.
         */
        _acceptSessionAndReceiveMessages(onMessage, onError, options) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!options) {
                    options = {};
                }
                const connectionId = this._context.namespace.connectionId;
                const noActiveSessionBackOffInSeconds = 10;
                while (!this._isCancelRequested) {
                    try {
                        yield this._maxConcurrentSessionsSemaphore.acquire();
                        sessionManager("[%s] Acquired the semaphore for max concurrent sessions: %d, %d.", connectionId, this._maxConcurrentSessionsSemaphore.currentLockCount(), this._maxConcurrentSessionsSemaphore.awaitedTaskCount());
                        yield this._maxPendingAcceptSessionsSemaphore.acquire();
                        sessionManager("[%s] Acquired the semaphore for max pending accept sessions: %d, %d.", connectionId, this._maxPendingAcceptSessionsSemaphore.currentLockCount(), this._maxPendingAcceptSessionsSemaphore.awaitedTaskCount());
                        const closeMessageSession = (messageSession) => __awaiter(this, void 0, void 0, function* () {
                            try {
                                yield this._maxConcurrentSessionsSemaphore.release();
                                sessionManager("[%s] Releasing the semaphore for max concurrent sessions: %d, %d.", connectionId, this._maxConcurrentSessionsSemaphore.currentLockCount(), this._maxConcurrentSessionsSemaphore.awaitedTaskCount());
                                if (messageSession.isOpen()) {
                                    yield messageSession.close();
                                }
                            }
                            catch (err) {
                                error("[%s] An error occurred while releasing the max concurrent session semaphore " +
                                    "or while closing MessageSession with id '%s': %O.", connectionId, messageSession.sessionId, err);
                            }
                        });
                        // Create the MessageSession.
                        const messageSession = yield MessageSession.create(this._context, Object.assign({ sessionId: undefined, callee: SessionCallee.sessionManager }, options));
                        messageSession.newMessageWaitTimeoutInSeconds = options.newMessageWaitTimeoutInSeconds;
                        if (this._isCancelRequested) {
                            sessionManager("[%s] Since cancellation was requested, we will close the messageSession with id '%s'.", connectionId, messageSession.sessionId);
                            yield closeMessageSession(messageSession);
                        }
                        const sessionId = messageSession.sessionId;
                        this._context.messageSessions[sessionId] = messageSession;
                        sessionManager("[%s] Created MessageSession with id '%s'.", connectionId, sessionId);
                        const onSessionError = (error) => __awaiter(this, void 0, void 0, function* () {
                            sessionManager("An error ocurred in MessageSession with id '%s': %O. Hence closing it.", connectionId, sessionId, error);
                            yield closeMessageSession(messageSession);
                            if (error.name !== ConditionErrorNameMapper["com.microsoft:message-wait-timeout"]) {
                                // notify the user about the error.
                                onError(error);
                            }
                        });
                        messageSession.receive(onMessage, onSessionError, options);
                    }
                    catch (err) {
                        error("[%s] An error occurred while accepting a MessageSession: %O", connectionId, err);
                        this._maxConcurrentSessionsSemaphore.release();
                        sessionManager("[%s] Releasing the semaphore for max concurrent sessions " +
                            "because an error ocurred: %d, %d.", connectionId, this._maxConcurrentSessionsSemaphore.currentLockCount(), this._maxConcurrentSessionsSemaphore.awaitedTaskCount());
                        // When we ask servicebus to give us a random session and if there are no active sessions,
                        // ServiceBus initially sends the attach frame which causes rhea to emit "receiver_open"
                        // event and thus rhea-promise resolves the promise. Moments later ServiceBus sends a
                        // detach frame with an error that the link creation timed out. Therefore inside
                        // MessageSession._init() after the promise to create a session enabled receiver link
                        // resolves we check for sessionId. If it is undefined then we reject the Promise with an
                        // error "session-cannot-be-locked". The "operation-timeout" error happens when
                        // rhea-promise does not receive a response from ServiceBus in a predefined time frame and
                        // the Promise is rejected. The "microsoft.timeout" error occurs when timeout happens on
                        // the server side and ServiceBus sends a detach frame due to which the Promise is rejected.
                        if (err.name === ConditionErrorNameMapper["amqp:operation-timeout"] ||
                            err.name === ConditionErrorNameMapper["com.microsoft:timeout"] ||
                            err.name === ConditionErrorNameMapper["com.microsoft:session-cannot-be-locked"]) {
                            // No point in delaying if cancel has been requested.
                            if (!this._isCancelRequested) {
                                sessionManager("[%s] Sleeping for %d seconds, since there are no more active MessageSessions on " +
                                    "the ServiceBus entity.", connectionId, noActiveSessionBackOffInSeconds);
                                yield delay(noActiveSessionBackOffInSeconds * 1000);
                            }
                        }
                        else {
                            // notify the user about the error only when it is not one of the above mentioned errors.
                            onError(err);
                        }
                    }
                    finally {
                        this._maxPendingAcceptSessionsSemaphore.release();
                        sessionManager("[%s] Releasing the semaphore for max pending accept sessions from " +
                            "the finally block: %d, %d.", connectionId, this._maxPendingAcceptSessionsSemaphore.currentLockCount(), this._maxPendingAcceptSessionsSemaphore.awaitedTaskCount());
                    }
                }
            });
        }
        /**
         * Manages MessageSessions based on the provided parameters.
         * @param onMessage The message handler to receive service bus messages from a session
         * enabled entity.
         * @param onError The error handler to receive an error that occurs while receiving messages
         * from a session enabled entity.
         * @throws Error if the underlying connection is closed.
         * @throws Error if the session enabled client is already receiving messages.
         * @throws MessagingError if any error occurs while receiving messages from the service.
         */
        manageMessageSessions(entityType, onMessage, onError, options) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._isManagingSessions) {
                    throw new Error(`${entityType}Client for "${this._context.namespace.config.entityPath}" ` +
                        `is already receiving messages from sessions. Please close this ${entityType}Client or ` +
                        `create a new one and receiveMessages from Sessions.`);
                }
                this._isManagingSessions = true;
                this._isCancelRequested = false;
                if (!options)
                    options = {};
                if (options.maxConcurrentSessions)
                    this.maxConcurrentSessions = options.maxConcurrentSessions;
                // We are explicitly configuring the messageSession to timeout in 60 seconds (if not provided
                // by the user) when no new messages are received.
                if (!options.newMessageWaitTimeoutInSeconds) {
                    options.newMessageWaitTimeoutInSeconds = defaultOperationTimeoutInSeconds;
                }
                this._maxConcurrentSessionsSemaphore = new Semaphore(this.maxConcurrenSessions);
                this._maxPendingAcceptSessionsSemaphore = new Semaphore(this.maxConcurrentAcceptSessionRequests);
                for (let i = 0; i < this._maxConcurrentAcceptSessionRequests; i++) {
                    this._acceptSessionAndReceiveMessages(onMessage, onError, options).catch((err) => {
                        error(err);
                    });
                }
            });
        }
        /**
         * Close the session manager.
         */
        close() {
            sessionManager("[%s] Closing the SessionMaanger for entity '%s'.", this._context.namespace.connectionId, this._context.entityPath);
            this._isCancelRequested = true;
            this._isManagingSessions = false;
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @internal
     */
    var ClientEntityContext;
    (function (ClientEntityContext) {
        /**
         * @internal
         */
        function create(entityPath, clientType, context, clientId, options) {
            entityCtxt("[%s] Creating client entity context for %s: %O", context.connectionId, clientId);
            if (!options)
                options = {};
            const entityContext = {
                namespace: context,
                entityPath: entityPath,
                clientType: clientType,
                clientId: clientId,
                isClosed: false,
                requestResponseLockedMessages: new ConcurrentExpiringMap(),
                isSessionEnabled: !!options.isSessionEnabled,
                messageSessions: {},
                expiredMessageSessions: {}
            };
            entityContext.sessionManager = new SessionManager(entityContext);
            entityContext.getReceiver = (name, sessionId) => {
                if (sessionId != undefined && entityContext.expiredMessageSessions[sessionId]) {
                    const error$1 = new Error(`The session lock has expired on the session with id ${sessionId}.`);
                    error$1.name = "SessionLockLostError";
                    error("[%s] Failed to find receiver '%s' as the session with id '%s' is expired", entityContext.namespace.connectionId, name, sessionId);
                    throw error$1;
                }
                if (sessionId != null &&
                    entityContext.messageSessions[sessionId] &&
                    entityContext.messageSessions[sessionId].name === name) {
                    return entityContext.messageSessions[sessionId];
                }
                if (entityContext.streamingReceiver && entityContext.streamingReceiver.name === name) {
                    return entityContext.streamingReceiver;
                }
                if (entityContext.batchingReceiver && entityContext.batchingReceiver.name === name) {
                    return entityContext.batchingReceiver;
                }
                let existingReceivers = "";
                if (sessionId != null && entityContext.messageSessions[sessionId]) {
                    existingReceivers = entityContext.messageSessions[sessionId].name;
                }
                else {
                    if (entityContext.streamingReceiver) {
                        existingReceivers = entityContext.streamingReceiver.name;
                    }
                    if (entityContext.batchingReceiver) {
                        existingReceivers +=
                            (existingReceivers ? ", " : "") + entityContext.batchingReceiver.name;
                    }
                }
                error("[%s] Failed to find receiver '%s' among existing receivers: %s", entityContext.namespace.connectionId, name, existingReceivers);
                return;
            };
            entityContext.onDetached = (error$1) => __awaiter(this, void 0, void 0, function* () {
                const connectionId = entityContext.namespace.connectionId;
                // Call onDetached() on sender so that it can decide whether to reconnect or not
                const sender = entityContext.sender;
                if (sender && !sender.isConnecting) {
                    try {
                        error("[%s] calling detached on sender '%s'.", connectionId, sender.name);
                        yield sender.onDetached();
                    }
                    catch (err) {
                        error("[%s] An error occurred while calling onDetached() the sender '%s': %O.", connectionId, sender.name, err);
                    }
                }
                // Call onDetached() on batchingReceiver so that it can gracefully close any ongoing batch operation.
                const batchingReceiver = entityContext.batchingReceiver;
                if (batchingReceiver && !batchingReceiver.isConnecting) {
                    try {
                        error("[%s] calling detached on batching receiver '%s'.", connectionId, batchingReceiver.name);
                        yield batchingReceiver.onDetached(error$1);
                    }
                    catch (err) {
                        error("[%s] An error occurred while calling onDetached() on the batching receiver '%s': %O.", connectionId, batchingReceiver.name, err);
                    }
                }
                // Call onDetached() on streamingReceiver so that it can decide whether to reconnect or not
                const streamingReceiver = entityContext.streamingReceiver;
                if (streamingReceiver && !streamingReceiver.isConnecting) {
                    try {
                        error("[%s] calling detached on streaming receiver '%s'.", connectionId, streamingReceiver.name);
                        yield streamingReceiver.onDetached(error$1);
                    }
                    catch (err) {
                        error("[%s] An error occurred while calling onDetached() on the streaming receiver '%s': %O.", connectionId, streamingReceiver.name, err);
                    }
                }
            });
            const isManagementClientSharedWithOtherClients = () => {
                for (const id of Object.keys(context.clientContexts)) {
                    if (context.clientContexts[id].entityPath === entityContext.entityPath &&
                        context.clientContexts[id].clientId !== entityContext.clientId) {
                        return true;
                    }
                }
                return false;
            };
            entityContext.close = () => __awaiter(this, void 0, void 0, function* () {
                if (!context.connection || !context.connection.isOpen()) {
                    return;
                }
                entityCtxt("[%s] Closing client entity context for %s: %O", context.connectionId, clientId);
                // Close sender
                if (entityContext.sender) {
                    yield entityContext.sender.close();
                }
                // Close batching receiver
                if (entityContext.batchingReceiver) {
                    yield entityContext.batchingReceiver.close();
                }
                // Close streaming receiver
                if (entityContext.streamingReceiver) {
                    yield entityContext.streamingReceiver.close();
                }
                // Close all the MessageSessions.
                for (const messageSessionId of Object.keys(entityContext.messageSessions)) {
                    yield entityContext.messageSessions[messageSessionId].close();
                }
                // Close the sessionManager.
                if (entityContext.sessionManager) {
                    entityContext.sessionManager.close();
                }
                // Make sure that we clear the map of deferred messages
                entityContext.requestResponseLockedMessages.clear();
                // Delete the reference in ConnectionContext
                delete context.clientContexts[clientId];
                // Close the managementClient unless it is shared with other clients
                if (entityContext.managementClient && !isManagementClientSharedWithOtherClients()) {
                    yield entityContext.managementClient.close();
                    entityContext.managementClient = undefined;
                }
                entityContext.isClosed = true;
                entityCtxt("[%s] Closed client entity context for %s: %O", context.connectionId, clientId);
            });
            let managementClient = getManagementClient(context.clientContexts, entityPath);
            if (!managementClient) {
                const mOptions = {
                    address: options.managementClientAddress || `${entityPath}/$management`,
                    audience: options.managementClientAudience
                };
                managementClient = new ManagementClient(entityContext, mOptions);
            }
            entityContext.managementClient = managementClient;
            const clientEntityContext = entityContext;
            context.clientContexts[entityContext.clientId] = clientEntityContext;
            entityCtxt("[%s] Created client entity context for %s: %O", context.connectionId, clientId);
            return clientEntityContext;
        }
        ClientEntityContext.create = create;
    })(ClientEntityContext || (ClientEntityContext = {}));
    // Multiple clients for the same Service Bus entity should be using the same management client.
    function getManagementClient(clients, entityPath) {
        let result;
        for (const id of Object.keys(clients)) {
            if (clients[id].entityPath === entityPath) {
                result = clients[id].managementClient;
                break;
            }
        }
        return result;
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes the client that allows interacting with a Service Bus Queue.
     * Use the `createQueueClient` function on the ServiceBusClient object to instantiate a QueueClient
     * @class QueueClient
     */
    class QueueClient {
        /**
         * Constructor for QueueClient.
         * This is not meant for the user to call directly.
         * The user should use the `createQueueClient` on the ServiceBusClient instead.
         *
         * @constructor
         * @internal
         * @param queueName The Queue name.
         * @param context The connection context to create the QueueClient.
         * @throws Error if the underlying connection is closed.
         */
        constructor(queueName, context) {
            throwErrorIfConnectionClosed(context);
            this.entityPath = String(queueName);
            this.id = `${this.entityPath}/${lib_5()}`;
            this._context = ClientEntityContext.create(this.entityPath, ClientType.QueueClient, context, this.id);
        }
        /**
         * Closes all the AMQP links for sender/receivers created by this client.
         * Once closed, neither the QueueClient nor its sender/receivers can be used for any
         * further operations.
         *
         * @returns {Promise<void>}
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Close the corresponding client context which will take care of closing all AMQP links
                    // associated with this client
                    yield this._context.close();
                }
                catch (err) {
                    error("[%s] An error occurred while closing the QueueClient for %s: %O", this._context.namespace.connectionId, this.id, err);
                    throw err;
                }
            });
        }
        /**
         * Creates a Sender to be used for sending messages, scheduling messages to be sent at a later time
         * and cancelling such scheduled messages.
         * @throws Error if the QueueClient or the underlying connection is closed.
         * @throws Error if an open sender already exists on the QueueClient.
         */
        createSender() {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            if (!this._currentSender || this._currentSender.isClosed) {
                this._currentSender = new Sender$1(this._context);
                return this._currentSender;
            }
            const errorMessage = getOpenSenderErrorMsg("QueueClient", this.entityPath);
            const error$1 = new Error(errorMessage);
            error(`[${this._context.namespace.connectionId}] %O`, error$1);
            throw error$1;
        }
        createReceiver(receiveMode, sessionOptions) {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            // Receiver for Queue where sessions are not enabled
            if (!sessionOptions) {
                if (!this._currentReceiver || this._currentReceiver.isClosed) {
                    this._currentReceiver = new Receiver$1(this._context, receiveMode);
                    return this._currentReceiver;
                }
                const errorMessage = getOpenReceiverErrorMsg(ClientType.QueueClient, this.entityPath);
                const error$1 = new Error(errorMessage);
                error(`[${this._context.namespace.connectionId}] %O`, error$1);
                throw error$1;
            }
            return new SessionReceiver(this._context, receiveMode, sessionOptions);
        }
        /**
         * Fetches the next batch of active messages (including deferred but not deadlettered messages).
         * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the
         * subsequent message.
         * - Unlike a `received` message, `peeked` message is a read-only version of the message.
         * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
         *
         * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
         * @returns Promise<ReceivedMessageInfo[]>
         * @throws Error if the QueueClient or the underlying connection is closed.
         * @throws MessagingError if the service returns an error while peeking for messages.
         */
        peek(maxMessageCount) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
                return this._context.managementClient.peek(maxMessageCount);
            });
        }
        /**
         * Peeks the desired number of active messages (including deferred but not deadlettered messages)
         * from the specified sequence number.
         * - Unlike a `received` message, `peeked` message is a read-only version of the message.
         * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
         *
         * @param fromSequenceNumber The sequence number from where to read the message.
         * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
         * @returns Promise<ReceivedMessageInfo[]>
         * @throws Error if the QueueClient or the underlying connection is closed.
         * @throws MessagingError if the service returns an error while peeking for messages.
         */
        peekBySequenceNumber(fromSequenceNumber, maxMessageCount) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
                return this._context.managementClient.peekBySequenceNumber(fromSequenceNumber, maxMessageCount);
            });
        }
        // /**
        //  * Lists the ids of the sessions on the ServiceBus Queue.
        //  * @param maxNumberOfSessions Maximum number of sessions.
        //  * @param lastUpdateTime Filter to include only sessions updated after a given time. Default
        //  * value is 3 days before the current time.
        //  */
        // async listMessageSessions(
        //   maxNumberOfSessions: number,
        //   lastUpdatedTime?: Date
        // ): Promise<string[]> {
        // TODO: Parameter validation if required
        // this.throwErrorIfClientOrConnectionClosed();
        //   return this._context.managementClient!.listMessageSessions(
        //     0,
        //     maxNumberOfSessions,
        //     lastUpdatedTime
        //   );
        // }
        /**
         * Returns the corresponding dead letter queue name for the queue represented by the given name.
         * Use this in the `createQueueClient` function on the `ServiceBusClient` instance to receive
         * messages from a dead letter queue.
         * @param queueName Name of the queue whose dead letter counterpart's name is being fetched
         */
        static getDeadLetterQueuePath(queueName) {
            return `${queueName}/$DeadLetterQueue`;
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes the client that allows interacting with a Service Bus Topic.
     * Use the `createTopicClient` function on the ServiceBusClient object to instantiate a TopicClient
     * @class TopicClient
     */
    class TopicClient {
        /**
         * Constructor for TopicClient.
         * This is not meant for the user to call directly.
         * The user should use the `createTopicClient` on the Namespace instead.
         *
         * @constructor
         * @internal
         * @param topicName - The topic name.
         * @param context - The connection context to create the TopicClient.
         * @throws Error if the TopicClient or the underlying connection is closed.
         */
        constructor(topicName, context) {
            throwErrorIfConnectionClosed(context);
            this.entityPath = String(topicName);
            this.id = `${this.entityPath}/${lib_5()}`;
            this._context = ClientEntityContext.create(this.entityPath, ClientType.TopicClient, context, this.id);
        }
        /**
         * Closes the AMQP link for the sender created by this client.
         * Once closed, neither the TopicClient nor its senders can be used for any
         * further operations.
         *
         * @returns {Promise<void>}
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Close the corresponding client context which will take care of closing all AMQP links
                    // associated with this client
                    yield this._context.close();
                }
                catch (err) {
                    error("[%s] An error occurred while closing the TopicClient for %s: %O", this._context.namespace.connectionId, this.id, err);
                    throw err;
                }
            });
        }
        /**
         * Creates a Sender to be used for sending messages, scheduling messages to be sent at a later time
         * and cancelling such scheduled messages.
         *
         * If the Topic has session enabled Subscriptions, then messages sent without the `sessionId`
         * property will go to the dead letter queue of such subscriptions.
         * @throws Error if the TopicClient or the underlying connection is closed.
         * @throws Error if an open sender already exists on the TopicClient.
         */
        createSender() {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            if (!this._currentSender || this._currentSender.isClosed) {
                this._currentSender = new Sender$1(this._context);
                return this._currentSender;
            }
            const errorMessage = getOpenSenderErrorMsg("TopicClient", this.entityPath);
            const error$1 = new Error(errorMessage);
            error(`[${this._context.namespace.connectionId}] %O`, error$1);
            throw error$1;
        }
        /**
         * Returns the corresponding dead letter topic name for the given topic and subscription names.
         * Use this in the `createSubscriptionClient` function of the `ServiceBusClient` instance to
         * receive messages from dead letter queue for given subscription.
         * @param topicName Name of the topic whose dead letter counterpart's name is being fetched
         * @param subscriptionName Name of the subscription whose dead letter counterpart's name is being fetched
         */
        static getDeadLetterTopicPath(topicName, subscriptionName) {
            return `${topicName}/Subscriptions/${subscriptionName}/$DeadLetterQueue`;
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes the client that allows interacting with a Service Bus Subscription.
     * Use the `createSubscriptionClient` function on the ServiceBusClient object to instantiate a
     * SubscriptionClient
     * @class SubscriptionClient
     */
    class SubscriptionClient {
        /**
         * Constructor for SubscriptionClient.
         * This is not meant for the user to call directly.
         * The user should use the `createSubscriptionClient` on the Namespace instead.
         *
         * @constructor
         * @internal
         * @param topicName - The Topic name.
         * @param subscriptionName - The Subscription name.
         * @param context - The connection context to create the SubscriptionClient.
         * @throws Error if the underlying connection is closed.
         */
        constructor(topicName, subscriptionName, context) {
            /**
             * @readonly
             * @property The name of the default rule on the subscription.
             */
            this.defaultRuleName = "$Default";
            throwErrorIfConnectionClosed(context);
            this.topicName = String(topicName);
            this.subscriptionName = String(subscriptionName);
            this.entityPath = `${topicName}/Subscriptions/${subscriptionName}`;
            this.id = `${this.entityPath}/${lib_5()}`;
            this._context = ClientEntityContext.create(this.entityPath, ClientType.SubscriptionClient, context, this.id);
        }
        /**
         * Closes the AMQP link for the receivers created by this client.
         * Once closed, neither the SubscriptionClient nor its receivers can be used for any
         * further operations.
         *
         * @returns {Promise<void>}
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Close the corresponding client context which will take care of closing all AMQP links
                    // associated with this client
                    yield this._context.close();
                }
                catch (err) {
                    error("[%s] An error occurred while closing the SubscriptionClient for %s: %O", this._context.namespace.connectionId, this.id, err);
                    throw err;
                }
            });
        }
        createReceiver(receiveMode, sessionOptions) {
            throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
            // Receiver for Subscription where sessions are not enabled
            if (!sessionOptions) {
                if (!this._currentReceiver || this._currentReceiver.isClosed) {
                    this._currentReceiver = new Receiver$1(this._context, receiveMode);
                    return this._currentReceiver;
                }
                const errorMessage = getOpenReceiverErrorMsg(ClientType.SubscriptionClient, this.entityPath);
                const error$1 = new Error(errorMessage);
                error(`[${this._context.namespace.connectionId}] %O`, error$1);
                throw error$1;
            }
            return new SessionReceiver(this._context, receiveMode, sessionOptions);
        }
        /**
         * Fetches the next batch of active messages (including deferred but not deadlettered messages).
         * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the
         * subsequent message.
         * - Unlike a `received` message, `peeked` message is a read-only version of the message.
         * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
         *
         * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
         * @returns Promise<ReceivedSBMessage[]>
         * @throws Error if the SubscriptionClient or the underlying connection is closed.
         * @throws MessagingError if the service returns an error while peeking for messages.
         */
        peek(maxMessageCount) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
                return this._context.managementClient.peek(maxMessageCount);
            });
        }
        /**
         * Peeks the desired number of active messages (including deferred but not deadlettered messages)
         * from the specified sequence number.
         * - Unlike a `received` message, `peeked` message is a read-only version of the message.
         * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
         *
         * @param fromSequenceNumber The sequence number from where to read the message.
         * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
         * @returns Promise<ReceivedSBMessage[]>
         * @throws Error if the SubscriptionClient or the underlying connection is closed.
         * @throws MessagingError if the service returns an error while peeking for messages.
         */
        peekBySequenceNumber(fromSequenceNumber, maxMessageCount) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
                return this._context.managementClient.peekBySequenceNumber(fromSequenceNumber, maxMessageCount);
            });
        }
        // #region topic-filters
        /**
         * Gets all rules associated with the subscription
         * @throws Error if the SubscriptionClient or the underlying connection is closed.
         * @throws MessagingError if the service returns an error while retrieving rules.
         */
        getRules() {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
                return this._context.managementClient.getRules();
            });
        }
        /**
         * Removes the rule on the subscription identified by the given rule name.
         *
         * **Caution**: If all rules on a subscription are removed, then the subscription will not receive
         * any more messages.
         * @param ruleName
         * @throws Error if the SubscriptionClient or the underlying connection is closed.
         * @throws MessagingError if the service returns an error while removing rules.
         */
        removeRule(ruleName) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
                return this._context.managementClient.removeRule(ruleName);
            });
        }
        /**
         * Adds a rule on the subscription as defined by the given rule name, filter and action.
         *
         * **Note**: Remove the default true filter on the subscription before adding a rule.
         * Otherwise, the added rule will have no affect as the true filter will always result in
         * the subscription receiving all messages.
         * @param ruleName Name of the rule
         * @param filter A Boolean, SQL expression or a Correlation filter. For SQL Filter syntax, see
         * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-filter SQLFilter syntax}.
         * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression. For SQL Rule Action syntax,
         * see {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-rule-action SQLRuleAction syntax}.
         * @throws Error if the SubscriptionClient or the underlying connection is closed.
         * @throws MessagingError if the service returns an error while adding rules.
         */
        addRule(ruleName, filter, sqlRuleActionExpression) {
            return __awaiter(this, void 0, void 0, function* () {
                throwErrorIfClientOrConnectionClosed(this._context.namespace, this.entityPath, this._context.isClosed);
                return this._context.managementClient.addRule(ruleName, filter, sqlRuleActionExpression);
            });
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes the client that allows interacting with a Service Bus instance.
     * Holds the AMQP connection to the Service Bus Namespace and is the entry point for using Queues,
     * Topics and Subscriptions.
     */
    class ServiceBusClient {
        /**
         * Instantiates a ServiceBusClient to interact with a Service Bus Namespace.
         *
         * @constructor
         * @param {ConnectionConfig} config - The connection configuration needed to connect to the
         * Service Bus Namespace.
         * @param {TokenProvider} [tokenProvider] - The token provider that provides the token for
         * authentication.
         * @param {ServiceBusClientOptions} - Options to control ways to interact with the Service Bus
         * Namespace.
         */
        constructor(config, tokenProvider, options) {
            if (!options)
                options = {};
            this.name = config.endpoint;
            this._context = ConnectionContext.create(config, tokenProvider, options);
        }
        /**
         * Creates a QueueClient for an existing Service Bus Queue.
         * @param {string} queueName The queue name.
         * @returns QueueClient.
         * @throws Error if the underlying connection is closed.
         */
        createQueueClient(queueName) {
            const client = new QueueClient(queueName, this._context);
            ns("Created the QueueClient for Queue: %s", queueName);
            return client;
        }
        /**
         * Creates a TopicClient for an existing Service Bus Topic.
         * @param {string} topicName The topic name.
         * @returns TopicClient.
         * @throws
         * @throws Error if the underlying connection is closed.
         */
        createTopicClient(topicName) {
            const client = new TopicClient(topicName, this._context);
            ns("Created the TopicClient for Topic: %s", topicName);
            return client;
        }
        /**
         * Creates a SubscriptionClient for an existing Service Bus Subscription.
         * @param {string} topicName The topic name.
         * @param {string} subscriptionName The subscription name.
         * @returns SubscriptionClient.
         * @throws Error if the underlying connection is closed.
         */
        createSubscriptionClient(topicName, subscriptionName) {
            const client = new SubscriptionClient(topicName, subscriptionName, this._context);
            ns("Created the SubscriptionClient for Topic: %s and Subscription: %s", topicName, subscriptionName);
            return client;
        }
        /**
         * Closes the AMQP connection created by this ServiceBusClient along with AMQP links for
         * sender/receivers created by the queue/topic/subscription clients created by this
         * ServiceBusClient.
         * Once closed,
         * - the clients created by this ServiceBusClient cannot be used to send/receive messages anymore.
         * - this ServiceBusClient cannot be used to create any new queues/topics/subscriptions clients.
         * @returns {Promise<any>}
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    if (this._context.connection.isOpen()) {
                        ns("Closing the amqp connection '%s' on the client.", this._context.connectionId);
                        // Close all the clients.
                        for (const id of Object.keys(this._context.clientContexts)) {
                            const clientContext = this._context.clientContexts[id];
                            yield clientContext.close();
                        }
                        yield this._context.cbsSession.close();
                        yield this._context.connection.close();
                        this._context.wasConnectionCloseCalled = true;
                        ns("Closed the amqp connection '%s' on the client.", this._context.connectionId);
                    }
                }
                catch (err) {
                    const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));
                    error(`An error occurred while closing the connection "${this._context.connectionId}":\n${errObj}`);
                    throw errObj;
                }
            });
        }
        /**
         * Creates a ServiceBusClient for the Service Bus Namespace represented in the given connection
         * string.
         * @param {string} connectionString - Connection string of the form
         * 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
         * @param {ServiceBusClientOptions} [options] Options to control ways to interact with the
         * Service Bus Namespace.
         * @returns {ServiceBusClient}
         */
        static createFromConnectionString(connectionString, options) {
            const config = ConnectionConfig.create(connectionString);
            config.webSocket = options && options.webSocket;
            config.webSocketEndpointPath = "$servicebus/websocket";
            config.webSocketConstructorOptions = options && options.webSocketConstructorOptions;
            ConnectionConfig.validate(config);
            const tokenProvider = new SasTokenProvider(config.endpoint, config.sharedAccessKeyName, config.sharedAccessKey);
            return new ServiceBusClient(config, tokenProvider, options);
        }
        /**
         * Creates a ServiceBusClient for the Service Bus Namespace represented by the given host using
         * the given TokenProvider.
         * @param {string} host - Fully qualified domain name for Servicebus. Most likely,
         * `<yournamespace>.servicebus.windows.net`.
         * @param {TokenProvider} tokenProvider - Your custom implementation of the {@link https://github.com/Azure/amqp-common-js/blob/master/lib/auth/token.ts Token Provider}
         * interface.
         * @param {ServiceBusClientOptions} options - Options to control ways to interact with the
         * Service Bus Namespace.
         * @returns {ServiceBusClient}
         */
        static createFromTokenProvider(host, tokenProvider, options) {
            host = String(host);
            if (!tokenProvider) {
                throw new TypeError('Missing parameter "tokenProvider"');
            }
            if (!host.endsWith("/"))
                host += "/";
            const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;` +
                `SharedAccessKey=defaultKeyValue`;
            const config = ConnectionConfig.create(connectionString);
            config.webSocket = options && options.webSocket;
            config.webSocketEndpointPath = "$servicebus/websocket";
            config.webSocketConstructorOptions = options && options.webSocketConstructorOptions;
            ConnectionConfig.validate(config);
            return new ServiceBusClient(config, tokenProvider, options);
        }
        /**
         * Creates a ServiceBusClient for the Service Bus Namespace represented by the given host using
         * the TokenCredentials generated using the `@azure/ms-rest-nodeauth` library.
         * @param {string} host - Fully qualified domain name for ServiceBus.
         * Most likely, {yournamespace}.servicebus.windows.net
         * @param {ServiceClientCredentials} credentials - The Token credentials generated by using the
         * `@azure/ms-rest-nodeauth` library. It can be one of the following:
         *  - ApplicationTokenCredentials
         *  - UserTokenCredentials
         *  - DeviceTokenCredentials
         *  - MSITokenCredentials
         * Token audience (or resource in case of MSI based credentials) to use when creating the credentials is https://servicebus.azure.net/
         * @param {ServiceBusClientOptions} options - Options to control ways to interact with the
         * Service Bus Namespace.
         * @returns {ServiceBusClient}
         * @throws Error if `createFromAadTokenCredentials` is accessed in browser context, as AAD support is not present in browser.
         */
        static createFromAadTokenCredentials(host, credentials, options) {
            {
                throw new Error("`createFromAadTokenCredentials` cannot be used to create ServiceBusClient as AAD support is not present in browser.");
            }
        }
    }

    exports.DefaultDataTransformer = DefaultDataTransformer;
    exports.MessagingError = MessagingError;
    exports.QueueClient = QueueClient;
    exports.Receiver = Receiver$1;
    exports.Sender = Sender$1;
    exports.ServiceBusClient = ServiceBusClient;
    exports.ServiceBusMessage = ServiceBusMessage;
    exports.SessionReceiver = SessionReceiver;
    exports.SubscriptionClient = SubscriptionClient;
    exports.TopicClient = TopicClient;
    exports.delay = delay;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=service-bus.js.map
