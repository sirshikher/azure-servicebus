/// <reference types="node" />
import { AmqpMessage } from '@azure/amqp-common';
import { ApplicationTokenCredentials } from '@azure/ms-rest-nodeauth';
import { DataTransformer } from '@azure/amqp-common';
import { DefaultDataTransformer } from '@azure/amqp-common';
import { delay } from '@azure/amqp-common';
import { Delivery } from 'rhea-promise';
import { DeviceTokenCredentials } from '@azure/ms-rest-nodeauth';
import { HttpOperationResponse } from '@azure/core-http';
import Long from 'long';
import { MessagingError } from '@azure/amqp-common';
import { MSITokenCredentials } from '@azure/ms-rest-nodeauth';
import { TokenInfo } from '@azure/amqp-common';
import { TokenProvider } from '@azure/amqp-common';
import { TokenType } from '@azure/amqp-common';
import { UserTokenCredentials } from '@azure/ms-rest-nodeauth';
import { WebSocketImpl } from 'rhea-promise';

/**
 * Represents type of `AuthorizationRule` in ATOM based management operations.
 */
export declare type AuthorizationRule = {
    claimType: string;
    claimValue: string;
    rights: {
        accessRights?: string[];
    };
    keyName: string;
    primaryKey?: string;
    secondaryKey?: string;
};

/**
 * Interface for Queue/Topic/Subscription clients
 */
declare interface Client {
    /**
     * @readonly
     * @property The path for the Service Bus entity for which this client is created.
     */
    readonly entityPath: string;
    /**
     * @readonly
     * @property A unique identifier for this client.
     */
    readonly id: string;
    /**
     * Closes the client along with all senders and receivers created using the client.
     */
    close(): Promise<void>;
}

/**
 * Represents the correlation filter expression.
 * A CorrelationFilter holds a set of conditions that are matched against user and system properties
 * of incoming messages from a Subscription.
 */
export declare interface CorrelationFilter {
    /**
     * Value to be matched with the `correlationId` property of the incoming message.
     */
    correlationId?: string;
    /**
     * Value to be matched with the `messageId` property of the incoming message.
     */
    messageId?: string;
    /**
     * Value to be matched with the `to` property of the incoming message.
     */
    to?: string;
    /**
     * Value to be matched with the `replyTo` property of the incoming message.
     */
    replyTo?: string;
    /**
     * Value to be matched with the `label` property of the incoming message.
     */
    label?: string;
    /**
     * Value to be matched with the `sessionId` property of the incoming message.
     */
    sessionId?: string;
    /**
     * Value to be matched with the `replyToSessionId` property of the incoming message.
     */
    replyToSessionId?: string;
    /**
     * Value to be matched with the `contentType` property of the incoming message.
     */
    contentType?: string;
    /**
     * Value to be matched with the user properties of the incoming message.
     */
    userProperties?: any;
}
export { DataTransformer }

/**
 * Describes the reason and error description for dead lettering a message using the `deadLetter()`
 * method on the message received from Service Bus.
 * @interface DeadLetterOptions
 */
export declare interface DeadLetterOptions {
    /**
     * @property The reason for deadlettering the message.
     */
    deadletterReason: string;
    /**
     * @property The error description for deadlettering the message.
     */
    deadLetterErrorDescription: string;
}
export { DefaultDataTransformer }
export { delay }
export { Delivery }

/**
 * Possible values for `status` of the Service Bus messaging entities.
 */
export declare type EntityStatus = "Active" | "Creating" | "Deleting" | "ReceiveDisabled" | "SendDisabled" | "Disabled" | "Renaming" | "Restoring" | "Unknown";
export { HttpOperationResponse }

/**
 * Represents type of message count details in ATOM based management operations.
 */
export declare type MessageCountDetails = {
    activeMessageCount: number;
    deadLetterMessageCount: number;
    scheduledMessageCount: number;
    transferMessageCount: number;
    transferDeadLetterMessageCount: number;
};

/**
 * Describes the options passed to `registerMessageHandler` method when receiving messages from a
 * Queue/Subscription which does not have sessions enabled.
 */
export declare interface MessageHandlerOptions {
    /**
     * @property Indicates whether the `complete()` method on the message should automatically be
     * called by the sdk after the user provided onMessage handler has been executed.
     * Calling `complete()` on a message removes it from the Queue/Subscription.
     * - **Default**: `true`.
     */
    autoComplete?: boolean;
    /**
     * @property The maximum duration in seconds until which the lock on the message will be renewed
     * by the sdk automatically. This auto renewal stops once the message is settled or once the user
     * provided onMessage handler completes ite execution.
     *
     * - **Default**: `300` seconds (5 minutes).
     * - **To disable autolock renewal**, set this to `0`.
     */
    maxMessageAutoRenewLockDurationInSeconds?: number;
    /**
     * @property The maximum number of concurrent calls that the sdk can make to the user's message
     * handler. Once this limit has been reached, further messages will not be received until atleast
     * one of the calls to the user's message handler has completed.
     * - **Default**: `1`.
     */
    maxConcurrentCalls?: number;
}
export { MessagingError }

/**
 * Describes the signature of the error handler passed to `registerMessageHandler` method.
 */
export declare interface OnError {
    /**
     * Handler for any error that occurs while receiving or processing messages.
     */
    (error: MessagingError | Error): void;
}

/**
 * Describes the signature of the message handler passed to `registerMessageHandler` method.
 */
export declare interface OnMessage {
    /**
     * Handler for processing each incoming message.
     */
    (message: ServiceBusMessage): Promise<void>;
}

/**
 * Describes the client that allows interacting with a Service Bus Queue.
 * Use the `createQueueClient` function on the ServiceBusClient object to instantiate a QueueClient
 * @class QueueClient
 */
export declare class QueueClient implements Client {
    /**
     * @readonly
     * @property The path for the Service Bus Queue for which this client is created.
     */
    readonly entityPath: string;
    /**
     * @readonly
     * @property A unique identifier for this client.
     */
    readonly id: string;
    /**
     * @property Describes the amqp connection context for the QueueClient.
     */
    private _context;
    private _currentReceiver;
    private _currentSender;
    /**
     * Closes all the AMQP links for sender/receivers created by this client.
     * Once closed, neither the QueueClient nor its sender/receivers can be used for any
     * further operations.
     *
     * @returns {Promise<void>}
     */
    close(): Promise<void>;
    /**
     * Creates a Sender to be used for sending messages, scheduling messages to be sent at a later time
     * and cancelling such scheduled messages.
     * @throws Error if the QueueClient or the underlying connection is closed.
     * @throws Error if an open sender already exists on the QueueClient.
     */
    createSender(): Sender;
    /**
     * Creates a Receiver for receiving messages from a Queue which does not have sessions enabled.
     * @param receiveMode An enum indicating the mode in which messages should be received. Possible
     * values are:
     * - `ReceiveMode.peekLock`: Once a message is received in this mode, the receiver has a lock on
     * the message for a particular duration. If the message is not settled by this time, it lands back
     * on Service Bus to be fetched by the next receive operation.
     * - `ReceiveMode.receiveAndDelete`: Messages received in this mode get automatically removed from
     * Service Bus.
     *
     * @returns Receiver A receiver to receive messages from a Queue which does not have
     * sessions enabled.
     * @throws Error if the QueueClient or the underlying connection is closed.
     * @throws Error if an open receiver already exists on the QueueClient.
     * @throws MessagingError with name `InvalidOperationError` if the Queue has sessions enabled
     * (in which case, use the overload of this method which takes
     * `sessionOptions` argument)
     */
    createReceiver(receiveMode: ReceiveMode): Receiver;
    /**
     * Creates a Receiver for receiving messages from a session enabled Queue. When no sessionId is
     * given, a random session among the available sessions is used.
     *
     * @param receiveMode An enum indicating the mode in which messages should be received. Possible
     * values are:
     * - `ReceiveMode.peekLock`: Once a message is received in this mode, the receiver has a lock on
     * the message for a particular duration. If the message is not settled by this time, it lands back
     * on Service Bus to be fetched by the next receive operation.
     * - `ReceiveMode.receiveAndDelete`: Messages received in this mode get automatically removed from
     * Service Bus.
     * @param sessionOptions Options to provide sessionId and duration of automatic lock renewal for
     * the session receiver.
     *
     * @returns SessionReceiver A receiver to receive from a session in the Queue.
     * @throws Error if the QueueClient or the underlying connection is closed.
     * @throws Error if an open receiver already exists on the QueueClient for given sessionId.
     * @throws MessagingError with name `SessionCannotBeLockedError` if the Queue does not have sessions enabled (in which
     * case do not pass the `sessionOptions` argument) or if Service Bus is not able to get a lock on
     * the session (in which case try again after some time)
     */
    createReceiver(receiveMode: ReceiveMode, sessionOptions: SessionReceiverOptions): SessionReceiver;
    /**
     * Fetches the next batch of active messages (including deferred but not deadlettered messages).
     * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the
     * subsequent message.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedMessageInfo[]>
     * @throws Error if the QueueClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peek(maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
    /**
     * Peeks the desired number of active messages (including deferred but not deadlettered messages)
     * from the specified sequence number.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedMessageInfo[]>
     * @throws Error if the QueueClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peekBySequenceNumber(fromSequenceNumber: Long, maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
    /**
     * Returns the corresponding dead letter queue name for the queue represented by the given name.
     * Use this in the `createQueueClient` function on the `ServiceBusClient` instance to receive
     * messages from a dead letter queue.
     * @param queueName Name of the queue whose dead letter counterpart's name is being fetched
     */
    static getDeadLetterQueuePath(queueName: string): string;
}

/**
 * Represents all attributes of a queue entity
 */
export declare interface QueueDetails {
    /**
     * Name of the queue
     */
    queueName: string;
    /**
     * Determines the amount of time in seconds in which a message should be locked
     * for processing by a receiver. After this period, the message is unlocked and
     * can be consumed by the next receiver.
     * Settable only at queue creation time.
     * This is specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    lockDuration: string;
    /**
     * The entity's size in bytes.
     *
     */
    sizeInBytes?: number;
    /**
     * Specifies the maximum queue size in megabytes. Any attempt to enqueue
     * a message that will cause the queue to exceed this value will fail.
     */
    maxSizeInMegabytes: number;
    /**
     * The entity's message count.
     *
     */
    messageCount?: number;
    /**
     * Depending on whether DeadLettering is enabled, a message is automatically
     * moved to the DeadLetterQueue or deleted if it has been stored in the queue
     * for longer than the specified time. This value is overwritten by a TTL
     * specified on the message if and only if the message TTL is smaller than
     * the TTL set on the queue.
     * This value is immutable after the Queue has been created.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    defaultMessageTtl: string;
    /**
     * Specifies the time span during which the Service Bus detects message duplication.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    duplicateDetectionHistoryTimeWindow: string;
    /**
     * Absolute URL or the name of the queue or topic the dead-lettered
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardDeadLetteredMessagesTo?: string;
    /**
     * Max idle time before entity is deleted.
     * This is specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    autoDeleteOnIdle: string;
    /**
     * The maximum delivery count of messages after which if it is still not settled,
     * gets moved to the dead-letter sub-queue.
     *
     */
    maxDeliveryCount: number;
    /**
     * If set to true, the queue will be session-aware and only SessionReceiver
     * will be supported. Session-aware queues are not supported through REST.
     * Settable only at queue creation time.
     */
    requiresSession: boolean;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations: boolean;
    /**
     *  If enabled, the topic will detect duplicate messages within the time
     * span specified by the DuplicateDetectionHistoryTimeWindow property.
     * Settable only at queue creation time.
     */
    requiresDuplicateDetection: boolean;
    /**
     * If it is enabled and a message expires, the Service Bus moves the message
     * from the queue into the queue’s dead-letter sub-queue. If disabled, message
     * will be permanently deleted from the queue. Settable only at queue creation time.
     */
    deadLetteringOnMessageExpiration: boolean;
    /**
     * Absolute URL or the name of the queue or topic the
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardTo?: string;
    /**
     * The user provided metadata information associated with the queue description.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata?: string;
    /**
     * Specifies whether the queue should be partitioned.
     */
    enablePartitioning: boolean;
    /**
     * Authorization rules on the queue
     */
    authorizationRules?: AuthorizationRule[];
    /**
     * Message count details
     */
    messageCountDetails?: MessageCountDetails;
    /**
     * Ordering support for messages
     */
    supportOrdering?: boolean;
    /**
     * Enable express option
     */
    enableExpress?: boolean;
    /**
     * Is anonymous accessible queue option
     */
    isAnonymousAccessible?: boolean;
    /**
     * Entity availability status
     */
    entityAvailabilityStatus?: string;
    /**
     * Status of the messaging entity.
     */
    status?: EntityStatus;
    /**
     * Created at timestamp
     */
    createdOn?: string;
    /**
     * Updated at timestamp
     */
    updatedOn?: string;
    /**
     * Accessed at timestamp
     */
    accessedOn?: string;
}

/**
 * Represents settable options on a queue
 */
export declare interface QueueOptions {
    /**
     * Determines the amount of time in seconds in which a message should be locked for
     * processing by a receiver. After this period, the message is unlocked and available
     * for consumption by the next receiver. Settable only at queue creation time.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    lockDuration?: string;
    /**
     * Specifies the maximum queue size in megabytes. Any attempt to enqueue a message that
     * will cause the queue to exceed this value will fail.
     */
    maxSizeInMegabytes?: number;
    /**
     * If enabled, the topic will detect duplicate messages within the time
     * span specified by the DuplicateDetectionHistoryTimeWindow property.
     * Settable only at queue creation time.
     */
    requiresDuplicateDetection?: boolean;
    /**
     * If set to true, the queue will be session-aware and only SessionReceiver
     * will be supported. Session-aware queues are not supported through REST.
     * Settable only at queue creation time.
     */
    requiresSession?: boolean;
    /**
     * Depending on whether DeadLettering is enabled, a message is automatically
     * moved to the dead-letter sub-queue or deleted if it has been stored in the
     * queue for longer than the specified time.
     * This value is overwritten by a TTL specified on the message
     * if and only if the message TTL is smaller than the TTL set on the queue.
     * This value is immutable after the Queue has been created.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    defaultMessageTtl?: string;
    /**
     * If it is enabled and a message expires, the Service Bus moves the message
     * from the queue into the queue’s dead-letter sub-queue. If disabled,
     * message will be permanently deleted from the queue.
     * Settable only at queue creation time.
     */
    deadLetteringOnMessageExpiration?: boolean;
    /**
     * Specifies the time span during which the Service Bus detects message duplication.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    duplicateDetectionHistoryTimeWindow?: string;
    /**
     * The maximum delivery count of messages after which if it is still not settled,
     * gets moved to the dead-letter sub-queue.
     */
    maxDeliveryCount?: number;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations?: boolean;
    /**
     * Authorization rules on the queue
     */
    authorizationRules?: AuthorizationRule[];
    /**
     * Status of the messaging entity.
     */
    status?: EntityStatus;
    /**
     * Absolute URL or the name of the queue or topic the
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardTo?: string;
    /**
     * The user provided metadata information associated with the queue description.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata?: string;
    /**
     * Max idle time before entity is deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    autoDeleteOnIdle?: string;
    /**
     * Specifies whether the queue should be partitioned.
     */
    enablePartitioning?: boolean;
    /**
     * Absolute URL or the name of the queue or topic the dead-lettered
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardDeadLetteredMessagesTo?: string;
}

/**
 * Describes the message received from Service Bus.
 * @interface ReceivedMessage
 */
declare interface ReceivedMessage extends ReceivedMessageInfo {
    /**
     * Removes the message from Service Bus.
     * @returns Promise<void>.
     */
    complete(): Promise<void>;
    /**
     * The lock held on the message by the receiver is let go, making the message available again in
     * Service Bus for another receive operation.
     * @param propertiesToModify The properties of the message to modify while abandoning the message.
     *
     * @return Promise<void>.
     */
    abandon(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    /**
     * Defers the processing of the message. Save the `sequenceNumber` of the message, in order to
     * receive it message again in the future using the `receiveDeferredMessage` method.
     * @param propertiesToModify The properties of the message to modify while deferring the message
     *
     * @returns Promise<void>
     */
    defer(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    /**
     * Moves the message to the deadletter sub-queue. To receive a deadletted message, create a new
     * QueueClient/SubscriptionClient using the path for the deadletter sub-queue.
     * @param options The DeadLetter options that can be provided while
     * rejecting the message.
     *
     * @returns Promise<void>
     */
    deadLetter(options?: DeadLetterOptions): Promise<void>;
}

/**
 * Describes the message received from Service Bus during peek operations and so cannot be settled.
 * @class ReceivedSBMessage
 */
export declare interface ReceivedMessageInfo extends SendableMessageInfo {
    /**
     * @property The lock token is a reference to the lock that is being held by the broker in
     * `ReceiveMode.PeekLock` mode. Locks are used internally settle messages as explained in the
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement product documentation in more detail}
     * - Not applicable when the message is received in `ReceiveMode.receiveAndDelete`
     * mode.
     * @readonly
     */
    readonly lockToken?: string;
    /**
     * @property Number of deliveries that have been attempted for this message. The count is
     * incremented when a message lock expires, or the message is explicitly abandoned using the
     * `abandon()` method on the message.
     * @readonly
     */
    readonly deliveryCount?: number;
    /**
     * @property The UTC instant at which the message has been accepted and stored in Service Bus.
     * @readonly
     */
    readonly enqueuedTimeUtc?: Date;
    /**
     * @property The UTC instant at which the message is marked for removal and no longer available for
     * retrieval from the entity due to expiration. This property is computed from 2 other properties
     * on the message: `enqueuedTimeUtc` + `timeToLive`.
     */
    readonly expiresAtUtc?: Date;
    /**
     * @property The UTC instant until which the message is held locked in the queue/subscription.
     * When the lock expires, the `deliveryCount` is incremented and the message is again available
     * for retrieval.
     * - Not applicable when the message is received in `ReceiveMode.receiveAndDelete`
     * mode.
     */
    lockedUntilUtc?: Date;
    /**
     * @property The original sequence number of the message. For
     * messages that have been auto-forwarded, this property reflects the sequence number that had
     * first been assigned to the message at its original point of submission.
     * @readonly
     */
    readonly enqueuedSequenceNumber?: number;
    /**
     * @property The unique number assigned to a message by Service Bus.
     * The sequence number is a unique 64-bit integer assigned to a message as it is accepted
     * and stored by the broker and functions as its true identifier. For partitioned entities,
     * the topmost 16 bits reflect the partition identifier. Sequence numbers monotonically increase.
     * They roll over to 0 when the 48-64 bit range is exhausted.
     *
     * **Max safe integer** that Javascript currently supports is `2^53 - 1`. The sequence number
     * is an AMQP `Long` type which can be upto 64 bits long. To represent that we are using a
     * library named {@link https://github.com/dcodeIO/long.js long.js}. We expect customers
     * to use the **`Long`** type exported by this library.
     * @readonly
     */
    readonly sequenceNumber?: Long;
    /**
     * @property {string} [deadLetterSource] The name of the queue or subscription that this message
     * was enqueued on, before it was deadlettered. Only set in messages that have been dead-lettered
     * and subsequently auto-forwarded from the dead-letter sub-queue to another entity. Indicates the
     * entity in which the message was dead-lettered.
     * @readonly
     */
    readonly deadLetterSource?: string;
    /**
     * @property {AmqpMessage} _amqpMessage The underlying raw amqp message.
     * @readonly
     */
    readonly _amqpMessage: AmqpMessage;
}

/**
 * The mode in which messages should be received. The 2 modes are `peekLock` and `receiveAndDelete`.
 */
export declare enum ReceiveMode {
    /**
     * Once a message is received in this mode, the receiver has a lock on the message for a
     * particular duration. If the message is not settled by this time, it lands back on Service Bus
     * to be fetched by the next receive operation.
     * @type {Number}
     */
    peekLock = 1,
    /**
     * Messages received in this mode get automatically removed from Service Bus.
     * @type {Number}
     */
    receiveAndDelete = 2
}

/**
 * The Receiver class can be used to receive messages in a batch or by registering handlers.
 * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate a Receiver.
 * The Receiver class is an abstraction over the underlying AMQP receiver link.
 * @class Receiver
 */
export declare class Receiver {
    /**
     * @property Describes the amqp connection context for the QueueClient.
     */
    private _context;
    private _receiveMode;
    /**
     * @property {boolean} [_isClosed] Denotes if close() was called on this receiver
     */
    private _isClosed;
    private _throwIfAlreadyReceiving;
    private _throwIfReceiverOrConnectionClosed;
    /**
     * @property Denotes receiveMode of this receiver.
     * @readonly
     */
    get receiveMode(): ReceiveMode;
    /**
     * @property Returns `true` if the receiver is closed. This can happen either because the receiver
     * itself has been closed or the client that created it has been closed.
     * @readonly
     */
    get isClosed(): boolean;
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the Receiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control if messages should be automatically completed, and/or have
     * their locks automatically renewed. You can control the maximum number of messages that should
     * be concurrently processed. You can also provide a timeout in seconds to denote the
     * amount of time to wait for a new message before closing the receiver.
     *
     * @returns void
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if current receiver is already in state of receiving messages.
     * @throws MessagingError if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
     */
    registerMessageHandler(onMessage: OnMessage, onError: OnError, options?: MessageHandlerOptions): void;
    /**
     * Returns a promise that resolves to an array of messages based on given count and timeout over
     * an AMQP receiver link from a Queue/Subscription.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
     * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * - **Default**: `60` seconds.
     * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws Error if current receiver is already in state of receiving messages.
     * @throws MessagingError if the service returns an error while receiving messages.
     */
    receiveMessages(maxMessageCount: number, maxWaitTimeInSeconds?: number): Promise<ServiceBusMessage[]>;
    /**
     * Gets an async iterator over messages from the receiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * If the iterator is not able to fetch a new message in over a minute, `undefined` will be returned.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws Error if current receiver is already in state of receiving messages.
     * @throws MessagingError if the service returns an error while receiving messages.
     */
    getMessageIterator(): AsyncIterableIterator<ServiceBusMessage>;
    /**
     * Renews the lock on the message for the duration as specified during the Queue/Subscription
     * creation.
     * - Check the `lockedUntilUtc` property on the message for the time when the lock expires.
     * - If a message is not settled (using either `complete()`, `defer()` or `deadletter()`,
     * before its lock expires, then the message lands back in the Queue/Subscription for the next
     * receive operation.
     *
     * @param lockTokenOrMessage - The `lockToken` property of the message or the message itself.
     * @returns Promise<Date> - New lock token expiry date and time in UTC format.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws MessagingError if the service returns an error while renewing message lock.
     */
    renewMessageLock(lockTokenOrMessage: string | ServiceBusMessage): Promise<Date>;
    /**
     * Returns a promise that resolves to a deferred message identified by the given `sequenceNumber`.
     * @param sequenceNumber The sequence number of the message that needs to be received.
     * @returns Promise<ServiceBusMessage | undefined>
     * - Returns `Message` identified by sequence number.
     * - Returns `undefined` if no such message is found.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws MessagingError if the service returns an error while receiving deferred message.
     */
    receiveDeferredMessage(sequenceNumber: Long): Promise<ServiceBusMessage | undefined>;
    /**
     * Returns a promise that resolves to an array of deferred messages identified by given `sequenceNumbers`.
     * @param sequenceNumbers An array of sequence numbers for the messages that need to be received.
     * @returns Promise<ServiceBusMessage[]>
     * - Returns a list of messages identified by the given sequenceNumbers.
     * - Returns an empty list if no messages are found.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws MessagingError if the service returns an error while receiving deferred messages.
     */
    receiveDeferredMessages(sequenceNumbers: Long[]): Promise<ServiceBusMessage[]>;
    /**
     * Closes the underlying AMQP receiver link.
     * Once closed, the receiver cannot be used for any further operations.
     * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate
     * a new Receiver
     *
     * @returns {Promise<void>}
     */
    close(): Promise<void>;
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
     */
    isReceivingMessages(): boolean;
}

/**
 * Represents a Rule on a Subscription that is used to filter the incoming message from the
 * Subscription.
 */
export declare interface RuleDescription {
    /**
     * Filter expression used to match messages. Supports 2 types:
     * - `string`: SQL-like condition expression that is evaluated against the messages'
     * user-defined properties and system properties. All system properties will be prefixed with
     * `sys.` in the condition expression.
     * - `CorrelationFilter`: Properties of the filter will be used to match with the message properties.
     */
    filter?: string | CorrelationFilter;
    /**
     * Action to perform if the message satisfies the filtering expression.
     */
    action?: string;
    /**
     * Represents the name of the rule.
     */
    name: string;
}

/**
 * Represents all attributes of a rule entity
 */
export declare interface RuleDetails {
    /**
     * Name of the rule
     */
    ruleName: string;
    /**
     * Defines the filter expression that the rule evaluates. For `SqlFilter` input,
     * the expression string is interpreted as a SQL92 expression which must
     * evaluate to True or False. Only one between a `CorrelationFilter` or
     * a `SqlFilter` can be defined.
     */
    filter?: SqlFilter | CorrelationFilter;
    /**
     * The SQL like expression that can be executed on the message should the
     * associated filter apply.
     */
    action?: SqlAction;
    /**
     * Name of topic
     */
    topicName: string;
    /**
     * Name of subscription
     */
    subscriptionName: string;
    /**
     * Created at timestamp
     */
    createdOn: string;
}

/**
 * Represents settable options on a rule
 */
export declare interface RuleOptions {
    /**
     * Defines the filter expression that the rule evaluates. For `SqlFilter` input,
     * the expression string is interpreted as a SQL92 expression which must
     * evaluate to True or False. Only one between a `CorrelationFilter` or
     * a `SqlFilter` can be defined.
     */
    filter?: SqlFilter | CorrelationFilter;
    /**
     * The SQL like expression that can be executed on the message should the
     * associated filter apply.
     */
    action?: SqlAction;
}

/**
 * Describes the message to be sent to Service Bus.
 * @interface SendableMessageInfo.
 */
export declare interface SendableMessageInfo {
    /**
     * @property The message body that needs to be sent or is received.
     */
    body: any;
    /**
     * @property The message identifier is an
     * application-defined value that uniquely identifies the message and its payload.
     *
     * Note: Numbers that are not whole integers are not allowed.
     */
    messageId?: string | number | Buffer;
    /**
     * @property The content type of the message. Optionally describes
     * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for
     * example "application/json".
     */
    contentType?: string;
    /**
     * @property The correlation identifier that allows an
     * application to specify a context for the message for the purposes of correlation, for example
     * reflecting the MessageId of a message that is being replied to.
     * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.
     */
    correlationId?: string | number | Buffer;
    /**
     * @property The partition key for sending a message to a partitioned entity.
     * Maximum length is 128 characters. For {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning partitioned entities},
     * setting this value enables assigning related messages to the same internal partition,
     * so that submission sequence order is correctly recorded. The partition is chosen by a hash
     * function over this value and cannot be chosen directly.
     * - For session-aware entities, the `sessionId` property overrides this value.
     * - For non partitioned entities, partition key will be ignored
     *
     */
    partitionKey?: string;
    /**
     * @property The partition key for sending a message into an entity
     * via a partitioned transfer queue. Maximum length is 128 characters. If a message is sent via a
     * transfer queue in the scope of a transaction, this value selects the transfer queue partition:
     * This is functionally equivalent to `partitionKey` property and ensures that messages are kept
     * together and in order as they are transferred.
     * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via Transfers and Send Via}.
     */
    viaPartitionKey?: string;
    /**
     * @property The session identifier for a session-aware entity. Maximum
     * length is 128 characters. For session-aware entities, this application-defined value specifies
     * the session affiliation of the message. Messages with the same session identifier are subject
     * to summary locking and enable exact in-order processing and demultiplexing. For
     * session-unaware entities, this value is ignored.
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions Message Sessions}.
     */
    sessionId?: string;
    /**
     * @property The session identifier augmenting the `replyTo` address.
     * Maximum length is 128 characters. This value augments the ReplyTo information and specifies
     * which SessionId should be set for the reply when sent to the reply entity.
     * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.
     */
    replyToSessionId?: string;
    /**
     * @property The message’s time to live value. This value is the relative
     * duration after which the message expires, starting from the instant the message has been
     * accepted and stored by the broker, as captured in `enqueuedTimeUtc`. When not set explicitly,
     * the assumed value is the DefaultTimeToLive for the respective queue or topic. A message-level
     * `timeToLive` value cannot be longer than the entity's DefaultTimeToLive setting and it is
     * silently adjusted if it does. See
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-expiration Expiration}.
     */
    timeToLive?: number;
    /**
     * @property The application specific label. This property enables the
     * application to indicate the purpose of the message to the receiver in a standardized. fashion,
     * similar to an email subject line. The mapped AMQP property is "subject".
     */
    label?: string;
    /**
     * @property The "to" address. This property is reserved for future use in routing
     * scenarios and presently ignored by the broker itself. Applications can use this value in
     * rule-driven {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-auto-forwarding auto-forward chaining}
     * scenarios to indicate the intended logical destination of the message.
     */
    to?: string;
    /**
     * @property The address of an entity to send replies to. This optional and
     * application-defined value is a standard way to express a reply path to the receiver of the
     * message. When a sender expects a reply, it sets the value to the absolute or relative path of
     * the queue or topic it expects the reply to be sent to. See
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.
     */
    replyTo?: string;
    /**
     * @property The date and time in UTC at which the message will
     * be enqueued. This property returns the time in UTC; when setting the property, the
     * supplied DateTime value must also be in UTC. This value is for delayed message sending.
     * It is utilized to delay messages sending to a specific time in the future. Message enqueuing
     * time does not mean that the message will be sent at the same time. It will get enqueued,
     * but the actual sending time depends on the queue's workload and its state.
     */
    scheduledEnqueueTimeUtc?: Date;
    /**
     * @property The application specific properties which can be
     * used for custom message metadata.
     */
    userProperties?: {
        [key: string]: any;
    };
}

/**
 * The Sender class can be used to send messages, schedule messages to be sent at a later time
 * and cancel such scheduled messages.
 * Use the `createSender` function on the QueueClient or TopicClient to instantiate a Sender.
 * The Sender class is an abstraction over the underlying AMQP sender link.
 * @class Sender
 */
export declare class Sender {
    /**
     * @property Describes the amqp connection context for the Client.
     */
    private _context;
    /**
     * @property Denotes if close() was called on this sender
     */
    private _isClosed;
    private _throwIfSenderOrConnectionClosed;
    /**
     * @property Returns `true` if either the sender or the client that created it has been closed
     * @readonly
     */
    get isClosed(): boolean;
    /**
     * Sends the given message after creating an AMQP Sender link if it doesnt already exists.
     *
     * To send a message to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`
     * and/or `partitionKey` properties respectively on the message.
     *
     * @param message - Message to send.
     * @returns Promise<void>
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while sending messages to the service.
     */
    send(message: SendableMessageInfo): Promise<void>;
    /**
     * Sends the given messages in a single batch i.e. in a single AMQP message after creating an AMQP
     * Sender link if it doesnt already exists.
     *
     * - To send messages to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`
     * and/or `partitionKey` properties respectively on the messages.
     * - When doing so, all
     * messages in the batch should have the same `sessionId` (if using sessions) and the same
     * `parititionKey` (if using paritions).
     *
     * @param messages - An array of SendableMessageInfo objects to be sent in a Batch message.
     * @return Promise<void>
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while sending messages to the service.
     */
    sendBatch(messages: SendableMessageInfo[]): Promise<void>;
    /**
     * Schedules given message to appear on Service Bus Queue/Subscription at a later time.
     *
     * Please note that you need to explicitly encode the message body if you intend to receive the message using a tool or library other than this library.
     * For example:
     *  1. Import DefaultDataTransformer and instantiate.
     *      ```js
     *        const dt = new DefaultDataTransformer();
     *      ```
     *  2. Use the `encode` method on the transformer to encode the message body before calling the scheduleMessage() method
     *      ```js
     *        message.body = dt.encode(message.body);
     *      ```
     *
     * @param scheduledEnqueueTimeUtc - The UTC time at which the message should be enqueued.
     * @param message - The message that needs to be scheduled.
     * @returns Promise<Long> - The sequence number of the message that was scheduled.
     * You will need the sequence number if you intend to cancel the scheduling of the message.
     * Save the `Long` type as-is in your application without converting to number. Since JavaScript
     * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while scheduling a message.
     */
    scheduleMessage(scheduledEnqueueTimeUtc: Date, message: SendableMessageInfo): Promise<Long>;
    /**
     * Schedules given messages to appear on Service Bus Queue/Subscription at a later time.
     *
     * Please note that you need to explicitly encode the message body if you intend to receive the message using a tool or library other than this library.
     * For example:
     *  1. Import DefaultDataTransformer and instantiate.
     *      ```js
     *        const dt = new DefaultDataTransformer();
     *      ```
     *  2. Use the `encode` method on the transformer to encode the message body before calling the scheduleMessage() method
     *      ```js
     *        message.body = dt.encode(message.body);
     *      ```
     *
     * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
     * @param messages - Array of Messages that need to be scheduled.
     * @returns Promise<Long[]> - The sequence numbers of messages that were scheduled.
     * You will need the sequence number if you intend to cancel the scheduling of the messages.
     * Save the `Long` type as-is in your application without converting to number. Since JavaScript
     * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while scheduling messages.
     */
    scheduleMessages(scheduledEnqueueTimeUtc: Date, messages: SendableMessageInfo[]): Promise<Long[]>;
    /**
     * Cancels a message that was scheduled to appear on a ServiceBus Queue/Subscription.
     * @param sequenceNumber - The sequence number of the message to be cancelled.
     * @returns Promise<void>
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while canceling a scheduled message.
     */
    cancelScheduledMessage(sequenceNumber: Long): Promise<void>;
    /**
     * Cancels multiple messages that were scheduled to appear on a ServiceBus Queue/Subscription.
     * @param sequenceNumbers - An Array of sequence numbers of the messages to be cancelled.
     * @returns Promise<void>
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws MessagingError if the service returns an error while canceling scheduled messages.
     */
    cancelScheduledMessages(sequenceNumbers: Long[]): Promise<void>;
    /**
     * Closes the underlying AMQP sender link.
     * Once closed, the sender cannot be used for any further operations.
     * Use the `createSender` function on the QueueClient or TopicClient to instantiate a new Sender
     *
     * @returns {Promise<void>}
     */
    close(): Promise<void>;
}

/**
 * Describes the client that allows interacting with a Service Bus instance.
 * Holds the AMQP connection to the Service Bus Namespace and is the entry point for using Queues,
 * Topics and Subscriptions.
 */
export declare class ServiceBusClient {
    /**
     * @readonly
     * @property The name of the Service Bus Namespace.
     */
    readonly name: string;
    /**
     * @property Describes the amqp connection context for the Namespace.
     * @private
     */
    private _context;
    /**
     * Instantiates a ServiceBusClient to interact with a Service Bus Namespace.
     *
     * @constructor
     * @param {ConnectionConfig} config - The connection configuration needed to connect to the
     * Service Bus Namespace.
     * @param {TokenProvider} [tokenProvider] - The token provider that provides the token for
     * authentication.
     * @param {ServiceBusClientOptions} - Options to control ways to interact with the Service Bus
     * Namespace.
     */
    private constructor();
    /**
     * Creates a QueueClient for an existing Service Bus Queue.
     * @param {string} queueName The queue name.
     * @returns QueueClient.
     * @throws Error if the underlying connection is closed.
     */
    createQueueClient(queueName: string): QueueClient;
    /**
     * Creates a TopicClient for an existing Service Bus Topic.
     * @param {string} topicName The topic name.
     * @returns TopicClient.
     * @throws
     * @throws Error if the underlying connection is closed.
     */
    createTopicClient(topicName: string): TopicClient;
    /**
     * Creates a SubscriptionClient for an existing Service Bus Subscription.
     * @param {string} topicName The topic name.
     * @param {string} subscriptionName The subscription name.
     * @returns SubscriptionClient.
     * @throws Error if the underlying connection is closed.
     */
    createSubscriptionClient(topicName: string, subscriptionName: string): SubscriptionClient;
    /**
     * Closes the AMQP connection created by this ServiceBusClient along with AMQP links for
     * sender/receivers created by the queue/topic/subscription clients created by this
     * ServiceBusClient.
     * Once closed,
     * - the clients created by this ServiceBusClient cannot be used to send/receive messages anymore.
     * - this ServiceBusClient cannot be used to create any new queues/topics/subscriptions clients.
     * @returns {Promise<any>}
     */
    close(): Promise<any>;
    /**
     * Creates a ServiceBusClient for the Service Bus Namespace represented in the given connection
     * string.
     * @param {string} connectionString - Connection string of the form
     * 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {ServiceBusClientOptions} [options] Options to control ways to interact with the
     * Service Bus Namespace.
     * @returns {ServiceBusClient}
     */
    static createFromConnectionString(connectionString: string, options?: ServiceBusClientOptions): ServiceBusClient;
    /**
     * Creates a ServiceBusClient for the Service Bus Namespace represented by the given host using
     * the given TokenProvider.
     * @param {string} host - Fully qualified domain name for Servicebus. Most likely,
     * `<yournamespace>.servicebus.windows.net`.
     * @param {TokenProvider} tokenProvider - Your custom implementation of the {@link https://github.com/Azure/amqp-common-js/blob/master/lib/auth/token.ts Token Provider}
     * interface.
     * @param {ServiceBusClientOptions} options - Options to control ways to interact with the
     * Service Bus Namespace.
     * @returns {ServiceBusClient}
     */
    static createFromTokenProvider(host: string, tokenProvider: TokenProvider, options?: ServiceBusClientOptions): ServiceBusClient;
    /**
     * Creates a ServiceBusClient for the Service Bus Namespace represented by the given host using
     * the TokenCredentials generated using the `@azure/ms-rest-nodeauth` library.
     * @param {string} host - Fully qualified domain name for ServiceBus.
     * Most likely, {yournamespace}.servicebus.windows.net
     * @param {ServiceClientCredentials} credentials - The Token credentials generated by using the
     * `@azure/ms-rest-nodeauth` library. It can be one of the following:
     *  - ApplicationTokenCredentials
     *  - UserTokenCredentials
     *  - DeviceTokenCredentials
     *  - MSITokenCredentials
     * Token audience (or resource in case of MSI based credentials) to use when creating the credentials is https://servicebus.azure.net/
     * @param {ServiceBusClientOptions} options - Options to control ways to interact with the
     * Service Bus Namespace.
     * @returns {ServiceBusClient}
     * @throws Error if `createFromAadTokenCredentials` is accessed in browser context, as AAD support is not present in browser.
     */
    static createFromAadTokenCredentials(host: string, credentials: ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials | MSITokenCredentials, options?: ServiceBusClientOptions): ServiceBusClient;
}

/**
 * Describes the options that can be provided while creating the ServiceBusClient.
 * @interface ServiceBusClientOptions
 */
export declare interface ServiceBusClientOptions {
    /**
     * @property The data transformer that will be used to encode
     * and decode the sent and received messages respectively. If not provided then we will use the
     * DefaultDataTransformer. The default transformer should handle majority of the cases. This
     * option needs to be used only for specialized scenarios.
     */
    dataTransformer?: DataTransformer;
    /**
     * @property The WebSocket constructor used to create an AMQP connection
     * over a WebSocket. In browsers, the built-in WebSocket will be  used by default. In Node, a
     * TCP socket will be used if a WebSocket constructor is not provided.
     */
    webSocket?: WebSocketImpl;
    /**
     * @property Options to be passed to the WebSocket constructor
     */
    webSocketConstructorOptions?: any;
}

/**
 * Describes the message received from Service Bus.
 * @class ServiceBusMessage
 */
export declare class ServiceBusMessage implements ReceivedMessage {
    /**
     * @property The message body that needs to be sent or is received.
     */
    body: any;
    /**
     * @property The application specific properties.
     */
    userProperties?: {
        [key: string]: any;
    };
    /**
     * @property The message identifier is an
     * application-defined value that uniquely identifies the message and its payload. The identifier
     * is a free-form string and can reflect a GUID or an identifier derived from the application
     * context. If enabled, the
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection duplicate detection}
     * identifies and removes second and further submissions of messages with the same MessageId.
     */
    messageId?: string | number | Buffer;
    /**
     * @property The content type of the message. Optionally describes
     * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for
     * example "application/json".
     */
    contentType?: string;
    /**
     * @property The correlation identifier that allows an
     * application to specify a context for the message for the purposes of correlation, for example
     * reflecting the MessageId of a message that is being replied to.
     * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.
     */
    correlationId?: string | number | Buffer;
    /**
     * @property The partition key for sending a message to a
     * partitioned entity. Maximum length is 128 characters. For {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning partitioned entities},
     * setting this value enables assigning related messages to the same internal partition,
     * so that submission sequence order is correctly recorded. The partition is chosen by a hash
     * function over this value and cannot be chosen directly. For session-aware entities,
     * the `sessionId` property overrides this value.
     */
    partitionKey?: string;
    /**
     * @property The partition key for sending a message into an entity
     * via a partitioned transfer queue. Maximum length is 128 characters. If a message is sent via a
     * transfer queue in the scope of a transaction, this value selects the transfer queue partition:
     * This is functionally equivalent to `partitionKey` property and ensures that messages are kept
     * together and in order as they are transferred.
     * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via Transfers and Send Via}.
     */
    viaPartitionKey?: string;
    /**
     * @property The session identifier for a session-aware entity. Maximum
     * length is 128 characters. For session-aware entities, this application-defined value specifies
     * the session affiliation of the message. Messages with the same session identifier are subject
     * to summary locking and enable exact in-order processing and demultiplexing. For
     * session-unaware entities, this value is ignored.
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions Message Sessions}.
     */
    sessionId?: string;
    /**
     * @property The session identifier augmenting the `replyTo` address.
     * Maximum length is 128 characters. This value augments the ReplyTo information and specifies
     * which SessionId should be set for the reply when sent to the reply entity.
     * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.
     */
    replyToSessionId?: string;
    /**
     * @property The message’s time to live value. This value is the relative
     * duration after which the message expires, starting from the instant the message has been
     * accepted and stored by the broker, as captured in `enqueuedTimeUtc`. When not set explicitly,
     * the assumed value is the DefaultTimeToLive for the respective queue or topic. A message-level
     * `timeToLive` value cannot be longer than the entity's DefaultTimeToLive setting and it is
     * silently adjusted if it does. See
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-expiration Expiration}.
     */
    timeToLive?: number;
    /**
     * @property The application specific label. This property enables the
     * application to indicate the purpose of the message to the receiver in a standardized. fashion,
     * similar to an email subject line. The mapped AMQP property is "subject".
     */
    label?: string;
    /**
     * @property The "to" address. This property is reserved for future use in routing
     * scenarios and presently ignored by the broker itself. Applications can use this value in
     * rule-driven {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-auto-forwarding auto-forward chaining}
     * scenarios to indicate the intended logical destination of the message.
     */
    to?: string;
    /**
     * @property The address of an entity to send replies to. This optional and
     * application-defined value is a standard way to express a reply path to the receiver of the
     * message. When a sender expects a reply, it sets the value to the absolute or relative path of
     * the queue or topic it expects the reply to be sent to. See
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation Message Routing and Correlation}.
     */
    replyTo?: string;
    /**
     * @property The date and time in UTC at which the message will
     * be enqueued. This property returns the time in UTC; when setting the property, the
     * supplied DateTime value must also be in UTC. This value is for delayed message sending.
     * It is utilized to delay messages sending to a specific time in the future. Message enqueuing
     * time does not mean that the message will be sent at the same time. It will get enqueued,
     * but the actual sending time depends on the queue's workload and its state.
     */
    scheduledEnqueueTimeUtc?: Date;
    /**
     * @property The lock token is a reference to the lock that is being held by the broker in
     * `ReceiveMode.PeekLock` mode. Locks are used internally settle messages as explained in the
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement product documentation in more detail}
     * - Not applicable when the message is received in `ReceiveMode.receiveAndDelete`
     * mode.
     * @readonly
     */
    readonly lockToken?: string;
    /**
     * @property Number of deliveries that have been attempted for this message. The count is
     * incremented when a message lock expires, or the message is explicitly abandoned using the
     * `abandon()` method on the message.
     * @readonly
     */
    readonly deliveryCount?: number;
    /**
     * @property The UTC instant at which the message has been accepted and stored in Service Bus.
     * @readonly
     */
    readonly enqueuedTimeUtc?: Date;
    /**
     * @property The UTC instant at which the message is marked for removal and no longer available for
     * retrieval from the entity due to expiration. This property is computed from 2 other properties
     * on the message: `enqueuedTimeUtc` + `timeToLive`.
     */
    readonly expiresAtUtc?: Date;
    /**
     * @property The UTC instant until which the message is held locked in the queue/subscription.
     * When the lock expires, the `deliveryCount` is incremented and the message is again available
     * for retrieval.
     * - Not applicable when the message is received in `ReceiveMode.receiveAndDelete`
     * mode.
     */
    lockedUntilUtc?: Date;
    /**
     * @property The original sequence number of the message. For
     * messages that have been auto-forwarded, this property reflects the sequence number that had
     * first been assigned to the message at its original point of submission.
     * @readonly
     */
    readonly enqueuedSequenceNumber?: number;
    /**
     * @property The unique number assigned to a message by Service Bus.
     * The sequence number is a unique 64-bit integer assigned to a message as it is accepted
     * and stored by the broker and functions as its true identifier. For partitioned entities,
     * the topmost 16 bits reflect the partition identifier. Sequence numbers monotonically increase.
     * They roll over to 0 when the 48-64 bit range is exhausted.
     * @readonly
     */
    readonly sequenceNumber?: Long;
    /**
     * @property The name of the queue or subscription that this message
     * was enqueued on, before it was deadlettered. Only set in messages that have been dead-lettered
     * and subsequently auto-forwarded from the dead-letter sub-queue to another entity. Indicates the
     * entity in which the message was dead-lettered.
     * @readonly
     */
    readonly deadLetterSource?: string;
    /**
     * The associated delivery of the received message.
     */
    readonly delivery: Delivery;
    /**
     * @property {AmqpMessage} _amqpMessage The underlying raw amqp message.
     * @readonly
     */
    readonly _amqpMessage: AmqpMessage;
    /**
     * @property Boolean denoting if the message has already been settled.
     * @readonly
     */
    get isSettled(): boolean;
    /**
     * @property {ClientEntityContext} _context The client entity context.
     * @readonly
     */
    private readonly _context;
    /**
     * Removes the message from Service Bus.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @returns Promise<void>.
     */
    complete(): Promise<void>;
    /**
     * The lock held on the message by the receiver is let go, making the message available again in
     * Service Bus for another receive operation.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param propertiesToModify The properties of the message to modify while abandoning the message.
     *
     * @return Promise<void>.
     */
    abandon(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    /**
     * Defers the processing of the message. Save the `sequenceNumber` of the message, in order to
     * receive it message again in the future using the `receiveDeferredMessage` method.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param propertiesToModify The properties of the message to modify while deferring the message
     *
     * @returns Promise<void>
     */
    defer(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    /**
     * Moves the message to the deadletter sub-queue. To receive a deadletted message, create a new
     * QueueClient/SubscriptionClient using the path for the deadletter sub-queue.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link got closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled. To avoid this error check the `isSettled`
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `ReceiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param options The DeadLetter options that can be provided while
     * rejecting the message.
     *
     * @returns Promise<void>
     */
    deadLetter(options?: DeadLetterOptions): Promise<void>;
    /**
     * Creates a clone of the current message to allow it to be re-sent to the queue
     * @returns ServiceBusMessage
     */
    clone(): SendableMessageInfo;
    /**
     * @private
     * Logs and Throws an error if the given message cannot be settled.
     * @param receiver Receiver to be used to settle this message
     * @param operation Settle operation: complete, abandon, defer or deadLetter
     */
    private throwIfMessageCannotBeSettled;
}

/**
 * Describes the options passed to `registerMessageHandler` method when receiving messages from a
 * Queue/Subscription which has sessions enabled.
 */
export declare interface SessionMessageHandlerOptions {
    /**
     * @property Indicates whether the `complete()` method on the message should automatically be
     * called by the sdk after the user provided onMessage handler has been executed.
     * Calling `complete()` on a message removes it from the Queue/Subscription.
     * - **Default**: `true`.
     */
    autoComplete?: boolean;
    /**
     * @property The maximum number of concurrent calls that the library
     * can make to the user's message handler. Once this limit has been reached, more messages will
     * not be received until atleast one of the calls to the user's message handler has completed.
     * - **Default**: `1`.
     */
    maxConcurrentCalls?: number;
}

/**
 * The SessionReceiver class can be used to receive messages from a session enabled Queue or
 * Subscription in a batch or by registering handlers.
 * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate a
 * SessionReceiver.
 * The SessionReceiver class is an abstraction over the underlying AMQP receiver link.
 * @class SessionReceiver
 */
export declare class SessionReceiver {
    /**
     * @property {ClientEntityContext} _context Describes the amqp connection context for the QueueClient.
     */
    private _context;
    private _receiveMode;
    private _messageSession;
    private _sessionOptions;
    /**
     * @property {boolean} [_isClosed] Denotes if close() was called on this receiver
     */
    private _isClosed;
    private _sessionId;
    private _throwIfReceiverOrConnectionClosed;
    private _createMessageSessionIfDoesntExist;
    private _throwIfAlreadyReceiving;
    /**
     * @property Denotes receiveMode of this receiver.
     * @readonly
     */
    get receiveMode(): ReceiveMode;
    /**
     * @property Returns `true` if the receiver is closed. This can happen either because the receiver
     * itself has been closed or the client that created it has been closed.
     * @readonly
     */
    get isClosed(): boolean;
    /**
     * @property The id of the session from which this receiver will receive messages.
     * Will return undefined until a AMQP receiver link has been successfully set up for the session.
     * @readonly
     */
    get sessionId(): string | undefined;
    /**
     * @property The time in UTC until which the session is locked.
     * Everytime `renewSessionLock()` is called, this time gets updated to current time plus the lock
     * duration as specified during the Queue/Subscription creation.
     *
     * Will return undefined until a AMQP receiver link has been successfully set up for the session.
     *
     * @readonly
     */
    get sessionLockedUntilUtc(): Date | undefined;
    /**
     * Renews the lock on the session for the duration as specified during the Queue/Subscription
     * creation.
     * - Check the `sessionLockedUntilUtc` property on the SessionReceiver for the time when the lock expires.
     * - When the lock on the session expires
     *     - No more messages can be received using this receiver
     *     - If a message is not settled (using either `complete()`, `defer()` or `deadletter()`,
     *   before the session lock expires, then the message lands back in the Queue/Subscription for the next
     *   receive operation.
     *
     * @returns Promise<Date> - New lock token expiry date and time in UTC format.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while renewing session lock.
     */
    renewSessionLock(): Promise<Date>;
    /**
     * Sets the state on the Session. For more on session states, see
     * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions#message-session-state Session State}
     * @param state The state that needs to be set.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while setting the session state.
     */
    setState(state: any): Promise<void>;
    /**
     * Gets the state of the Session. For more on session states, see
     * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions#message-session-state Session State}
     * @returns Promise<any> The state of that session
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while retrieving session state.
     */
    getState(): Promise<any>;
    /**
     * Fetches the next batch of active messages (including deferred but not deadlettered messages) in
     * the current session.
     * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the
     * subsequent message.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param maxMessageCount The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedMessageInfo[]>
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peek(maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
    /**
     * Peeks the desired number of active messages (including deferred but not deadlettered messages)
     * from the specified sequence number in the current session.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peekBySequenceNumber(fromSequenceNumber: Long, maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
    /**
     * Returns a promise that resolves to a deferred message identified by the given `sequenceNumber`.
     * @param sequenceNumber The sequence number of the message that needs to be received.
     * @returns Promise<ServiceBusMessage | undefined>
     * - Returns `Message` identified by sequence number.
     * - Returns `undefined` if no such message is found.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while receiving deferred message.
     */
    receiveDeferredMessage(sequenceNumber: Long): Promise<ServiceBusMessage | undefined>;
    /**
     * Returns a promise that resolves to an array of deferred messages identified by given `sequenceNumbers`.
     * @param sequenceNumbers An array of sequence numbers for the messages that need to be received.
     * @returns Promise<ServiceBusMessage[]>
     * - Returns a list of messages identified by the given sequenceNumbers.
     * - Returns an empty list if no messages are found.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws MessagingError if the service returns an error while receiving deferred messages.
     */
    receiveDeferredMessages(sequenceNumbers: Long[]): Promise<ServiceBusMessage[]>;
    /**
     * Returns a promise that resolves to an array of messages based on given count and timeout over
     * an AMQP receiver link from a Queue/Subscription.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param maxMessageCount      The maximum number of messages to receive from Queue/Subscription.
     * @param maxWaitTimeInSeconds The total wait time in seconds until which the receiver will attempt to receive specified number of messages.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * - **Default**: `60` seconds.
     * @returns Promise<ServiceBusMessage[]> A promise that resolves with an array of Message objects.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if the receiver is already in state of receiving messages.
     * @throws MessagingError if the service returns an error while receiving messages.
     */
    receiveMessages(maxMessageCount: number, maxWaitTimeInSeconds?: number): Promise<ServiceBusMessage[]>;
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed
     * or if the lock on the session should be automatically renewed. You can control the
     * maximum number of messages that should be concurrently processed. You can
     * also provide a timeout in seconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     *
     * @returns void
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if the receiver is already in state of receiving messages.
     * @throws MessagingErrormif the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
     */
    registerMessageHandler(onMessage: OnMessage, onError: OnError, options?: SessionMessageHandlerOptions): void;
    /**
     * Gets an async iterator over messages from the receiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * If the iterator is not able to fetch a new message in over a minute, `undefined` will be returned
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if the receiver is already in state of receiving messages.
     * @throws MessagingError if the service returns an error while receiving messages.
     */
    getMessageIterator(): AsyncIterableIterator<ServiceBusMessage>;
    /**
     * Closes the underlying AMQP receiver link.
     * Once closed, the receiver cannot be used for any further operations.
     * Use the `createReceiver` function on the QueueClient or SubscriptionClient to instantiate
     * a new Receiver
     *
     * @returns {Promise<void>}
     */
    close(): Promise<void>;
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
     */
    isReceivingMessages(): boolean;
}

/**
 * Describes the options passed to the `createReceiver` method when using a Queue/Subscription that
 * has sessions enabled.
 */
export declare interface SessionReceiverOptions {
    /**
     * @property The id of the session from which messages need to be received. If null or undefined is
     * provided, Service Bus chooses a random session from available sessions.
     */
    sessionId: string | undefined;
    /**
     * @property The maximum duration in seconds
     * until which, the lock on the session will be renewed automatically by the sdk.
     * - **Default**: `300` seconds (5 minutes).
     * - **To disable autolock renewal**, set this to `0`.
     */
    maxSessionAutoRenewLockDurationInSeconds?: number;
}

/**
 * Represents all possible fields on SqlAction
 */
export declare type SqlAction = SqlFilter;

/**
 * Represents all possible fields on SqlFilter
 */
export declare interface SqlFilter {
    /**
     * SQL expression to use.
     */
    sqlExpression?: string;
    /**
     * SQL parameters to the expression
     */
    sqlParameters?: SqlParameter[];
    /**
     * This property is reserved for future use. An integer value showing the
     * compatibility level, currently hard-coded to 20.
     */
    compatibilityLevel?: number;
    /**
     * Boolean value indicating whether the SQL filter expression requires preprocessing
     */
    requiresPreprocessing?: boolean;
}

/**
 * Represents type of SQL `Parameter` in ATOM based management operations
 */
export declare type SqlParameter = {
    key: string;
    value: string | number;
    type: string;
};

/**
 * Describes the client that allows interacting with a Service Bus Subscription.
 * Use the `createSubscriptionClient` function on the ServiceBusClient object to instantiate a
 * SubscriptionClient
 * @class SubscriptionClient
 */
export declare class SubscriptionClient implements Client {
    /**
     * @readonly
     * @property The name of the Service Bus Topic for whose Subscription, this client is created.
     */
    readonly topicName: string;
    /**
     * @readonly
     * @property The name of the Service Bus Subscription for which this client is created.
     */
    readonly subscriptionName: string;
    /**
     * @readonly
     * @property The name of the default rule on the subscription.
     */
    readonly defaultRuleName: string;
    /**
     * @readonly
     * @property The path for the Service Bus Subscription for which this client is created.
     */
    readonly entityPath: string;
    /**
     * @readonly
     * @property A unique identifier for this client.
     */
    readonly id: string;
    /**
     * @property Describes the amqp connection context for the SubscriptionClient.
     */
    private _context;
    private _currentReceiver;
    /**
     * Closes the AMQP link for the receivers created by this client.
     * Once closed, neither the SubscriptionClient nor its receivers can be used for any
     * further operations.
     *
     * @returns {Promise<void>}
     */
    close(): Promise<void>;
    /**
     * Creates a Receiver for receiving messages from a Subscription which does not have sessions enabled.
     * @param receiveMode An enum indicating the mode in which messages should be received. Possible
     * values are:
     * - `ReceiveMode.peekLock`: Once a message is received in this mode, the receiver has a lock on
     * the message for a particular duration. If the message is not settled by this time, it lands back
     * on Service Bus to be fetched by the next receive operation.
     * - `ReceiveMode.receiveAndDelete`: Messages received in this mode get automatically removed from
     * Service Bus.
     *
     * @returns Receiver A receiver to receive messages from a Subscription which does not have
     * sessions enabled.
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws Error if an open receiver already exists on the SubscriptionClient.
     * @throws MessagingError with name `InvalidOperationError` if the Queue has sessions enabled
     * (in which case, use the overload of this method which takes
     * `sessionOptions` argument)
     */
    createReceiver(receiveMode: ReceiveMode): Receiver;
    /**
     * Creates a Receiver for receiving messages from a session enabled Subscription. When no sessionId is
     * given, a random session among the available sessions is used.
     * @param receiveMode An enum indicating the mode in which messages should be received. Possible
     * values are:
     * - `ReceiveMode.peekLock`: Once a message is received in this mode, the receiver has a lock on
     * the message for a particular duration. If the message is not settled by this time, it lands back
     * on Service Bus to be fetched by the next receive operation.
     * - `ReceiveMode.receiveAndDelete`: Messages received in this mode get automatically removed from
     * Service Bus.
     * @param sessionOptions Options to provide sessionId and duration of automatic lock renewal for
     * the session receiver.
     *
     * @returns SessionReceiver A receiver to receive from a session in the Subscription.
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws Error if an open receiver already exists on the SubscriptionClient for given sessionId.
     * @throws MessagingError with name `SessionCannotBeLockedError` if the Queue does not have sessions enabled (in which
     * case do not pass the `sessionOptions` argument) or if Service Bus is not able to get a lock on
     * the session (in which case try again after some time)
     */
    createReceiver(receiveMode: ReceiveMode, sessionOptions: SessionReceiverOptions): SessionReceiver;
    /**
     * Fetches the next batch of active messages (including deferred but not deadlettered messages).
     * - The first call to `peek()` fetches the first active message. Each subsequent call fetches the
     * subsequent message.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peek(maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
    /**
     * Peeks the desired number of active messages (including deferred but not deadlettered messages)
     * from the specified sequence number.
     * - Unlike a `received` message, `peeked` message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`. The lock on it cannot be renewed.
     *
     * @param fromSequenceNumber The sequence number from where to read the message.
     * @param [maxMessageCount] The maximum number of messages to peek. Default value `1`.
     * @returns Promise<ReceivedSBMessage[]>
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while peeking for messages.
     */
    peekBySequenceNumber(fromSequenceNumber: Long, maxMessageCount?: number): Promise<ReceivedMessageInfo[]>;
    /**
     * Gets all rules associated with the subscription
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while retrieving rules.
     */
    getRules(): Promise<RuleDescription[]>;
    /**
     * Removes the rule on the subscription identified by the given rule name.
     *
     * **Caution**: If all rules on a subscription are removed, then the subscription will not receive
     * any more messages.
     * @param ruleName
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while removing rules.
     */
    removeRule(ruleName: string): Promise<void>;
    /**
     * Adds a rule on the subscription as defined by the given rule name, filter and action.
     *
     * **Note**: Remove the default true filter on the subscription before adding a rule.
     * Otherwise, the added rule will have no affect as the true filter will always result in
     * the subscription receiving all messages.
     * @param ruleName Name of the rule
     * @param filter A Boolean, SQL expression or a Correlation filter. For SQL Filter syntax, see
     * {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-filter SQLFilter syntax}.
     * @param sqlRuleActionExpression Action to perform if the message satisfies the filtering expression. For SQL Rule Action syntax,
     * see {@link https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-sql-rule-action SQLRuleAction syntax}.
     * @throws Error if the SubscriptionClient or the underlying connection is closed.
     * @throws MessagingError if the service returns an error while adding rules.
     */
    addRule(ruleName: string, filter: boolean | string | CorrelationFilter, sqlRuleActionExpression?: string): Promise<void>;
}

/**
 * Represents all attributes of a subscription entity
 */
export declare interface SubscriptionDetails {
    /**
     * Name of the subscription
     */
    subscriptionName: string;
    /**
     * Name of the topic
     */
    topicName: string;
    /**
     * The default lock duration is applied to subscriptions that do not define a
     * lock duration.
     * Settable only at subscription creation time.
     * This is specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    lockDuration: string;
    /**
     * The entity's size in bytes.
     *
     */
    sizeInBytes?: number;
    /**
     * Specifies the maximum topic size in megabytes. Any attempt to enqueue a message
     * that will cause the topic to exceed this value will fail. All messages that are
     * stored in the topic or any of its subscriptions count towards this value.
     * Multiple copies of a message that reside in one or multiple subscriptions
     * count as a single messages. For example, if message m exists once in subscription
     * s1 and twice in subscription s2, m is counted as a single message.
     */
    maxSizeInMegabytes?: number;
    /**
     * The entity's message count.
     *
     */
    messageCount: number;
    /**
     * Specifies whether the topic should be partitioned
     */
    enablePartitioning?: boolean;
    /**
     * If set to true, the subscription will be session-aware and only SessionReceiver
     * will be supported. Session-aware subscription are not supported through REST.
     * Settable only at subscription creation time.
     */
    requiresSession: boolean;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations: boolean;
    /**
     * Determines how long a message lives in the subscription. Based on whether
     * dead-lettering is enabled, a message whose TTL has expired will either be moved
     * to the subscription’s associated dead-letter sub-queue or permanently deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    defaultMessageTtl?: string;
    /**
     * Indicates the default rule description.
     *
     */
    defaultRuleDescription?: any;
    /**
     * Max idle time before entity is deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    autoDeleteOnIdle: string;
    /**
     * If it is enabled and a message expires, the Service Bus moves the message from
     * the queue into the subscription’s dead-letter sub-queue. If disabled, message
     * will be permanently deleted from the subscription’s main queue. Settable only
     * at subscription creation time.
     */
    deadLetteringOnMessageExpiration: boolean;
    /**
     * Determines how the Service Bus handles a message that causes an exception
     * during a subscription’s filter evaluation. If the value is set to true,
     * the message that caused the exception will be moved to the subscription’s
     * dead-letter sub-queue. Otherwise, it will be discarded. By default this
     * parameter is set to true, allowing the user a chance to investigate the
     * cause of the exception. It can occur from a malformed message or some
     * incorrect assumptions being made in the filter about the form of the message.
     * Settable only at topic creation time.
     */
    deadLetteringOnFilterEvaluationExceptions: boolean;
    /**
     * Absolute URL or the name of the queue or topic the dead-lettered
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardDeadLetteredMessagesTo?: string;
    /**
     * The maximum delivery count of messages after which if it is still not settled,
     * gets moved to the dead-letter sub-queue.
     *
     */
    maxDeliveryCount: number;
    /**
     * Absolute URL or the name of the queue or topic the
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardTo?: string;
    /**
     * The user provided metadata information associated with the subscription description.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata?: string;
    /**
     * Message count details
     */
    messageCountDetails?: MessageCountDetails;
    /**
     * Entity availability status
     */
    entityAvailabilityStatus: string;
    /**
     * Status of the messaging entity.
     */
    status?: EntityStatus;
    /**
     * Created at timestamp
     */
    createdOn: string;
    /**
     * Updated at timestamp
     */
    updatedOn: string;
    /**
     * Accessed at timestamp
     */
    accessedOn?: string;
}

/**
 * Represents settable options on a subscription
 */
export declare interface SubscriptionOptions {
    /**
     * The default lock duration is applied to subscriptions that do not define a lock
     * duration. Settable only at subscription creation time.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    lockDuration?: string;
    /**
     * If set to true, the subscription will be session-aware and only SessionReceiver
     * will be supported. Session-aware subscription are not supported through REST.
     * Settable only at subscription creation time.
     */
    requiresSession?: boolean;
    /**
     * Determines how long a message lives in the subscription. Based on whether
     * dead-lettering is enabled, a message whose TTL has expired will either be moved
     * to the subscription’s associated DeadLtterQueue or permanently deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    defaultMessageTtl?: string;
    /**
     * If it is enabled and a message expires, the Service Bus moves the message from
     * the queue into the subscription’s dead-letter sub-queue. If disabled, message
     * will be permanently deleted from the subscription’s main queue.
     * Settable only at subscription creation time.
     */
    deadLetteringOnMessageExpiration?: boolean;
    /**
     * Determines how the Service Bus handles a message that causes an exception during
     * a subscription’s filter evaluation. If the value is set to true, the message that
     * caused the exception will be moved to the subscription’s dead-letter sub-queue.
     * Otherwise, it will be discarded. By default this parameter is set to true,
     * allowing the user a chance to investigate the cause of the exception.
     * It can occur from a malformed message or some incorrect assumptions being made
     * in the filter about the form of the message. Settable only at topic creation time.
     */
    deadLetteringOnFilterEvaluationExceptions?: boolean;
    /**
     * The maximum delivery count of messages after which if it is still not settled,
     * gets moved to the dead-letter sub-queue.
     *
     */
    maxDeliveryCount?: number;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations?: boolean;
    /**
     * Status of the messaging entity.
     */
    status?: EntityStatus;
    /**
     * Absolute URL or the name of the queue or topic the
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardTo?: string;
    /**
     * The user provided metadata information associated with the subscription description.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata?: string;
    /**
     * Absolute URL or the name of the queue or topic the dead-lettered
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardDeadLetteredMessagesTo?: string;
    /**
     * Max idle time before entity is deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    autoDeleteOnIdle?: string;
}
export { TokenInfo }
export { TokenProvider }
export { TokenType }

/**
 * Describes the client that allows interacting with a Service Bus Topic.
 * Use the `createTopicClient` function on the ServiceBusClient object to instantiate a TopicClient
 * @class TopicClient
 */
export declare class TopicClient implements Client {
    /**
     * @readonly
     * @property The path for the Service Bus Topic for which this client is created.
     */
    readonly entityPath: string;
    /**
     * @readonly
     * @property A unique identifier for this client.
     */
    readonly id: string;
    /**
     * @property Describes the amqp connection context for the QueueClient.
     */
    private _context;
    private _currentSender;
    /**
     * Closes the AMQP link for the sender created by this client.
     * Once closed, neither the TopicClient nor its senders can be used for any
     * further operations.
     *
     * @returns {Promise<void>}
     */
    close(): Promise<void>;
    /**
     * Creates a Sender to be used for sending messages, scheduling messages to be sent at a later time
     * and cancelling such scheduled messages.
     *
     * If the Topic has session enabled Subscriptions, then messages sent without the `sessionId`
     * property will go to the dead letter queue of such subscriptions.
     * @throws Error if the TopicClient or the underlying connection is closed.
     * @throws Error if an open sender already exists on the TopicClient.
     */
    createSender(): Sender;
    /**
     * Returns the corresponding dead letter topic name for the given topic and subscription names.
     * Use this in the `createSubscriptionClient` function of the `ServiceBusClient` instance to
     * receive messages from dead letter queue for given subscription.
     * @param topicName Name of the topic whose dead letter counterpart's name is being fetched
     * @param subscriptionName Name of the subscription whose dead letter counterpart's name is being fetched
     */
    static getDeadLetterTopicPath(topicName: string, subscriptionName: string): string;
}

/**
 * Represents all attributes of a topic entity
 */
export declare interface TopicDetails {
    /**
     * Name of the topic
     */
    topicName: string;
    /**
     * Specifies the topic size in bytes.
     */
    sizeInBytes?: number;
    /**
     * Specifies the maximum topic size in megabytes. Any attempt to enqueue a message
     * that will cause the topic to exceed this value will fail. All messages that are
     * stored in the topic or any of its subscriptions count towards this value.
     * Multiple copies of a message that reside in one or multiple subscriptions
     * count as a single messages. For example, if message m exists once in subscription
     * s1 and twice in subscription s2, m is counted as a single message.
     */
    maxSizeInMegabytes: number;
    /**
     * If enabled, the topic will detect duplicate messages within the time span specified
     * by the DuplicateDetectionHistoryTimeWindow property.
     * Settable only at topic creation time.
     */
    requiresDuplicateDetection: boolean;
    /**
     * Enable Subscription Partitioning option
     */
    enableSubscriptionPartitioning?: boolean;
    /**
     * Filtering Messages Before Publishing option
     */
    filteringMessagesBeforePublishing?: boolean;
    /**
     * Authorization rules on the topic
     */
    authorizationRules?: AuthorizationRule[];
    /**
     * Specifies whether the topic should be partitioned
     */
    enablePartitioning: boolean;
    /**
     * Specifies whether the topic supports message ordering.
     */
    supportOrdering: boolean;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations: boolean;
    /**
     * Max idle time before entity is deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    autoDeleteOnIdle?: string;
    /**
     * The entity's message count.
     *
     */
    messageCount?: number;
    /**
     * The subscription count on given topic.
     *
     */
    subscriptionCount?: number;
    /**
     * The maximum delivery count of messages after which if it is still not settled,
     * gets moved to the dead-letter sub-queue.
     *
     */
    maxDeliveryCount?: number;
    /**
     * Determines how long a message lives in the associated subscriptions.
     * Subscriptions inherit the TTL from the topic unless they are created explicitly with
     * a smaller TTL. Based on whether dead-lettering is enabled, a message whose TTL has
     * expired will either be moved to the subscription’s associated dead-letter sub-queue or
     * will be permanently deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    defaultMessageTtl: string;
    /**
     * Specifies the time span during which the Service Bus will detect message duplication.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    duplicateDetectionHistoryTimeWindow: string;
    /**
     * The user provided metadata information associated with the topic description.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata?: string;
    /**
     * Is Express option
     */
    isExpress?: boolean;
    /**
     * Enable express option
     */
    enableExpress?: boolean;
    /**
     * Message count details
     */
    messageCountDetails?: MessageCountDetails;
    /**
     * Is anonymous accessible topic option
     */
    isAnonymousAccessible?: boolean;
    /**
     * Entity availability status
     */
    entityAvailabilityStatus?: string;
    /**
     * Status of the messaging entity.
     */
    status?: EntityStatus;
    /**
     * Created at timestamp
     */
    createdOn?: string;
    /**
     * Updated at timestamp
     */
    updatedOn?: string;
    /**
     * Accessed at timestamp
     */
    accessedOn?: string;
}

/**
 * Represents settable options on a topic
 */
export declare interface TopicOptions {
    /**
     * Determines how long a message lives in the associated subscriptions.
     * Subscriptions inherit the TTL from the topic unless they are created explicitly
     * with a smaller TTL. Based on whether dead-lettering is enabled, a message whose
     * TTL has expired will either be moved to the subscription’s associated dead-letter
     * sub-queue or will be permanently deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    defaultMessageTtl?: string;
    /**
     * Specifies the maximum topic size in megabytes. Any attempt to enqueue a message
     * that will cause the topic to exceed this value will fail. All messages that are
     * stored in the topic or any of its subscriptions count towards this value.
     * Multiple copies of a message that reside in one or multiple subscriptions count
     * as a single messages. For example, if message m exists once in subscription s1
     * and twice in subscription s2, m is counted as a single message.
     */
    maxSizeInMegabytes?: number;
    /**
     * If enabled, the topic will detect duplicate messages within the time span
     * specified by the DuplicateDetectionHistoryTimeWindow property.
     * Settable only at topic creation time.
     */
    requiresDuplicateDetection?: boolean;
    /**
     * Specifies the time span during which the Service Bus will detect message duplication.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    duplicateDetectionHistoryTimeWindow?: string;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations?: boolean;
    /**
     * Authorization rules on the topic
     */
    authorizationRules?: AuthorizationRule[];
    /**
     * Status of the messaging entity.
     */
    status?: EntityStatus;
    /**
     * The user provided metadata information associated with the topic description.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata?: string;
    /**
     * Specifies whether the topic supports message ordering.
     */
    supportOrdering?: boolean;
    /**
     * Max idle time before entity is deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     */
    autoDeleteOnIdle?: string;
    /**
     * Specifies whether the topic should be partitioned
     */
    enablePartitioning?: boolean;
}
export { WebSocketImpl }

export { }
